[
  {
    "id": 1615,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
    "start-bug-line": 11,
    "end-bug-line": 11,
    "bug": "",
    "fix": "import com.fasterxml.jackson.core.JsonParser;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.net.MalformedURLException; import java.net.URI; import java.net.URL; import java.util.*; <extra_id_0> import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JacksonStdImpl; import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; @JacksonStdImpl public class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1; public final static int TYPE_BYTE = 2; public final static int TYPE_SHORT = 3;"
      },
      {
        "txt": "public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9; public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11; public final static int TYPE_UUID = 12; public final static int TYPE_URI = 13;"
      },
      {
        "txt": "public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser; protected StdKeyDeserializer(int kind, Class<?> cls) { this(kind, cls, null); } protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {"
      },
      {
        "txt": "_kind = kind; _keyClass = cls; _deser = deser; } public static StdKeyDeserializer forType(Class<?> raw) { int kind; if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) {"
      },
      {
        "txt": "kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) {"
      },
      {
        "txt": "kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) {"
      },
      {
        "txt": "kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);"
      },
      {
        "txt": "} else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); } @Override public Object deserializeKey(String key, DeserializationContext ctxt)"
      },
      {
        "txt": "throws IOException { if (key == null) { // is this even legal call? return null; } try { Object result = _parse(key, ctxt); if (result != null) { return result; }"
      },
      {
        "txt": "} catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null; } return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); } public Class<?> getKeyClass() { return _keyClass; }"
      },
      {
        "txt": "protected Object _parse(String key, DeserializationContext ctxt) throws Exception { switch (_kind) { case TYPE_BOOLEAN: if (\"true\".equals(key)) { return Boolean.TRUE; } if (\"false\".equals(key)) { return Boolean.FALSE; }"
      },
      {
        "txt": "return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\"); case TYPE_BYTE: { int value = _parseInt(key); if (value < Byte.MIN_VALUE || value > 255) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 8-bit value\"); } return Byte.valueOf((byte) value); } case TYPE_SHORT:"
      },
      {
        "txt": "{ int value = _parseInt(key); if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 16-bit value\"); } return Short.valueOf((short) value); } case TYPE_CHAR: if (key.length() == 1) { return Character.valueOf(key.charAt(0));"
      },
      {
        "txt": "} return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\"); case TYPE_INT: return _parseInt(key); case TYPE_LONG: return _parseLong(key); case TYPE_FLOAT: return Float.valueOf((float) _parseDouble(key)); case TYPE_DOUBLE: return _parseDouble(key);"
      },
      {
        "txt": "case TYPE_LOCALE: try { return _deser._deserialize(key, ctxt); } catch (IOException e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as locale\"); } case TYPE_CURRENCY: try { return _deser._deserialize(key, ctxt); } catch (IOException e) {"
      },
      {
        "txt": "return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as currency\"); } case TYPE_DATE: return ctxt.parseDate(key); case TYPE_CALENDAR: java.util.Date date = ctxt.parseDate(key); return (date == null) ? null : ctxt.constructCalendar(date); case TYPE_UUID: try { return UUID.fromString(key);"
      },
      {
        "txt": "} catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_URI: try { return URI.create(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_URL:"
      },
      {
        "txt": "try { return new URL(key); } catch (MalformedURLException e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_CLASS: try { return ctxt.findClass(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\");"
      },
      {
        "txt": "} default: throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass); } } protected int _parseInt(String key) throws IllegalArgumentException { return Integer.parseInt(key); } protected long _parseLong(String key) throws IllegalArgumentException { return Long.parseLong(key);"
      },
      {
        "txt": "} protected double _parseDouble(String key) throws IllegalArgumentException { return NumberInput.parseDouble(key); } @JacksonStdImpl final static class StringKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; private final static StringKD sString = new StringKD(String.class); private final static StringKD sObject = new StringKD(Object.class);"
      },
      {
        "txt": "private StringKD(Class<?> nominalType) { super(-1, nominalType); } public static StringKD forType(Class<?> nominalType) { if (nominalType == String.class) { return sString; } if (nominalType == Object.class) { return sObject; } return new StringKD(nominalType);"
      },
      {
        "txt": "} @Override public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { return key; } } final static class DelegatingKD extends KeyDeserializer // note: NOT the std one implements java.io.Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) { _keyClass = cls; _delegate = deser; } @SuppressWarnings(\"resource\") @Override public final Object deserializeKey(String key, DeserializationContext ctxt)"
      },
      {
        "txt": "throws IOException { if (key == null) { // is this even legal call? return null; } try { Object result = _delegate.deserialize(ctxt.getParser(), ctxt); if (result != null) { return result; }"
      },
      {
        "txt": "return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage()); } } public Class<?> getKeyClass() { return _keyClass; } } @JacksonStdImpl final static class EnumKD extends StdKeyDeserializer {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected EnumKD(EnumResolver er, AnnotatedMethod factory) { super(-1, er.getEnumClass()); _byNameResolver = er; _factory = factory; } @Override"
      },
      {
        "txt": "public Object _parse(String key, DeserializationContext ctxt) throws IOException { if (_factory != null) { try { return _factory.call1(key); } catch (Exception e) { ClassUtil.unwrapAndThrowAsIAE(e); } } EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)"
      },
      {
        "txt": "? _getToStringResolver(ctxt) : _byNameResolver; Enum<?> e = res.findEnum(key); if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\", res.getEnumIds()); } return e; } private EnumResolver _getToStringResolver(DeserializationContext ctxt) {"
      },
      {
        "txt": "EnumResolver res = _byToStringResolver; if (res == null) { synchronized (this) { res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(), ctxt.getAnnotationIntrospector()); } } return res; } }"
      },
      {
        "txt": "final static class StringCtorKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) { super(-1, ctor.getDeclaringClass()); _ctor = ctor; } @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception"
      },
      {
        "txt": "{ return _ctor.newInstance(key); } } final static class StringFactoryKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) { super(-1, fm.getDeclaringClass());"
      },
      {
        "txt": "_factoryMethod = fm; } @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception { return _factoryMethod.invoke(null, key); } }"
      }
    ]
  },
  {
    "id": 1616,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
    "start-bug-line": 18,
    "end-bug-line": 18,
    "bug": "",
    "fix": "import com.fasterxml.jackson.databind.util.TokenBuffer;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.deser.std; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.net.MalformedURLException; import java.net.URI; import java.net.URL; import java.util.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JacksonStdImpl; import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; <extra_id_0> @JacksonStdImpl public class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1;"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1; public final static int TYPE_BYTE = 2; public final static int TYPE_SHORT = 3; public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9;"
      },
      {
        "txt": "public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11; public final static int TYPE_UUID = 12; public final static int TYPE_URI = 13; public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser;"
      },
      {
        "txt": "protected StdKeyDeserializer(int kind, Class<?> cls) { this(kind, cls, null); } protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) { _kind = kind; _keyClass = cls; _deser = deser; } public static StdKeyDeserializer forType(Class<?> raw) {"
      },
      {
        "txt": "int kind; if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) {"
      },
      {
        "txt": "kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) {"
      },
      {
        "txt": "kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) {"
      },
      {
        "txt": "kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; }"
      },
      {
        "txt": "return new StdKeyDeserializer(kind, raw); } @Override public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException { if (key == null) { // is this even legal call? return null; } try {"
      },
      {
        "txt": "Object result = _parse(key, ctxt); if (result != null) { return result; } } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;"
      },
      {
        "txt": "} return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); } public Class<?> getKeyClass() { return _keyClass; } protected Object _parse(String key, DeserializationContext ctxt) throws Exception { switch (_kind) { case TYPE_BOOLEAN: if (\"true\".equals(key)) { return Boolean.TRUE;"
      },
      {
        "txt": "} if (\"false\".equals(key)) { return Boolean.FALSE; } return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\"); case TYPE_BYTE: { int value = _parseInt(key); if (value < Byte.MIN_VALUE || value > 255) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 8-bit value\");"
      },
      {
        "txt": "} return Byte.valueOf((byte) value); } case TYPE_SHORT: { int value = _parseInt(key); if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 16-bit value\"); } return Short.valueOf((short) value);"
      },
      {
        "txt": "} case TYPE_CHAR: if (key.length() == 1) { return Character.valueOf(key.charAt(0)); } return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\"); case TYPE_INT: return _parseInt(key); case TYPE_LONG: return _parseLong(key);"
      },
      {
        "txt": "case TYPE_FLOAT: return Float.valueOf((float) _parseDouble(key)); case TYPE_DOUBLE: return _parseDouble(key); case TYPE_LOCALE: try { return _deser._deserialize(key, ctxt); } catch (IOException e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as locale\"); }"
      },
      {
        "txt": "case TYPE_CURRENCY: try { return _deser._deserialize(key, ctxt); } catch (IOException e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as currency\"); } case TYPE_DATE: return ctxt.parseDate(key); case TYPE_CALENDAR: java.util.Date date = ctxt.parseDate(key);"
      },
      {
        "txt": "return (date == null) ? null : ctxt.constructCalendar(date); case TYPE_UUID: try { return UUID.fromString(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_URI: try { return URI.create(key);"
      },
      {
        "txt": "} catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_URL: try { return new URL(key); } catch (MalformedURLException e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_CLASS:"
      },
      {
        "txt": "try { return ctxt.findClass(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\"); } default: throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass); } } protected int _parseInt(String key) throws IllegalArgumentException {"
      },
      {
        "txt": "return Integer.parseInt(key); } protected long _parseLong(String key) throws IllegalArgumentException { return Long.parseLong(key); } protected double _parseDouble(String key) throws IllegalArgumentException { return NumberInput.parseDouble(key); } @JacksonStdImpl final static class StringKD extends StdKeyDeserializer"
      },
      {
        "txt": "{ private static final long serialVersionUID = 1L; private final static StringKD sString = new StringKD(String.class); private final static StringKD sObject = new StringKD(Object.class); private StringKD(Class<?> nominalType) { super(-1, nominalType); } public static StringKD forType(Class<?> nominalType) { if (nominalType == String.class) { return sString; }"
      },
      {
        "txt": "if (nominalType == Object.class) { return sObject; } return new StringKD(nominalType); } @Override public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { return key; } }"
      },
      {
        "txt": "final static class DelegatingKD extends KeyDeserializer // note: NOT the std one implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) { _keyClass = cls; _delegate = deser;"
      },
      {
        "txt": "} @SuppressWarnings(\"resource\") @Override public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException { if (key == null) { // is this even legal call? return null; } try {"
      },
      {
        "txt": "Object result = _delegate.deserialize(ctxt.getParser(), ctxt); if (result != null) { return result; } return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage()); } } public Class<?> getKeyClass() { return _keyClass; }"
      },
      {
        "txt": "} @JacksonStdImpl final static class EnumKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected EnumKD(EnumResolver er, AnnotatedMethod factory) { super(-1, er.getEnumClass());"
      },
      {
        "txt": "_byNameResolver = er; _factory = factory; } @Override public Object _parse(String key, DeserializationContext ctxt) throws IOException { if (_factory != null) { try { return _factory.call1(key); } catch (Exception e) {"
      },
      {
        "txt": "ClassUtil.unwrapAndThrowAsIAE(e); } } EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING) ? _getToStringResolver(ctxt) : _byNameResolver; Enum<?> e = res.findEnum(key); if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\", res.getEnumIds()); }"
      },
      {
        "txt": "return e; } private EnumResolver _getToStringResolver(DeserializationContext ctxt) { EnumResolver res = _byToStringResolver; if (res == null) { synchronized (this) { res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(), ctxt.getAnnotationIntrospector()); }"
      },
      {
        "txt": "} return res; } } final static class StringCtorKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) { super(-1, ctor.getDeclaringClass());"
      },
      {
        "txt": "_ctor = ctor; } @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception { return _ctor.newInstance(key); } } final static class StringFactoryKeyDeserializer extends StdKeyDeserializer {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) { super(-1, fm.getDeclaringClass()); _factoryMethod = fm; } @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception { return _factoryMethod.invoke(null, key);"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 1617,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
    "start-bug-line": 314,
    "end-bug-line": 314,
    "bug": "",
    "fix": "TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt); tb.writeString(key);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.net.MalformedURLException; import java.net.URI; import java.net.URL; import java.util.*; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.annotation.JacksonStdImpl; import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; @JacksonStdImpl public class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1;"
      },
      {
        "txt": "public final static int TYPE_BYTE = 2; public final static int TYPE_SHORT = 3; public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9; public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11;"
      },
      {
        "txt": "public final static int TYPE_UUID = 12; public final static int TYPE_URI = 13; public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser; protected StdKeyDeserializer(int kind, Class<?> cls) { this(kind, cls, null);"
      },
      {
        "txt": "} protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) { _kind = kind; _keyClass = cls; _deser = deser; } public static StdKeyDeserializer forType(Class<?> raw) { int kind; if (raw == String.class || raw == Object.class) {"
      },
      {
        "txt": "return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) {"
      },
      {
        "txt": "kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) {"
      },
      {
        "txt": "kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) {"
      },
      {
        "txt": "FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); }"
      },
      {
        "txt": "@Override public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException { if (key == null) { // is this even legal call? return null; } try { Object result = _parse(key, ctxt); if (result != null) {"
      },
      {
        "txt": "return result; } } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null; } return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");"
      },
      {
        "txt": "} public Class<?> getKeyClass() { return _keyClass; } protected Object _parse(String key, DeserializationContext ctxt) throws Exception { switch (_kind) { case TYPE_BOOLEAN: if (\"true\".equals(key)) { return Boolean.TRUE; } if (\"false\".equals(key)) {"
      },
      {
        "txt": "return Boolean.FALSE; } return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\"); case TYPE_BYTE: { int value = _parseInt(key); if (value < Byte.MIN_VALUE || value > 255) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 8-bit value\"); } return Byte.valueOf((byte) value);"
      },
      {
        "txt": "} case TYPE_SHORT: { int value = _parseInt(key); if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 16-bit value\"); } return Short.valueOf((short) value); } case TYPE_CHAR:"
      },
      {
        "txt": "if (key.length() == 1) { return Character.valueOf(key.charAt(0)); } return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\"); case TYPE_INT: return _parseInt(key); case TYPE_LONG: return _parseLong(key); case TYPE_FLOAT: return Float.valueOf((float) _parseDouble(key));"
      },
      {
        "txt": "case TYPE_DOUBLE: return _parseDouble(key); case TYPE_LOCALE: try { return _deser._deserialize(key, ctxt); } catch (IOException e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as locale\"); } case TYPE_CURRENCY: try {"
      },
      {
        "txt": "return _deser._deserialize(key, ctxt); } catch (IOException e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as currency\"); } case TYPE_DATE: return ctxt.parseDate(key); case TYPE_CALENDAR: java.util.Date date = ctxt.parseDate(key); return (date == null) ? null : ctxt.constructCalendar(date); case TYPE_UUID:"
      },
      {
        "txt": "try { return UUID.fromString(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_URI: try { return URI.create(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());"
      },
      {
        "txt": "} case TYPE_URL: try { return new URL(key); } catch (MalformedURLException e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_CLASS: try { return ctxt.findClass(key);"
      },
      {
        "txt": "} catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\"); } default: throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass); } } protected int _parseInt(String key) throws IllegalArgumentException { return Integer.parseInt(key); }"
      },
      {
        "txt": "protected long _parseLong(String key) throws IllegalArgumentException { return Long.parseLong(key); } protected double _parseDouble(String key) throws IllegalArgumentException { return NumberInput.parseDouble(key); } @JacksonStdImpl final static class StringKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private final static StringKD sString = new StringKD(String.class); private final static StringKD sObject = new StringKD(Object.class); private StringKD(Class<?> nominalType) { super(-1, nominalType); } public static StringKD forType(Class<?> nominalType) { if (nominalType == String.class) { return sString; } if (nominalType == Object.class) { return sObject;"
      },
      {
        "txt": "} return new StringKD(nominalType); } @Override public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { return key; } } final static class DelegatingKD extends KeyDeserializer // note: NOT the std one"
      },
      {
        "txt": "implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) { _keyClass = cls; _delegate = deser; } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException { if (key == null) { // is this even legal call? return null; } <extra_id_0> Object result = _delegate.deserialize(ctxt.getParser(), ctxt); if (result != null) { return result; } return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); } catch (Exception re) {"
      },
      {
        "txt": "return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage()); } } public Class<?> getKeyClass() { return _keyClass; } } @JacksonStdImpl final static class EnumKD extends StdKeyDeserializer {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected EnumKD(EnumResolver er, AnnotatedMethod factory) { super(-1, er.getEnumClass()); _byNameResolver = er; _factory = factory; } @Override"
      },
      {
        "txt": "public Object _parse(String key, DeserializationContext ctxt) throws IOException { if (_factory != null) { try { return _factory.call1(key); } catch (Exception e) { ClassUtil.unwrapAndThrowAsIAE(e); } } EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)"
      },
      {
        "txt": "? _getToStringResolver(ctxt) : _byNameResolver; Enum<?> e = res.findEnum(key); if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\", res.getEnumIds()); } return e; } private EnumResolver _getToStringResolver(DeserializationContext ctxt) {"
      },
      {
        "txt": "EnumResolver res = _byToStringResolver; if (res == null) { synchronized (this) { res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(), ctxt.getAnnotationIntrospector()); } } return res; } }"
      },
      {
        "txt": "final static class StringCtorKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) { super(-1, ctor.getDeclaringClass()); _ctor = ctor; } @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception"
      },
      {
        "txt": "{ return _ctor.newInstance(key); } } final static class StringFactoryKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) { super(-1, fm.getDeclaringClass());"
      },
      {
        "txt": "_factoryMethod = fm; } @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception { return _factoryMethod.invoke(null, key); } }"
      }
    ]
  },
  {
    "id": 1618,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
    "start-bug-line": 316,
    "end-bug-line": 316,
    "bug": "Object result = _delegate.deserialize(ctxt.getParser(), ctxt);",
    "fix": "JsonParser p = tb.asParser(); p.nextToken(); Object result = _delegate.deserialize(p, ctxt);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.deser.std; import java.io.IOException;"
      },
      {
        "txt": "import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.net.MalformedURLException; import java.net.URI; import java.net.URL; import java.util.*; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; @JacksonStdImpl public class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1; public final static int TYPE_BYTE = 2;"
      },
      {
        "txt": "public final static int TYPE_SHORT = 3; public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9; public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11; public final static int TYPE_UUID = 12;"
      },
      {
        "txt": "public final static int TYPE_URI = 13; public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser; protected StdKeyDeserializer(int kind, Class<?> cls) { this(kind, cls, null); }"
      },
      {
        "txt": "protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) { _kind = kind; _keyClass = cls; _deser = deser; } public static StdKeyDeserializer forType(Class<?> raw) { int kind; if (raw == String.class || raw == Object.class) { return StringKD.forType(raw);"
      },
      {
        "txt": "} else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR;"
      },
      {
        "txt": "} else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT;"
      },
      {
        "txt": "} else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);"
      },
      {
        "txt": "return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); } @Override"
      },
      {
        "txt": "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException { if (key == null) { // is this even legal call? return null; } try { Object result = _parse(key, ctxt); if (result != null) { return result;"
      },
      {
        "txt": "} } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null; } return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); }"
      },
      {
        "txt": "public Class<?> getKeyClass() { return _keyClass; } protected Object _parse(String key, DeserializationContext ctxt) throws Exception { switch (_kind) { case TYPE_BOOLEAN: if (\"true\".equals(key)) { return Boolean.TRUE; } if (\"false\".equals(key)) { return Boolean.FALSE;"
      },
      {
        "txt": "} return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\"); case TYPE_BYTE: { int value = _parseInt(key); if (value < Byte.MIN_VALUE || value > 255) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 8-bit value\"); } return Byte.valueOf((byte) value); }"
      },
      {
        "txt": "case TYPE_SHORT: { int value = _parseInt(key); if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 16-bit value\"); } return Short.valueOf((short) value); } case TYPE_CHAR: if (key.length() == 1) {"
      },
      {
        "txt": "return Character.valueOf(key.charAt(0)); } return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\"); case TYPE_INT: return _parseInt(key); case TYPE_LONG: return _parseLong(key); case TYPE_FLOAT: return Float.valueOf((float) _parseDouble(key)); case TYPE_DOUBLE:"
      },
      {
        "txt": "return _parseDouble(key); case TYPE_LOCALE: try { return _deser._deserialize(key, ctxt); } catch (IOException e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as locale\"); } case TYPE_CURRENCY: try { return _deser._deserialize(key, ctxt);"
      },
      {
        "txt": "} catch (IOException e) { return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as currency\"); } case TYPE_DATE: return ctxt.parseDate(key); case TYPE_CALENDAR: java.util.Date date = ctxt.parseDate(key); return (date == null) ? null : ctxt.constructCalendar(date); case TYPE_UUID: try {"
      },
      {
        "txt": "return UUID.fromString(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_URI: try { return URI.create(key); } catch (Exception e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); }"
      },
      {
        "txt": "case TYPE_URL: try { return new URL(key); } catch (MalformedURLException e) { return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage()); } case TYPE_CLASS: try { return ctxt.findClass(key); } catch (Exception e) {"
      },
      {
        "txt": "return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\"); } default: throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass); } } protected int _parseInt(String key) throws IllegalArgumentException { return Integer.parseInt(key); } protected long _parseLong(String key) throws IllegalArgumentException {"
      },
      {
        "txt": "return Long.parseLong(key); } protected double _parseDouble(String key) throws IllegalArgumentException { return NumberInput.parseDouble(key); } @JacksonStdImpl final static class StringKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; private final static StringKD sString = new StringKD(String.class);"
      },
      {
        "txt": "private final static StringKD sObject = new StringKD(Object.class); private StringKD(Class<?> nominalType) { super(-1, nominalType); } public static StringKD forType(Class<?> nominalType) { if (nominalType == String.class) { return sString; } if (nominalType == Object.class) { return sObject; }"
      },
      {
        "txt": "return new StringKD(nominalType); } @Override public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { return key; } } final static class DelegatingKD extends KeyDeserializer // note: NOT the std one implements java.io.Serializable"
      },
      {
        "txt": "{ private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) { _keyClass = cls; _delegate = deser; } @SuppressWarnings(\"resource\") @Override"
      },
      {
        "txt": "throws IOException { if (key == null) { // is this even legal call? return null; } try { <extra_id_0> if (result != null) { return result; } return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\"); } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());"
      },
      {
        "txt": "} catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage()); } } public Class<?> getKeyClass() { return _keyClass; } } @JacksonStdImpl final static class EnumKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected EnumKD(EnumResolver er, AnnotatedMethod factory) { super(-1, er.getEnumClass()); _byNameResolver = er; _factory = factory; } @Override public Object _parse(String key, DeserializationContext ctxt) throws IOException"
      },
      {
        "txt": "{ if (_factory != null) { try { return _factory.call1(key); } catch (Exception e) { ClassUtil.unwrapAndThrowAsIAE(e); } } EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING) ? _getToStringResolver(ctxt) : _byNameResolver;"
      },
      {
        "txt": "Enum<?> e = res.findEnum(key); if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\", res.getEnumIds()); } return e; } private EnumResolver _getToStringResolver(DeserializationContext ctxt) { EnumResolver res = _byToStringResolver;"
      },
      {
        "txt": "if (res == null) { synchronized (this) { res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(), ctxt.getAnnotationIntrospector()); } } return res; } } final static class StringCtorKeyDeserializer extends StdKeyDeserializer"
      },
      {
        "txt": "{ private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) { super(-1, ctor.getDeclaringClass()); _ctor = ctor; } @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception {"
      },
      {
        "txt": "return _ctor.newInstance(key); } } final static class StringFactoryKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) { super(-1, fm.getDeclaringClass()); _factoryMethod = fm;"
      },
      {
        "txt": "} @Override public Object _parse(String key, DeserializationContext ctxt) throws Exception { return _factoryMethod.invoke(null, key); } }"
      }
    ]
  }
]