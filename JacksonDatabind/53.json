[
  {
    "id": 1543,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java",
    "start-bug-line": 302,
    "end-bug-line": 302,
    "bug": "",
    "fix": "public Object asKey(Class<?> rawBase) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.*; import java.util.*; import com.fasterxml.jackson.databind.JavaType; public class TypeBindings implements java.io.Serializable { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private final static String[] NO_STRINGS = new String[0]; private final static JavaType[] NO_TYPES = new JavaType[0]; private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null); private final String[] _names; private final JavaType[] _types; private final String[] _unboundVariables; private final int _hashCode; private TypeBindings(String[] names, JavaType[] types, String[] uvars) { _names = (names == null) ? NO_STRINGS : names;"
      },
      {
        "txt": "_types = (types == null) ? NO_TYPES : types; if (_names.length != _types.length) { throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\"); } int h = 1; for (int i = 0, len = _types.length; i < len; ++i) { h += _types[i].hashCode(); } _unboundVariables = uvars; _hashCode = h;"
      },
      {
        "txt": "} public static TypeBindings emptyBindings() { return EMPTY; } protected Object readResolve() { if ((_names == null) || (_names.length == 0)) { return EMPTY; } return this; }"
      },
      {
        "txt": "public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList) { JavaType[] types = (typeList == null || typeList.isEmpty()) ? NO_TYPES : typeList.toArray(new JavaType[typeList.size()]); return create(erasedType, types); } public static TypeBindings create(Class<?> erasedType, JavaType[] types) { if (types == null) { types = NO_TYPES;"
      },
      {
        "txt": "} else switch (types.length) { case 1: return create(erasedType, types[0]); case 2: return create(erasedType, types[0], types[1]); } TypeVariable<?>[] vars = erasedType.getTypeParameters(); String[] names; if (vars == null || vars.length == 0) { names = NO_STRINGS;"
      },
      {
        "txt": "} else { int len = vars.length; names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\""
      },
      {
        "txt": "+((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()"
      },
      {
        "txt": "+\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) { TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 2) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 2 type parameters: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() }, new JavaType[] { typeArg1, typeArg2 }, null); } public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); int varLen = (vars == null) ? 0 : vars.length;"
      },
      {
        "txt": "if (varLen == 0) { return EMPTY; } if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); }"
      },
      {
        "txt": "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); if (vars == null || vars.length == 0) { return EMPTY; } if (types == null) { types = NO_TYPES; } int len = vars.length;"
      },
      {
        "txt": "String[] names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\" +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null);"
      },
      {
        "txt": "} public TypeBindings withUnboundVariable(String name) { int len = (_unboundVariables == null) ? 0 : _unboundVariables.length; String[] names = (len == 0) ? new String[1] : Arrays.copyOf(_unboundVariables, len+1); names[len] = name; return new TypeBindings(_names, _types, names); } public JavaType findBoundType(String name)"
      },
      {
        "txt": "{ for (int i = 0, len = _names.length; i < len; ++i) { if (name.equals(_names[i])) { JavaType t = _types[i]; if (t instanceof ResolvedRecursiveType) { ResolvedRecursiveType rrt = (ResolvedRecursiveType) t; JavaType t2 = rrt.getSelfReferencedType(); if (t2 != null) { t = t2; } else {"
      },
      {
        "txt": "throw new IllegalStateException(String.format (\"Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)\", name, i, t.getRawClass())); } } return t; } } return null; }"
      },
      {
        "txt": "public boolean isEmpty() { return (_types.length == 0); } public int size() { return _types.length; } public String getBoundName(int index) { if (index < 0 || index >= _names.length) { return null;"
      },
      {
        "txt": "} return _names[index]; } public JavaType getBoundType(int index) { if (index < 0 || index >= _types.length) { return null; } return _types[index]; }"
      },
      {
        "txt": "public List<JavaType> getTypeParameters() { if (_types.length == 0) { return Collections.emptyList(); } return Arrays.asList(_types); } public boolean hasUnbound(String name) { if (_unboundVariables != null) { for (int i = _unboundVariables.length; --i >= 0; ) {"
      },
      {
        "txt": "return true; } } } return false; } <extra_id_0> @Override public String toString() { if (_types.length == 0) { return \"<>\"; } StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "} StringBuilder sb = new StringBuilder(); sb.append('<'); for (int i = 0, len = _types.length; i < len; ++i) { if (i > 0) { sb.append(','); } String sig = _types[i].getGenericSignature(); sb.append(sig); }"
      },
      {
        "txt": "sb.append('>'); return sb.toString(); } @Override public int hashCode() { return _hashCode; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null || o.getClass() != getClass()) return false; TypeBindings other = (TypeBindings) o; int len = _types.length;"
      },
      {
        "txt": "if (len != other.size()) { return false; } JavaType[] otherTypes = other._types; for (int i = 0; i < len; ++i) { if (!otherTypes[i].equals(_types[i])) { return false; } } return true;"
      },
      {
        "txt": "} protected JavaType[] typeParameterArray() { return _types; } static class TypeParamStash { private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters();"
      },
      {
        "txt": "private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters(); public static TypeVariable<?>[] paramsFor1(Class<?> erasedType) { if (erasedType == Collection.class) { return VARS_COLLECTION; } if (erasedType == List.class) { return VARS_LIST;"
      },
      {
        "txt": "} if (erasedType == ArrayList.class) { return VARS_ARRAY_LIST; } if (erasedType == AbstractList.class) { return VARS_ABSTRACT_LIST; } if (erasedType == Iterable.class) { return VARS_ITERABLE; }"
      },
      {
        "txt": "return erasedType.getTypeParameters(); } public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) { if (erasedType == Map.class) { return VARS_MAP; } if (erasedType == HashMap.class) { return VARS_HASH_MAP; }"
      },
      {
        "txt": "if (erasedType == LinkedHashMap.class) { return VARS_LINKED_HASH_MAP; } return erasedType.getTypeParameters(); } }"
      }
    ]
  },
  {
    "id": 1544,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java",
    "start-bug-line": 304,
    "end-bug-line": 304,
    "bug": "",
    "fix": "return new AsKey(rawBase, _types, _hashCode); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.*; import java.util.*; import com.fasterxml.jackson.databind.JavaType; public class TypeBindings implements java.io.Serializable { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private final static String[] NO_STRINGS = new String[0]; private final static JavaType[] NO_TYPES = new JavaType[0]; private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null); private final String[] _names; private final JavaType[] _types; private final String[] _unboundVariables; private final int _hashCode; private TypeBindings(String[] names, JavaType[] types, String[] uvars) { _names = (names == null) ? NO_STRINGS : names;"
      },
      {
        "txt": "_types = (types == null) ? NO_TYPES : types; if (_names.length != _types.length) { throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\"); } int h = 1; for (int i = 0, len = _types.length; i < len; ++i) { h += _types[i].hashCode(); } _unboundVariables = uvars; _hashCode = h;"
      },
      {
        "txt": "} public static TypeBindings emptyBindings() { return EMPTY; } protected Object readResolve() { if ((_names == null) || (_names.length == 0)) { return EMPTY; } return this; }"
      },
      {
        "txt": "public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList) { JavaType[] types = (typeList == null || typeList.isEmpty()) ? NO_TYPES : typeList.toArray(new JavaType[typeList.size()]); return create(erasedType, types); } public static TypeBindings create(Class<?> erasedType, JavaType[] types) { if (types == null) { types = NO_TYPES;"
      },
      {
        "txt": "} else switch (types.length) { case 1: return create(erasedType, types[0]); case 2: return create(erasedType, types[0], types[1]); } TypeVariable<?>[] vars = erasedType.getTypeParameters(); String[] names; if (vars == null || vars.length == 0) { names = NO_STRINGS;"
      },
      {
        "txt": "} else { int len = vars.length; names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\""
      },
      {
        "txt": "+((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()"
      },
      {
        "txt": "+\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) { TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 2) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 2 type parameters: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() }, new JavaType[] { typeArg1, typeArg2 }, null); } public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); int varLen = (vars == null) ? 0 : vars.length;"
      },
      {
        "txt": "if (varLen == 0) { return EMPTY; } if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); }"
      },
      {
        "txt": "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); if (vars == null || vars.length == 0) { return EMPTY; } if (types == null) { types = NO_TYPES; } int len = vars.length;"
      },
      {
        "txt": "String[] names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\" +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null);"
      },
      {
        "txt": "} public TypeBindings withUnboundVariable(String name) { int len = (_unboundVariables == null) ? 0 : _unboundVariables.length; String[] names = (len == 0) ? new String[1] : Arrays.copyOf(_unboundVariables, len+1); names[len] = name; return new TypeBindings(_names, _types, names); } public JavaType findBoundType(String name)"
      },
      {
        "txt": "{ for (int i = 0, len = _names.length; i < len; ++i) { if (name.equals(_names[i])) { JavaType t = _types[i]; if (t instanceof ResolvedRecursiveType) { ResolvedRecursiveType rrt = (ResolvedRecursiveType) t; JavaType t2 = rrt.getSelfReferencedType(); if (t2 != null) { t = t2; } else {"
      },
      {
        "txt": "throw new IllegalStateException(String.format (\"Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)\", name, i, t.getRawClass())); } } return t; } } return null; }"
      },
      {
        "txt": "public boolean isEmpty() { return (_types.length == 0); } public int size() { return _types.length; } public String getBoundName(int index) { if (index < 0 || index >= _names.length) { return null;"
      },
      {
        "txt": "} return _names[index]; } public JavaType getBoundType(int index) { if (index < 0 || index >= _types.length) { return null; } return _types[index]; }"
      },
      {
        "txt": "public List<JavaType> getTypeParameters() { if (_types.length == 0) { return Collections.emptyList(); } return Arrays.asList(_types); } public boolean hasUnbound(String name) { if (_unboundVariables != null) { for (int i = _unboundVariables.length; --i >= 0; ) {"
      },
      {
        "txt": "return true; } } } return false; } <extra_id_0> @Override public String toString() { if (_types.length == 0) { return \"<>\"; } StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "} StringBuilder sb = new StringBuilder(); sb.append('<'); for (int i = 0, len = _types.length; i < len; ++i) { if (i > 0) { sb.append(','); } String sig = _types[i].getGenericSignature(); sb.append(sig); }"
      },
      {
        "txt": "sb.append('>'); return sb.toString(); } @Override public int hashCode() { return _hashCode; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null || o.getClass() != getClass()) return false; TypeBindings other = (TypeBindings) o; int len = _types.length;"
      },
      {
        "txt": "if (len != other.size()) { return false; } JavaType[] otherTypes = other._types; for (int i = 0; i < len; ++i) { if (!otherTypes[i].equals(_types[i])) { return false; } } return true;"
      },
      {
        "txt": "} protected JavaType[] typeParameterArray() { return _types; } static class TypeParamStash { private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters();"
      },
      {
        "txt": "private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters(); public static TypeVariable<?>[] paramsFor1(Class<?> erasedType) { if (erasedType == Collection.class) { return VARS_COLLECTION; } if (erasedType == List.class) { return VARS_LIST;"
      },
      {
        "txt": "} if (erasedType == ArrayList.class) { return VARS_ARRAY_LIST; } if (erasedType == AbstractList.class) { return VARS_ABSTRACT_LIST; } if (erasedType == Iterable.class) { return VARS_ITERABLE; }"
      },
      {
        "txt": "return erasedType.getTypeParameters(); } public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) { if (erasedType == Map.class) { return VARS_MAP; } if (erasedType == HashMap.class) { return VARS_HASH_MAP; }"
      },
      {
        "txt": "if (erasedType == LinkedHashMap.class) { return VARS_LINKED_HASH_MAP; } return erasedType.getTypeParameters(); } }"
      }
    ]
  },
  {
    "id": 1545,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java",
    "start-bug-line": 428,
    "end-bug-line": 428,
    "bug": "",
    "fix": "final static class AsKey { private final Class<?> _raw; private final JavaType[] _params; private final int _hash;  public AsKey(Class<?> raw, JavaType[] params, int hash) { _raw = raw ; _params = params; _hash = hash; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.*; import java.util.*; import com.fasterxml.jackson.databind.JavaType; public class TypeBindings implements java.io.Serializable { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private final static String[] NO_STRINGS = new String[0]; private final static JavaType[] NO_TYPES = new JavaType[0]; private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null); private final String[] _names; private final JavaType[] _types; private final String[] _unboundVariables; private final int _hashCode; private TypeBindings(String[] names, JavaType[] types, String[] uvars) { _names = (names == null) ? NO_STRINGS : names;"
      },
      {
        "txt": "_types = (types == null) ? NO_TYPES : types; if (_names.length != _types.length) { throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\"); } int h = 1; for (int i = 0, len = _types.length; i < len; ++i) { h += _types[i].hashCode(); } _unboundVariables = uvars; _hashCode = h;"
      },
      {
        "txt": "} public static TypeBindings emptyBindings() { return EMPTY; } protected Object readResolve() { if ((_names == null) || (_names.length == 0)) { return EMPTY; } return this; }"
      },
      {
        "txt": "public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList) { JavaType[] types = (typeList == null || typeList.isEmpty()) ? NO_TYPES : typeList.toArray(new JavaType[typeList.size()]); return create(erasedType, types); } public static TypeBindings create(Class<?> erasedType, JavaType[] types) { if (types == null) { types = NO_TYPES;"
      },
      {
        "txt": "} else switch (types.length) { case 1: return create(erasedType, types[0]); case 2: return create(erasedType, types[0], types[1]); } TypeVariable<?>[] vars = erasedType.getTypeParameters(); String[] names; if (vars == null || vars.length == 0) { names = NO_STRINGS;"
      },
      {
        "txt": "} else { int len = vars.length; names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\""
      },
      {
        "txt": "+((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()"
      },
      {
        "txt": "+\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) { TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 2) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 2 type parameters: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() }, new JavaType[] { typeArg1, typeArg2 }, null); } public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); int varLen = (vars == null) ? 0 : vars.length;"
      },
      {
        "txt": "if (varLen == 0) { return EMPTY; } if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); }"
      },
      {
        "txt": "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); if (vars == null || vars.length == 0) { return EMPTY; } if (types == null) { types = NO_TYPES; } int len = vars.length;"
      },
      {
        "txt": "String[] names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\" +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null);"
      },
      {
        "txt": "} public TypeBindings withUnboundVariable(String name) { int len = (_unboundVariables == null) ? 0 : _unboundVariables.length; String[] names = (len == 0) ? new String[1] : Arrays.copyOf(_unboundVariables, len+1); names[len] = name; return new TypeBindings(_names, _types, names); } public JavaType findBoundType(String name)"
      },
      {
        "txt": "{ for (int i = 0, len = _names.length; i < len; ++i) { if (name.equals(_names[i])) { JavaType t = _types[i]; if (t instanceof ResolvedRecursiveType) { ResolvedRecursiveType rrt = (ResolvedRecursiveType) t; JavaType t2 = rrt.getSelfReferencedType(); if (t2 != null) { t = t2; } else {"
      },
      {
        "txt": "throw new IllegalStateException(String.format (\"Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)\", name, i, t.getRawClass())); } } return t; } } return null; }"
      },
      {
        "txt": "public boolean isEmpty() { return (_types.length == 0); } public int size() { return _types.length; } public String getBoundName(int index) { if (index < 0 || index >= _names.length) { return null;"
      },
      {
        "txt": "} return _names[index]; } public JavaType getBoundType(int index) { if (index < 0 || index >= _types.length) { return null; } return _types[index]; }"
      },
      {
        "txt": "public List<JavaType> getTypeParameters() { if (_types.length == 0) { return Collections.emptyList(); } return Arrays.asList(_types); } public boolean hasUnbound(String name) { if (_unboundVariables != null) { for (int i = _unboundVariables.length; --i >= 0; ) {"
      },
      {
        "txt": "if (name.equals(_unboundVariables[i])) { return true; } } } return false; } @Override public String toString() { if (_types.length == 0) {"
      },
      {
        "txt": "return \"<>\"; } StringBuilder sb = new StringBuilder(); sb.append('<'); for (int i = 0, len = _types.length; i < len; ++i) { if (i > 0) { sb.append(','); } String sig = _types[i].getGenericSignature(); sb.append(sig);"
      },
      {
        "txt": "} sb.append('>'); return sb.toString(); } @Override public int hashCode() { return _hashCode; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null || o.getClass() != getClass()) return false; TypeBindings other = (TypeBindings) o;"
      },
      {
        "txt": "int len = _types.length; if (len != other.size()) { return false; } JavaType[] otherTypes = other._types; for (int i = 0; i < len; ++i) { if (!otherTypes[i].equals(_types[i])) { return false; } }"
      },
      {
        "txt": "return true; } protected JavaType[] typeParameterArray() { return _types; } static class TypeParamStash { private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters();"
      },
      {
        "txt": "private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters(); public static TypeVariable<?>[] paramsFor1(Class<?> erasedType) { if (erasedType == Collection.class) { return VARS_COLLECTION; } if (erasedType == List.class) {"
      },
      {
        "txt": "return VARS_LIST; } if (erasedType == ArrayList.class) { return VARS_ARRAY_LIST; } if (erasedType == AbstractList.class) { return VARS_ABSTRACT_LIST; } if (erasedType == Iterable.class) { return VARS_ITERABLE;"
      },
      {
        "txt": "} return erasedType.getTypeParameters(); } public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) { if (erasedType == Map.class) { return VARS_MAP; } if (erasedType == HashMap.class) { return VARS_HASH_MAP;"
      },
      {
        "txt": "if (erasedType == LinkedHashMap.class) { return VARS_LINKED_HASH_MAP; } return erasedType.getTypeParameters(); } } <extra_id_0> }"
      }
    ]
  },
  {
    "id": 1546,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java",
    "start-bug-line": 429,
    "end-bug-line": 429,
    "bug": "",
    "fix": "@Override public int hashCode() { return _hash; }  @Override public boolean equals(Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != getClass()) return false; AsKey other = (AsKey) o;  if ((_hash == other._hash) && (_raw == other._raw)) { final JavaType[] otherParams = other._params; final int len = _params.length;  if (len == otherParams.length) { for (int i = 0; i < len; ++i) { if (!_params[i].equals(otherParams[i])) { return false; } } return true; } } return false; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.*; import java.util.*; import com.fasterxml.jackson.databind.JavaType; public class TypeBindings implements java.io.Serializable { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private final static String[] NO_STRINGS = new String[0]; private final static JavaType[] NO_TYPES = new JavaType[0]; private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null); private final String[] _names; private final JavaType[] _types; private final String[] _unboundVariables; private final int _hashCode; private TypeBindings(String[] names, JavaType[] types, String[] uvars) { _names = (names == null) ? NO_STRINGS : names;"
      },
      {
        "txt": "_types = (types == null) ? NO_TYPES : types; if (_names.length != _types.length) { throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\"); } int h = 1; for (int i = 0, len = _types.length; i < len; ++i) { h += _types[i].hashCode(); } _unboundVariables = uvars; _hashCode = h;"
      },
      {
        "txt": "} public static TypeBindings emptyBindings() { return EMPTY; } protected Object readResolve() { if ((_names == null) || (_names.length == 0)) { return EMPTY; } return this; }"
      },
      {
        "txt": "public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList) { JavaType[] types = (typeList == null || typeList.isEmpty()) ? NO_TYPES : typeList.toArray(new JavaType[typeList.size()]); return create(erasedType, types); } public static TypeBindings create(Class<?> erasedType, JavaType[] types) { if (types == null) { types = NO_TYPES;"
      },
      {
        "txt": "} else switch (types.length) { case 1: return create(erasedType, types[0]); case 2: return create(erasedType, types[0], types[1]); } TypeVariable<?>[] vars = erasedType.getTypeParameters(); String[] names; if (vars == null || vars.length == 0) { names = NO_STRINGS;"
      },
      {
        "txt": "} else { int len = vars.length; names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\""
      },
      {
        "txt": "+((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()"
      },
      {
        "txt": "+\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) { TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 2) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 2 type parameters: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() }, new JavaType[] { typeArg1, typeArg2 }, null); } public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); int varLen = (vars == null) ? 0 : vars.length;"
      },
      {
        "txt": "if (varLen == 0) { return EMPTY; } if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); }"
      },
      {
        "txt": "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); if (vars == null || vars.length == 0) { return EMPTY; } if (types == null) { types = NO_TYPES; } int len = vars.length;"
      },
      {
        "txt": "String[] names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\" +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null);"
      },
      {
        "txt": "} public TypeBindings withUnboundVariable(String name) { int len = (_unboundVariables == null) ? 0 : _unboundVariables.length; String[] names = (len == 0) ? new String[1] : Arrays.copyOf(_unboundVariables, len+1); names[len] = name; return new TypeBindings(_names, _types, names); } public JavaType findBoundType(String name)"
      },
      {
        "txt": "{ for (int i = 0, len = _names.length; i < len; ++i) { if (name.equals(_names[i])) { JavaType t = _types[i]; if (t instanceof ResolvedRecursiveType) { ResolvedRecursiveType rrt = (ResolvedRecursiveType) t; JavaType t2 = rrt.getSelfReferencedType(); if (t2 != null) { t = t2; } else {"
      },
      {
        "txt": "throw new IllegalStateException(String.format (\"Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)\", name, i, t.getRawClass())); } } return t; } } return null; }"
      },
      {
        "txt": "public boolean isEmpty() { return (_types.length == 0); } public int size() { return _types.length; } public String getBoundName(int index) { if (index < 0 || index >= _names.length) { return null;"
      },
      {
        "txt": "} return _names[index]; } public JavaType getBoundType(int index) { if (index < 0 || index >= _types.length) { return null; } return _types[index]; }"
      },
      {
        "txt": "public List<JavaType> getTypeParameters() { if (_types.length == 0) { return Collections.emptyList(); } return Arrays.asList(_types); } public boolean hasUnbound(String name) { if (_unboundVariables != null) { for (int i = _unboundVariables.length; --i >= 0; ) {"
      },
      {
        "txt": "if (name.equals(_unboundVariables[i])) { return true; } } } return false; } @Override public String toString() { if (_types.length == 0) {"
      },
      {
        "txt": "return \"<>\"; } StringBuilder sb = new StringBuilder(); sb.append('<'); for (int i = 0, len = _types.length; i < len; ++i) { if (i > 0) { sb.append(','); } String sig = _types[i].getGenericSignature(); sb.append(sig);"
      },
      {
        "txt": "} sb.append('>'); return sb.toString(); } @Override public int hashCode() { return _hashCode; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null || o.getClass() != getClass()) return false; TypeBindings other = (TypeBindings) o;"
      },
      {
        "txt": "int len = _types.length; if (len != other.size()) { return false; } JavaType[] otherTypes = other._types; for (int i = 0; i < len; ++i) { if (!otherTypes[i].equals(_types[i])) { return false; } }"
      },
      {
        "txt": "return true; } protected JavaType[] typeParameterArray() { return _types; } static class TypeParamStash { private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters();"
      },
      {
        "txt": "private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters(); public static TypeVariable<?>[] paramsFor1(Class<?> erasedType) { if (erasedType == Collection.class) { return VARS_COLLECTION; } if (erasedType == List.class) {"
      },
      {
        "txt": "return VARS_LIST; } if (erasedType == ArrayList.class) { return VARS_ARRAY_LIST; } if (erasedType == AbstractList.class) { return VARS_ABSTRACT_LIST; } if (erasedType == Iterable.class) { return VARS_ITERABLE;"
      },
      {
        "txt": "} return erasedType.getTypeParameters(); } public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) { if (erasedType == Map.class) { return VARS_MAP; } if (erasedType == HashMap.class) { return VARS_HASH_MAP;"
      },
      {
        "txt": "if (erasedType == LinkedHashMap.class) { return VARS_LINKED_HASH_MAP; } return erasedType.getTypeParameters(); } } <extra_id_0> }"
      }
    ]
  },
  {
    "id": 1547,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java",
    "start-bug-line": 430,
    "end-bug-line": 430,
    "bug": "",
    "fix": "@Override public String toString() { return _raw.getName()+\"<>\"; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.*; import java.util.*; import com.fasterxml.jackson.databind.JavaType; public class TypeBindings implements java.io.Serializable { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private final static String[] NO_STRINGS = new String[0]; private final static JavaType[] NO_TYPES = new JavaType[0]; private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null); private final String[] _names; private final JavaType[] _types; private final String[] _unboundVariables; private final int _hashCode; private TypeBindings(String[] names, JavaType[] types, String[] uvars) { _names = (names == null) ? NO_STRINGS : names;"
      },
      {
        "txt": "_types = (types == null) ? NO_TYPES : types; if (_names.length != _types.length) { throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\"); } int h = 1; for (int i = 0, len = _types.length; i < len; ++i) { h += _types[i].hashCode(); } _unboundVariables = uvars; _hashCode = h;"
      },
      {
        "txt": "} public static TypeBindings emptyBindings() { return EMPTY; } protected Object readResolve() { if ((_names == null) || (_names.length == 0)) { return EMPTY; } return this; }"
      },
      {
        "txt": "public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList) { JavaType[] types = (typeList == null || typeList.isEmpty()) ? NO_TYPES : typeList.toArray(new JavaType[typeList.size()]); return create(erasedType, types); } public static TypeBindings create(Class<?> erasedType, JavaType[] types) { if (types == null) { types = NO_TYPES;"
      },
      {
        "txt": "} else switch (types.length) { case 1: return create(erasedType, types[0]); case 2: return create(erasedType, types[0], types[1]); } TypeVariable<?>[] vars = erasedType.getTypeParameters(); String[] names; if (vars == null || vars.length == 0) { names = NO_STRINGS;"
      },
      {
        "txt": "} else { int len = vars.length; names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\""
      },
      {
        "txt": "+((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()"
      },
      {
        "txt": "+\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); } public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) { TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType); int varLen = (vars == null) ? 0 : vars.length; if (varLen != 2) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 2 type parameters: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() }, new JavaType[] { typeArg1, typeArg2 }, null); } public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); int varLen = (vars == null) ? 0 : vars.length;"
      },
      {
        "txt": "if (varLen == 0) { return EMPTY; } if (varLen != 1) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with 1 type parameter: class expects \"+varLen); } return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null); }"
      },
      {
        "txt": "public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) { TypeVariable<?>[] vars = erasedType.getTypeParameters(); if (vars == null || vars.length == 0) { return EMPTY; } if (types == null) { types = NO_TYPES; } int len = vars.length;"
      },
      {
        "txt": "String[] names = new String[len]; for (int i = 0; i < len; ++i) { names[i] = vars[i].getName(); } if (names.length != types.length) { throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName() +\" with \"+types.length+\" type parameter\" +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length); } return new TypeBindings(names, types, null);"
      },
      {
        "txt": "} public TypeBindings withUnboundVariable(String name) { int len = (_unboundVariables == null) ? 0 : _unboundVariables.length; String[] names = (len == 0) ? new String[1] : Arrays.copyOf(_unboundVariables, len+1); names[len] = name; return new TypeBindings(_names, _types, names); } public JavaType findBoundType(String name)"
      },
      {
        "txt": "{ for (int i = 0, len = _names.length; i < len; ++i) { if (name.equals(_names[i])) { JavaType t = _types[i]; if (t instanceof ResolvedRecursiveType) { ResolvedRecursiveType rrt = (ResolvedRecursiveType) t; JavaType t2 = rrt.getSelfReferencedType(); if (t2 != null) { t = t2; } else {"
      },
      {
        "txt": "throw new IllegalStateException(String.format (\"Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)\", name, i, t.getRawClass())); } } return t; } } return null; }"
      },
      {
        "txt": "public boolean isEmpty() { return (_types.length == 0); } public int size() { return _types.length; } public String getBoundName(int index) { if (index < 0 || index >= _names.length) { return null;"
      },
      {
        "txt": "} return _names[index]; } public JavaType getBoundType(int index) { if (index < 0 || index >= _types.length) { return null; } return _types[index]; }"
      },
      {
        "txt": "public List<JavaType> getTypeParameters() { if (_types.length == 0) { return Collections.emptyList(); } return Arrays.asList(_types); } public boolean hasUnbound(String name) { if (_unboundVariables != null) { for (int i = _unboundVariables.length; --i >= 0; ) {"
      },
      {
        "txt": "if (name.equals(_unboundVariables[i])) { return true; } } } return false; } @Override public String toString() { if (_types.length == 0) {"
      },
      {
        "txt": "return \"<>\"; } StringBuilder sb = new StringBuilder(); sb.append('<'); for (int i = 0, len = _types.length; i < len; ++i) { if (i > 0) { sb.append(','); } String sig = _types[i].getGenericSignature(); sb.append(sig);"
      },
      {
        "txt": "} sb.append('>'); return sb.toString(); } @Override public int hashCode() { return _hashCode; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null || o.getClass() != getClass()) return false; TypeBindings other = (TypeBindings) o;"
      },
      {
        "txt": "int len = _types.length; if (len != other.size()) { return false; } JavaType[] otherTypes = other._types; for (int i = 0; i < len; ++i) { if (!otherTypes[i].equals(_types[i])) { return false; } }"
      },
      {
        "txt": "return true; } protected JavaType[] typeParameterArray() { return _types; } static class TypeParamStash { private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters();"
      },
      {
        "txt": "private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters(); private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters(); public static TypeVariable<?>[] paramsFor1(Class<?> erasedType) { if (erasedType == Collection.class) { return VARS_COLLECTION; } if (erasedType == List.class) {"
      },
      {
        "txt": "return VARS_LIST; } if (erasedType == ArrayList.class) { return VARS_ARRAY_LIST; } if (erasedType == AbstractList.class) { return VARS_ABSTRACT_LIST; } if (erasedType == Iterable.class) { return VARS_ITERABLE;"
      },
      {
        "txt": "} return erasedType.getTypeParameters(); } public static TypeVariable<?>[] paramsFor2(Class<?> erasedType) { if (erasedType == Map.class) { return VARS_MAP; } if (erasedType == HashMap.class) { return VARS_HASH_MAP;"
      },
      {
        "txt": "if (erasedType == LinkedHashMap.class) { return VARS_LINKED_HASH_MAP; } return erasedType.getTypeParameters(); } } <extra_id_0>"
      }
    ]
  },
  {
    "id": 1548,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 117,
    "end-bug-line": 117,
    "bug": "protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);",
    "fix": "protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory();"
      },
      {
        "txt": "protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); <extra_id_0> protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null;"
      },
      {
        "txt": "_parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods;"
      },
      {
        "txt": "_classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); }"
      },
      {
        "txt": "return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() {"
      },
      {
        "txt": "return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass();"
      },
      {
        "txt": "} public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim; } } Throwable prob = null;"
      },
      {
        "txt": "ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); }"
      },
      {
        "txt": "} try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) { throw (RuntimeException) prob;"
      },
      {
        "txt": "} throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); }"
      },
      {
        "txt": "protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE;"
      },
      {
        "txt": "if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; } JavaType newType;"
      },
      {
        "txt": "do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass,"
      },
      {
        "txt": "TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));"
      },
      {
        "txt": "break; } if (rawBase == EnumSet.class) { return baseType; } } } int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings());"
      },
      {
        "txt": "break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) {"
      },
      {
        "txt": "if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); }"
      },
      {
        "txt": "} while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());"
      },
      {
        "txt": "Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h); } return subtype; }"
      },
      {
        "txt": "} if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType; } JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType);"
      },
      {
        "txt": "} } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; }"
      },
      {
        "txt": "JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); }"
      },
      {
        "txt": "return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { JavaType match = type.findSuperType(expType); if (match == null) {"
      },
      {
        "txt": "return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {"
      },
      {
        "txt": "return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) { return type1; }"
      },
      {
        "txt": "Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; } return type1; }"
      },
      {
        "txt": "public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) { return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass();"
      },
      {
        "txt": "JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); }"
      },
      {
        "txt": "return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } @Deprecated public JavaType constructType(Type type, JavaType contextType) {"
      },
      {
        "txt": "TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); }"
      },
      {
        "txt": "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass,"
      },
      {
        "txt": "_fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; } return CollectionLikeType.upgradeFrom(type, elementType); }"
      },
      {
        "txt": "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); } return constructMapType(mapClass, kt, vt); }"
      },
      {
        "txt": "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS));"
      },
      {
        "txt": "} public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {"
      },
      {
        "txt": "return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); } public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {"
      },
      {
        "txt": "return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len];"
      },
      {
        "txt": "for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,"
      },
      {
        "txt": "JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {"
      },
      {
        "txt": "return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType());"
      },
      {
        "txt": "} private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) {"
      },
      {
        "txt": "case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); }"
      },
      {
        "txt": "} return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType();"
      },
      {
        "txt": "} else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);"
      },
      {
        "txt": "} protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result; } }"
      },
      {
        "txt": "return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() { return CORE_TYPE_OBJECT; }"
      },
      {
        "txt": "protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null;"
      },
      {
        "txt": "} protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); }"
      },
      {
        "txt": "else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) {"
      },
      {
        "txt": "resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) {"
      },
      {
        "txt": "JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; } } return resultType;"
      },
      {
        "txt": "} protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType);"
      },
      {
        "txt": "if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);"
      },
      {
        "txt": "prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else { JavaType superClass;"
      },
      {
        "txt": "JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces,"
      },
      {
        "txt": "CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) {"
      },
      {
        "txt": "result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); } return result;"
      },
      {
        "txt": "} protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)"
      },
      {
        "txt": "{ Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings);"
      },
      {
        "txt": "} return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) {"
      },
      {
        "txt": "return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,"
      },
      {
        "txt": "TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) {"
      },
      {
        "txt": "return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount];"
      },
      {
        "txt": "for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);"
      },
      {
        "txt": "return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; } if (bindings.hasUnbound(name)) {"
      },
      {
        "txt": "return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1549,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 385,
    "end-bug-line": 385,
    "bug": "",
    "fix": "TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference;"
      },
      {
        "txt": "import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE;"
      },
      {
        "txt": "private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);"
      },
      {
        "txt": "protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) {"
      },
      {
        "txt": "this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests"
      },
      {
        "txt": "return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); }"
      },
      {
        "txt": "public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); }"
      },
      {
        "txt": "public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className);"
      },
      {
        "txt": "if (prim != null) { return prim; } } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) {"
      },
      {
        "txt": "try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) {"
      },
      {
        "txt": "prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {"
      },
      {
        "txt": "return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE;"
      },
      {
        "txt": "if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {"
      },
      {
        "txt": "final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; }"
      },
      {
        "txt": "if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) {"
      },
      {
        "txt": "if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class)"
      },
      {
        "txt": "|| (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; }"
      },
      {
        "txt": "} int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } <extra_id_0> newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { TypeBindings tb = null;"
      },
      {
        "txt": "if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } }"
      },
      {
        "txt": "newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h);"
      },
      {
        "txt": "} return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType;"
      },
      {
        "txt": "} JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass();"
      },
      {
        "txt": "if (rawBase == superClass) { return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format("
      },
      {
        "txt": "\"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType)"
      },
      {
        "txt": "{ JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType);"
      },
      {
        "txt": "} @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; }"
      },
      {
        "txt": "if (type2 == null) { return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2;"
      },
      {
        "txt": "} return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef)"
      },
      {
        "txt": "{ return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray();"
      },
      {
        "txt": "if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings);"
      },
      {
        "txt": "} @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); }"
      },
      {
        "txt": "public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType));"
      },
      {
        "txt": "} public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type;"
      },
      {
        "txt": "} return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS);"
      },
      {
        "txt": "} return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {"
      },
      {
        "txt": "return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; }"
      },
      {
        "txt": "return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes);"
      },
      {
        "txt": "} public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); }"
      },
      {
        "txt": "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {"
      },
      {
        "txt": "return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {"
      },
      {
        "txt": "return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType());"
      },
      {
        "txt": "} public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING;"
      },
      {
        "txt": "} else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break;"
      },
      {
        "txt": "default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters();"
      },
      {
        "txt": "JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); }"
      },
      {
        "txt": "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) {"
      },
      {
        "txt": "return result; } } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); }"
      },
      {
        "txt": "protected JavaType _unknownType() { return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING;"
      },
      {
        "txt": "if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); }"
      },
      {
        "txt": "else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) {"
      },
      {
        "txt": "resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) {"
      },
      {
        "txt": "b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t;"
      },
      {
        "txt": "} } return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; }"
      },
      {
        "txt": "boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else {"
      },
      {
        "txt": "ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),"
      },
      {
        "txt": "bindings); } else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);"
      },
      {
        "txt": "} if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) {"
      },
      {
        "txt": "_typeCache.putIfAbsent(rawType, result); } return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; }"
      },
      {
        "txt": "return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len];"
      },
      {
        "txt": "for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) {"
      },
      {
        "txt": "return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; }"
      },
      {
        "txt": "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } }"
      },
      {
        "txt": "return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) {"
      },
      {
        "txt": "return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) {"
      },
      {
        "txt": "newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); }"
      },
      {
        "txt": "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) {"
      },
      {
        "txt": "return type; } if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      },
      {
        "txt": "{ return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1550,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 386,
    "end-bug-line": 386,
    "bug": "newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });",
    "fix": "newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE;"
      },
      {
        "txt": "private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);"
      },
      {
        "txt": "protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null);"
      },
      {
        "txt": "} protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader);"
      },
      {
        "txt": "} if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; }"
      },
      {
        "txt": "public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) {"
      },
      {
        "txt": "if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) {"
      },
      {
        "txt": "return prim; } } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try {"
      },
      {
        "txt": "return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e);"
      },
      {
        "txt": "} } if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader);"
      },
      {
        "txt": "} protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE;"
      },
      {
        "txt": "if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass();"
      },
      {
        "txt": "if (rawBase == subclass) { return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class)"
      },
      {
        "txt": "|| (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class)"
      },
      {
        "txt": "|| (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; } }"
      },
      {
        "txt": "int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { <extra_id_0> } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) {"
      },
      {
        "txt": "TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass,"
      },
      {
        "txt": "(tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);"
      },
      {
        "txt": "} JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h); }"
      },
      {
        "txt": "return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType; }"
      },
      {
        "txt": "JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) {"
      },
      {
        "txt": "return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\","
      },
      {
        "txt": "superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {"
      },
      {
        "txt": "JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); }"
      },
      {
        "txt": "@Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) {"
      },
      {
        "txt": "return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; }"
      },
      {
        "txt": "return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) {"
      },
      {
        "txt": "return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); }"
      },
      {
        "txt": "@Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) {"
      },
      {
        "txt": "return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); }"
      },
      {
        "txt": "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; }"
      },
      {
        "txt": "return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); }"
      },
      {
        "txt": "return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass,"
      },
      {
        "txt": "_fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType);"
      },
      {
        "txt": "} public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); }"
      },
      {
        "txt": "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {"
      },
      {
        "txt": "int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));"
      },
      {
        "txt": "} public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses);"
      },
      {
        "txt": "} public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); }"
      },
      {
        "txt": "public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default:"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct;"
      },
      {
        "txt": "if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");"
      },
      {
        "txt": "} return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result;"
      },
      {
        "txt": "} } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() {"
      },
      {
        "txt": "return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7"
      },
      {
        "txt": "} return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) {"
      },
      {
        "txt": "resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);"
      },
      {
        "txt": "} else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS;"
      },
      {
        "txt": "} for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; }"
      },
      {
        "txt": "} return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty();"
      },
      {
        "txt": "if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType);"
      },
      {
        "txt": "if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings);"
      },
      {
        "txt": "} else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); }"
      },
      {
        "txt": "if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) {"
      },
      {
        "txt": "result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result);"
      },
      {
        "txt": "} return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings);"
      },
      {
        "txt": "} protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) {"
      },
      {
        "txt": "Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "} if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null;"
      },
      {
        "txt": "} protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE;"
      },
      {
        "txt": "} if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS;"
      },
      {
        "txt": "} else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)"
      },
      {
        "txt": "{ JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type;"
      },
      {
        "txt": "} if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {"
      },
      {
        "txt": "return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1551,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 388,
    "end-bug-line": 388,
    "bug": "newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);",
    "fix": "newType = baseType.refine(subclass, tb, baseType, NO_TYPES);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory();"
      },
      {
        "txt": "protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser;"
      },
      {
        "txt": "protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {"
      },
      {
        "txt": "_parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) {"
      },
      {
        "txt": "return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear();"
      },
      {
        "txt": "} public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t;"
      },
      {
        "txt": "} return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim; }"
      },
      {
        "txt": "} Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader); } catch (Exception e) {"
      },
      {
        "txt": "prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); } }"
      },
      {
        "txt": "if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException {"
      },
      {
        "txt": "return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE;"
      },
      {
        "txt": "if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType;"
      },
      {
        "txt": "} JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType));"
      },
      {
        "txt": "} if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class)"
      },
      {
        "txt": "|| (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; } } } int typeParamCount = subclass.getTypeParameters().length;"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { <extra_id_0> } if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0));"
      },
      {
        "txt": "if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); }"
      },
      {
        "txt": "} while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());"
      },
      {
        "txt": "Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h); } return subtype; }"
      },
      {
        "txt": "} if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType; } JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType);"
      },
      {
        "txt": "} } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; }"
      },
      {
        "txt": "JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); }"
      },
      {
        "txt": "return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { JavaType match = type.findSuperType(expType); if (match == null) {"
      },
      {
        "txt": "return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {"
      },
      {
        "txt": "return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) { return type1; }"
      },
      {
        "txt": "Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; } return type1; }"
      },
      {
        "txt": "public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) { return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass();"
      },
      {
        "txt": "JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); }"
      },
      {
        "txt": "return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } @Deprecated public JavaType constructType(Type type, JavaType contextType) {"
      },
      {
        "txt": "TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); }"
      },
      {
        "txt": "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass,"
      },
      {
        "txt": "_fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; } return CollectionLikeType.upgradeFrom(type, elementType); }"
      },
      {
        "txt": "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); } return constructMapType(mapClass, kt, vt); }"
      },
      {
        "txt": "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS));"
      },
      {
        "txt": "} public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {"
      },
      {
        "txt": "return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); } public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {"
      },
      {
        "txt": "return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len];"
      },
      {
        "txt": "for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,"
      },
      {
        "txt": "JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {"
      },
      {
        "txt": "return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType());"
      },
      {
        "txt": "} private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) {"
      },
      {
        "txt": "case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); }"
      },
      {
        "txt": "} return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType();"
      },
      {
        "txt": "} else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);"
      },
      {
        "txt": "} protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result; } }"
      },
      {
        "txt": "return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() { return CORE_TYPE_OBJECT; }"
      },
      {
        "txt": "protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null;"
      },
      {
        "txt": "} protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); }"
      },
      {
        "txt": "else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) {"
      },
      {
        "txt": "resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) {"
      },
      {
        "txt": "JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; } } return resultType;"
      },
      {
        "txt": "} protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType);"
      },
      {
        "txt": "if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);"
      },
      {
        "txt": "prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else { JavaType superClass;"
      },
      {
        "txt": "JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces,"
      },
      {
        "txt": "CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) {"
      },
      {
        "txt": "result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); } return result;"
      },
      {
        "txt": "} protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)"
      },
      {
        "txt": "{ Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings);"
      },
      {
        "txt": "} return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) {"
      },
      {
        "txt": "return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,"
      },
      {
        "txt": "TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) {"
      },
      {
        "txt": "return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount];"
      },
      {
        "txt": "for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);"
      },
      {
        "txt": "return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; } if (bindings.hasUnbound(name)) {"
      },
      {
        "txt": "return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1552,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 392,
    "end-bug-line": 402,
    "bug": "TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);",
    "fix": "newType = _fromClass(null, subclass, tb);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap;"
      },
      {
        "txt": "@SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class;"
      },
      {
        "txt": "private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this);"
      },
      {
        "txt": "_modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader;"
      },
      {
        "txt": "} public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);"
      },
      {
        "txt": "} public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader;"
      },
      {
        "txt": "} public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); }"
      },
      {
        "txt": "public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim; } } Throwable prob = null; ClassLoader loader = this.getClassLoader();"
      },
      {
        "txt": "if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); } }"
      },
      {
        "txt": "try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) { throw (RuntimeException) prob; }"
      },
      {
        "txt": "throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className)"
      },
      {
        "txt": "{ if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE;"
      },
      {
        "txt": "return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; } JavaType newType; do { // bogus loop to be able to break"
      },
      {
        "txt": "if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings());"
      },
      {
        "txt": "break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));"
      },
      {
        "txt": "break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break;"
      },
      {
        "txt": "} if (rawBase == EnumSet.class) { return baseType; } } } int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break;"
      },
      {
        "txt": "if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { <extra_id_0> } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass)"
      },
      {
        "txt": "if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h);"
      },
      {
        "txt": "} h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h); } return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) {"
      },
      {
        "txt": "ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType; } JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass);"
      },
      {
        "txt": "} public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException"
      },
      {
        "txt": "{ return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray();"
      },
      {
        "txt": "} @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2)"
      },
      {
        "txt": "{ if (type1 == null) { return type2; } if (type2 == null) { return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) {"
      },
      {
        "txt": "return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; } return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); }"
      },
      {
        "txt": "public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) { return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated"
      },
      {
        "txt": "public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings);"
      },
      {
        "txt": "} public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS));"
      },
      {
        "txt": "} public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {"
      },
      {
        "txt": "JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; } return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) {"
      },
      {
        "txt": "kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); } return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] {"
      },
      {
        "txt": "keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass,"
      },
      {
        "txt": "TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated"
      },
      {
        "txt": "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); } public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType);"
      },
      {
        "txt": "} public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); }"
      },
      {
        "txt": "return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes);"
      },
      {
        "txt": "} public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {"
      },
      {
        "txt": "return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)"
      },
      {
        "txt": "{ JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break;"
      },
      {
        "txt": "case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); }"
      },
      {
        "txt": "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) {"
      },
      {
        "txt": "ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)"
      },
      {
        "txt": "{ if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result; } } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() { return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL;"
      },
      {
        "txt": "if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {"
      },
      {
        "txt": "JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; }"
      },
      {
        "txt": "else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));"
      },
      {
        "txt": "} if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format("
      },
      {
        "txt": "\"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; } } return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {"
      },
      {
        "txt": "JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; }"
      },
      {
        "txt": "} if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; }"
      },
      {
        "txt": "context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null;"
      },
      {
        "txt": "superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) {"
      },
      {
        "txt": "result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } }"
      },
      {
        "txt": "} } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); } return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {"
      },
      {
        "txt": "Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) {"
      },
      {
        "txt": "return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; }"
      },
      {
        "txt": "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) {"
      },
      {
        "txt": "return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "if (result != null) { return result; } } return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType();"
      },
      {
        "txt": "if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments();"
      },
      {
        "txt": "int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); }"
      },
      {
        "txt": "newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)"
      },
      {
        "txt": "{ final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; } if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name);"
      },
      {
        "txt": "Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1553,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 456,
    "end-bug-line": 456,
    "bug": "",
    "fix": "private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0];"
      },
      {
        "txt": "protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE;"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers;"
      },
      {
        "txt": "protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); }"
      },
      {
        "txt": "protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); }"
      },
      {
        "txt": "if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() {"
      },
      {
        "txt": "_typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) {"
      },
      {
        "txt": "return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim;"
      },
      {
        "txt": "} } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader);"
      },
      {
        "txt": "} catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); }"
      },
      {
        "txt": "} if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); }"
      },
      {
        "txt": "protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE;"
      },
      {
        "txt": "if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) {"
      },
      {
        "txt": "return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format("
      },
      {
        "txt": "\"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class)"
      },
      {
        "txt": "|| (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class)"
      },
      {
        "txt": "|| (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; } } }"
      },
      {
        "txt": "int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); }"
      },
      {
        "txt": "if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } }"
      },
      {
        "txt": "newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h);"
      },
      {
        "txt": "} return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType;"
      },
      {
        "txt": "JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } <extra_id_0> public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; }"
      },
      {
        "txt": "return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\","
      },
      {
        "txt": "superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {"
      },
      {
        "txt": "JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); }"
      },
      {
        "txt": "@Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) {"
      },
      {
        "txt": "return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; }"
      },
      {
        "txt": "return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) {"
      },
      {
        "txt": "return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); }"
      },
      {
        "txt": "@Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) {"
      },
      {
        "txt": "return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); }"
      },
      {
        "txt": "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; }"
      },
      {
        "txt": "return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); }"
      },
      {
        "txt": "return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass,"
      },
      {
        "txt": "_fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType);"
      },
      {
        "txt": "} public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); }"
      },
      {
        "txt": "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {"
      },
      {
        "txt": "int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));"
      },
      {
        "txt": "} public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses);"
      },
      {
        "txt": "} public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); }"
      },
      {
        "txt": "public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default:"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct;"
      },
      {
        "txt": "if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");"
      },
      {
        "txt": "} return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result;"
      },
      {
        "txt": "} } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() {"
      },
      {
        "txt": "return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7"
      },
      {
        "txt": "} return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) {"
      },
      {
        "txt": "resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);"
      },
      {
        "txt": "} else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS;"
      },
      {
        "txt": "} for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; }"
      },
      {
        "txt": "} return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty();"
      },
      {
        "txt": "if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType);"
      },
      {
        "txt": "if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings);"
      },
      {
        "txt": "} else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); }"
      },
      {
        "txt": "if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) {"
      },
      {
        "txt": "result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result);"
      },
      {
        "txt": "} return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings);"
      },
      {
        "txt": "} protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) {"
      },
      {
        "txt": "Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "} if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null;"
      },
      {
        "txt": "} protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE;"
      },
      {
        "txt": "} if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS;"
      },
      {
        "txt": "} else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)"
      },
      {
        "txt": "{ JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type;"
      },
      {
        "txt": "} if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {"
      },
      {
        "txt": "return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1554,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 458,
    "end-bug-line": 458,
    "bug": "",
    "fix": "int baseCount = baseType.containedTypeCount(); if (baseCount == typeParamCount) { if (typeParamCount == 1) { return TypeBindings.create(subclass, baseType.containedType(0)); } if (typeParamCount == 2) { return TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } List<JavaType> types = new ArrayList<JavaType>(baseCount); for (int i = 0; i < baseCount; ++i) { types.add(baseType.containedType(i)); } return TypeBindings.create(subclass, types); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0];"
      },
      {
        "txt": "protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE;"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers;"
      },
      {
        "txt": "protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); }"
      },
      {
        "txt": "protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); }"
      },
      {
        "txt": "if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() {"
      },
      {
        "txt": "_typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) {"
      },
      {
        "txt": "return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim;"
      },
      {
        "txt": "} } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader);"
      },
      {
        "txt": "} catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); }"
      },
      {
        "txt": "} if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); }"
      },
      {
        "txt": "protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE;"
      },
      {
        "txt": "if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) {"
      },
      {
        "txt": "return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format("
      },
      {
        "txt": "\"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class)"
      },
      {
        "txt": "|| (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class)"
      },
      {
        "txt": "|| (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; } } }"
      },
      {
        "txt": "int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); }"
      },
      {
        "txt": "if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } }"
      },
      {
        "txt": "newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h);"
      },
      {
        "txt": "} return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType;"
      },
      {
        "txt": "JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } <extra_id_0> public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; }"
      },
      {
        "txt": "return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\","
      },
      {
        "txt": "superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {"
      },
      {
        "txt": "JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); }"
      },
      {
        "txt": "@Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) {"
      },
      {
        "txt": "return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; }"
      },
      {
        "txt": "return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) {"
      },
      {
        "txt": "return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); }"
      },
      {
        "txt": "@Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) {"
      },
      {
        "txt": "return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); }"
      },
      {
        "txt": "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; }"
      },
      {
        "txt": "return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); }"
      },
      {
        "txt": "return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass,"
      },
      {
        "txt": "_fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType);"
      },
      {
        "txt": "} public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); }"
      },
      {
        "txt": "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {"
      },
      {
        "txt": "int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));"
      },
      {
        "txt": "} public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses);"
      },
      {
        "txt": "} public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); }"
      },
      {
        "txt": "public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default:"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct;"
      },
      {
        "txt": "if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");"
      },
      {
        "txt": "} return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result;"
      },
      {
        "txt": "} } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() {"
      },
      {
        "txt": "return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7"
      },
      {
        "txt": "} return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) {"
      },
      {
        "txt": "resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);"
      },
      {
        "txt": "} else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS;"
      },
      {
        "txt": "} for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; }"
      },
      {
        "txt": "} return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty();"
      },
      {
        "txt": "if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType);"
      },
      {
        "txt": "if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings);"
      },
      {
        "txt": "} else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); }"
      },
      {
        "txt": "if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) {"
      },
      {
        "txt": "result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result);"
      },
      {
        "txt": "} return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings);"
      },
      {
        "txt": "} protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) {"
      },
      {
        "txt": "Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "} if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null;"
      },
      {
        "txt": "} protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE;"
      },
      {
        "txt": "} if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS;"
      },
      {
        "txt": "} else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)"
      },
      {
        "txt": "{ JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type;"
      },
      {
        "txt": "} if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {"
      },
      {
        "txt": "return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1555,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 459,
    "end-bug-line": 459,
    "bug": "",
    "fix": "return TypeBindings.emptyBindings(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0];"
      },
      {
        "txt": "protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE;"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers;"
      },
      {
        "txt": "protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); }"
      },
      {
        "txt": "protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); }"
      },
      {
        "txt": "if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() {"
      },
      {
        "txt": "_typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) {"
      },
      {
        "txt": "return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim;"
      },
      {
        "txt": "} } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader);"
      },
      {
        "txt": "} catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); }"
      },
      {
        "txt": "} if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); }"
      },
      {
        "txt": "protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE;"
      },
      {
        "txt": "if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) {"
      },
      {
        "txt": "return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format("
      },
      {
        "txt": "\"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class)"
      },
      {
        "txt": "|| (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class)"
      },
      {
        "txt": "|| (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; } } }"
      },
      {
        "txt": "int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); }"
      },
      {
        "txt": "if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } }"
      },
      {
        "txt": "newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h);"
      },
      {
        "txt": "} return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType;"
      },
      {
        "txt": "JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } <extra_id_0> public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; }"
      },
      {
        "txt": "return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\","
      },
      {
        "txt": "superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {"
      },
      {
        "txt": "JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); }"
      },
      {
        "txt": "@Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) {"
      },
      {
        "txt": "return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; }"
      },
      {
        "txt": "return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) {"
      },
      {
        "txt": "return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); }"
      },
      {
        "txt": "@Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) {"
      },
      {
        "txt": "return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); }"
      },
      {
        "txt": "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; }"
      },
      {
        "txt": "return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); }"
      },
      {
        "txt": "return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass,"
      },
      {
        "txt": "_fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType);"
      },
      {
        "txt": "} public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); }"
      },
      {
        "txt": "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {"
      },
      {
        "txt": "int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));"
      },
      {
        "txt": "} public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses);"
      },
      {
        "txt": "} public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); }"
      },
      {
        "txt": "public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default:"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct;"
      },
      {
        "txt": "if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");"
      },
      {
        "txt": "} return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result;"
      },
      {
        "txt": "} } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() {"
      },
      {
        "txt": "return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7"
      },
      {
        "txt": "} return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) {"
      },
      {
        "txt": "resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);"
      },
      {
        "txt": "} else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS;"
      },
      {
        "txt": "} for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; }"
      },
      {
        "txt": "} return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty();"
      },
      {
        "txt": "if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType);"
      },
      {
        "txt": "if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings);"
      },
      {
        "txt": "} else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); }"
      },
      {
        "txt": "if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) {"
      },
      {
        "txt": "result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result);"
      },
      {
        "txt": "} return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings);"
      },
      {
        "txt": "} protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) {"
      },
      {
        "txt": "Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "} if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null;"
      },
      {
        "txt": "} protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE;"
      },
      {
        "txt": "} if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS;"
      },
      {
        "txt": "} else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)"
      },
      {
        "txt": "{ JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type;"
      },
      {
        "txt": "} if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {"
      },
      {
        "txt": "return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1556,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 1160,
    "end-bug-line": 1162,
    "bug": "boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType);",
    "fix": "final Object key; if ((bindings == null) || bindings.isEmpty()) { key = rawType; result = _typeCache.get(key); // ok, cache object is synced } else { key = bindings.asKey(rawType); } result = _typeCache.get(key); // ok, cache object is synced",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class;"
      },
      {
        "txt": "private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() {"
      },
      {
        "txt": "_parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods;"
      },
      {
        "txt": "_classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); }"
      },
      {
        "txt": "return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() {"
      },
      {
        "txt": "return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass();"
      },
      {
        "txt": "} public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim; } } Throwable prob = null;"
      },
      {
        "txt": "ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); }"
      },
      {
        "txt": "} try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) { throw (RuntimeException) prob;"
      },
      {
        "txt": "} throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); }"
      },
      {
        "txt": "protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE;"
      },
      {
        "txt": "if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; } JavaType newType;"
      },
      {
        "txt": "do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass,"
      },
      {
        "txt": "TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));"
      },
      {
        "txt": "break; } if (rawBase == EnumSet.class) { return baseType; } } } int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings());"
      },
      {
        "txt": "break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) {"
      },
      {
        "txt": "if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); }"
      },
      {
        "txt": "} while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());"
      },
      {
        "txt": "Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h); } return subtype; }"
      },
      {
        "txt": "} if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType; } JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType);"
      },
      {
        "txt": "} } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; }"
      },
      {
        "txt": "JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); }"
      },
      {
        "txt": "return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { JavaType match = type.findSuperType(expType); if (match == null) {"
      },
      {
        "txt": "return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {"
      },
      {
        "txt": "return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) { return type1; }"
      },
      {
        "txt": "Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; } return type1; }"
      },
      {
        "txt": "public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) { return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass();"
      },
      {
        "txt": "JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); }"
      },
      {
        "txt": "return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } @Deprecated public JavaType constructType(Type type, JavaType contextType) {"
      },
      {
        "txt": "TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); }"
      },
      {
        "txt": "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass,"
      },
      {
        "txt": "_fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; } return CollectionLikeType.upgradeFrom(type, elementType); }"
      },
      {
        "txt": "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); } return constructMapType(mapClass, kt, vt); }"
      },
      {
        "txt": "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS));"
      },
      {
        "txt": "} public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {"
      },
      {
        "txt": "return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); } public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {"
      },
      {
        "txt": "return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len];"
      },
      {
        "txt": "for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,"
      },
      {
        "txt": "JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {"
      },
      {
        "txt": "return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType());"
      },
      {
        "txt": "} private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) {"
      },
      {
        "txt": "case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); }"
      },
      {
        "txt": "} return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType();"
      },
      {
        "txt": "} else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);"
      },
      {
        "txt": "} protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result; } }"
      },
      {
        "txt": "return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() { return CORE_TYPE_OBJECT; }"
      },
      {
        "txt": "protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null;"
      },
      {
        "txt": "} protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); }"
      },
      {
        "txt": "else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) {"
      },
      {
        "txt": "resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) {"
      },
      {
        "txt": "JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; } } return resultType;"
      },
      {
        "txt": "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } <extra_id_0> if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType);"
      },
      {
        "txt": "if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType);"
      },
      {
        "txt": "} if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);"
      },
      {
        "txt": "} else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "} if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } }"
      },
      {
        "txt": "} context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); } return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType);"
      },
      {
        "txt": "if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES;"
      },
      {
        "txt": "} int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "} return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) {"
      },
      {
        "txt": "return result; } } return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) {"
      },
      {
        "txt": "return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length;"
      },
      {
        "txt": "JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt);"
      },
      {
        "txt": "} return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) {"
      },
      {
        "txt": "final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; } if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds();"
      },
      {
        "txt": "return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1557,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 1165,
    "end-bug-line": 1165,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference;"
      },
      {
        "txt": "import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE;"
      },
      {
        "txt": "private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);"
      },
      {
        "txt": "protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) {"
      },
      {
        "txt": "this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests"
      },
      {
        "txt": "return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); }"
      },
      {
        "txt": "public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); }"
      },
      {
        "txt": "public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className);"
      },
      {
        "txt": "if (prim != null) { return prim; } } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) {"
      },
      {
        "txt": "try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) {"
      },
      {
        "txt": "prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {"
      },
      {
        "txt": "return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE;"
      },
      {
        "txt": "if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {"
      },
      {
        "txt": "final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; }"
      },
      {
        "txt": "if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) {"
      },
      {
        "txt": "if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class)"
      },
      {
        "txt": "|| (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; }"
      },
      {
        "txt": "} } int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else {"
      },
      {
        "txt": "newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1));"
      },
      {
        "txt": "} } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass)"
      },
      {
        "txt": "|| Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler();"
      },
      {
        "txt": "if (h != null) { subtype = subtype.withTypeHandler(h); } return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType();"
      },
      {
        "txt": "if (at.getContentType().getRawClass() == rawComp) { return baseType; } JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)"
      },
      {
        "txt": "{ final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType));"
      },
      {
        "txt": "} throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical);"
      },
      {
        "txt": "} public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7"
      },
      {
        "txt": "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) {"
      },
      {
        "txt": "return type2; } if (type2 == null) { return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; }"
      },
      {
        "txt": "if (raw1.isAssignableFrom(raw2)) { return type2; } return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings);"
      },
      {
        "txt": "} public JavaType constructType(TypeReference<?> typeRef) { return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); }"
      },
      {
        "txt": "TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null)"
      },
      {
        "txt": "? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) {"
      },
      {
        "txt": "return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {"
      },
      {
        "txt": "return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType));"
      },
      {
        "txt": "if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; } return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else {"
      },
      {
        "txt": "kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); } return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType }));"
      },
      {
        "txt": "} public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) {"
      },
      {
        "txt": "return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)"
      },
      {
        "txt": "{ return constructSimpleType(rawType, parameterTypes); } public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) {"
      },
      {
        "txt": "return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); }"
      },
      {
        "txt": "public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,"
      },
      {
        "txt": "Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); }"
      },
      {
        "txt": "public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt;"
      },
      {
        "txt": "if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0);"
      },
      {
        "txt": "vt = typeParams.get(1); break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)"
      },
      {
        "txt": "{ List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); }"
      },
      {
        "txt": "return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) {"
      },
      {
        "txt": "ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) {"
      },
      {
        "txt": "JavaType result = _findWellKnownSimple(raw); if (result != null) { return result; } } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() { return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG;"
      },
      {
        "txt": "} else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) {"
      },
      {
        "txt": "resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings);"
      },
      {
        "txt": "} else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) {"
      },
      {
        "txt": "TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType));"
      },
      {
        "txt": "} resultType = t; } } return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) {"
      },
      {
        "txt": "} boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; <extra_id_0> } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) {"
      },
      {
        "txt": "ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),"
      },
      {
        "txt": "bindings); } else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);"
      },
      {
        "txt": "} if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) {"
      },
      {
        "txt": "_typeCache.putIfAbsent(rawType, result); } return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; }"
      },
      {
        "txt": "return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len];"
      },
      {
        "txt": "for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) {"
      },
      {
        "txt": "return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; }"
      },
      {
        "txt": "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } }"
      },
      {
        "txt": "return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) {"
      },
      {
        "txt": "return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) {"
      },
      {
        "txt": "newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); }"
      },
      {
        "txt": "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) {"
      },
      {
        "txt": "return type; } if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      },
      {
        "txt": "{ return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  },
  {
    "id": 1558,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 1225,
    "end-bug-line": 1227,
    "bug": "if (cachable) { _typeCache.putIfAbsent(rawType, result); }",
    "fix": "_typeCache.putIfAbsent(key, result); // cache object syncs",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();"
      },
      {
        "txt": "private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader;"
      },
      {
        "txt": "private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this);"
      },
      {
        "txt": "_modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);"
      },
      {
        "txt": "} return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); }"
      },
      {
        "txt": "public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; }"
      },
      {
        "txt": "return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim; } }"
      },
      {
        "txt": "Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e);"
      },
      {
        "txt": "} } try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) {"
      },
      {
        "txt": "throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name);"
      },
      {
        "txt": "} protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE;"
      },
      {
        "txt": "if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; }"
      },
      {
        "txt": "JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); }"
      },
      {
        "txt": "if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass,"
      },
      {
        "txt": "TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; } } } int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { TypeBindings tb = null;"
      },
      {
        "txt": "if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);"
      },
      {
        "txt": "} } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); }"
      },
      {
        "txt": "JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h); } return subtype;"
      },
      {
        "txt": "} } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType; } JavaType componentType = _fromAny(null, rawComp, null);"
      },
      {
        "txt": "return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType;"
      },
      {
        "txt": "} JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType));"
      },
      {
        "txt": "} return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { JavaType match = type.findSuperType(expType);"
      },
      {
        "txt": "if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); } @Deprecated // since 2.7"
      },
      {
        "txt": "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) { return type1;"
      },
      {
        "txt": "} Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; } return type1;"
      },
      {
        "txt": "} public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) { return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);"
      },
      {
        "txt": "final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");"
      },
      {
        "txt": "} return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } @Deprecated"
      },
      {
        "txt": "public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null);"
      },
      {
        "txt": "} public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {"
      },
      {
        "txt": "return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; } return CollectionLikeType.upgradeFrom(type, elementType);"
      },
      {
        "txt": "} public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); } return constructMapType(mapClass, kt, vt);"
      },
      {
        "txt": "} public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS),"
      },
      {
        "txt": "_fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType); }"
      },
      {
        "txt": "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); } public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)"
      },
      {
        "txt": "{ return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length;"
      },
      {
        "txt": "JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); }"
      },
      {
        "txt": "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses); }"
      },
      {
        "txt": "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) {"
      },
      {
        "txt": "return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters();"
      },
      {
        "txt": "switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");"
      },
      {
        "txt": "} } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) {"
      },
      {
        "txt": "ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)"
      },
      {
        "txt": "{ List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); }"
      },
      {
        "txt": "return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result; }"
      },
      {
        "txt": "} return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() { return CORE_TYPE_OBJECT;"
      },
      {
        "txt": "} protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 }"
      },
      {
        "txt": "return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings);"
      },
      {
        "txt": "} else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); }"
      },
      {
        "txt": "else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS; }"
      },
      {
        "txt": "for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); } resultType = t; } }"
      },
      {
        "txt": "return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) {"
      },
      {
        "txt": "result = _typeCache.get(rawType); if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) {"
      },
      {
        "txt": "ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else {"
      },
      {
        "txt": "JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) {"
      },
      {
        "txt": "result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); <extra_id_0> return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) {"
      },
      {
        "txt": "Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) {"
      },
      {
        "txt": "return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; }"
      },
      {
        "txt": "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) {"
      },
      {
        "txt": "return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "if (result != null) { return result; } } return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType();"
      },
      {
        "txt": "if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments();"
      },
      {
        "txt": "int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); }"
      },
      {
        "txt": "newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)"
      },
      {
        "txt": "{ final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; } if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name);"
      },
      {
        "txt": "Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  }
]