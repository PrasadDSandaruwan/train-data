[
  {
    "id": 1713,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 47,
    "end-bug-line": 47,
    "bug": "",
    "fix": "protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = \"yyyy-MM-dd'T'HH:mm:ss.SSS\";",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*;"
      },
      {
        "txt": "@SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; <extra_id_0> protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123;"
      },
      {
        "txt": "protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);"
      },
      {
        "txt": "DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z;"
      },
      {
        "txt": "protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {"
      },
      {
        "txt": "_timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE;"
      },
      {
        "txt": "} if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; }"
      },
      {
        "txt": "return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient); } @Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); }"
      },
      {
        "txt": "public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE);"
      },
      {
        "txt": "} @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats();"
      },
      {
        "txt": "_timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); }"
      },
      {
        "txt": "} @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true; } return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException"
      },
      {
        "txt": "{ dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true); } else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i);"
      },
      {
        "txt": "if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else {"
      },
      {
        "txt": "dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\");"
      },
      {
        "txt": "} else { sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); }"
      },
      {
        "txt": "@Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try { return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } }"
      },
      {
        "txt": "int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } } if (i < 0) { // all digits"
      },
      {
        "txt": "if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {"
      },
      {
        "txt": "if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition); } @Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone;"
      },
      {
        "txt": "if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str; } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); }"
      },
      {
        "txt": "@Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-'"
      },
      {
        "txt": ") { return true; } return false; } protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1);"
      },
      {
        "txt": "DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') {"
      },
      {
        "txt": "df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString();"
      },
      {
        "txt": "} } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\";"
      },
      {
        "txt": "} len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10:"
      },
      {
        "txt": "sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds"
      },
      {
        "txt": "sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601; formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); }"
      },
      {
        "txt": "} else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default:"
      },
      {
        "txt": "sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);"
      },
      {
        "txt": "} } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); }"
      },
      {
        "txt": "return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); }"
      },
      {
        "txt": "private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true; c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true;"
      },
      {
        "txt": "} return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else {"
      },
      {
        "txt": "df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; }"
      },
      {
        "txt": "protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1714,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 65,
    "end-bug-line": 65,
    "bug": "",
    "fix": "DATE_FORMAT_STR_ISO8601_NO_TZ,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat;"
      },
      {
        "txt": "import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat {"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, <extra_id_0> DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 }"
      },
      {
        "txt": "DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);"
      },
      {
        "txt": "DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale;"
      },
      {
        "txt": "protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) {"
      },
      {
        "txt": "_timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE;"
      },
      {
        "txt": "} public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient); }"
      },
      {
        "txt": "public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient); }"
      },
      {
        "txt": "@Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null);"
      },
      {
        "txt": "} @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override"
      },
      {
        "txt": "public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled;"
      },
      {
        "txt": "if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true; }"
      },
      {
        "txt": "return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true);"
      },
      {
        "txt": "} else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } }"
      },
      {
        "txt": "if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt; }"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"');"
      },
      {
        "txt": "throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try { return parseAsISO8601(dateStr, pos, false);"
      },
      {
        "txt": "} catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break;"
      },
      {
        "txt": "} } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos); }"
      },
      {
        "txt": "@Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition); }"
      },
      {
        "txt": "@Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str; }"
      },
      {
        "txt": "@Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) {"
      },
      {
        "txt": "if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)"
      },
      {
        "txt": "throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) {"
      },
      {
        "txt": "df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); }"
      },
      {
        "txt": "if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr);"
      },
      {
        "txt": "sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr);"
      },
      {
        "txt": "switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second"
      },
      {
        "txt": "break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601; formatStr = DATE_FORMAT_STR_ISO8601;"
      },
      {
        "txt": "if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0');"
      },
      {
        "txt": "case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException"
      },
      {
        "txt": "(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "_timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true;"
      },
      {
        "txt": "c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {"
      },
      {
        "txt": "if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) {"
      },
      {
        "txt": "df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1715,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 84,
    "end-bug-line": 84,
    "bug": "",
    "fix": "protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition;"
      },
      {
        "txt": "import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE;"
      },
      {
        "txt": "DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; <extra_id_0> protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);"
      },
      {
        "txt": "DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale;"
      },
      {
        "txt": "protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) {"
      },
      {
        "txt": "_timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE;"
      },
      {
        "txt": "} public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient); }"
      },
      {
        "txt": "public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient); }"
      },
      {
        "txt": "@Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null);"
      },
      {
        "txt": "} @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override"
      },
      {
        "txt": "public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled;"
      },
      {
        "txt": "if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true; }"
      },
      {
        "txt": "return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true);"
      },
      {
        "txt": "} else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } }"
      },
      {
        "txt": "if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt; }"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"');"
      },
      {
        "txt": "throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try { return parseAsISO8601(dateStr, pos, false);"
      },
      {
        "txt": "} catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break;"
      },
      {
        "txt": "} } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos); }"
      },
      {
        "txt": "@Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition); }"
      },
      {
        "txt": "@Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str; }"
      },
      {
        "txt": "@Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) {"
      },
      {
        "txt": "if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)"
      },
      {
        "txt": "throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) {"
      },
      {
        "txt": "df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); }"
      },
      {
        "txt": "if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr);"
      },
      {
        "txt": "sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr);"
      },
      {
        "txt": "switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second"
      },
      {
        "txt": "break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601; formatStr = DATE_FORMAT_STR_ISO8601;"
      },
      {
        "txt": "if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0');"
      },
      {
        "txt": "case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException"
      },
      {
        "txt": "(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "_timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true;"
      },
      {
        "txt": "c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {"
      },
      {
        "txt": "if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) {"
      },
      {
        "txt": "df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1716,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 102,
    "end-bug-line": 102,
    "bug": "",
    "fix": "DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat"
      },
      {
        "txt": "{ public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN"
      },
      {
        "txt": "}; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN;"
      },
      {
        "txt": "DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); <extra_id_0> DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient;"
      },
      {
        "txt": "protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7"
      },
      {
        "txt": "public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() {"
      },
      {
        "txt": "return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient);"
      },
      {
        "txt": "} public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient);"
      },
      {
        "txt": "} @Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "tz, loc, null); } @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; }"
      },
      {
        "txt": "@Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) {"
      },
      {
        "txt": "Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true;"
      },
      {
        "txt": "} return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\""
      },
      {
        "txt": "dt = parseAsISO8601(dateStr, pos, true); } else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } }"
      },
      {
        "txt": "} if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt;"
      },
      {
        "txt": "} StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); }"
      },
      {
        "txt": "sb.append('\"'); throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try {"
      },
      {
        "txt": "return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') {"
      },
      {
        "txt": "break; } } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos);"
      },
      {
        "txt": "} @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition);"
      },
      {
        "txt": "} @Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str;"
      },
      {
        "txt": "} @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr)"
      },
      {
        "txt": "{ if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; }"
      },
      {
        "txt": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN;"
      },
      {
        "txt": "if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);"
      },
      {
        "txt": "} if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break;"
      },
      {
        "txt": "case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) {"
      },
      {
        "txt": "case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString();"
      },
      {
        "txt": "df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) {"
      },
      {
        "txt": "throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) {"
      },
      {
        "txt": "_formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6);"
      },
      {
        "txt": "if (c == '+' || c == '-') return true; c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)"
      },
      {
        "txt": "{ if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } }"
      },
      {
        "txt": "if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null;"
      }
    ]
  },
  {
    "id": 1717,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 132,
    "end-bug-line": 132,
    "bug": "",
    "fix": "protected transient DateFormat _formatISO8601_noTz; // 2.8.10",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat"
      },
      {
        "txt": "{ public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN"
      },
      {
        "txt": "}; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN;"
      },
      {
        "txt": "static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); }"
      },
      {
        "txt": "protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; <extra_id_0> public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz;"
      },
      {
        "txt": "public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() {"
      },
      {
        "txt": "return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient);"
      },
      {
        "txt": "} public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient);"
      },
      {
        "txt": "} @Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "tz, loc, null); } @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; }"
      },
      {
        "txt": "@Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) {"
      },
      {
        "txt": "Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true;"
      },
      {
        "txt": "} return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\""
      },
      {
        "txt": "dt = parseAsISO8601(dateStr, pos, true); } else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } }"
      },
      {
        "txt": "} if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt;"
      },
      {
        "txt": "} StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); }"
      },
      {
        "txt": "sb.append('\"'); throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try {"
      },
      {
        "txt": "return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') {"
      },
      {
        "txt": "break; } } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos);"
      },
      {
        "txt": "} @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition);"
      },
      {
        "txt": "} @Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str;"
      },
      {
        "txt": "} @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr)"
      },
      {
        "txt": "{ if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; }"
      },
      {
        "txt": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN;"
      },
      {
        "txt": "if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);"
      },
      {
        "txt": "} if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break;"
      },
      {
        "txt": "case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) {"
      },
      {
        "txt": "case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString();"
      },
      {
        "txt": "df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) {"
      },
      {
        "txt": "throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) {"
      },
      {
        "txt": "_formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6);"
      },
      {
        "txt": "if (c == '+' || c == '-') return true; c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)"
      },
      {
        "txt": "{ if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } }"
      },
      {
        "txt": "if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null;"
      }
    ]
  },
  {
    "id": 1718,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 514,
    "end-bug-line": 514,
    "bug": "StringBuilder sb = new StringBuilder(dateStr);",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat;"
      },
      {
        "txt": "import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat {"
      },
      {
        "txt": "public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN };"
      },
      {
        "txt": "private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static {"
      },
      {
        "txt": "DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat();"
      },
      {
        "txt": "protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; }"
      },
      {
        "txt": "@Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; }"
      },
      {
        "txt": "public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; }"
      },
      {
        "txt": "return new StdDateFormat(tz, _locale, _lenient); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() {"
      },
      {
        "txt": "return new StdDateFormat(_timezone, _locale, _lenient); } @Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {"
      },
      {
        "txt": "return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone;"
      },
      {
        "txt": "} @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7"
      },
      {
        "txt": "public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) {"
      },
      {
        "txt": "return true; } return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt;"
      },
      {
        "txt": "if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true); } else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; }"
      },
      {
        "txt": "} } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) {"
      },
      {
        "txt": "return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f);"
      },
      {
        "txt": "} sb.append('\"'); throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\""
      },
      {
        "txt": "try { return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') {"
      },
      {
        "txt": "if (i > 0 || ch != '-') { break; } } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } }"
      },
      {
        "txt": "return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); }"
      },
      {
        "txt": "return _formatISO8601.format(date, toAppendTo, fieldPosition); } @Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\";"
      },
      {
        "txt": "return str; } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); }"
      },
      {
        "txt": "protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false;"
      },
      {
        "txt": "} protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,"
      },
      {
        "txt": "DEFAULT_TIMEZONE, _locale, _lenient); } if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3);"
      },
      {
        "txt": "if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss"
      },
      {
        "txt": "int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8:"
      },
      {
        "txt": "sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); }"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { <extra_id_0> int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0');"
      },
      {
        "txt": "case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException"
      },
      {
        "txt": "(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "_timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true;"
      },
      {
        "txt": "c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {"
      },
      {
        "txt": "if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) {"
      },
      {
        "txt": "df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1719,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 518,
    "end-bug-line": 518,
    "bug": "",
    "fix": "StringBuilder sb = new StringBuilder(dateStr);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition;"
      },
      {
        "txt": "import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7"
      },
      {
        "txt": "} private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);"
      },
      {
        "txt": "DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient;"
      },
      {
        "txt": "protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz;"
      },
      {
        "txt": "_locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; }"
      },
      {
        "txt": "public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient); } public StdDateFormat withLocale(Locale loc) {"
      },
      {
        "txt": "if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient); } @Deprecated"
      },
      {
        "txt": "public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); }"
      },
      {
        "txt": "@Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz)"
      },
      {
        "txt": "{ if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) {"
      },
      {
        "txt": "_lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true; } return _lenient.booleanValue();"
      },
      {
        "txt": "} @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true); } else {"
      },
      {
        "txt": "int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } } if ((i < 0)"
      },
      {
        "txt": "&& (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt; } StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException"
      },
      {
        "txt": "(String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try { return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared..."
      },
      {
        "txt": "return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; }"
      },
      {
        "txt": "} } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos); } @Override"
      },
      {
        "txt": "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition); } @Override"
      },
      {
        "txt": "public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str; } @Override // since 2.7[.2], as per [databind#1130]"
      },
      {
        "txt": "public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5"
      },
      {
        "txt": "&& Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException"
      },
      {
        "txt": "{ int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,"
      },
      {
        "txt": "_timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } if (dateStr.charAt(len-4) == ':') {"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2);"
      },
      {
        "txt": "dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) {"
      },
      {
        "txt": "case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second break;"
      },
      {
        "txt": "case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601; formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) {"
      },
      {
        "txt": "_timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial <extra_id_0> case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\");"
      },
      {
        "txt": "default: sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,"
      },
      {
        "txt": "DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());"
      },
      {
        "txt": "} return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos);"
      },
      {
        "txt": "} private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true; c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3);"
      },
      {
        "txt": "if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);"
      },
      {
        "txt": "} else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df;"
      },
      {
        "txt": "} protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1720,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 526,
    "end-bug-line": 526,
    "bug": "",
    "fix": "dateStr = sb.toString();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition;"
      },
      {
        "txt": "import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE;"
      },
      {
        "txt": "static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);"
      },
      {
        "txt": "DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone;"
      },
      {
        "txt": "protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7"
      },
      {
        "txt": "public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() {"
      },
      {
        "txt": "return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient);"
      },
      {
        "txt": "} public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient);"
      },
      {
        "txt": "} @Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "tz, loc, null); } @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; }"
      },
      {
        "txt": "@Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) {"
      },
      {
        "txt": "Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true;"
      },
      {
        "txt": "} return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\""
      },
      {
        "txt": "dt = parseAsISO8601(dateStr, pos, true); } else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } }"
      },
      {
        "txt": "} if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt;"
      },
      {
        "txt": "} StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); }"
      },
      {
        "txt": "sb.append('\"'); throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try {"
      },
      {
        "txt": "return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') {"
      },
      {
        "txt": "break; } } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos);"
      },
      {
        "txt": "} @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition);"
      },
      {
        "txt": "} @Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str;"
      },
      {
        "txt": "} @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr)"
      },
      {
        "txt": "{ if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; }"
      },
      {
        "txt": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN;"
      },
      {
        "txt": "if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);"
      },
      {
        "txt": "} if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break;"
      },
      {
        "txt": "case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) {"
      },
      {
        "txt": "case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\"); } <extra_id_0> sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,"
      },
      {
        "txt": "if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\","
      },
      {
        "txt": "dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient);"
      },
      {
        "txt": "} return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true; c = str.charAt(len-5);"
      },
      {
        "txt": "if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) {"
      },
      {
        "txt": "df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue());"
      },
      {
        "txt": "} return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1721,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 527,
    "end-bug-line": 530,
    "bug": "sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z;",
    "fix": "df = _formatISO8601_noTz; formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException;"
      },
      {
        "txt": "import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static {"
      },
      {
        "txt": "DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);"
      },
      {
        "txt": "DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale;"
      },
      {
        "txt": "protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) {"
      },
      {
        "txt": "_timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE;"
      },
      {
        "txt": "} public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient); }"
      },
      {
        "txt": "public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient); }"
      },
      {
        "txt": "@Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null);"
      },
      {
        "txt": "} @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override"
      },
      {
        "txt": "public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled;"
      },
      {
        "txt": "if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true; }"
      },
      {
        "txt": "return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true);"
      },
      {
        "txt": "} else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } }"
      },
      {
        "txt": "if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt; }"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"');"
      },
      {
        "txt": "throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try { return parseAsISO8601(dateStr, pos, false);"
      },
      {
        "txt": "} catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break;"
      },
      {
        "txt": "} } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos); }"
      },
      {
        "txt": "@Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition); }"
      },
      {
        "txt": "@Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str; }"
      },
      {
        "txt": "@Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) {"
      },
      {
        "txt": "if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)"
      },
      {
        "txt": "throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) {"
      },
      {
        "txt": "df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); }"
      },
      {
        "txt": "if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr);"
      },
      {
        "txt": "sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr);"
      },
      {
        "txt": "switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second"
      },
      {
        "txt": "break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601; formatStr = DATE_FORMAT_STR_ISO8601;"
      },
      {
        "txt": "if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0');"
      },
      {
        "txt": "case 9: sb.append('0'); break; default: sb.append(\".000\"); } } <extra_id_0> if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } }"
      },
      {
        "txt": "} } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt;"
      },
      {
        "txt": "} protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str)"
      },
      {
        "txt": "{ int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true; c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; }"
      },
      {
        "txt": "return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone();"
      },
      {
        "txt": "if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() {"
      },
      {
        "txt": "_formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1722,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 535,
    "end-bug-line": 536,
    "bug": "df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);",
    "fix": "df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr, _timezone, _locale, _lenient);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\")"
      },
      {
        "txt": "public class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z,"
      },
      {
        "txt": "DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601;"
      },
      {
        "txt": "protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);"
      },
      {
        "txt": "DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain;"
      },
      {
        "txt": "public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz;"
      },
      {
        "txt": "_locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; }"
      },
      {
        "txt": "if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient);"
      },
      {
        "txt": "} @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient); } @Deprecated public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {"
      },
      {
        "txt": "return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); }"
      },
      {
        "txt": "@Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz;"
      },
      {
        "txt": "} } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } }"
      },
      {
        "txt": "@Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true; } return _lenient.booleanValue(); } @Override public Date parse(String dateStr) throws ParseException {"
      },
      {
        "txt": "dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true); } else { int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') {"
      },
      {
        "txt": "if (i > 0 || ch != '-') { break; } } } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos);"
      },
      {
        "txt": "} } if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else {"
      },
      {
        "txt": "sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override"
      },
      {
        "txt": "public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try { return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared... return null; } } int i = dateStr.length();"
      },
      {
        "txt": "while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {"
      },
      {
        "txt": "return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) {"
      },
      {
        "txt": "_formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition); } @Override public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) {"
      },
      {
        "txt": "str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str; } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130]"
      },
      {
        "txt": "public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) {"
      },
      {
        "txt": "return true; } return false; } protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException { int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df;"
      },
      {
        "txt": "String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z;"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); }"
      },
      {
        "txt": "} else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; }"
      },
      {
        "txt": "len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break;"
      },
      {
        "txt": "case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\");"
      },
      {
        "txt": "} dateStr = sb.toString(); } df = _formatISO8601; formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else {"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\".000\");"
      },
      {
        "txt": "} sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { <extra_id_0> } } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException"
      },
      {
        "txt": "if (dt == null) { throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {"
      },
      {
        "txt": "if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) {"
      },
      {
        "txt": "char c = str.charAt(len-6); if (c == '+' || c == '-') return true; c = str.charAt(len-5); if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format,"
      },
      {
        "txt": "TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); }"
      },
      {
        "txt": "} if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null;"
      },
      {
        "txt": "_formatPlain = null; }"
      }
    ]
  },
  {
    "id": 1723,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 597,
    "end-bug-line": 597,
    "bug": "",
    "fix": "_formatISO8601_noTz = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition;"
      },
      {
        "txt": "import java.text.SimpleDateFormat; import java.util.*; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7"
      },
      {
        "txt": "} private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);"
      },
      {
        "txt": "DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient;"
      },
      {
        "txt": "protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz;"
      },
      {
        "txt": "_locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { _timezone = tz; _locale = loc; _lenient = lenient; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; }"
      },
      {
        "txt": "public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient); } public StdDateFormat withLocale(Locale loc) {"
      },
      {
        "txt": "if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient); } @Deprecated"
      },
      {
        "txt": "public static DateFormat getISO8601Format(TimeZone tz) { return getISO8601Format(tz, DEFAULT_LOCALE); } public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); }"
      },
      {
        "txt": "@Deprecated public static DateFormat getRFC1123Format(TimeZone tz) { return getRFC1123Format(tz, DEFAULT_LOCALE); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz)"
      },
      {
        "txt": "{ if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) {"
      },
      {
        "txt": "_lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { if (_lenient == null) { return true; } return _lenient.booleanValue();"
      },
      {
        "txt": "} @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt; if (looksLikeISO8601(dateStr)) { // also includes \"plain\" dt = parseAsISO8601(dateStr, pos, true); } else {"
      },
      {
        "txt": "int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } } if ((i < 0)"
      },
      {
        "txt": "&& (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { dt = new Date(Long.parseLong(dateStr)); } else { dt = parseAsRFC1123(dateStr, pos); } } if (dt != null) { return dt; } StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException"
      },
      {
        "txt": "(String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" try { return parseAsISO8601(dateStr, pos, false); } catch (ParseException e) { // will NOT be thrown due to false but is declared..."
      },
      {
        "txt": "return null; } } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; }"
      },
      {
        "txt": "} } if (i < 0) { // all digits if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) { return new Date(Long.parseLong(dateStr)); } } return parseAsRFC1123(dateStr, pos); } @Override"
      },
      {
        "txt": "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { if (_formatISO8601 == null) { _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale, _lenient); } return _formatISO8601.format(date, toAppendTo, fieldPosition); } @Override"
      },
      {
        "txt": "public String toString() { String str = \"DateFormat \"+getClass().getName(); TimeZone tz = _timezone; if (tz != null) { str += \" (timezone: \"+tz+\")\"; } str += \"(locale: \"+_locale+\")\"; return str; } @Override // since 2.7[.2], as per [databind#1130]"
      },
      {
        "txt": "public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5"
      },
      {
        "txt": "&& Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException"
      },
      {
        "txt": "{ int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df; String formatStr; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; formatStr = DATE_FORMAT_STR_PLAIN; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,"
      },
      {
        "txt": "_timezone, _locale, _lenient); } } else if (c == 'Z') { df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } if (dateStr.charAt(len-4) == ':') {"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, \".000\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { // remove optional colon StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2);"
      },
      {
        "txt": "dateStr = sb.toString(); } else if (c == '+' || c == '-') { // missing minutes dateStr += \"00\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) {"
      },
      {
        "txt": "case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \"00\"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, \"000\"); break; case 8: sb.insert(offset, \".000\"); break; case 7: // not legal to have single-digit second break;"
      },
      {
        "txt": "case 6: // probably not legal, but let's allow sb.insert(offset, \"00.000\"); case 5: // is legal to omit seconds sb.insert(offset, \":00.000\"); } dateStr = sb.toString(); } df = _formatISO8601; formatStr = DATE_FORMAT_STR_ISO8601; if (_formatISO8601 == null) {"
      },
      {
        "txt": "df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0');"
      },
      {
        "txt": "case 9: sb.append('0'); break; default: sb.append(\".000\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z;"
      },
      {
        "txt": "if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } } Date dt = df.parse(dateStr, pos); if (dt == null) { throw new ParseException (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\","
      },
      {
        "txt": "dateStr, formatStr, _lenient), pos.getErrorIndex()); } return dt; } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient);"
      },
      {
        "txt": "} return _formatRFC1123.parse(dateStr, pos); } private final static boolean hasTimeZone(String str) { int len = str.length(); if (len >= 6) { char c = str.charAt(len-6); if (c == '+' || c == '-') return true; c = str.charAt(len-5);"
      },
      {
        "txt": "if (c == '+' || c == '-') return true; c = str.charAt(len-3); if (c == '+' || c == '-') return true; } return false; } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) {"
      },
      {
        "txt": "df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue());"
      },
      {
        "txt": "return df; } protected void _clearFormats() { _formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; <extra_id_0> _formatPlain = null; } }"
      }
    ]
  }
]