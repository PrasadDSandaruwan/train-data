[
  {
    "id": 1520,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
    "start-bug-line": 816,
    "end-bug-line": 816,
    "bug": "",
    "fix": "Class<?> currRaw = type.getRawClass();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind; import java.lang.annotation.Annotation; import java.util.*; import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.core.Version;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.Versioned; import com.fasterxml.jackson.databind.JsonDeserializer; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.deser.ValueInstantiator; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ser.BeanPropertyWriter; import com.fasterxml.jackson.databind.type.MapLikeType; import com.fasterxml.jackson.databind.type.TypeFactory; import com.fasterxml.jackson.databind.util.Converter; import com.fasterxml.jackson.databind.util.NameTransformer; @SuppressWarnings(\"serial\") public abstract class AnnotationIntrospector implements Versioned, java.io.Serializable { public static class ReferenceProperty"
      },
      {
        "txt": "{ public enum Type { MANAGED_REFERENCE ,BACK_REFERENCE ; } private final Type _type; private final String _name; public ReferenceProperty(Type t, String n) { _type = t;"
      },
      {
        "txt": "_name = n; } public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); } public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); } public Type getType() { return _type; } public String getName() { return _name; } public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; } public boolean isBackReference() { return _type == Type.BACK_REFERENCE; } } public static AnnotationIntrospector nopInstance() {"
      },
      {
        "txt": "return NopAnnotationIntrospector.instance; } public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) { return new AnnotationIntrospectorPair(a1, a2); } public Collection<AnnotationIntrospector> allIntrospectors() { return Collections.singletonList(this); } public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) { result.add(this);"
      },
      {
        "txt": "return result; } @Override public abstract Version version(); public boolean isAnnotationBundle(Annotation ann) { return false; } public ObjectIdInfo findObjectIdInfo(Annotated ann) { return null; }"
      },
      {
        "txt": "public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { return objectIdInfo; } public PropertyName findRootName(AnnotatedClass ac) { return null; } public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) { return null; } @Deprecated"
      },
      {
        "txt": "public String[] findPropertiesToIgnore(Annotated ac) { return findPropertiesToIgnore(ac, true); } public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { return null; } public Boolean isIgnorableType(AnnotatedClass ac) { return null; } public Object findFilterId(Annotated ann) { return null; } public Object findNamingStrategy(AnnotatedClass ac) { return null; } public String findClassDescription(AnnotatedClass ac) { return null; } public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) { return checker;"
      },
      {
        "txt": "} public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) { return null; } public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) { return null; } public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,"
      },
      {
        "txt": "AnnotatedMember am, JavaType containerType) { return null; } public List<NamedType> findSubtypes(Annotated a) { return null; } public String findTypeName(AnnotatedClass ac) { return null; } public Boolean isTypeId(AnnotatedMember member) { return null; } public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; } public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; } public boolean hasIgnoreMarker(AnnotatedMember m) { return false; } public Object findInjectableValueId(AnnotatedMember m) { return null; }"
      },
      {
        "txt": "public Boolean hasRequiredMarker(AnnotatedMember m) { return null; } public Class<?>[] findViews(Annotated a) { return null; } public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; } public PropertyName findWrapperName(Annotated ann) { return null; } public String findPropertyDefaultValue(Annotated ann) { return null; } public String findPropertyDescription(Annotated ann) { return null; } public Integer findPropertyIndex(Annotated ann) { return null; } public String findImplicitPropertyName(AnnotatedMember member) { return null; } public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; } public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config,"
      },
      {
        "txt": "AnnotatedMethod setter1, AnnotatedMethod setter2) { return null; } public Object findSerializer(Annotated am) { return null; } public Object findKeySerializer(Annotated am) { return null; } public Object findContentSerializer(Annotated am) {"
      },
      {
        "txt": "return null; } public Object findNullSerializer(Annotated am) { return null; } public JsonSerialize.Typing findSerializationTyping(Annotated a) { return null; } public Object findSerializationConverter(Annotated a) { return null;"
      },
      {
        "txt": "} public Object findSerializationContentConverter(AnnotatedMember a) { return null; } @Deprecated // since 2.7 public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { return defValue; } @Deprecated // since 2.7 public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {"
      },
      {
        "txt": "return defValue; } public JsonInclude.Value findPropertyInclusion(Annotated a) { return JsonInclude.Value.empty(); } @Deprecated // since 2.7 public Class<?> findSerializationType(Annotated a) { return null; } @Deprecated // since 2.7"
      },
      {
        "txt": "public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { return null; } @Deprecated // since 2.7 public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { return null; } public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {"
      },
      {
        "txt": "final TypeFactory tf = config.getTypeFactory(); Class<?> serClass = findSerializationType(a); if (serClass != null) { if (type.hasRawClass(serClass)) { type = type.withStaticTyping(); } else { <extra_id_0> type = tf.constructGeneralizedType(type, serClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);"
      },
      {
        "txt": "type, serClass.getName(), a.getName(), iae.getMessage()), iae); } } } if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); Class<?> keyClass = findSerializationKeyType(a, keyType); if (keyClass != null) { if (keyType.hasRawClass(keyClass)) {"
      },
      {
        "txt": "keyType = keyType.withStaticTyping(); } else { Class<?> currRaw = keyType.getRawClass(); try { if (keyClass.isAssignableFrom(currRaw)) { // common case keyType = tf.constructGeneralizedType(keyType, keyClass); } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well keyType = tf.constructSpecializedType(keyType, keyClass); } else { throw new JsonMappingException(null,"
      },
      {
        "txt": "String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName())); } } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae); } }"
      },
      {
        "txt": "type = ((MapLikeType) type).withKeyType(keyType); } } JavaType contentType = type.getContentType(); if (contentType != null) { // collection[like], map[like], array, reference Class<?> contentClass = findSerializationContentType(a, contentType); if (contentClass != null) { if (contentType.hasRawClass(contentClass)) { contentType = contentType.withStaticTyping(); } else {"
      },
      {
        "txt": "Class<?> currRaw = contentType.getRawClass(); try { if (contentClass.isAssignableFrom(currRaw)) { // common case contentType = tf.constructGeneralizedType(contentType, contentClass); } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well contentType = tf.constructSpecializedType(contentType, contentClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));"
      },
      {
        "txt": "} } catch (IllegalArgumentException iae) { // shouldn't really happen throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae); } } type = type.withContentType(contentType); }"
      },
      {
        "txt": "} return type; } public String[] findSerializationPropertyOrder(AnnotatedClass ac) { return null; } public Boolean findSerializationSortAlphabetically(Annotated ann) { return null; } public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,"
      },
      {
        "txt": "List<BeanPropertyWriter> properties) { } public PropertyName findNameForSerialization(Annotated a) { if (name != null) { if (name.length() == 0) { // empty String means 'default' return PropertyName.USE_DEFAULT; } return new PropertyName(name); } return null; }"
      },
      {
        "txt": "public boolean hasAsValueAnnotation(AnnotatedMethod am) { return false; } public String findEnumValue(Enum<?> value) { return value.name(); } public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) { for (int i = 0, len = enumValues.length; i < len; ++i) { if (names[i] == null) { names[i] = findEnumValue(enumValues[i]);"
      },
      {
        "txt": "} } return names; } public Object findDeserializer(Annotated am) { return null; } public Object findKeyDeserializer(Annotated am) { return null; }"
      },
      {
        "txt": "public Object findContentDeserializer(Annotated am) { return null; } public Object findDeserializationConverter(Annotated a) { return null; } public Object findDeserializationContentConverter(AnnotatedMember a) { return null; } public JavaType refineDeserializationType(final MapperConfig<?> config,"
      },
      {
        "txt": "final Annotated a, final JavaType baseType) throws JsonMappingException { JavaType type = baseType; final TypeFactory tf = config.getTypeFactory(); Class<?> valueClass = findDeserializationType(a, type); if ((valueClass != null) && !type.hasRawClass(valueClass)) { try { type = tf.constructSpecializedType(type, valueClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null,"
      },
      {
        "txt": "String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae); } } if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); Class<?> keyClass = findDeserializationKeyType(a, keyType); if (keyClass != null) { try {"
      },
      {
        "txt": "keyType = tf.constructSpecializedType(keyType, keyClass); type = ((MapLikeType) type).withKeyType(keyType); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae); } } }"
      },
      {
        "txt": "JavaType contentType = type.getContentType(); if (contentType != null) { // collection[like], map[like], array, reference Class<?> contentClass = findDeserializationContentType(a, contentType); if (contentClass != null) { try { contentType = tf.constructSpecializedType(contentType, contentClass); type = type.withContentType(contentType); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\","
      },
      {
        "txt": "type, contentClass.getName(), a.getName(), iae.getMessage()), iae); } } } return type; } @Deprecated public Class<?> findDeserializationType(Annotated am, JavaType baseType) { return null;"
      },
      {
        "txt": "} @Deprecated public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { return null; } @Deprecated public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { return null; } public Object findValueInstantiator(AnnotatedClass ac) {"
      },
      {
        "txt": "return null; } public Class<?> findPOJOBuilder(AnnotatedClass ac) { return null; } public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) { return null; } public PropertyName findNameForDeserialization(Annotated a) { if (name != null) {"
      },
      {
        "txt": "if (name.length() == 0) { // empty String means 'default' return PropertyName.USE_DEFAULT; } return new PropertyName(name); } return null; } public boolean hasAnySetterAnnotation(AnnotatedMethod am) { return false; }"
      },
      {
        "txt": "public boolean hasAnyGetterAnnotation(AnnotatedMethod am) { return false; } public boolean hasCreatorAnnotation(Annotated a) { return false; } public JsonCreator.Mode findCreatorBinding(Annotated a) { return null; } protected <A extends Annotation> A _findAnnotation(Annotated annotated,"
      },
      {
        "txt": "Class<A> annoClass) { return annotated.getAnnotation(annoClass); } protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) { return annotated.hasAnnotation(annoClass); } protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) { return annotated.hasOneOf(annoClasses); }"
      }
    ]
  },
  {
    "id": 1521,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
    "start-bug-line": 819,
    "end-bug-line": 819,
    "bug": "",
    "fix": "if (serClass.isAssignableFrom(currRaw)) { // common case",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind; import java.lang.annotation.Annotation; import java.util.*; import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.core.Versioned;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.JsonDeserializer; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.deser.ValueInstantiator; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.type.MapLikeType; import com.fasterxml.jackson.databind.type.TypeFactory; import com.fasterxml.jackson.databind.util.Converter; import com.fasterxml.jackson.databind.util.NameTransformer; @SuppressWarnings(\"serial\") public abstract class AnnotationIntrospector implements Versioned, java.io.Serializable { public static class ReferenceProperty {"
      },
      {
        "txt": "public enum Type { MANAGED_REFERENCE ,BACK_REFERENCE ; } private final Type _type; private final String _name; public ReferenceProperty(Type t, String n) { _type = t; _name = n;"
      },
      {
        "txt": "} public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); } public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); } public Type getType() { return _type; } public String getName() { return _name; } public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; } public boolean isBackReference() { return _type == Type.BACK_REFERENCE; } } public static AnnotationIntrospector nopInstance() { return NopAnnotationIntrospector.instance;"
      },
      {
        "txt": "} public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) { return new AnnotationIntrospectorPair(a1, a2); } public Collection<AnnotationIntrospector> allIntrospectors() { return Collections.singletonList(this); } public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) { result.add(this); return result;"
      },
      {
        "txt": "} @Override public abstract Version version(); public boolean isAnnotationBundle(Annotation ann) { return false; } public ObjectIdInfo findObjectIdInfo(Annotated ann) { return null; } public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {"
      },
      {
        "txt": "return objectIdInfo; } public PropertyName findRootName(AnnotatedClass ac) { return null; } public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) { return null; } @Deprecated public String[] findPropertiesToIgnore(Annotated ac) {"
      },
      {
        "txt": "return findPropertiesToIgnore(ac, true); } public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { return null; } public Boolean isIgnorableType(AnnotatedClass ac) { return null; } public Object findFilterId(Annotated ann) { return null; } public Object findNamingStrategy(AnnotatedClass ac) { return null; } public String findClassDescription(AnnotatedClass ac) { return null; } public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) { return checker; }"
      },
      {
        "txt": "public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) { return null; } public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) { return null; } public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) {"
      },
      {
        "txt": "return null; } public List<NamedType> findSubtypes(Annotated a) { return null; } public String findTypeName(AnnotatedClass ac) { return null; } public Boolean isTypeId(AnnotatedMember member) { return null; } public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; } public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; } public boolean hasIgnoreMarker(AnnotatedMember m) { return false; } public Object findInjectableValueId(AnnotatedMember m) { return null; } public Boolean hasRequiredMarker(AnnotatedMember m) { return null; }"
      },
      {
        "txt": "public Class<?>[] findViews(Annotated a) { return null; } public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; } public PropertyName findWrapperName(Annotated ann) { return null; } public String findPropertyDefaultValue(Annotated ann) { return null; } public String findPropertyDescription(Annotated ann) { return null; } public Integer findPropertyIndex(Annotated ann) { return null; } public String findImplicitPropertyName(AnnotatedMember member) { return null; } public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; } public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2) {"
      },
      {
        "txt": "return null; } public Object findSerializer(Annotated am) { return null; } public Object findKeySerializer(Annotated am) { return null; } public Object findContentSerializer(Annotated am) { return null;"
      },
      {
        "txt": "} public Object findNullSerializer(Annotated am) { return null; } public JsonSerialize.Typing findSerializationTyping(Annotated a) { return null; } public Object findSerializationConverter(Annotated a) { return null; }"
      },
      {
        "txt": "public Object findSerializationContentConverter(AnnotatedMember a) { return null; } @Deprecated // since 2.7 public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { return defValue; } @Deprecated // since 2.7 public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) { return defValue;"
      },
      {
        "txt": "} public JsonInclude.Value findPropertyInclusion(Annotated a) { return JsonInclude.Value.empty(); } @Deprecated // since 2.7 public Class<?> findSerializationType(Annotated a) { return null; } @Deprecated // since 2.7 public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {"
      },
      {
        "txt": "return null; } @Deprecated // since 2.7 public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { return null; } public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException { JavaType type = baseType;"
      },
      {
        "txt": "Class<?> serClass = findSerializationType(a); if (serClass != null) { if (type.hasRawClass(serClass)) { type = type.withStaticTyping(); } else { try { <extra_id_0> } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae); }"
      },
      {
        "txt": "iae); } } } if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); Class<?> keyClass = findSerializationKeyType(a, keyType); if (keyClass != null) { if (keyType.hasRawClass(keyClass)) { keyType = keyType.withStaticTyping();"
      },
      {
        "txt": "} else { Class<?> currRaw = keyType.getRawClass(); try { if (keyClass.isAssignableFrom(currRaw)) { // common case keyType = tf.constructGeneralizedType(keyType, keyClass); } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well keyType = tf.constructSpecializedType(keyType, keyClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\","
      },
      {
        "txt": "keyType, keyClass.getName())); } } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae); } } type = ((MapLikeType) type).withKeyType(keyType);"
      },
      {
        "txt": "} } JavaType contentType = type.getContentType(); if (contentType != null) { // collection[like], map[like], array, reference Class<?> contentClass = findSerializationContentType(a, contentType); if (contentClass != null) { if (contentType.hasRawClass(contentClass)) { contentType = contentType.withStaticTyping(); } else { Class<?> currRaw = contentType.getRawClass();"
      },
      {
        "txt": "try { if (contentClass.isAssignableFrom(currRaw)) { // common case contentType = tf.constructGeneralizedType(contentType, contentClass); } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well contentType = tf.constructSpecializedType(contentType, contentClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName())); }"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { // shouldn't really happen throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae); } } type = type.withContentType(contentType); } }"
      },
      {
        "txt": "return type; } public String[] findSerializationPropertyOrder(AnnotatedClass ac) { return null; } public Boolean findSerializationSortAlphabetically(Annotated ann) { return null; } public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties) { }"
      },
      {
        "txt": "public PropertyName findNameForSerialization(Annotated a) { if (name != null) { if (name.length() == 0) { // empty String means 'default' return PropertyName.USE_DEFAULT; } return new PropertyName(name); } return null; } public boolean hasAsValueAnnotation(AnnotatedMethod am) {"
      },
      {
        "txt": "return false; } public String findEnumValue(Enum<?> value) { return value.name(); } public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) { for (int i = 0, len = enumValues.length; i < len; ++i) { if (names[i] == null) { names[i] = findEnumValue(enumValues[i]); }"
      },
      {
        "txt": "} return names; } public Object findDeserializer(Annotated am) { return null; } public Object findKeyDeserializer(Annotated am) { return null; } public Object findContentDeserializer(Annotated am) {"
      },
      {
        "txt": "return null; } public Object findDeserializationConverter(Annotated a) { return null; } public Object findDeserializationContentConverter(AnnotatedMember a) { return null; } public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException"
      },
      {
        "txt": "{ JavaType type = baseType; final TypeFactory tf = config.getTypeFactory(); Class<?> valueClass = findDeserializationType(a, type); if ((valueClass != null) && !type.hasRawClass(valueClass)) { try { type = tf.constructSpecializedType(type, valueClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\","
      },
      {
        "txt": "type, valueClass.getName(), a.getName(), iae.getMessage()), iae); } } if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); Class<?> keyClass = findDeserializationKeyType(a, keyType); if (keyClass != null) { try { keyType = tf.constructSpecializedType(keyType, keyClass);"
      },
      {
        "txt": "type = ((MapLikeType) type).withKeyType(keyType); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae); } } } JavaType contentType = type.getContentType();"
      },
      {
        "txt": "if (contentType != null) { // collection[like], map[like], array, reference Class<?> contentClass = findDeserializationContentType(a, contentType); if (contentClass != null) { try { contentType = tf.constructSpecializedType(contentType, contentClass); type = type.withContentType(contentType); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()),"
      },
      {
        "txt": "iae); } } } return type; } @Deprecated public Class<?> findDeserializationType(Annotated am, JavaType baseType) { return null; }"
      },
      {
        "txt": "@Deprecated public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { return null; } @Deprecated public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { return null; } public Object findValueInstantiator(AnnotatedClass ac) { return null;"
      },
      {
        "txt": "} public Class<?> findPOJOBuilder(AnnotatedClass ac) { return null; } public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) { return null; } public PropertyName findNameForDeserialization(Annotated a) { if (name != null) { if (name.length() == 0) { // empty String means 'default'"
      },
      {
        "txt": "return PropertyName.USE_DEFAULT; } return new PropertyName(name); } return null; } public boolean hasAnySetterAnnotation(AnnotatedMethod am) { return false; } public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {"
      },
      {
        "txt": "return false; } public boolean hasCreatorAnnotation(Annotated a) { return false; } public JsonCreator.Mode findCreatorBinding(Annotated a) { return null; } protected <A extends Annotation> A _findAnnotation(Annotated annotated, Class<A> annoClass) {"
      },
      {
        "txt": "return annotated.getAnnotation(annoClass); } protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) { return annotated.hasAnnotation(annoClass); } protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) { return annotated.hasOneOf(annoClasses); }"
      }
    ]
  },
  {
    "id": 1522,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
    "start-bug-line": 820,
    "end-bug-line": 820,
    "bug": "",
    "fix": "} else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName())); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind; import java.lang.annotation.Annotation; import java.util.*; import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.core.Versioned; import com.fasterxml.jackson.databind.JsonDeserializer;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.deser.ValueInstantiator; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.ser.BeanPropertyWriter; import com.fasterxml.jackson.databind.type.MapLikeType;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.type.TypeFactory; import com.fasterxml.jackson.databind.util.Converter; import com.fasterxml.jackson.databind.util.NameTransformer; @SuppressWarnings(\"serial\") public abstract class AnnotationIntrospector implements Versioned, java.io.Serializable { public static class ReferenceProperty { public enum Type {"
      },
      {
        "txt": "MANAGED_REFERENCE ,BACK_REFERENCE ; } private final Type _type; private final String _name; public ReferenceProperty(Type t, String n) { _type = t; _name = n; }"
      },
      {
        "txt": "public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); } public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); } public Type getType() { return _type; } public String getName() { return _name; } public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; } public boolean isBackReference() { return _type == Type.BACK_REFERENCE; } } public static AnnotationIntrospector nopInstance() { return NopAnnotationIntrospector.instance; }"
      },
      {
        "txt": "public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) { return new AnnotationIntrospectorPair(a1, a2); } public Collection<AnnotationIntrospector> allIntrospectors() { return Collections.singletonList(this); } public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) { result.add(this); return result; }"
      },
      {
        "txt": "@Override public abstract Version version(); public boolean isAnnotationBundle(Annotation ann) { return false; } public ObjectIdInfo findObjectIdInfo(Annotated ann) { return null; } public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { return objectIdInfo;"
      },
      {
        "txt": "} public PropertyName findRootName(AnnotatedClass ac) { return null; } public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) { return null; } @Deprecated public String[] findPropertiesToIgnore(Annotated ac) { return findPropertiesToIgnore(ac, true);"
      },
      {
        "txt": "} public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { return null; } public Boolean isIgnorableType(AnnotatedClass ac) { return null; } public Object findFilterId(Annotated ann) { return null; } public Object findNamingStrategy(AnnotatedClass ac) { return null; } public String findClassDescription(AnnotatedClass ac) { return null; } public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) { return checker; } public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,"
      },
      {
        "txt": "AnnotatedClass ac, JavaType baseType) { return null; } public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) { return null; } public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) { return null;"
      },
      {
        "txt": "} public List<NamedType> findSubtypes(Annotated a) { return null; } public String findTypeName(AnnotatedClass ac) { return null; } public Boolean isTypeId(AnnotatedMember member) { return null; } public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; } public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; } public boolean hasIgnoreMarker(AnnotatedMember m) { return false; } public Object findInjectableValueId(AnnotatedMember m) { return null; } public Boolean hasRequiredMarker(AnnotatedMember m) { return null; } public Class<?>[] findViews(Annotated a) { return null; }"
      },
      {
        "txt": "public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; } public PropertyName findWrapperName(Annotated ann) { return null; } public String findPropertyDefaultValue(Annotated ann) { return null; } public String findPropertyDescription(Annotated ann) { return null; } public Integer findPropertyIndex(Annotated ann) { return null; } public String findImplicitPropertyName(AnnotatedMember member) { return null; } public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; } public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2) { return null;"
      },
      {
        "txt": "} public Object findSerializer(Annotated am) { return null; } public Object findKeySerializer(Annotated am) { return null; } public Object findContentSerializer(Annotated am) { return null; }"
      },
      {
        "txt": "public Object findNullSerializer(Annotated am) { return null; } public JsonSerialize.Typing findSerializationTyping(Annotated a) { return null; } public Object findSerializationConverter(Annotated a) { return null; } public Object findSerializationContentConverter(AnnotatedMember a) {"
      },
      {
        "txt": "return null; } @Deprecated // since 2.7 public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { return defValue; } @Deprecated // since 2.7 public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) { return defValue; }"
      },
      {
        "txt": "public JsonInclude.Value findPropertyInclusion(Annotated a) { return JsonInclude.Value.empty(); } @Deprecated // since 2.7 public Class<?> findSerializationType(Annotated a) { return null; } @Deprecated // since 2.7 public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { return null;"
      },
      {
        "txt": "} @Deprecated // since 2.7 public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { return null; } public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException { JavaType type = baseType; final TypeFactory tf = config.getTypeFactory();"
      },
      {
        "txt": "if (serClass != null) { if (type.hasRawClass(serClass)) { type = type.withStaticTyping(); } else { try { type = tf.constructGeneralizedType(type, serClass); <extra_id_0> throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae); } }"
      },
      {
        "txt": "} } } if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); Class<?> keyClass = findSerializationKeyType(a, keyType); if (keyClass != null) { if (keyType.hasRawClass(keyClass)) { keyType = keyType.withStaticTyping(); } else {"
      },
      {
        "txt": "Class<?> currRaw = keyType.getRawClass(); try { if (keyClass.isAssignableFrom(currRaw)) { // common case keyType = tf.constructGeneralizedType(keyType, keyClass); } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well keyType = tf.constructSpecializedType(keyType, keyClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));"
      },
      {
        "txt": "} } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae); } } type = ((MapLikeType) type).withKeyType(keyType); }"
      },
      {
        "txt": "} JavaType contentType = type.getContentType(); if (contentType != null) { // collection[like], map[like], array, reference Class<?> contentClass = findSerializationContentType(a, contentType); if (contentClass != null) { if (contentType.hasRawClass(contentClass)) { contentType = contentType.withStaticTyping(); } else { Class<?> currRaw = contentType.getRawClass(); try {"
      },
      {
        "txt": "if (contentClass.isAssignableFrom(currRaw)) { // common case contentType = tf.constructGeneralizedType(contentType, contentClass); } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well contentType = tf.constructSpecializedType(contentType, contentClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName())); } } catch (IllegalArgumentException iae) { // shouldn't really happen"
      },
      {
        "txt": "throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae); } } type = type.withContentType(contentType); } } return type;"
      },
      {
        "txt": "} public String[] findSerializationPropertyOrder(AnnotatedClass ac) { return null; } public Boolean findSerializationSortAlphabetically(Annotated ann) { return null; } public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties) { } public PropertyName findNameForSerialization(Annotated a) {"
      },
      {
        "txt": "if (name != null) { if (name.length() == 0) { // empty String means 'default' return PropertyName.USE_DEFAULT; } return new PropertyName(name); } return null; } public boolean hasAsValueAnnotation(AnnotatedMethod am) { return false;"
      },
      {
        "txt": "} public String findEnumValue(Enum<?> value) { return value.name(); } public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) { for (int i = 0, len = enumValues.length; i < len; ++i) { if (names[i] == null) { names[i] = findEnumValue(enumValues[i]); } }"
      },
      {
        "txt": "return names; } public Object findDeserializer(Annotated am) { return null; } public Object findKeyDeserializer(Annotated am) { return null; } public Object findContentDeserializer(Annotated am) { return null;"
      },
      {
        "txt": "} public Object findDeserializationConverter(Annotated a) { return null; } public Object findDeserializationContentConverter(AnnotatedMember a) { return null; } public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {"
      },
      {
        "txt": "JavaType type = baseType; final TypeFactory tf = config.getTypeFactory(); Class<?> valueClass = findDeserializationType(a, type); if ((valueClass != null) && !type.hasRawClass(valueClass)) { try { type = tf.constructSpecializedType(type, valueClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()),"
      },
      {
        "txt": "iae); } } if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); Class<?> keyClass = findDeserializationKeyType(a, keyType); if (keyClass != null) { try { keyType = tf.constructSpecializedType(keyType, keyClass); type = ((MapLikeType) type).withKeyType(keyType);"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae); } } } JavaType contentType = type.getContentType(); if (contentType != null) { // collection[like], map[like], array, reference"
      },
      {
        "txt": "Class<?> contentClass = findDeserializationContentType(a, contentType); if (contentClass != null) { try { contentType = tf.constructSpecializedType(contentType, contentClass); type = type.withContentType(contentType); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);"
      },
      {
        "txt": "} } } return type; } @Deprecated public Class<?> findDeserializationType(Annotated am, JavaType baseType) { return null; } @Deprecated"
      },
      {
        "txt": "public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { return null; } @Deprecated public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { return null; } public Object findValueInstantiator(AnnotatedClass ac) { return null; }"
      },
      {
        "txt": "public Class<?> findPOJOBuilder(AnnotatedClass ac) { return null; } public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) { return null; } public PropertyName findNameForDeserialization(Annotated a) { if (name != null) { if (name.length() == 0) { // empty String means 'default' return PropertyName.USE_DEFAULT;"
      },
      {
        "txt": "} return new PropertyName(name); } return null; } public boolean hasAnySetterAnnotation(AnnotatedMethod am) { return false; } public boolean hasAnyGetterAnnotation(AnnotatedMethod am) { return false;"
      },
      {
        "txt": "} public boolean hasCreatorAnnotation(Annotated a) { return false; } public JsonCreator.Mode findCreatorBinding(Annotated a) { return null; } protected <A extends Annotation> A _findAnnotation(Annotated annotated, Class<A> annoClass) { return annotated.getAnnotation(annoClass);"
      },
      {
        "txt": "} protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) { return annotated.hasAnnotation(annoClass); } protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) { return annotated.hasOneOf(annoClasses); }"
      }
    ]
  }
]