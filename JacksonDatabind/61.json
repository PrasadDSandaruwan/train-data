[
  {
    "id": 1602,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
    "start-bug-line": 232,
    "end-bug-line": 232,
    "bug": "",
    "fix": "if (t.isPrimitive()) { return false; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind; import java.io.*;"
      },
      {
        "txt": "import java.lang.reflect.Type; import java.net.URL; import java.text.DateFormat; import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.CharacterEscapes; import com.fasterxml.jackson.core.io.SegmentedStringWriter;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.type.ResolvedType; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.core.util.*; import com.fasterxml.jackson.databind.cfg.BaseSettings; import com.fasterxml.jackson.databind.cfg.ContextAttributes; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.cfg.MutableConfigOverride; import com.fasterxml.jackson.databind.cfg.ConfigOverrides; import com.fasterxml.jackson.databind.deser.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper; import com.fasterxml.jackson.databind.jsontype.*; import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver; import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder; import com.fasterxml.jackson.databind.node.*; import com.fasterxml.jackson.databind.ser.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.RootNameLookup;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.StdDateFormat; import com.fasterxml.jackson.databind.util.TokenBuffer; Simplest usage is of form: <pre> final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse! MyValue value = new MyValue(); File newState = new File(\"my-stuff.json\"); mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class); JsonNode root = mapper.readTree(newState);"
      },
      {
        "txt": "int age = root.at(\"/personal/age\").getValueAsInt(); </pre> public class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable // as of 2.1 { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT,"
      },
      {
        "txt": "OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor;"
      },
      {
        "txt": "public DefaultTypeResolverBuilder(DefaultTyping t) { _appliesFor = t; } @Override public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null; } @Override"
      },
      {
        "txt": "JavaType baseType, Collection<NamedType> subtypes) { return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null; } public boolean useForType(JavaType t) { <extra_id_0> switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE:"
      },
      {
        "txt": "} case OBJECT_AND_NON_CONCRETE: while (t.isReferenceType()) { t = t.getReferencedType(); } return t.isJavaLangObject() || (!t.isConcrete() && !TreeNode.class.isAssignableFrom(t.getRawClass())); case NON_FINAL: while (t.isArrayType()) {"
      },
      {
        "txt": "t = t.getContentType(); } while (t.isReferenceType()) { t = t.getReferencedType(); } return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()); default: return t.isJavaLangObject(); } }"
      },
      {
        "txt": "} private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings( null, // can not share global ClassIntrospector any more (2.5+) DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null,"
      },
      {
        "txt": "Locale.getDefault(), null, // to indicate \"use Jackson default TimeZone\" (UTC since Jackson 2.7) Base64Variants.getDefaultVariant() // 2.1 ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected ConfigOverrides _propertyOverrides; protected SimpleMixInResolver _mixIns;"
      },
      {
        "txt": "protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; protected Set<Object> _registeredModuleTypes; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() { this(null, null, null);"
      },
      {
        "txt": "} public ObjectMapper(JsonFactory jf) { this(jf, null, null); } protected ObjectMapper(ObjectMapper src) { _jsonFactory = src._jsonFactory.copy(); _jsonFactory.setCodec(this); _subtypeResolver = src._subtypeResolver; _typeFactory = src._typeFactory;"
      },
      {
        "txt": "_injectableValues = src._injectableValues; _propertyOverrides = src._propertyOverrides.copy(); _mixIns = src._mixIns.copy(); RootNameLookup rootNames = new RootNameLookup(); _serializationConfig = new SerializationConfig(src._serializationConfig, _mixIns, rootNames, _propertyOverrides); _deserializationConfig = new DeserializationConfig(src._deserializationConfig, _mixIns, rootNames, _propertyOverrides); _serializerProvider = src._serializerProvider.copy(); _deserializationContext = src._deserializationContext.copy(); _serializerFactory = src._serializerFactory; Set<Object> reg = src._registeredModuleTypes;"
      },
      {
        "txt": "if (reg == null) { _registeredModuleTypes = null; } else { _registeredModuleTypes = new LinkedHashSet<Object>(reg); } } public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { if (jf == null) {"
      },
      {
        "txt": "_jsonFactory = new MappingJsonFactory(this); } else { _jsonFactory = jf; if (jf.getCodec() == null) { // as per [JACKSON-741] _jsonFactory.setCodec(this); } } _subtypeResolver = new StdSubtypeResolver(); RootNameLookup rootNames = new RootNameLookup(); _typeFactory = TypeFactory.defaultInstance();"
      },
      {
        "txt": "SimpleMixInResolver mixins = new SimpleMixInResolver(null); _mixIns = mixins; BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector()); ConfigOverrides propOverrides = new ConfigOverrides(); _propertyOverrides = propOverrides; _serializationConfig = new SerializationConfig(base, _subtypeResolver, mixins, rootNames, propOverrides); _deserializationConfig = new DeserializationConfig(base, _subtypeResolver, mixins, rootNames, propOverrides); final boolean needOrder = _jsonFactory.requiresPropertyOrdering();"
      },
      {
        "txt": "if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) { configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder); } _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; _serializerFactory = BeanSerializerFactory.instance; } protected ClassIntrospector defaultClassIntrospector() { return new BasicClassIntrospector();"
      },
      {
        "txt": "} public ObjectMapper copy() { _checkInvalidCopy(ObjectMapper.class); return new ObjectMapper(this); } protected void _checkInvalidCopy(Class<?> exp) { if (getClass() != exp) { throw new IllegalStateException(\"Failed copy(): \"+getClass().getName() +\" (version: \"+version()+\") does not override copy(); it has to\");"
      },
      {
        "txt": "} } protected ObjectReader _newReader(DeserializationConfig config) { return new ObjectReader(this, config); } protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) { return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues); }"
      },
      {
        "txt": "protected ObjectWriter _newWriter(SerializationConfig config) { return new ObjectWriter(this, config); } protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) { return new ObjectWriter(this, config, schema); } protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp) { return new ObjectWriter(this, config, rootType, pp); }"
      },
      {
        "txt": "@Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public ObjectMapper registerModule(Module module) { if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) { Object typeId = module.getTypeId(); if (typeId != null) { if (_registeredModuleTypes == null) {"
      },
      {
        "txt": "_registeredModuleTypes = new LinkedHashSet<Object>(); } if (!_registeredModuleTypes.add(typeId)) { return this; } } } String name = module.getModuleName(); if (name == null) { throw new IllegalArgumentException(\"Module without defined name\");"
      },
      {
        "txt": "} Version version = module.version(); if (version == null) { throw new IllegalArgumentException(\"Module without defined version\"); } final ObjectMapper mapper = this; module.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() {"
      },
      {
        "txt": "return version(); } @SuppressWarnings(\"unchecked\") @Override public <C extends ObjectCodec> C getOwner() { return (C) mapper; } @Override public TypeFactory getTypeFactory() { return _typeFactory;"
      },
      {
        "txt": "} @Override public boolean isEnabled(MapperFeature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(DeserializationFeature f) { return mapper.isEnabled(f); } @Override"
      },
      {
        "txt": "public boolean isEnabled(SerializationFeature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(JsonFactory.Feature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(JsonParser.Feature f) { return mapper.isEnabled(f);"
      },
      {
        "txt": "} @Override public boolean isEnabled(JsonGenerator.Feature f) { return mapper.isEnabled(f); } @Override public MutableConfigOverride configOverride(Class<?> type) { return mapper.configOverride(type); } @Override"
      },
      {
        "txt": "public void addDeserializers(Deserializers d) { DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void addKeyDeserializers(KeyDeserializers d) { DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override"
      },
      {
        "txt": "public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void addSerializers(Serializers s) { mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); } @Override public void addKeySerializers(Serializers s) {"
      },
      {
        "txt": "mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); } @Override public void addBeanSerializerModifier(BeanSerializerModifier modifier) { mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); } @Override public void addAbstractTypeResolver(AbstractTypeResolver resolver) { DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); mapper._deserializationContext = mapper._deserializationContext.with(df);"
      },
      {
        "txt": "} @Override public void addTypeModifier(TypeModifier modifier) { TypeFactory f = mapper._typeFactory; f = f.withModifier(modifier); mapper.setTypeFactory(f); } @Override public void addValueInstantiators(ValueInstantiators instantiators) { DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);"
      },
      {
        "txt": "mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void setClassIntrospector(ClassIntrospector ci) { mapper._deserializationConfig = mapper._deserializationConfig.with(ci); mapper._serializationConfig = mapper._serializationConfig.with(ci); } @Override public void insertAnnotationIntrospector(AnnotationIntrospector ai) { mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);"
      },
      {
        "txt": "mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); } @Override public void appendAnnotationIntrospector(AnnotationIntrospector ai) { mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); } @Override public void registerSubtypes(Class<?>... subtypes) { mapper.registerSubtypes(subtypes);"
      },
      {
        "txt": "} @Override public void registerSubtypes(NamedType... subtypes) { mapper.registerSubtypes(subtypes); } @Override public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { mapper.addMixIn(target, mixinSource); } @Override"
      },
      {
        "txt": "public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { mapper.addHandler(handler); } @Override public void setNamingStrategy(PropertyNamingStrategy naming) { mapper.setPropertyNamingStrategy(naming); } }); return this; }"
      },
      {
        "txt": "public ObjectMapper registerModules(Module... modules) { for (Module module : modules) { registerModule(module); } return this; } public ObjectMapper registerModules(Iterable<Module> modules) { for (Module module : modules) {"
      },
      {
        "txt": "registerModule(module); } return this; } public static List<Module> findModules() { return findModules(null); } public static List<Module> findModules(ClassLoader classLoader) { ArrayList<Module> modules = new ArrayList<Module>();"
      },
      {
        "txt": "ServiceLoader<Module> loader = (classLoader == null) ? ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader); for (Module module : loader) { modules.add(module); } return modules; } public ObjectMapper findAndRegisterModules() { return registerModules(findModules()); }"
      },
      {
        "txt": "public SerializationConfig getSerializationConfig() { return _serializationConfig; } public DeserializationConfig getDeserializationConfig() { return _deserializationConfig; } public DeserializationContext getDeserializationContext() { return _deserializationContext; } public ObjectMapper setSerializerFactory(SerializerFactory f) {"
      },
      {
        "txt": "_serializerFactory = f; return this; } public SerializerFactory getSerializerFactory() { return _serializerFactory; } public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) { _serializerProvider = p; return this; }"
      },
      {
        "txt": "public SerializerProvider getSerializerProvider() { return _serializerProvider; } public SerializerProvider getSerializerProviderInstance() { return _serializerProvider(_serializationConfig); } public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins) { _mixIns.setLocalDefinitions(sourceMixins); return this;"
      },
      {
        "txt": "} public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) { _mixIns.addLocalDefinition(target, mixinSource); return this; } public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) { SimpleMixInResolver r = _mixIns.withOverrides(resolver); if (r != _mixIns) {"
      },
      {
        "txt": "_mixIns = r; _deserializationConfig = new DeserializationConfig(_deserializationConfig, r); _serializationConfig = new SerializationConfig(_serializationConfig, r); } return this; } public Class<?> findMixInClassFor(Class<?> cls) { return _mixIns.findMixInClassFor(cls); } public int mixInCount() {"
      },
      {
        "txt": "return _mixIns.localSize(); } @Deprecated public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) { setMixIns(sourceMixins); } @Deprecated public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) { addMixIn(target, mixinSource); }"
      },
      {
        "txt": "public VisibilityChecker<?> getVisibilityChecker() { return _serializationConfig.getDefaultVisibilityChecker(); } @Deprecated public void setVisibilityChecker(VisibilityChecker<?> vc) { setVisibility(vc); } public ObjectMapper setVisibility(VisibilityChecker<?> vc) { _deserializationConfig = _deserializationConfig.with(vc); _serializationConfig = _serializationConfig.with(vc);"
      },
      {
        "txt": "return this; } public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility); _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility); return this; } public SubtypeResolver getSubtypeResolver() { return _subtypeResolver;"
      },
      {
        "txt": "} public ObjectMapper setSubtypeResolver(SubtypeResolver str) { _subtypeResolver = str; _deserializationConfig = _deserializationConfig.with(str); _serializationConfig = _serializationConfig.with(str); return this; } public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) { _serializationConfig = _serializationConfig.with(ai); _deserializationConfig = _deserializationConfig.with(ai);"
      },
      {
        "txt": "return this; } public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) { _serializationConfig = _serializationConfig.with(serializerAI); _deserializationConfig = _deserializationConfig.with(deserializerAI); return this; } public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) { _serializationConfig = _serializationConfig.with(s);"
      },
      {
        "txt": "_deserializationConfig = _deserializationConfig.with(s); return this; } public PropertyNamingStrategy getPropertyNamingStrategy() { return _serializationConfig.getPropertyNamingStrategy(); } public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) { setPropertyInclusion(JsonInclude.Value.construct(incl, JsonInclude.Include.USE_DEFAULTS)); return this; }"
      },
      {
        "txt": "public ObjectMapper setPropertyInclusion(JsonInclude.Value incl) { _serializationConfig = _serializationConfig.withPropertyInclusion(incl); return this; } public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) { _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp); return this; } public ObjectMapper enableDefaultTyping() { return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);"
      },
      {
        "txt": "} public ObjectMapper enableDefaultTyping(DefaultTyping dti) { return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY); } public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) { if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) { throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs); } TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);"
      },
      {
        "txt": "typer = typer.init(JsonTypeInfo.Id.CLASS, null); typer = typer.inclusion(includeAs); return setDefaultTyping(typer); } public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) { TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); typer = typer.init(JsonTypeInfo.Id.CLASS, null); typer = typer.inclusion(JsonTypeInfo.As.PROPERTY); typer = typer.typeProperty(propertyName);"
      },
      {
        "txt": "return setDefaultTyping(typer); } public ObjectMapper disableDefaultTyping() { return setDefaultTyping(null); } public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) { _deserializationConfig = _deserializationConfig.with(typer); _serializationConfig = _serializationConfig.with(typer); return this; }"
      },
      {
        "txt": "public void registerSubtypes(Class<?>... classes) { getSubtypeResolver().registerSubtypes(classes); } public void registerSubtypes(NamedType... types) { getSubtypeResolver().registerSubtypes(types); } public MutableConfigOverride configOverride(Class<?> type) { return _propertyOverrides.findOrCreateOverride(type); } public TypeFactory getTypeFactory() {"
      },
      {
        "txt": "return _typeFactory; } public ObjectMapper setTypeFactory(TypeFactory f) { _typeFactory = f; _deserializationConfig = _deserializationConfig.with(f); _serializationConfig = _serializationConfig.with(f); return this; } public JavaType constructType(Type t) {"
      },
      {
        "txt": "return _typeFactory.constructType(t); } public JsonNodeFactory getNodeFactory() { return _deserializationConfig.getNodeFactory(); } public ObjectMapper setNodeFactory(JsonNodeFactory f) { _deserializationConfig = _deserializationConfig.with(f); return this; } public ObjectMapper addHandler(DeserializationProblemHandler h) {"
      },
      {
        "txt": "_deserializationConfig = _deserializationConfig.withHandler(h); return this; } public ObjectMapper clearProblemHandlers() { _deserializationConfig = _deserializationConfig.withNoProblemHandlers(); return this; } public ObjectMapper setConfig(DeserializationConfig config) { _deserializationConfig = config; return this;"
      },
      {
        "txt": "} @Deprecated public void setFilters(FilterProvider filterProvider) { _serializationConfig = _serializationConfig.withFilters(filterProvider); } public ObjectMapper setFilterProvider(FilterProvider filterProvider) { _serializationConfig = _serializationConfig.withFilters(filterProvider); return this; } public ObjectMapper setBase64Variant(Base64Variant v) {"
      },
      {
        "txt": "_serializationConfig = _serializationConfig.with(v); _deserializationConfig = _deserializationConfig.with(v); return this; } public ObjectMapper setConfig(SerializationConfig config) { _serializationConfig = config; return this; } @Override public JsonFactory getFactory() { return _jsonFactory; }"
      },
      {
        "txt": "@Deprecated @Override public JsonFactory getJsonFactory() { return getFactory(); } public ObjectMapper setDateFormat(DateFormat dateFormat) { _deserializationConfig = _deserializationConfig.with(dateFormat); _serializationConfig = _serializationConfig.with(dateFormat); return this; } public DateFormat getDateFormat() {"
      },
      {
        "txt": "return _serializationConfig.getDateFormat(); } public Object setHandlerInstantiator(HandlerInstantiator hi) { _deserializationConfig = _deserializationConfig.with(hi); _serializationConfig = _serializationConfig.with(hi); return this; } public ObjectMapper setInjectableValues(InjectableValues injectableValues) { _injectableValues = injectableValues;"
      },
      {
        "txt": "return this; } public InjectableValues getInjectableValues() { return _injectableValues; } public ObjectMapper setLocale(Locale l) { _deserializationConfig = _deserializationConfig.with(l); _serializationConfig = _serializationConfig.with(l); return this; }"
      },
      {
        "txt": "public ObjectMapper setTimeZone(TimeZone tz) { _deserializationConfig = _deserializationConfig.with(tz); _serializationConfig = _serializationConfig.with(tz); return this; } public boolean isEnabled(MapperFeature f) { return _serializationConfig.isEnabled(f); } public ObjectMapper configure(MapperFeature f, boolean state) { _serializationConfig = state ?"
      },
      {
        "txt": "_serializationConfig.with(f) : _serializationConfig.without(f); _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); return this; } public ObjectMapper enable(MapperFeature... f) { _deserializationConfig = _deserializationConfig.with(f); _serializationConfig = _serializationConfig.with(f); return this; }"
      },
      {
        "txt": "public ObjectMapper disable(MapperFeature... f) { _deserializationConfig = _deserializationConfig.without(f); _serializationConfig = _serializationConfig.without(f); return this; } public boolean isEnabled(SerializationFeature f) { return _serializationConfig.isEnabled(f); } public ObjectMapper configure(SerializationFeature f, boolean state) { _serializationConfig = state ?"
      },
      {
        "txt": "_serializationConfig.with(f) : _serializationConfig.without(f); return this; } public ObjectMapper enable(SerializationFeature f) { _serializationConfig = _serializationConfig.with(f); return this; } public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) { _serializationConfig = _serializationConfig.with(first, f);"
      },
      {
        "txt": "return this; } public ObjectMapper disable(SerializationFeature f) { _serializationConfig = _serializationConfig.without(f); return this; } public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) { _serializationConfig = _serializationConfig.without(first, f); return this;"
      },
      {
        "txt": "} public boolean isEnabled(DeserializationFeature f) { return _deserializationConfig.isEnabled(f); } public ObjectMapper configure(DeserializationFeature f, boolean state) { _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); return this; } public ObjectMapper enable(DeserializationFeature feature) {"
      },
      {
        "txt": "_deserializationConfig = _deserializationConfig.with(feature); return this; } public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) { _deserializationConfig = _deserializationConfig.with(first, f); return this; } public ObjectMapper disable(DeserializationFeature feature) { _deserializationConfig = _deserializationConfig.without(feature);"
      },
      {
        "txt": "return this; } public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) { _deserializationConfig = _deserializationConfig.without(first, f); return this; } public boolean isEnabled(JsonParser.Feature f) { return _deserializationConfig.isEnabled(f, _jsonFactory); }"
      },
      {
        "txt": "public ObjectMapper configure(JsonParser.Feature f, boolean state) { _jsonFactory.configure(f, state); return this; } public ObjectMapper enable(JsonParser.Feature... features) { for (JsonParser.Feature f : features) { _jsonFactory.enable(f); } return this; }"
      },
      {
        "txt": "public ObjectMapper disable(JsonParser.Feature... features) { for (JsonParser.Feature f : features) { _jsonFactory.disable(f); } return this; } public boolean isEnabled(JsonGenerator.Feature f) { return _serializationConfig.isEnabled(f, _jsonFactory); } public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {"
      },
      {
        "txt": "_jsonFactory.configure(f, state); return this; } public ObjectMapper enable(JsonGenerator.Feature... features) { for (JsonGenerator.Feature f : features) { _jsonFactory.enable(f); } return this; } public ObjectMapper disable(JsonGenerator.Feature... features) {"
      },
      {
        "txt": "for (JsonGenerator.Feature f : features) { _jsonFactory.disable(f); } return this; } public boolean isEnabled(JsonFactory.Feature f) { return _jsonFactory.isEnabled(f); } @Override @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueType)); } @Override @SuppressWarnings(\"unchecked\") public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueTypeRef)); } @Override @SuppressWarnings(\"unchecked\") public final <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), p, (JavaType) valueType); } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "public <T> T readValue(JsonParser p, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), p, valueType); } @Override public <T extends TreeNode> T readTree(JsonParser p) throws IOException, JsonProcessingException { DeserializationConfig cfg = getDeserializationConfig();"
      },
      {
        "txt": "JsonToken t = p.getCurrentToken(); if (t == null) { t = p.nextToken(); if (t == null) { return null; } } JsonNode n = (JsonNode) _readValue(cfg, p, JSON_NODE_TYPE); if (n == null) { n = getNodeFactory().nullNode();"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") T result = (T) n; return result; } @Override public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException { return readValues(p, (JavaType) valueType);"
      },
      {
        "txt": "} public <T> MappingIterator<T> readValues(JsonParser p, JavaType valueType) throws IOException, JsonProcessingException { DeserializationConfig config = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(p, config); JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType); return new MappingIterator<T>(valueType, p, ctxt, deser, false, null); }"
      },
      {
        "txt": "@Override public <T> MappingIterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException, JsonProcessingException { return readValues(p, _typeFactory.constructType(valueType)); } @Override public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "return readValues(p, _typeFactory.constructType(valueTypeRef)); } public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(Reader r) throws IOException, JsonProcessingException"
      },
      {
        "txt": "{ JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(String content) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; }"
      },
      {
        "txt": "public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(File file) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);"
      },
      {
        "txt": "return (n == null) ? NullNode.instance : n; } public JsonNode readTree(URL source) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } @Override public void writeValue(JsonGenerator g, Object value)"
      },
      {
        "txt": "throws IOException, JsonGenerationException, JsonMappingException { SerializationConfig config = getSerializationConfig(); if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { if (g.getPrettyPrinter() == null) { g.setPrettyPrinter(config.constructDefaultPrettyPrinter()); } } if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _writeCloseableValue(g, value, config);"
      },
      {
        "txt": "} else { _serializerProvider(config).serializeValue(g, value); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { g.flush(); } } } @Override public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException"
      },
      {
        "txt": "{ SerializationConfig config = getSerializationConfig(); _serializerProvider(config).serializeValue(jgen, rootNode); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { jgen.flush(); } } public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "SerializationConfig config = getSerializationConfig(); _serializerProvider(config).serializeValue(jgen, rootNode); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { jgen.flush(); } } @Override public ObjectNode createObjectNode() { return _deserializationConfig.getNodeFactory().objectNode(); }"
      },
      {
        "txt": "@Override public ArrayNode createArrayNode() { return _deserializationConfig.getNodeFactory().arrayNode(); } @Override public JsonParser treeAsTokens(TreeNode n) { return new TreeTraversingParser((JsonNode) n, this); } @SuppressWarnings(\"unchecked\") @Override"
      },
      {
        "txt": "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { try { if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { return (T) n; } if (n.asToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { if (n instanceof POJONode) { Object ob = ((POJONode) n).getPojo();"
      },
      {
        "txt": "if ((ob == null) || valueType.isInstance(ob)) { return (T) ob; } } } return readValue(treeAsTokens(n), valueType); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e);"
      },
      {
        "txt": "} } @SuppressWarnings({ \"unchecked\", \"resource\" }) public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException { if (fromValue == null) return null; TokenBuffer buf = new TokenBuffer(this, false); if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true);"
      },
      {
        "txt": "} JsonNode result; try { writeValue(buf, fromValue); JsonParser p = buf.asParser(); result = readTree(p); p.close(); } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); }"
      },
      {
        "txt": "return (T) result; } public boolean canSerialize(Class<?> type) { return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null); } public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) { return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause); } public boolean canDeserialize(JavaType type) {"
      },
      {
        "txt": "return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, null); } public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) { return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, cause); } @SuppressWarnings(\"unchecked\") public <T> T readValue(File src, Class<T> valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(URL src, JavaType valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType)); }"
      },
      {
        "txt": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(Reader src, TypeReference valueTypeRef)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, Class<T> valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));"
      },
      {
        "txt": "} @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(DataInput src, Class<T> valueType) throws IOException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(DataInput src, JavaType valueType) throws IOException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException"
      },
      {
        "txt": "{ _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value); } public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value); } public void writeValue(DataOutput out, Object value) throws IOException"
      },
      {
        "txt": "{ _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value); } public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(w), value); } @SuppressWarnings(\"resource\") public String writeValueAsString(Object value)"
      },
      {
        "txt": "throws JsonProcessingException { SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); try { _configAndWriteValue(_jsonFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { // to support [JACKSON-758] throw e; } catch (IOException e) { // shouldn't really happen, but is declared as possibility so: throw JsonMappingException.fromUnexpectedIOE(e); }"
      },
      {
        "txt": "return sw.getAndClear(); } @SuppressWarnings(\"resource\") public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); try { _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); } catch (JsonProcessingException e) { // to support [JACKSON-758]"
      },
      {
        "txt": "throw e; } catch (IOException e) { // shouldn't really happen, but is declared as possibility so: throw JsonMappingException.fromUnexpectedIOE(e); } byte[] result = bb.toByteArray(); bb.release(); return result; } public ObjectWriter writer() { return _newWriter(getSerializationConfig());"
      },
      {
        "txt": "} public ObjectWriter writer(SerializationFeature feature) { return _newWriter(getSerializationConfig().with(feature)); } public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) { return _newWriter(getSerializationConfig().with(first, other)); } public ObjectWriter writer(DateFormat df) { return _newWriter(getSerializationConfig().with(df));"
      },
      {
        "txt": "} public ObjectWriter writerWithView(Class<?> serializationView) { return _newWriter(getSerializationConfig().withView(serializationView)); } public ObjectWriter writerFor(Class<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null :_typeFactory.constructType(rootType)), } public ObjectWriter writerFor(TypeReference<?> rootType) { return _newWriter(getSerializationConfig(),"
      },
      {
        "txt": "((rootType == null) ? null : _typeFactory.constructType(rootType)), } public ObjectWriter writerFor(JavaType rootType) { return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null); } public ObjectWriter writer(PrettyPrinter pp) { if (pp == null) { // need to use a marker to indicate explicit disabling of pp pp = ObjectWriter.NULL_PRETTY_PRINTER; } return _newWriter(getSerializationConfig(), /*root type*/ null, pp);"
      },
      {
        "txt": "} public ObjectWriter writerWithDefaultPrettyPrinter() { SerializationConfig config = getSerializationConfig(); return _newWriter(config, } public ObjectWriter writer(FilterProvider filterProvider) { return _newWriter(getSerializationConfig().withFilters(filterProvider)); } public ObjectWriter writer(FormatSchema schema) { _verifySchemaType(schema);"
      },
      {
        "txt": "return _newWriter(getSerializationConfig(), schema); } public ObjectWriter writer(Base64Variant defaultBase64) { return _newWriter(getSerializationConfig().with(defaultBase64)); } public ObjectWriter writer(CharacterEscapes escapes) { return _newWriter(getSerializationConfig()).with(escapes); } public ObjectWriter writer(ContextAttributes attrs) { return _newWriter(getSerializationConfig().with(attrs));"
      },
      {
        "txt": "} @Deprecated public ObjectWriter writerWithType(Class<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null :_typeFactory.constructType(rootType)), } @Deprecated public ObjectWriter writerWithType(TypeReference<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)),"
      },
      {
        "txt": "} @Deprecated public ObjectWriter writerWithType(JavaType rootType) { return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null); } public ObjectReader reader() { return _newReader(getDeserializationConfig()).with(_injectableValues); } public ObjectReader reader(DeserializationFeature feature) { return _newReader(getDeserializationConfig().with(feature));"
      },
      {
        "txt": "} public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) { return _newReader(getDeserializationConfig().with(first, other)); } public ObjectReader readerForUpdating(Object valueToUpdate) { JavaType t = _typeFactory.constructType(valueToUpdate.getClass()); return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues); }"
      },
      {
        "txt": "public ObjectReader readerFor(JavaType type) { return _newReader(getDeserializationConfig(), type, null, null, _injectableValues); } public ObjectReader readerFor(Class<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); } public ObjectReader readerFor(TypeReference<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,"
      },
      {
        "txt": "null, _injectableValues); } public ObjectReader reader(JsonNodeFactory f) { return _newReader(getDeserializationConfig()).with(f); } public ObjectReader reader(FormatSchema schema) { _verifySchemaType(schema); return _newReader(getDeserializationConfig(), null, null, schema, _injectableValues); }"
      },
      {
        "txt": "public ObjectReader reader(InjectableValues injectableValues) { return _newReader(getDeserializationConfig(), null, null, null, injectableValues); } public ObjectReader readerWithView(Class<?> view) { return _newReader(getDeserializationConfig().withView(view)); } public ObjectReader reader(Base64Variant defaultBase64) { return _newReader(getDeserializationConfig().with(defaultBase64)); }"
      },
      {
        "txt": "public ObjectReader reader(ContextAttributes attrs) { return _newReader(getDeserializationConfig().with(attrs)); } @Deprecated public ObjectReader reader(JavaType type) { return _newReader(getDeserializationConfig(), type, null, null, _injectableValues); } @Deprecated public ObjectReader reader(Class<?> type) {"
      },
      {
        "txt": "return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); } @Deprecated public ObjectReader reader(TypeReference<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); } @SuppressWarnings(\"unchecked\") public <T> T convertValue(Object fromValue, Class<T> toValueType)"
      },
      {
        "txt": "throws IllegalArgumentException { if (fromValue == null) return null; return (T) _convert(fromValue, _typeFactory.constructType(toValueType)); } @SuppressWarnings(\"unchecked\") public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException { return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException { if (fromValue == null) return null; return (T) _convert(fromValue, toValueType); } @SuppressWarnings(\"resource\") protected Object _convert(Object fromValue, JavaType toValueType)"
      },
      {
        "txt": "throws IllegalArgumentException { Class<?> targetType = toValueType.getRawClass(); if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { return fromValue; } TokenBuffer buf = new TokenBuffer(this, false); if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {"
      },
      {
        "txt": "buf = buf.forceUseOfBigDecimal(true); } try { SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); _serializerProvider(config).serializeValue(buf, fromValue); final JsonParser p = buf.asParser(); Object result; final DeserializationConfig deserConfig = getDeserializationConfig(); JsonToken t = _initForReading(p); if (t == JsonToken.VALUE_NULL) {"
      },
      {
        "txt": "DeserializationContext ctxt = createDeserializationContext(p, deserConfig); result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { // pointing to event other than null DeserializationContext ctxt = createDeserializationContext(p, deserConfig); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); result = deser.deserialize(p, ctxt); } p.close();"
      },
      {
        "txt": "return result; } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); } } @Deprecated public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException { return _serializerProvider(getSerializationConfig()).generateJsonSchema(t); }"
      },
      {
        "txt": "public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException { acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor); } public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException { if (type == null) { throw new IllegalArgumentException(\"type must be provided\");"
      },
      {
        "txt": "} _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor); } protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { return _serializerProvider.createInstance(config, _serializerFactory); } protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException { SerializationConfig cfg = getSerializationConfig();"
      },
      {
        "txt": "cfg.initialize(g); // since 2.5 if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _configAndWriteCloseable(g, value, cfg); return; } try { _serializerProvider(cfg).serializeValue(g, value); } catch (Exception e) { ClassUtil.closeOnFailAndThrowAsIAE(g, e); return;"
      },
      {
        "txt": "} g.close(); } private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException { Closeable toClose = (Closeable) value; try { _serializerProvider(cfg).serializeValue(g, value); Closeable tmpToClose = toClose;"
      },
      {
        "txt": "toClose = null; tmpToClose.close(); } catch (Exception e) { ClassUtil.closeOnFailAndThrowAsIAE(g, toClose, e); return; } g.close(); } private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException"
      },
      {
        "txt": "{ Closeable toClose = (Closeable) value; try { _serializerProvider(cfg).serializeValue(g, value); if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { g.flush(); } } catch (Exception e) { ClassUtil.closeOnFailAndThrowAsIAE(null, toClose, e); return;"
      },
      {
        "txt": "} toClose.close(); } protected DefaultDeserializationContext createDeserializationContext(JsonParser p, DeserializationConfig cfg) { return _deserializationContext.createInstance(cfg, p, _injectableValues); } protected Object _readValue(DeserializationConfig cfg, JsonParser p, JavaType valueType) throws IOException {"
      },
      {
        "txt": "Object result; JsonToken t = _initForReading(p); if (t == JsonToken.VALUE_NULL) { DeserializationContext ctxt = createDeserializationContext(p, cfg); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { // pointing to event other than null DeserializationContext ctxt = createDeserializationContext(p, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);"
      },
      {
        "txt": "if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(p, ctxt); } } p.clearCurrentToken(); return result; } protected Object _readMapAndClose(JsonParser p0, JavaType valueType)"
      },
      {
        "txt": "throws IOException { try (JsonParser p = p0) { Object result; JsonToken t = _initForReading(p); if (t == JsonToken.VALUE_NULL) { DeserializationContext ctxt = createDeserializationContext(p, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {"
      },
      {
        "txt": "result = null; } else { DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(p, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(p, ctxt); }"
      },
      {
        "txt": "ctxt.checkUnresolvedObjectId(); } p.clearCurrentToken(); return result; } } protected JsonToken _initForReading(JsonParser p) throws IOException { _deserializationConfig.initialize(p); // since 2.5 JsonToken t = p.getCurrentToken();"
      },
      {
        "txt": "if (t == null) { t = p.nextToken(); if (t == null) { throw JsonMappingException.from(p, \"No content to map due to end-of-input\"); } } return t; } protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config,"
      },
      {
        "txt": "JavaType rootType, JsonDeserializer<Object> deser) throws IOException { PropertyName expRootName = config.findRootName(rootType); String expSimpleName = expRootName.getSimpleName(); if (p.getCurrentToken() != JsonToken.START_OBJECT) { ctxt.reportWrongTokenException(p, JsonToken.START_OBJECT, \"Current token not START_OBJECT (needed to unwrap root name '%s'), but %s\", expSimpleName, p.getCurrentToken()); }"
      },
      {
        "txt": "if (p.nextToken() != JsonToken.FIELD_NAME) { ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME, \"Current token not FIELD_NAME (to contain expected root name '\" +expSimpleName+\"'), but \"+p.getCurrentToken()); } String actualName = p.getCurrentName(); if (!expSimpleName.equals(actualName)) { ctxt.reportMappingException(\"Root name '%s' does not match expected ('%s') for type %s\", actualName, expSimpleName, rootType); }"
      },
      {
        "txt": "p.nextToken(); Object result = deser.deserialize(p, ctxt); if (p.nextToken() != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(p, JsonToken.END_OBJECT, \"Current token not END_OBJECT (to match wrapper object with root name '%s'), but %s\", expSimpleName, p.getCurrentToken()); } return result; } protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,"
      },
      {
        "txt": "JavaType valueType) throws JsonMappingException { JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); if (deser != null) { return deser; } deser = ctxt.findRootValueDeserializer(valueType); if (deser == null) { // can this happen? throw JsonMappingException.from(ctxt,"
      },
      {
        "txt": "\"Can not find a deserializer for type \"+valueType); } _rootDeserializers.put(valueType, deser); return deser; } protected void _verifySchemaType(FormatSchema schema) { if (schema != null) { if (!_jsonFactory.canUseSchema(schema)) { throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()"
      },
      {
        "txt": "+\" for format \"+_jsonFactory.getFormatName()); } } }"
      }
    ]
  },
  {
    "id": 1603,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java",
    "start-bug-line": 74,
    "end-bug-line": 74,
    "bug": "",
    "fix": "if (baseType.isPrimitive()) { return null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.jsontype.impl; import java.util.Collection; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.NoClass; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.jsontype.*; public class StdTypeResolverBuilder implements TypeResolverBuilder<StdTypeResolverBuilder>"
      },
      {
        "txt": "{ protected JsonTypeInfo.Id _idType; protected JsonTypeInfo.As _includeAs; protected String _typeProperty; protected boolean _typeIdVisible = false; protected Class<?> _defaultImpl; protected TypeIdResolver _customIdResolver; public StdTypeResolverBuilder() { } public static StdTypeResolverBuilder noTypeInfoBuilder() { return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null);"
      },
      {
        "txt": "} @Override public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes) { if (idType == null) { throw new IllegalArgumentException(\"idType can not be null\"); } _idType = idType; _customIdResolver = idRes; _typeProperty = idType.getDefaultPropertyName();"
      },
      {
        "txt": "} @Override public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { if (_idType == JsonTypeInfo.Id.NONE) { return null; } <extra_id_0> switch (_includeAs) { case WRAPPER_ARRAY: return new AsArrayTypeSerializer(idRes, null); case PROPERTY: return new AsPropertyTypeSerializer(idRes, null, _typeProperty); case WRAPPER_OBJECT:"
      },
      {
        "txt": "return new AsPropertyTypeSerializer(idRes, null, _typeProperty); case WRAPPER_OBJECT: return new AsWrapperTypeSerializer(idRes, null); case EXTERNAL_PROPERTY: return new AsExternalTypeSerializer(idRes, null, _typeProperty); case EXISTING_PROPERTY: return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty); } throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs); }"
      },
      {
        "txt": "@Override public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { if (_idType == JsonTypeInfo.Id.NONE) { return null; } TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); JavaType defaultImpl; if (_defaultImpl == null) { defaultImpl = null; } else {"
      },
      {
        "txt": "if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) { defaultImpl = config.getTypeFactory().constructType(_defaultImpl); } else { defaultImpl = config.getTypeFactory() .constructSpecializedType(baseType, _defaultImpl); } } switch (_includeAs) { case WRAPPER_ARRAY:"
      },
      {
        "txt": "return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl); case PROPERTY: case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs); case WRAPPER_OBJECT: return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl); case EXTERNAL_PROPERTY:"
      },
      {
        "txt": "return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl); } throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs); } @Override public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) { if (includeAs == null) { throw new IllegalArgumentException(\"includeAs can not be null\"); }"
      },
      {
        "txt": "_includeAs = includeAs; return this; } @Override public StdTypeResolverBuilder typeProperty(String typeIdPropName) { if (typeIdPropName == null || typeIdPropName.length() == 0) { typeIdPropName = _idType.getDefaultPropertyName(); } _typeProperty = typeIdPropName; return this;"
      },
      {
        "txt": "} @Override public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) { _defaultImpl = defaultImpl; return this; } @Override public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) { _typeIdVisible = isVisible; return this;"
      },
      {
        "txt": "} @Override public Class<?> getDefaultImpl() { return _defaultImpl; } public String getTypeProperty() { return _typeProperty; } public boolean isTypeIdVisible() { return _typeIdVisible; } protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { if (_customIdResolver != null) { return _customIdResolver; } if (_idType == null) throw new IllegalStateException(\"Can not build, 'init()' not yet called\"); switch (_idType) {"
      },
      {
        "txt": "case CLASS: return new ClassNameIdResolver(baseType, config.getTypeFactory()); case MINIMAL_CLASS: return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); case NAME: return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); case NONE: // hmmh. should never get this far with 'none' return null; case CUSTOM: // need custom resolver... }"
      },
      {
        "txt": "throw new IllegalStateException(\"Do not know how to construct standard type id resolver for idType: \"+_idType); }"
      }
    ]
  },
  {
    "id": 1604,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java",
    "start-bug-line": 104,
    "end-bug-line": 104,
    "bug": "",
    "fix": "if (baseType.isPrimitive()) { return null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.jsontype.impl; import java.util.Collection; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.NoClass; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.jsontype.*; public class StdTypeResolverBuilder implements TypeResolverBuilder<StdTypeResolverBuilder>"
      },
      {
        "txt": "{ protected JsonTypeInfo.Id _idType; protected JsonTypeInfo.As _includeAs; protected String _typeProperty; protected boolean _typeIdVisible = false; protected Class<?> _defaultImpl; protected TypeIdResolver _customIdResolver; public StdTypeResolverBuilder() { } public static StdTypeResolverBuilder noTypeInfoBuilder() { return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null);"
      },
      {
        "txt": "} @Override public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes) { if (idType == null) { throw new IllegalArgumentException(\"idType can not be null\"); } _idType = idType; _customIdResolver = idRes; _typeProperty = idType.getDefaultPropertyName();"
      },
      {
        "txt": "return this; } @Override public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { if (_idType == JsonTypeInfo.Id.NONE) { return null; } TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); switch (_includeAs) { case WRAPPER_ARRAY:"
      },
      {
        "txt": "return new AsArrayTypeSerializer(idRes, null); case PROPERTY: return new AsPropertyTypeSerializer(idRes, null, _typeProperty); case WRAPPER_OBJECT: return new AsWrapperTypeSerializer(idRes, null); case EXTERNAL_PROPERTY: return new AsExternalTypeSerializer(idRes, null, _typeProperty); case EXISTING_PROPERTY: return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty); }"
      },
      {
        "txt": "} @Override public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { if (_idType == JsonTypeInfo.Id.NONE) { return null; } <extra_id_0> TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); JavaType defaultImpl; if (_defaultImpl == null) { defaultImpl = null; } else { if ((_defaultImpl == Void.class)"
      },
      {
        "txt": "} else { if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) { defaultImpl = config.getTypeFactory().constructType(_defaultImpl); } else { defaultImpl = config.getTypeFactory() .constructSpecializedType(baseType, _defaultImpl); } } switch (_includeAs) {"
      },
      {
        "txt": "case WRAPPER_ARRAY: return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl); case PROPERTY: case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs); case WRAPPER_OBJECT: return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);"
      },
      {
        "txt": "case EXTERNAL_PROPERTY: return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl); } throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs); } @Override public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) { if (includeAs == null) { throw new IllegalArgumentException(\"includeAs can not be null\");"
      },
      {
        "txt": "} _includeAs = includeAs; return this; } @Override public StdTypeResolverBuilder typeProperty(String typeIdPropName) { if (typeIdPropName == null || typeIdPropName.length() == 0) { typeIdPropName = _idType.getDefaultPropertyName(); } _typeProperty = typeIdPropName;"
      },
      {
        "txt": "return this; } @Override public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) { _defaultImpl = defaultImpl; return this; } @Override public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) { _typeIdVisible = isVisible;"
      },
      {
        "txt": "return this; } @Override public Class<?> getDefaultImpl() { return _defaultImpl; } public String getTypeProperty() { return _typeProperty; } public boolean isTypeIdVisible() { return _typeIdVisible; } protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { if (_customIdResolver != null) { return _customIdResolver; } if (_idType == null) throw new IllegalStateException(\"Can not build, 'init()' not yet called\");"
      },
      {
        "txt": "switch (_idType) { case CLASS: return new ClassNameIdResolver(baseType, config.getTypeFactory()); case MINIMAL_CLASS: return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); case NAME: return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); case NONE: // hmmh. should never get this far with 'none' return null; case CUSTOM: // need custom resolver..."
      },
      {
        "txt": "} throw new IllegalStateException(\"Do not know how to construct standard type id resolver for idType: \"+_idType); }"
      }
    ]
  }
]