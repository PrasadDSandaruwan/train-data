[
  {
    "id": 1408,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 580,
    "end-bug-line": 580,
    "bug": "return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,",
    "fix": "return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method;"
      },
      {
        "txt": "import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>();"
      },
      {
        "txt": "static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));"
      },
      {
        "txt": "_concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue();"
      },
      {
        "txt": "if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } }"
      },
      {
        "txt": "_concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config);"
      },
      {
        "txt": "@Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl)"
      },
      {
        "txt": "{ BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } }"
      },
      {
        "txt": "} if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType();"
      },
      {
        "txt": "JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); }"
      },
      {
        "txt": "} } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; }"
      },
      {
        "txt": "@Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) {"
      },
      {
        "txt": "b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers();"
      },
      {
        "txt": "protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); }"
      },
      {
        "txt": "} JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e);"
      },
      {
        "txt": "} } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);"
      },
      {
        "txt": "return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; }"
      },
      {
        "txt": "if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);"
      },
      {
        "txt": "} if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); }"
      },
      {
        "txt": "if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) {"
      },
      {
        "txt": "case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; }"
      },
      {
        "txt": "if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc);"
      },
      {
        "txt": "} protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; }"
      },
      {
        "txt": "return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null;"
      },
      {
        "txt": "} JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) {"
      },
      {
        "txt": "return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);"
      },
      {
        "txt": "if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig();"
      },
      {
        "txt": "if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false;"
      },
      {
        "txt": "JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { <extra_id_0> keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config,"
      },
      {
        "txt": "MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config,"
      },
      {
        "txt": "type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; }"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) {"
      },
      {
        "txt": "if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); }"
      },
      {
        "txt": "public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc,"
      },
      {
        "txt": "keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer,"
      },
      {
        "txt": "keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);"
      },
      {
        "txt": "if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) {"
      },
      {
        "txt": "ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); }"
      },
      {
        "txt": "@Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();"
      },
      {
        "txt": "JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config,"
      },
      {
        "txt": "Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } }"
      },
      {
        "txt": "return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) {"
      },
      {
        "txt": "if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType());"
      },
      {
        "txt": "if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; }"
      },
      {
        "txt": "protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null;"
      },
      {
        "txt": "} protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); }"
      },
      {
        "txt": "return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false;"
      },
      {
        "txt": "} AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {"
      },
      {
        "txt": "if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; }"
      },
      {
        "txt": "return cls; }"
      }
    ]
  },
  {
    "id": 1409,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 585,
    "end-bug-line": 585,
    "bug": "",
    "fix": "MapLikeType mlType = (MapLikeType) type;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress;"
      },
      {
        "txt": "import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory"
      },
      {
        "txt": "implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls);"
      },
      {
        "txt": "_concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance;"
      },
      {
        "txt": "_concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) {"
      },
      {
        "txt": "_factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); }"
      },
      {
        "txt": "@Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) {"
      },
      {
        "txt": "for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) {"
      },
      {
        "txt": "ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) {"
      },
      {
        "txt": "ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) {"
      },
      {
        "txt": "BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); }"
      },
      {
        "txt": "if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);"
      },
      {
        "txt": "if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser;"
      },
      {
        "txt": "} protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();"
      },
      {
        "txt": "if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; }"
      },
      {
        "txt": "protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; }"
      },
      {
        "txt": "if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType();"
      },
      {
        "txt": "} JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); }"
      },
      {
        "txt": "if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating"
      },
      {
        "txt": "return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null;"
      },
      {
        "txt": "} protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); }"
      },
      {
        "txt": "protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser);"
      },
      {
        "txt": "} protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; }"
      },
      {
        "txt": "} JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map"
      },
      {
        "txt": "JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; <extra_id_0> MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; }"
      },
      {
        "txt": "if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config,"
      },
      {
        "txt": "clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } }"
      },
      {
        "txt": "return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) {"
      },
      {
        "txt": "enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; }"
      },
      {
        "txt": "} else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) {"
      },
      {
        "txt": "ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); }"
      },
      {
        "txt": "public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) {"
      },
      {
        "txt": "mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY;"
      },
      {
        "txt": "break; default: break; } return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break;"
      },
      {
        "txt": "} } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); }"
      },
      {
        "txt": "} if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); }"
      },
      {
        "txt": "@Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null);"
      },
      {
        "txt": "if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) {"
      },
      {
        "txt": "try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config,"
      },
      {
        "txt": "Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try {"
      },
      {
        "txt": "type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException"
      },
      {
        "txt": "{ AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());"
      },
      {
        "txt": "} protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {"
      },
      {
        "txt": "return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) {"
      },
      {
        "txt": "throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1410,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 586,
    "end-bug-line": 586,
    "bug": "MapLikeType mlType = (MapLikeType) type;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer;"
      },
      {
        "txt": "import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable"
      },
      {
        "txt": "{ protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls);"
      },
      {
        "txt": "_concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer);"
      },
      {
        "txt": "_concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;"
      },
      {
        "txt": "_concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config;"
      },
      {
        "txt": "} public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override"
      },
      {
        "txt": "public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type)"
      },
      {
        "txt": "throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) {"
      },
      {
        "txt": "ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false);"
      },
      {
        "txt": "if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m);"
      },
      {
        "txt": "} ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());"
      },
      {
        "txt": "AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) {"
      },
      {
        "txt": "return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) {"
      },
      {
        "txt": "try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser; }"
      },
      {
        "txt": "protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) {"
      },
      {
        "txt": "Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); }"
      },
      {
        "txt": "JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance;"
      },
      {
        "txt": "} if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null;"
      },
      {
        "txt": "default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; }"
      },
      {
        "txt": "protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass();"
      },
      {
        "txt": "if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0];"
      },
      {
        "txt": "return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); }"
      },
      {
        "txt": "protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); }"
      },
      {
        "txt": "protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } }"
      },
      {
        "txt": "JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type;"
      },
      {
        "txt": "if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom <extra_id_0> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; } if (type.isCollectionLikeType()) {"
      },
      {
        "txt": "CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null;"
      },
      {
        "txt": "} if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)"
      },
      {
        "txt": "throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } }"
      },
      {
        "txt": "if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null;"
      },
      {
        "txt": "} ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else {"
      },
      {
        "txt": "ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)"
      },
      {
        "txt": "throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass())"
      },
      {
        "txt": "&& ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue);"
      },
      {
        "txt": "} ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break;"
      },
      {
        "txt": "default: break; } return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } }"
      },
      {
        "txt": "if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5"
      },
      {
        "txt": "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException"
      },
      {
        "txt": "{ return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {"
      },
      {
        "txt": "((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try {"
      },
      {
        "txt": "type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type)"
      },
      {
        "txt": "{ AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass);"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());"
      },
      {
        "txt": "} } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector();"
      },
      {
        "txt": "Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); }"
      },
      {
        "txt": "protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC);"
      },
      {
        "txt": "} return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");"
      },
      {
        "txt": "} Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1411,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 589,
    "end-bug-line": 589,
    "bug": "",
    "fix": "if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat;"
      },
      {
        "txt": "import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>();"
      },
      {
        "txt": "protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete);"
      },
      {
        "txt": "_concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);"
      },
      {
        "txt": "for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName());"
      },
      {
        "txt": "} } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig;"
      },
      {
        "txt": "} public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); }"
      },
      {
        "txt": "@Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break;"
      },
      {
        "txt": "} } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod();"
      },
      {
        "txt": "if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else {"
      },
      {
        "txt": "ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } }"
      },
      {
        "txt": "return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);"
      },
      {
        "txt": "Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes);"
      },
      {
        "txt": "} protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) {"
      },
      {
        "txt": "return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) {"
      },
      {
        "txt": "throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m);"
      },
      {
        "txt": "} JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType();"
      },
      {
        "txt": "} return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null);"
      },
      {
        "txt": "if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } }"
      },
      {
        "txt": "return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) {"
      },
      {
        "txt": "return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a);"
      },
      {
        "txt": "if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException {"
      },
      {
        "txt": "Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException"
      },
      {
        "txt": "{ Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType);"
      },
      {
        "txt": "if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,"
      },
      {
        "txt": "} JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); <extra_id_0> if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null;"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {"
      },
      {
        "txt": "return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else {"
      },
      {
        "txt": "Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "} else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } }"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) {"
      },
      {
        "txt": "return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); }"
      },
      {
        "txt": "public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null;"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null;"
      },
      {
        "txt": "if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector();"
      },
      {
        "txt": "MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; }"
      },
      {
        "txt": "return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());"
      },
      {
        "txt": "} } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) {"
      },
      {
        "txt": "Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); }"
      },
      {
        "txt": "} Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } }"
      },
      {
        "txt": "return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) {"
      },
      {
        "txt": "return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) {"
      },
      {
        "txt": "if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); }"
      },
      {
        "txt": "protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) {"
      },
      {
        "txt": "return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1412,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 594,
    "end-bug-line": 595,
    "bug": "} return ser;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress;"
      },
      {
        "txt": "import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory"
      },
      {
        "txt": "extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance;"
      },
      {
        "txt": "_concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);"
      },
      {
        "txt": "DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) {"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig;"
      },
      {
        "txt": "protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional));"
      },
      {
        "txt": "} @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override"
      },
      {
        "txt": "public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null;"
      },
      {
        "txt": "if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl;"
      },
      {
        "txt": "if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated();"
      },
      {
        "txt": "if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType)"
      },
      {
        "txt": "{ BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac);"
      },
      {
        "txt": "} if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "{ Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) {"
      },
      {
        "txt": "Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } }"
      },
      {
        "txt": "return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; }"
      },
      {
        "txt": "AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null;"
      },
      {
        "txt": "} protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser;"
      },
      {
        "txt": "} if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) {"
      },
      {
        "txt": "kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer();"
      },
      {
        "txt": "} if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); }"
      },
      {
        "txt": "if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO"
      },
      {
        "txt": "case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);"
      },
      {
        "txt": "} protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory());"
      },
      {
        "txt": "return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; }"
      },
      {
        "txt": "return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true;"
      },
      {
        "txt": "} } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo());"
      },
      {
        "txt": "if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type;"
      },
      {
        "txt": "mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } <extra_id_0> } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type;"
      },
      {
        "txt": "if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config,"
      },
      {
        "txt": "clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } }"
      },
      {
        "txt": "return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) {"
      },
      {
        "txt": "enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; }"
      },
      {
        "txt": "} else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) {"
      },
      {
        "txt": "ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); }"
      },
      {
        "txt": "public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) {"
      },
      {
        "txt": "mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY;"
      },
      {
        "txt": "break; default: break; } return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break;"
      },
      {
        "txt": "} } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); }"
      },
      {
        "txt": "} if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); }"
      },
      {
        "txt": "@Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null);"
      },
      {
        "txt": "if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) {"
      },
      {
        "txt": "try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config,"
      },
      {
        "txt": "Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try {"
      },
      {
        "txt": "type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException"
      },
      {
        "txt": "{ AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());"
      },
      {
        "txt": "} protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {"
      },
      {
        "txt": "return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) {"
      },
      {
        "txt": "throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1413,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 598,
    "end-bug-line": 598,
    "bug": "return null;",
    "fix": "return ser;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference;"
      },
      {
        "txt": "import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete ="
      },
      {
        "txt": "new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls);"
      },
      {
        "txt": "NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);"
      },
      {
        "txt": "_concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but:"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() {"
      },
      {
        "txt": "return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));"
      },
      {
        "txt": "} @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) {"
      },
      {
        "txt": "break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType);"
      },
      {
        "txt": "AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate);"
      },
      {
        "txt": "} else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); }"
      },
      {
        "txt": "} return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector();"
      },
      {
        "txt": "TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; }"
      },
      {
        "txt": "return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) {"
      },
      {
        "txt": "if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance();"
      },
      {
        "txt": "} catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc)"
      },
      {
        "txt": "throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) {"
      },
      {
        "txt": "ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; }"
      },
      {
        "txt": "if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) {"
      },
      {
        "txt": "vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); }"
      },
      {
        "txt": "if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: }"
      },
      {
        "txt": "} return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); }"
      },
      {
        "txt": "if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException"
      },
      {
        "txt": "{ Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config,"
      },
      {
        "txt": "elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) {"
      },
      {
        "txt": "return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } <extra_id_0> } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null; } if (type.isArrayType()) {"
      },
      {
        "txt": "return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null);"
      },
      {
        "txt": "if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType);"
      },
      {
        "txt": "} else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "} } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls)"
      },
      {
        "txt": "{ return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer);"
      },
      {
        "txt": "} public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType();"
      },
      {
        "txt": "EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc);"
      },
      {
        "txt": "AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer;"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc)"
      },
      {
        "txt": "throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break;"
      },
      {
        "txt": "} return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException"
      },
      {
        "txt": "{ JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,"
      },
      {
        "txt": "elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException"
      },
      {
        "txt": "{ return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType,"
      },
      {
        "txt": "staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());"
      },
      {
        "txt": "} } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } }"
      },
      {
        "txt": "} return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) {"
      },
      {
        "txt": "return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a);"
      },
      {
        "txt": "if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer)"
      },
      {
        "txt": "{ if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING);"
      },
      {
        "txt": "} protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src;"
      },
      {
        "txt": "if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1414,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 603,
    "end-bug-line": 603,
    "bug": "return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,",
    "fix": "return buildCollectionSerializer(prov,  (CollectionType) clt, beanDesc, staticTyping,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\")"
      },
      {
        "txt": "public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer());"
      },
      {
        "txt": "final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));"
      },
      {
        "txt": "_concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);"
      },
      {
        "txt": "} else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); }"
      },
      {
        "txt": "protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); }"
      },
      {
        "txt": "@Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());"
      },
      {
        "txt": "JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) {"
      },
      {
        "txt": "ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true);"
      },
      {
        "txt": "Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } }"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else {"
      },
      {
        "txt": "subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName);"
      },
      {
        "txt": "if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } }"
      },
      {
        "txt": "} return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance;"
      },
      {
        "txt": "} AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); }"
      },
      {
        "txt": "return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) {"
      },
      {
        "txt": "return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0);"
      },
      {
        "txt": "if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer();"
      },
      {
        "txt": "} if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance;"
      },
      {
        "txt": "case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config,"
      },
      {
        "txt": "JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);"
      },
      {
        "txt": "return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; }"
      },
      {
        "txt": "JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null;"
      },
      {
        "txt": "} return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {"
      },
      {
        "txt": "staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,"
      },
      {
        "txt": "beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { <extra_id_0> elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config,"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) {"
      },
      {
        "txt": "break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; }"
      },
      {
        "txt": "} if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {"
      },
      {
        "txt": "return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,"
      },
      {
        "txt": "MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass);"
      },
      {
        "txt": "} ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config,"
      },
      {
        "txt": "type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) {"
      },
      {
        "txt": "case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; } return null; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else {"
      },
      {
        "txt": "ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {"
      },
      {
        "txt": "Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");"
      },
      {
        "txt": "} try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try {"
      },
      {
        "txt": "type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; }"
      },
      {
        "txt": "protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null;"
      },
      {
        "txt": "} if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1415,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 612,
    "end-bug-line": 612,
    "bug": "",
    "fix": "if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method;"
      },
      {
        "txt": "import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>();"
      },
      {
        "txt": "static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));"
      },
      {
        "txt": "_concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue();"
      },
      {
        "txt": "if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } }"
      },
      {
        "txt": "_concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config);"
      },
      {
        "txt": "@Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl)"
      },
      {
        "txt": "{ BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } }"
      },
      {
        "txt": "} if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType();"
      },
      {
        "txt": "JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); }"
      },
      {
        "txt": "} } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; }"
      },
      {
        "txt": "@Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) {"
      },
      {
        "txt": "b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers();"
      },
      {
        "txt": "protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); }"
      },
      {
        "txt": "} JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e);"
      },
      {
        "txt": "} } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);"
      },
      {
        "txt": "return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; }"
      },
      {
        "txt": "if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);"
      },
      {
        "txt": "} if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); }"
      },
      {
        "txt": "if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) {"
      },
      {
        "txt": "case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; }"
      },
      {
        "txt": "if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc);"
      },
      {
        "txt": "} protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; }"
      },
      {
        "txt": "return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null;"
      },
      {
        "txt": "} JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) {"
      },
      {
        "txt": "return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);"
      },
      {
        "txt": "if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig();"
      },
      {
        "txt": "if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false;"
      },
      {
        "txt": "} JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping,"
      },
      {
        "txt": "} JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); <extra_id_0> if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config,"
      },
      {
        "txt": "type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; }"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) {"
      },
      {
        "txt": "if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); }"
      },
      {
        "txt": "public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc,"
      },
      {
        "txt": "keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer,"
      },
      {
        "txt": "keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);"
      },
      {
        "txt": "if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) {"
      },
      {
        "txt": "ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); }"
      },
      {
        "txt": "@Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();"
      },
      {
        "txt": "JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config,"
      },
      {
        "txt": "Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } }"
      },
      {
        "txt": "return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) {"
      },
      {
        "txt": "if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType());"
      },
      {
        "txt": "if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; }"
      },
      {
        "txt": "protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null;"
      },
      {
        "txt": "} protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); }"
      },
      {
        "txt": "return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false;"
      },
      {
        "txt": "} AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {"
      },
      {
        "txt": "if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; }"
      },
      {
        "txt": "return cls; }"
      }
    ]
  },
  {
    "id": 1416,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 616,
    "end-bug-line": 616,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress;"
      },
      {
        "txt": "import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory"
      },
      {
        "txt": "implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls);"
      },
      {
        "txt": "_concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance;"
      },
      {
        "txt": "_concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) {"
      },
      {
        "txt": "_factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); }"
      },
      {
        "txt": "@Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) {"
      },
      {
        "txt": "for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) {"
      },
      {
        "txt": "ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) {"
      },
      {
        "txt": "ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) {"
      },
      {
        "txt": "BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); }"
      },
      {
        "txt": "if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);"
      },
      {
        "txt": "if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser;"
      },
      {
        "txt": "} protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();"
      },
      {
        "txt": "if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; }"
      },
      {
        "txt": "protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; }"
      },
      {
        "txt": "if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType();"
      },
      {
        "txt": "} JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); }"
      },
      {
        "txt": "if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating"
      },
      {
        "txt": "return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null;"
      },
      {
        "txt": "} protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); }"
      },
      {
        "txt": "protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser);"
      },
      {
        "txt": "} protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; }"
      },
      {
        "txt": "} JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map"
      },
      {
        "txt": "MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config,"
      },
      {
        "txt": "mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } }"
      },
      {
        "txt": "return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type;"
      },
      {
        "txt": "ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); <extra_id_0> } return ser; } } return null; }"
      },
      {
        "txt": "return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) {"
      },
      {
        "txt": "enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; }"
      },
      {
        "txt": "} else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) {"
      },
      {
        "txt": "ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); }"
      },
      {
        "txt": "public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) {"
      },
      {
        "txt": "mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY;"
      },
      {
        "txt": "break; default: break; } return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break;"
      },
      {
        "txt": "} } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); }"
      },
      {
        "txt": "} if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); }"
      },
      {
        "txt": "@Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null);"
      },
      {
        "txt": "if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) {"
      },
      {
        "txt": "try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config,"
      },
      {
        "txt": "Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try {"
      },
      {
        "txt": "type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException"
      },
      {
        "txt": "{ AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());"
      },
      {
        "txt": "} protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {"
      },
      {
        "txt": "return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) {"
      },
      {
        "txt": "throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1417,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 618,
    "end-bug-line": 618,
    "bug": "return ser;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*;"
      },
      {
        "txt": "import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable {"
      },
      {
        "txt": "protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls);"
      },
      {
        "txt": "_concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer);"
      },
      {
        "txt": "_concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls);"
      },
      {
        "txt": "} else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; }"
      },
      {
        "txt": "public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException;"
      },
      {
        "txt": "@Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc);"
      },
      {
        "txt": "if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) {"
      },
      {
        "txt": "beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); }"
      },
      {
        "txt": "ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser);"
      },
      {
        "txt": "} } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo();"
      },
      {
        "txt": "AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null;"
      },
      {
        "txt": "} return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName();"
      },
      {
        "txt": "if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try {"
      },
      {
        "txt": "return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated();"
      },
      {
        "txt": "if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance;"
      },
      {
        "txt": "} if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1);"
      },
      {
        "txt": "if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer();"
      },
      {
        "txt": "} if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; }"
      },
      {
        "txt": "if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default:"
      },
      {
        "txt": "} } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException"
      },
      {
        "txt": "{ Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser)"
      },
      {
        "txt": "throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType();"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());"
      },
      {
        "txt": "if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) {"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; }"
      },
      {
        "txt": "if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config,"
      },
      {
        "txt": "if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } <extra_id_0> } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,"
      },
      {
        "txt": "if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException"
      },
      {
        "txt": "{ JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; }"
      },
      {
        "txt": "ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {"
      },
      {
        "txt": "return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException"
      },
      {
        "txt": "{ JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {"
      },
      {
        "txt": "JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else {"
      },
      {
        "txt": "Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); }"
      },
      {
        "txt": "ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config,"
      },
      {
        "txt": "JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default:"
      },
      {
        "txt": "break; } return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)"
      },
      {
        "txt": "throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } }"
      },
      {
        "txt": "if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) {"
      },
      {
        "txt": "ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");"
      },
      {
        "txt": "return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass);"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) {"
      },
      {
        "txt": "AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); }"
      },
      {
        "txt": "} } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a);"
      },
      {
        "txt": "if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector();"
      },
      {
        "txt": "Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config,"
      },
      {
        "txt": "BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); }"
      },
      {
        "txt": "return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); }"
      },
      {
        "txt": "Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1418,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 621,
    "end-bug-line": 621,
    "bug": "return null;",
    "fix": "return ser;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy ="
      },
      {
        "txt": "new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));"
      },
      {
        "txt": "_concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {"
      },
      {
        "txt": "Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); }"
      },
      {
        "txt": "} _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; }"
      },
      {
        "txt": "public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override"
      },
      {
        "txt": "public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; }"
      },
      {
        "txt": "} } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) {"
      },
      {
        "txt": "final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault();"
      },
      {
        "txt": "} } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser;"
      },
      {
        "txt": "} @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null;"
      },
      {
        "txt": "if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); }"
      },
      {
        "txt": "protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type);"
      },
      {
        "txt": "} } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \""
      },
      {
        "txt": "+e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); }"
      },
      {
        "txt": "JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance;"
      },
      {
        "txt": "} if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); }"
      },
      {
        "txt": "return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer();"
      },
      {
        "txt": "} if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) {"
      },
      {
        "txt": "switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance;"
      },
      {
        "txt": "} if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0];"
      },
      {
        "txt": "return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance;"
      },
      {
        "txt": "} return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) {"
      },
      {
        "txt": "return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a);"
      },
      {
        "txt": "if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) {"
      },
      {
        "txt": "staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) {"
      },
      {
        "txt": "return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } <extra_id_0> } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null;"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null;"
      },
      {
        "txt": "} Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass();"
      },
      {
        "txt": "if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) {"
      },
      {
        "txt": "if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls);"
      },
      {
        "txt": "} public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) {"
      },
      {
        "txt": "return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),"
      },
      {
        "txt": "type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException {"
      },
      {
        "txt": "JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl;"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null;"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));"
      },
      {
        "txt": "} @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0];"
      },
      {
        "txt": "return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); }"
      },
      {
        "txt": "protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); }"
      },
      {
        "txt": "} return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());"
      },
      {
        "txt": "if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } }"
      },
      {
        "txt": "Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type;"
      },
      {
        "txt": "} protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); }"
      },
      {
        "txt": "return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef);"
      },
      {
        "txt": "} return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) {"
      },
      {
        "txt": "return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)"
      },
      {
        "txt": "{ if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null;"
      },
      {
        "txt": "} return cls; }"
      }
    ]
  },
  {
    "id": 1419,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 624,
    "end-bug-line": 624,
    "bug": "return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,",
    "fix": "return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\")"
      },
      {
        "txt": "public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer());"
      },
      {
        "txt": "final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));"
      },
      {
        "txt": "_concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);"
      },
      {
        "txt": "} else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); }"
      },
      {
        "txt": "protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); }"
      },
      {
        "txt": "@Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());"
      },
      {
        "txt": "JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) {"
      },
      {
        "txt": "ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true);"
      },
      {
        "txt": "Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } }"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else {"
      },
      {
        "txt": "subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName);"
      },
      {
        "txt": "if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } }"
      },
      {
        "txt": "} return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance;"
      },
      {
        "txt": "} AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); }"
      },
      {
        "txt": "return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) {"
      },
      {
        "txt": "return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0);"
      },
      {
        "txt": "if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer();"
      },
      {
        "txt": "} if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance;"
      },
      {
        "txt": "case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config,"
      },
      {
        "txt": "JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);"
      },
      {
        "txt": "return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; }"
      },
      {
        "txt": "JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null;"
      },
      {
        "txt": "} return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {"
      },
      {
        "txt": "staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,"
      },
      {
        "txt": "beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); }"
      },
      {
        "txt": "return ser; } } return null; } if (type.isArrayType()) { <extra_id_0> elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) {"
      },
      {
        "txt": "break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; }"
      },
      {
        "txt": "} if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {"
      },
      {
        "txt": "return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,"
      },
      {
        "txt": "MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass);"
      },
      {
        "txt": "} ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config,"
      },
      {
        "txt": "type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) {"
      },
      {
        "txt": "case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; } return null; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else {"
      },
      {
        "txt": "ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {"
      },
      {
        "txt": "Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");"
      },
      {
        "txt": "} try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try {"
      },
      {
        "txt": "type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; }"
      },
      {
        "txt": "protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null;"
      },
      {
        "txt": "} if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1420,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 636,
    "end-bug-line": 636,
    "bug": "protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,",
    "fix": "protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference;"
      },
      {
        "txt": "import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete ="
      },
      {
        "txt": "new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls);"
      },
      {
        "txt": "NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);"
      },
      {
        "txt": "_concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but:"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() {"
      },
      {
        "txt": "return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));"
      },
      {
        "txt": "} @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) {"
      },
      {
        "txt": "break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType);"
      },
      {
        "txt": "AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate);"
      },
      {
        "txt": "} else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); }"
      },
      {
        "txt": "} return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector();"
      },
      {
        "txt": "TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; }"
      },
      {
        "txt": "return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) {"
      },
      {
        "txt": "if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance();"
      },
      {
        "txt": "} catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc)"
      },
      {
        "txt": "throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) {"
      },
      {
        "txt": "ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; }"
      },
      {
        "txt": "if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) {"
      },
      {
        "txt": "vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); }"
      },
      {
        "txt": "if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: }"
      },
      {
        "txt": "} return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); }"
      },
      {
        "txt": "if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException"
      },
      {
        "txt": "{ Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config,"
      },
      {
        "txt": "elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) {"
      },
      {
        "txt": "return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; } if (type.isCollectionLikeType()) {"
      },
      {
        "txt": "CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null;"
      },
      {
        "txt": "if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } <extra_id_0> CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null);"
      },
      {
        "txt": "if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType);"
      },
      {
        "txt": "} else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "} } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls)"
      },
      {
        "txt": "{ return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer);"
      },
      {
        "txt": "} public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType();"
      },
      {
        "txt": "EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc);"
      },
      {
        "txt": "AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer;"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc)"
      },
      {
        "txt": "throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break;"
      },
      {
        "txt": "} return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException"
      },
      {
        "txt": "{ JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,"
      },
      {
        "txt": "elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException"
      },
      {
        "txt": "{ return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType,"
      },
      {
        "txt": "staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());"
      },
      {
        "txt": "} } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } }"
      },
      {
        "txt": "} return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) {"
      },
      {
        "txt": "return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a);"
      },
      {
        "txt": "if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer)"
      },
      {
        "txt": "{ if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING);"
      },
      {
        "txt": "} protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src;"
      },
      {
        "txt": "if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1421,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 641,
    "end-bug-line": 641,
    "bug": "",
    "fix": "SerializationConfig config = prov.getConfig();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\")"
      },
      {
        "txt": "public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer());"
      },
      {
        "txt": "final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));"
      },
      {
        "txt": "_concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);"
      },
      {
        "txt": "} else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); }"
      },
      {
        "txt": "protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); }"
      },
      {
        "txt": "@Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());"
      },
      {
        "txt": "JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) {"
      },
      {
        "txt": "ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true);"
      },
      {
        "txt": "Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } }"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else {"
      },
      {
        "txt": "subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName);"
      },
      {
        "txt": "if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } }"
      },
      {
        "txt": "} return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance;"
      },
      {
        "txt": "} AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); }"
      },
      {
        "txt": "return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) {"
      },
      {
        "txt": "return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0);"
      },
      {
        "txt": "if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer();"
      },
      {
        "txt": "} if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance;"
      },
      {
        "txt": "case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config,"
      },
      {
        "txt": "JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);"
      },
      {
        "txt": "return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; }"
      },
      {
        "txt": "JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null;"
      },
      {
        "txt": "} return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {"
      },
      {
        "txt": "staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,"
      },
      {
        "txt": "beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "} protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { <extra_id_0> for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; }"
      },
      {
        "txt": "} if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {"
      },
      {
        "txt": "return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,"
      },
      {
        "txt": "MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass);"
      },
      {
        "txt": "} ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config,"
      },
      {
        "txt": "type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) {"
      },
      {
        "txt": "case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; } return null; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else {"
      },
      {
        "txt": "ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {"
      },
      {
        "txt": "Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");"
      },
      {
        "txt": "} try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try {"
      },
      {
        "txt": "type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; }"
      },
      {
        "txt": "protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null;"
      },
      {
        "txt": "} if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1422,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 655,
    "end-bug-line": 655,
    "bug": "",
    "fix": "ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*;"
      },
      {
        "txt": "@SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static {"
      },
      {
        "txt": "_concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));"
      },
      {
        "txt": "_concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) {"
      },
      {
        "txt": "_concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);"
      },
      {
        "txt": "} protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override"
      },
      {
        "txt": "public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier));"
      },
      {
        "txt": "} @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) {"
      },
      {
        "txt": "BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } }"
      },
      {
        "txt": "if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,"
      },
      {
        "txt": "rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } }"
      },
      {
        "txt": "} } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override"
      },
      {
        "txt": "public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType);"
      },
      {
        "txt": "} else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type,"
      },
      {
        "txt": "SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } }"
      },
      {
        "txt": "JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); }"
      },
      {
        "txt": "} } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser);"
      },
      {
        "txt": "} return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);"
      },
      {
        "txt": "if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); }"
      },
      {
        "txt": "if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING:"
      },
      {
        "txt": "return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); }"
      },
      {
        "txt": "protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); }"
      },
      {
        "txt": "if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; }"
      },
      {
        "txt": "JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser;"
      },
      {
        "txt": "} JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) {"
      },
      {
        "txt": "return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) {"
      },
      {
        "txt": "if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; }"
      },
      {
        "txt": "JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null;"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { <extra_id_0> JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) {"
      },
      {
        "txt": "if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); }"
      },
      {
        "txt": "public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc,"
      },
      {
        "txt": "keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer,"
      },
      {
        "txt": "keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);"
      },
      {
        "txt": "if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) {"
      },
      {
        "txt": "ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); }"
      },
      {
        "txt": "@Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();"
      },
      {
        "txt": "JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config,"
      },
      {
        "txt": "Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } }"
      },
      {
        "txt": "return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) {"
      },
      {
        "txt": "if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType());"
      },
      {
        "txt": "if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; }"
      },
      {
        "txt": "protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null;"
      },
      {
        "txt": "} protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); }"
      },
      {
        "txt": "return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false;"
      },
      {
        "txt": "} AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {"
      },
      {
        "txt": "if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; }"
      },
      {
        "txt": "return cls; }"
      }
    ]
  },
  {
    "id": 1423,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 691,
    "end-bug-line": 691,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*;"
      },
      {
        "txt": "@SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static {"
      },
      {
        "txt": "_concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));"
      },
      {
        "txt": "_concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) {"
      },
      {
        "txt": "_concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);"
      },
      {
        "txt": "} protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override"
      },
      {
        "txt": "public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier));"
      },
      {
        "txt": "} @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) {"
      },
      {
        "txt": "BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } }"
      },
      {
        "txt": "if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,"
      },
      {
        "txt": "rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } }"
      },
      {
        "txt": "} } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override"
      },
      {
        "txt": "public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType);"
      },
      {
        "txt": "} else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type,"
      },
      {
        "txt": "SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } }"
      },
      {
        "txt": "JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); }"
      },
      {
        "txt": "} } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser);"
      },
      {
        "txt": "} return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);"
      },
      {
        "txt": "if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); }"
      },
      {
        "txt": "if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING:"
      },
      {
        "txt": "return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); }"
      },
      {
        "txt": "protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); }"
      },
      {
        "txt": "if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; }"
      },
      {
        "txt": "JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser;"
      },
      {
        "txt": "} JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) {"
      },
      {
        "txt": "return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) {"
      },
      {
        "txt": "if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; }"
      },
      {
        "txt": "JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null;"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null;"
      },
      {
        "txt": "} Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass();"
      },
      {
        "txt": "if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) {"
      },
      {
        "txt": "ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); <extra_id_0> } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); }"
      },
      {
        "txt": "protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();"
      },
      {
        "txt": "enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId);"
      },
      {
        "txt": "Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) {"
      },
      {
        "txt": "switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; } return null;"
      },
      {
        "txt": "} protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config,"
      },
      {
        "txt": "type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance;"
      },
      {
        "txt": "} else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException"
      },
      {
        "txt": "{ return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0];"
      },
      {
        "txt": "return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5"
      },
      {
        "txt": "protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); }"
      },
      {
        "txt": "protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc)"
      },
      {
        "txt": "throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type)"
      },
      {
        "txt": "{ Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type);"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) {"
      },
      {
        "txt": "try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; }"
      },
      {
        "txt": "protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null;"
      },
      {
        "txt": "} protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; }"
      },
      {
        "txt": "AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) {"
      },
      {
        "txt": "return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls;"
      }
    ]
  },
  {
    "id": 1424,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 737,
    "end-bug-line": 737,
    "bug": "protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,",
    "fix": "protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*;"
      },
      {
        "txt": "import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable {"
      },
      {
        "txt": "protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls);"
      },
      {
        "txt": "_concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer);"
      },
      {
        "txt": "_concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls);"
      },
      {
        "txt": "} else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; }"
      },
      {
        "txt": "public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException;"
      },
      {
        "txt": "@Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc);"
      },
      {
        "txt": "if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) {"
      },
      {
        "txt": "beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); }"
      },
      {
        "txt": "ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser);"
      },
      {
        "txt": "} } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo();"
      },
      {
        "txt": "AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null;"
      },
      {
        "txt": "} return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName();"
      },
      {
        "txt": "if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try {"
      },
      {
        "txt": "return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated();"
      },
      {
        "txt": "if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance;"
      },
      {
        "txt": "} if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1);"
      },
      {
        "txt": "if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer();"
      },
      {
        "txt": "} if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; }"
      },
      {
        "txt": "if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default:"
      },
      {
        "txt": "} } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException"
      },
      {
        "txt": "{ Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser)"
      },
      {
        "txt": "throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType();"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());"
      },
      {
        "txt": "if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) {"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; }"
      },
      {
        "txt": "if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config,"
      },
      {
        "txt": "clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } }"
      },
      {
        "txt": "return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "} if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) {"
      },
      {
        "txt": "enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; }"
      },
      {
        "txt": "} else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) {"
      },
      {
        "txt": "ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); }"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } <extra_id_0> MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null;"
      },
      {
        "txt": "{ JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {"
      },
      {
        "txt": "JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else {"
      },
      {
        "txt": "Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); }"
      },
      {
        "txt": "ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config,"
      },
      {
        "txt": "JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default:"
      },
      {
        "txt": "break; } return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)"
      },
      {
        "txt": "throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } }"
      },
      {
        "txt": "if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) {"
      },
      {
        "txt": "ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType)"
      },
      {
        "txt": "throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");"
      },
      {
        "txt": "return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass);"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) {"
      },
      {
        "txt": "AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); }"
      },
      {
        "txt": "} } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a);"
      },
      {
        "txt": "if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector();"
      },
      {
        "txt": "Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config,"
      },
      {
        "txt": "BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); }"
      },
      {
        "txt": "return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); }"
      },
      {
        "txt": "Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1425,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 743,
    "end-bug-line": 743,
    "bug": "",
    "fix": "final SerializationConfig config = prov.getConfig();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\")"
      },
      {
        "txt": "public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer());"
      },
      {
        "txt": "final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));"
      },
      {
        "txt": "_concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);"
      },
      {
        "txt": "} else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); }"
      },
      {
        "txt": "protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) {"
      },
      {
        "txt": "return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); }"
      },
      {
        "txt": "@Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());"
      },
      {
        "txt": "JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) {"
      },
      {
        "txt": "ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true);"
      },
      {
        "txt": "Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } }"
      },
      {
        "txt": "} if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else {"
      },
      {
        "txt": "subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName);"
      },
      {
        "txt": "if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } }"
      },
      {
        "txt": "} return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance;"
      },
      {
        "txt": "} AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); }"
      },
      {
        "txt": "return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) {"
      },
      {
        "txt": "return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0);"
      },
      {
        "txt": "if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer();"
      },
      {
        "txt": "} if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance;"
      },
      {
        "txt": "case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config,"
      },
      {
        "txt": "JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);"
      },
      {
        "txt": "return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; }"
      },
      {
        "txt": "JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null;"
      },
      {
        "txt": "} return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {"
      },
      {
        "txt": "staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,"
      },
      {
        "txt": "beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom"
      },
      {
        "txt": "MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config,"
      },
      {
        "txt": "type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; }"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) {"
      },
      {
        "txt": "if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {"
      },
      {
        "txt": "ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); }"
      },
      {
        "txt": "public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType);"
      },
      {
        "txt": "protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { <extra_id_0> for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "} if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass);"
      },
      {
        "txt": "} ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config,"
      },
      {
        "txt": "type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); }"
      },
      {
        "txt": "} return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) {"
      },
      {
        "txt": "case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; } return null; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else {"
      },
      {
        "txt": "ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {"
      },
      {
        "txt": "Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");"
      },
      {
        "txt": "} try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try {"
      },
      {
        "txt": "type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; }"
      },
      {
        "txt": "protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null;"
      },
      {
        "txt": "} if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1426,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 756,
    "end-bug-line": 756,
    "bug": "",
    "fix": "ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy ="
      },
      {
        "txt": "new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));"
      },
      {
        "txt": "_concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {"
      },
      {
        "txt": "Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); }"
      },
      {
        "txt": "} _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; }"
      },
      {
        "txt": "public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override"
      },
      {
        "txt": "public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; }"
      },
      {
        "txt": "} } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) {"
      },
      {
        "txt": "final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault();"
      },
      {
        "txt": "} } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser;"
      },
      {
        "txt": "} @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null;"
      },
      {
        "txt": "if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); }"
      },
      {
        "txt": "protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type);"
      },
      {
        "txt": "} } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \""
      },
      {
        "txt": "+e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); }"
      },
      {
        "txt": "JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance;"
      },
      {
        "txt": "} if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); }"
      },
      {
        "txt": "return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer();"
      },
      {
        "txt": "} if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) {"
      },
      {
        "txt": "switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance;"
      },
      {
        "txt": "} if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0];"
      },
      {
        "txt": "return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance;"
      },
      {
        "txt": "} return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) {"
      },
      {
        "txt": "return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a);"
      },
      {
        "txt": "if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) {"
      },
      {
        "txt": "staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) {"
      },
      {
        "txt": "return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null; } if (type.isArrayType()) {"
      },
      {
        "txt": "return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null);"
      },
      {
        "txt": "if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType);"
      },
      {
        "txt": "} else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); }"
      },
      {
        "txt": "} } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls)"
      },
      {
        "txt": "{ return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer);"
      },
      {
        "txt": "} public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { <extra_id_0> if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector();"
      },
      {
        "txt": "MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; }"
      },
      {
        "txt": "return incl; } return null; } protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {"
      },
      {
        "txt": "JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {"
      },
      {
        "txt": "JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ?"
      },
      {
        "txt": "TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());"
      },
      {
        "txt": "} } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) {"
      },
      {
        "txt": "Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); }"
      },
      {
        "txt": "} Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } }"
      },
      {
        "txt": "return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef);"
      },
      {
        "txt": "} return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) {"
      },
      {
        "txt": "return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) {"
      },
      {
        "txt": "if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); }"
      },
      {
        "txt": "protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) {"
      },
      {
        "txt": "return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1427,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 784,
    "end-bug-line": 784,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress;"
      },
      {
        "txt": "import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory"
      },
      {
        "txt": "extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance;"
      },
      {
        "txt": "_concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);"
      },
      {
        "txt": "DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) {"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig;"
      },
      {
        "txt": "protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional));"
      },
      {
        "txt": "} @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override"
      },
      {
        "txt": "public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null;"
      },
      {
        "txt": "if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl;"
      },
      {
        "txt": "if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated();"
      },
      {
        "txt": "if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType)"
      },
      {
        "txt": "{ BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac);"
      },
      {
        "txt": "} if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "{ Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) {"
      },
      {
        "txt": "Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } }"
      },
      {
        "txt": "return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; }"
      },
      {
        "txt": "AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null;"
      },
      {
        "txt": "} protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser;"
      },
      {
        "txt": "} if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) {"
      },
      {
        "txt": "kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer();"
      },
      {
        "txt": "} if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); }"
      },
      {
        "txt": "if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO"
      },
      {
        "txt": "case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);"
      },
      {
        "txt": "} protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory());"
      },
      {
        "txt": "return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; }"
      },
      {
        "txt": "return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true;"
      },
      {
        "txt": "} } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo());"
      },
      {
        "txt": "if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type;"
      },
      {
        "txt": "ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "} return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null;"
      },
      {
        "txt": "CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null;"
      },
      {
        "txt": "} protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) {"
      },
      {
        "txt": "if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance;"
      },
      {
        "txt": "} } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); }"
      },
      {
        "txt": "protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();"
      },
      {
        "txt": "enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId);"
      },
      {
        "txt": "type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } <extra_id_0> if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) {"
      },
      {
        "txt": "case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; } return null; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else {"
      },
      {
        "txt": "ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {"
      },
      {
        "txt": "return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt);"
      },
      {
        "txt": "} protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,"
      },
      {
        "txt": "JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {"
      },
      {
        "txt": "Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");"
      },
      {
        "txt": "} try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try {"
      },
      {
        "txt": "type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,"
      },
      {
        "txt": "Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; }"
      },
      {
        "txt": "protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null;"
      },
      {
        "txt": "} if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1428,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 831,
    "end-bug-line": 831,
    "bug": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,",
    "fix": "protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference;"
      },
      {
        "txt": "import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete ="
      },
      {
        "txt": "new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance; _concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls);"
      },
      {
        "txt": "NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance); DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);"
      },
      {
        "txt": "_concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) { @SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but:"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() {"
      },
      {
        "txt": "return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional)); } @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));"
      },
      {
        "txt": "} @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) {"
      },
      {
        "txt": "break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType);"
      },
      {
        "txt": "AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate);"
      },
      {
        "txt": "} else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); }"
      },
      {
        "txt": "} return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector();"
      },
      {
        "txt": "TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac); } if (b == null) { return null; }"
      },
      {
        "txt": "return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) {"
      },
      {
        "txt": "if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) { Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance();"
      },
      {
        "txt": "} catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } } return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc)"
      },
      {
        "txt": "throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; } AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) {"
      },
      {
        "txt": "ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null; } protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; } if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; }"
      },
      {
        "txt": "if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) {"
      },
      {
        "txt": "vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer(); } if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); }"
      },
      {
        "txt": "if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); } if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) {"
      },
      {
        "txt": "JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: }"
      },
      {
        "txt": "} return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); } return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); }"
      },
      {
        "txt": "if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException {"
      },
      {
        "txt": "Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); } protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException"
      },
      {
        "txt": "{ Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; } return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true; } } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config,"
      },
      {
        "txt": "elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) {"
      },
      {
        "txt": "return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) {"
      },
      {
        "txt": "for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; } if (type.isCollectionLikeType()) {"
      },
      {
        "txt": "CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null;"
      },
      {
        "txt": "} if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null; } protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)"
      },
      {
        "txt": "throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } }"
      },
      {
        "txt": "if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass(); if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null;"
      },
      {
        "txt": "} ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else {"
      },
      {
        "txt": "ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance; } } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping,"
      },
      {
        "txt": "elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); } protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)"
      },
      {
        "txt": "throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass())"
      },
      {
        "txt": "&& ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "} else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId); Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue);"
      },
      {
        "txt": "} ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) { switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break;"
      },
      {
        "txt": "break; } return incl; } return null; } <extra_id_0> ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null;"
      },
      {
        "txt": "{ JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) {"
      },
      {
        "txt": "Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw); } } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,"
      },
      {
        "txt": "elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException"
      },
      {
        "txt": "{ return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType,"
      },
      {
        "txt": "staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser;"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\") protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); } try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());"
      },
      {
        "txt": "} } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } }"
      },
      {
        "txt": "} return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) {"
      },
      {
        "txt": "return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a);"
      },
      {
        "txt": "if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer)"
      },
      {
        "txt": "{ if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING);"
      },
      {
        "txt": "} protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; } if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src;"
      },
      {
        "txt": "if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1429,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
    "start-bug-line": 841,
    "end-bug-line": 841,
    "bug": "",
    "fix": "SerializationConfig config = prov.getConfig();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.lang.reflect.Method; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress;"
      },
      {
        "txt": "import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.*; import com.fasterxml.jackson.databind.ser.std.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.*; @SuppressWarnings(\"serial\") public abstract class BasicSerializerFactory"
      },
      {
        "txt": "extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static { _concrete.put(String.class.getName(), new StringSerializer()); final ToStringSerializer sls = ToStringSerializer.instance;"
      },
      {
        "txt": "_concrete.put(StringBuffer.class.getName(), sls); _concrete.put(StringBuilder.class.getName(), sls); _concrete.put(Character.class.getName(), sls); _concrete.put(Character.TYPE.getName(), sls); NumberSerializers.addAll(_concrete); _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true)); _concrete.put(Boolean.class.getName(), new BooleanSerializer(false)); _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class)); _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class)); _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);"
      },
      {
        "txt": "DateSerializer dateSer = DateSerializer.instance; _concrete.put(java.util.Date.class.getName(), dateSer); _concrete.put(java.sql.Timestamp.class.getName(), dateSer); _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class); _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class); for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) { Object value = en.getValue(); if (value instanceof JsonSerializer<?>) { _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value); } else if (value instanceof Class<?>) {"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value; _concreteLazy.put(en.getKey().getName(), cls); } else { // should never happen, but: throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName()); } } _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class); } protected final SerializerFactoryConfig _factoryConfig;"
      },
      {
        "txt": "protected BasicSerializerFactory(SerializerFactoryConfig config) { _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; } public SerializerFactoryConfig getFactoryConfig() { return _factoryConfig; } public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalSerializers(additional));"
      },
      {
        "txt": "} @Override public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); } @Override public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { return withConfig(_factoryConfig.withSerializerModifier(modifier)); } @Override"
      },
      {
        "txt": "public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null;"
      },
      {
        "txt": "if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl;"
      },
      {
        "txt": "if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated();"
      },
      {
        "txt": "if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } }"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; } @Override public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType)"
      },
      {
        "txt": "{ BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); AnnotatedClass ac = bean.getClassInfo(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); Collection<NamedType> subtypes = null; if (b == null) { b = config.getDefaultTyper(baseType); } else { subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac);"
      },
      {
        "txt": "} if (b == null) { return null; } return b.buildTypeSerializer(config, baseType, subtypes); } protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping)"
      },
      {
        "txt": "{ Class<?> raw = type.getRawClass(); String clsName = raw.getName(); if (type.isReferenceType()) { if (type.isTypeOrSubTypeOf(AtomicReference.class)) { return new AtomicReferenceSerializer((ReferenceType) type); } } JsonSerializer<?> ser = _concrete.get(clsName); if (ser == null) {"
      },
      {
        "txt": "Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); if (serClass != null) { try { return serClass.newInstance(); } catch (Exception e) { throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \" +e.getMessage(), e); } } }"
      },
      {
        "txt": "return ser; } protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); if (JsonSerializable.class.isAssignableFrom(raw)) { return SerializableSerializer.instance; }"
      },
      {
        "txt": "AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); if (valueMethod != null) { Method m = valueMethod.getAnnotated(); if (prov.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); return new JsonValueSerializer(m, ser); } return null;"
      },
      {
        "txt": "} protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { Class<?> raw = type.getRawClass(); JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser;"
      },
      {
        "txt": "} if (Calendar.class.isAssignableFrom(raw)) { return CalendarSerializer.instance; } if (java.util.Date.class.isAssignableFrom(raw)) { return DateSerializer.instance; } if (Map.Entry.class.isAssignableFrom(raw)) { JavaType kt = type.containedType(0); if (kt == null) {"
      },
      {
        "txt": "kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt); } if (ByteBuffer.class.isAssignableFrom(raw)) { return new ByteBufferSerializer();"
      },
      {
        "txt": "} if (InetAddress.class.isAssignableFrom(raw)) { return new InetAddressSerializer(); } if (InetSocketAddress.class.isAssignableFrom(raw)) { return new InetSocketAddressSerializer(); } if (TimeZone.class.isAssignableFrom(raw)) { return new TimeZoneSerializer(); }"
      },
      {
        "txt": "if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { return ToStringSerializer.instance; } if (Number.class.isAssignableFrom(raw)) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; case OBJECT: // need to bail out to let it be serialized as POJO"
      },
      {
        "txt": "case ARRAY: // or, I guess ARRAY; otherwise no point in speculating return null; default: } } return NumberSerializer.instance; } if (Enum.class.isAssignableFrom(raw)) { return buildEnumSerializer(prov.getConfig(), type, beanDesc); }"
      },
      {
        "txt": "return null; } protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); } protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ Class<?> type = javaType.getRawClass(); if (Iterator.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt); } if (Iterable.class.isAssignableFrom(type)) { JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);"
      },
      {
        "txt": "JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, javaType, beanDesc, staticTyping, vt); } if (CharSequence.class.isAssignableFrom(type)) { return ToStringSerializer.instance; } return null; } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { Object serDef = prov.getAnnotationIntrospector().findSerializer(a); if (serDef == null) { return null; } JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);"
      },
      {
        "txt": "} protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { Converter<Object,Object> conv = findConverter(prov, a); if (conv == null) { return ser; } JavaType delegateType = conv.getOutputType(prov.getTypeFactory());"
      },
      {
        "txt": "return new StdDelegatingSerializer(conv, delegateType, ser); } protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); if (convDef == null) { return null; }"
      },
      {
        "txt": "return prov.converterInstance(a, convDef); } protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); if (!staticTyping && type.useStaticType()) { if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { staticTyping = true;"
      },
      {
        "txt": "} } JavaType elementType = type.getContentType(); TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); if (elementTypeSerializer != null) { staticTyping = false; } JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo());"
      },
      {
        "txt": "if (type.isMapLikeType()) { // implements java.util.Map MapLikeType mlt = (MapLikeType) type; JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type;"
      },
      {
        "txt": "ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; }"
      },
      {
        "txt": "} return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } JsonSerializer<?> ser = null;"
      },
      {
        "txt": "CollectionLikeType clType = (CollectionLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } }"
      },
      {
        "txt": "return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null;"
      },
      {
        "txt": "} protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { return null; } Class<?> raw = type.getRawClass();"
      },
      {
        "txt": "if (EnumSet.class.isAssignableFrom(raw)) { JavaType enumType = type.getContentType(); if (!enumType.isEnumType()) { enumType = null; } ser = buildEnumSetSerializer(enumType); } else { Class<?> elementRaw = type.getContentType().getRawClass(); if (isIndexedList(raw)) { if (elementRaw == String.class) {"
      },
      {
        "txt": "if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = IndexedStringListSerializer.instance; } } else { ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } else if (elementRaw == String.class) { if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { ser = StringCollectionSerializer.instance;"
      },
      {
        "txt": "} } if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); } } return ser; } protected boolean isIndexedList(Class<?> cls) { return RandomAccess.class.isAssignableFrom(cls); } public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType,"
      },
      {
        "txt": "boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer); } public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer); } public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) { return new EnumSetSerializer(enumType); }"
      },
      {
        "txt": "protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);"
      },
      {
        "txt": "if (ser != null) { break; } } if (ser == null) { if (EnumMap.class.isAssignableFrom(type.getRawClass()) && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) { JavaType keyType = type.getKeyType(); EnumValues enums = null; if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance) @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();"
      },
      {
        "txt": "enums = EnumValues.construct(config, enumClass); } ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); } else { Object filterId = findFilterId(config, beanDesc); AnnotationIntrospector ai = config.getAnnotationIntrospector(); MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId);"
      },
      {
        "txt": "Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc); if (suppressableValue != null) { mapSer = mapSer.withContentInclusion(suppressableValue); } ser = mapSer; } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapSerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException { JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null); if (incl != null) {"
      },
      {
        "txt": "switch (incl) { case NON_DEFAULT: incl = JsonInclude.Include.NON_EMPTY; break; default: break; } return incl; } return null;"
      },
      {
        "txt": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { <extra_id_0> for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; }"
      },
      {
        "txt": "break; } } if (ser == null) { Class<?> raw = type.getRawClass(); if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { if (String[].class == raw) { ser = StringArraySerializer.instance; } else { ser = StdArraySerializers.findStandardImpl(raw);"
      },
      {
        "txt": "} } if (ser == null) { ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyArraySerializer(config, type, beanDesc, ser);"
      },
      {
        "txt": "} } return ser; } protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));"
      },
      {
        "txt": "} @Deprecated // since 2.5 protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); }"
      },
      {
        "txt": "protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException { return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType)); } @Deprecated // since 2.5 protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc,"
      },
      {
        "txt": "boolean staticTyping) throws JsonMappingException { JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class); JavaType vt = (params == null || params.length != 1) ? TypeFactory.unknownType() : params[0]; return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); } protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping,"
      },
      {
        "txt": "JavaType keyType, JavaType valueType) throws JsonMappingException { return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null); } protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException {"
      },
      {
        "txt": "JsonFormat.Value format = beanDesc.findExpectedFormat(null); if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\"); return null; } @SuppressWarnings(\"unchecked\") Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); } } return ser; } @SuppressWarnings(\"unchecked\") protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);"
      },
      {
        "txt": "if (superclass != null) { try { type = (T) type.widenBy(superclass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage()); } } return modifySecondaryTypesByAnnotation(config, a, type); } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); if (type.isContainerType()) { Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapType)) { throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\"); }"
      },
      {
        "txt": "try { type = (T) ((MapType) type).widenKey(keyClass); } catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage()); } } Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.widenContentsBy(cc);"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage()); } } } return type; } protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException"
      },
      {
        "txt": "{ AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findKeySerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a)"
      },
      {
        "txt": "throws JsonMappingException { AnnotationIntrospector intr = prov.getAnnotationIntrospector(); Object serDef = intr.findContentSerializer(a); if (serDef != null) { return prov.serializerInstance(a, serDef); } return null; } protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {"
      },
      {
        "txt": "return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo()); } protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { if (typeSer != null) { return false; } AnnotationIntrospector intr = config.getAnnotationIntrospector(); JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());"
      },
      {
        "txt": "if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) { return (t == JsonSerialize.Typing.STATIC); } return config.isEnabled(MapperFeature.USE_STATIC_TYPING); } protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { if (src == null) { return null; }"
      },
      {
        "txt": "if (!(src instanceof Class)) { throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\"); } Class<?> cls = (Class<?>) src; if (cls == noneClass || ClassUtil.isBogusClass(cls)) { return null; } return cls; }"
      }
    ]
  },
  {
    "id": 1430,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
    "start-bug-line": 174,
    "end-bug-line": 177,
    "bug": "JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); if (ser != null) { return ser; }",
    "fix": "JsonSerializer<?> ser = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.util.*; import com.fasterxml.jackson.annotation.ObjectIdGenerator; import com.fasterxml.jackson.annotation.ObjectIdGenerators; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter; import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter; import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator; import com.fasterxml.jackson.databind.ser.std.MapSerializer; import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.Converter;"
      },
      {
        "txt": "public class BeanSerializerFactory extends BasicSerializerFactory implements java.io.Serializable // since 2.1 { private static final long serialVersionUID = 1; public final static BeanSerializerFactory instance = new BeanSerializerFactory(null); protected BeanSerializerFactory(SerializerFactoryConfig config) { super(config); }"
      },
      {
        "txt": "@Override public SerializerFactory withConfig(SerializerFactoryConfig config) { if (_factoryConfig == config) { return this; } if (getClass() != BeanSerializerFactory.class) { throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName() +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \" +\"additional serializer definitions\");"
      },
      {
        "txt": "} return new BeanSerializerFactory(config); } @Override protected Iterable<Serializers> customSerializers() { return _factoryConfig.serializers(); } @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createSerializer(SerializerProvider prov,"
      },
      {
        "txt": "JavaType origType) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); BeanDescription beanDesc = config.introspect(origType); JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); if (ser != null) { return (JsonSerializer<Object>) ser; } boolean staticTyping;"
      },
      {
        "txt": "JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); if (type == origType) { // no changes, won't force static typing staticTyping = false; } else { // changes; assume static typing; plus, need to re-introspect if class differs staticTyping = true; if (!type.hasRawClass(origType.getRawClass())) { beanDesc = config.introspect(type); } } Converter<Object,Object> conv = beanDesc.findSerializationConverter();"
      },
      {
        "txt": "if (conv == null) { // no, simple return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); if (!delegateType.hasRawClass(type.getRawClass())) { beanDesc = config.introspect(delegateType); ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); } if (ser == null && !delegateType.isJavaLangObject()) { ser = _createSerializer2(prov, delegateType, beanDesc, true);"
      },
      {
        "txt": "return new StdDelegatingSerializer(conv, delegateType, ser); } protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { <extra_id_0> final SerializationConfig config = prov.getConfig(); if (type.isContainerType()) { if (!staticTyping) { staticTyping = usesStaticTyping(config, beanDesc, null); if (property == null) { JavaType t = origType.getContentType();"
      },
      {
        "txt": "if (property == null) { JavaType t = origType.getContentType(); if (t != null && !t.hasRawClass(Object.class)) { staticTyping = true; } } } ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser;"
      },
      {
        "txt": "} } else { for (Serializers serializers : customSerializers()) { ser = serializers.findSerializer(config, type, beanDesc); if (ser != null) { break; } } } if (ser == null) {"
      },
      {
        "txt": "ser = findSerializerByLookup(type, config, beanDesc, staticTyping); if (ser == null) { ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); if (ser == null) { ser = findBeanSerializer(prov, type, beanDesc); if (ser == null) { ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); if (ser == null) { ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass()); }"
      },
      {
        "txt": "} } } } if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifySerializer(config, beanDesc, ser); } }"
      },
      {
        "txt": "} return ser; } public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { if (!isPotentialBeanType(type.getRawClass())) { if (!type.isEnumType()) { return null; }"
      },
      {
        "txt": "} return constructBeanSerializer(prov, beanDesc); } public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType); TypeSerializer typeSer;"
      },
      {
        "txt": "if (b == null) { typeSer = createTypeSerializer(config, baseType); } else { Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass( config, accessor, baseType); typeSer = b.buildTypeSerializer(config, baseType, subtypes); } return typeSer; } public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,"
      },
      {
        "txt": "SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { JavaType contentType = containerType.getContentType(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType); TypeSerializer typeSer; if (b == null) { typeSer = createTypeSerializer(config, contentType); } else {"
      },
      {
        "txt": "Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, accessor, contentType); typeSer = b.buildTypeSerializer(config, contentType, subtypes); } return typeSer; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException"
      },
      {
        "txt": "{ if (beanDesc.getBeanClass() == Object.class) { return prov.getUnknownTypeSerializer(Object.class); } final SerializationConfig config = prov.getConfig(); BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); builder.setConfig(config); List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); if (props == null) { props = new ArrayList<BeanPropertyWriter>();"
      },
      {
        "txt": "} else { props = removeOverlappingTypeIds(prov, beanDesc, builder, props); } prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { props = mod.changeProperties(config, beanDesc, props); } } props = filterBeanProperties(config, beanDesc, props);"
      },
      {
        "txt": "if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { props = mod.orderProperties(config, beanDesc, props); } } builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); builder.setProperties(props); builder.setFilterId(findFilterId(config, beanDesc)); AnnotatedMember anyGetter = beanDesc.findAnyGetter(); if (anyGetter != null) {"
      },
      {
        "txt": "if (config.canOverrideAccessModifiers()) { anyGetter.fixAccess(); } JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); JavaType valueType = type.getContentType(); TypeSerializer typeSer = createTypeSerializer(config, valueType); JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter); if (anySer == null) { anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,"
      },
      {
        "txt": "typeSer, null, null, /*filterId*/ null); } PropertyName name = PropertyName.construct(anyGetter.getName()); BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL); builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer)); } processViews(config, builder); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {"
      },
      {
        "txt": "builder = mod.updateBuilder(config, beanDesc, builder); } } JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); if (ser == null) { if (beanDesc.hasKnownClassAnnotations()) { return builder.createDummy(); } } return ser;"
      },
      {
        "txt": "} protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); if (objectIdInfo == null) { return null; } ObjectIdGenerator<?> gen;"
      },
      {
        "txt": "Class<?> implClass = objectIdInfo.getGeneratorType(); if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work String propName = objectIdInfo.getPropertyName().getSimpleName(); BeanPropertyWriter idProp = null; for (int i = 0, len = props.size() ;; ++i) { if (i == len) { throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName() +\": can not find property with name '\"+propName+\"'\"); } BeanPropertyWriter prop = props.get(i);"
      },
      {
        "txt": "if (propName.equals(prop.getName())) { idProp = prop; if (i > 0) { props.remove(i); props.add(0, idProp); } break; } } JavaType idType = idProp.getType();"
      },
      {
        "txt": "gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId()); } JavaType type = prov.constructType(implClass); JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); } protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,"
      },
      {
        "txt": "Class<?>[] inViews) { return FilteredBeanPropertyWriter.constructViewBased(writer, inViews); } protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc) { return new PropertyBuilder(config, beanDesc); } protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {"
      },
      {
        "txt": "return new BeanSerializerBuilder(beanDesc); } protected boolean isPotentialBeanType(Class<?> type) { return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type); } protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException {"
      },
      {
        "txt": "List<BeanPropertyDefinition> properties = beanDesc.findProperties(); final SerializationConfig config = prov.getConfig(); removeIgnorableTypes(config, beanDesc, properties); if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { removeSetterlessGetters(config, beanDesc, properties); } if (properties.isEmpty()) { return null; } boolean staticTyping = usesStaticTyping(config, beanDesc, null);"
      },
      {
        "txt": "PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); TypeBindings typeBind = beanDesc.bindingsForBeanType(); for (BeanPropertyDefinition property : properties) { final AnnotatedMember accessor = property.getAccessor(); if (property.isTypeId()) { if (accessor != null) { // only add if we can access... but otherwise? if (config.canOverrideAccessModifiers()) { accessor.fixAccess(); }"
      },
      {
        "txt": "builder.setTypeId(accessor); } continue; } AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); if (refType != null && refType.isBackReference()) { continue; } if (accessor instanceof AnnotatedMethod) { result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));"
      },
      {
        "txt": "} else { result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); } } return result; } protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) { AnnotationIntrospector intr = config.getAnnotationIntrospector();"
      },
      {
        "txt": "AnnotatedClass ac = beanDesc.getClassInfo(); String[] ignored = intr.findPropertiesToIgnore(ac, true); if (ignored != null && ignored.length > 0) { HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored); Iterator<BeanPropertyWriter> it = props.iterator(); while (it.hasNext()) { if (ignoredSet.contains(it.next().getName())) { it.remove(); } }"
      },
      {
        "txt": "} return props; } protected void processViews(SerializationConfig config, BeanSerializerBuilder builder) { List<BeanPropertyWriter> props = builder.getProperties(); boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION); final int propCount = props.size(); int viewsFound = 0; BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];"
      },
      {
        "txt": "for (int i = 0; i < propCount; ++i) { BeanPropertyWriter bpw = props.get(i); Class<?>[] views = bpw.getViews(); if (views == null) { // no view info? include or exclude by default? if (includeByDefault) { filtered[i] = bpw; } } else { ++viewsFound; filtered[i] = constructFilteredBeanWriter(bpw, views);"
      },
      {
        "txt": "} } if (includeByDefault && viewsFound == 0) { return; } builder.setFilteredProperties(filtered); } protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) {"
      },
      {
        "txt": "AnnotationIntrospector intr = config.getAnnotationIntrospector(); HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>(); Iterator<BeanPropertyDefinition> it = properties.iterator(); while (it.hasNext()) { BeanPropertyDefinition property = it.next(); AnnotatedMember accessor = property.getAccessor(); if (accessor == null) { it.remove(); continue; }"
      },
      {
        "txt": "Class<?> type = accessor.getRawType(); Boolean result = ignores.get(type); if (result == null) { BeanDescription desc = config.introspectClassAnnotations(type); AnnotatedClass ac = desc.getClassInfo(); result = intr.isIgnorableType(ac); if (result == null) { result = Boolean.FALSE; } ignores.put(type, result);"
      },
      {
        "txt": "} if (result.booleanValue()) { it.remove(); } } } protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { Iterator<BeanPropertyDefinition> it = properties.iterator();"
      },
      {
        "txt": "while (it.hasNext()) { BeanPropertyDefinition property = it.next(); if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) { it.remove(); } } } protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder, List<BeanPropertyWriter> props)"
      },
      {
        "txt": "{ for (int i = 0, end = props.size(); i < end; ++i) { BeanPropertyWriter bpw = props.get(i); TypeSerializer td = bpw.getTypeSerializer(); if ((td == null) || (td.getTypeInclusion() != As.EXTERNAL_PROPERTY)) { continue; } String n = td.getPropertyName(); PropertyName typePropName = PropertyName.construct(n); for (BeanPropertyWriter w2 : props) {"
      },
      {
        "txt": "if ((w2 != bpw) && w2.wouldConflictWithName(typePropName)) { bpw.assignTypeSerializer(null); break; } } } return props; } protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext,"
      },
      {
        "txt": "PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException { final PropertyName name = propDef.getFullName(); if (prov.canOverrideAccessModifiers()) { accessor.fixAccess(); } JavaType type = accessor.getType(typeContext); BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(), pb.getClassAnnotations(), accessor, propDef.getMetadata());"
      },
      {
        "txt": "JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov, accessor); if (annotatedSerializer instanceof ResolvableSerializer) { ((ResolvableSerializer) annotatedSerializer).resolve(prov); } annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property); TypeSerializer contentTypeSer = null; if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) { contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);"
      },
      {
        "txt": "} TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor); BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer, typeSer, contentTypeSer, accessor, staticTyping); return pbw; }"
      }
    ]
  },
  {
    "id": 1431,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
    "start-bug-line": 212,
    "end-bug-line": 212,
    "bug": "",
    "fix": "if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.ser; import java.util.*; import com.fasterxml.jackson.annotation.ObjectIdGenerator; import com.fasterxml.jackson.annotation.ObjectIdGenerators; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.databind.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter; import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter; import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator; import com.fasterxml.jackson.databind.ser.std.MapSerializer; import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.Converter; public class BeanSerializerFactory extends BasicSerializerFactory implements java.io.Serializable // since 2.1 { private static final long serialVersionUID = 1; public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);"
      },
      {
        "txt": "protected BeanSerializerFactory(SerializerFactoryConfig config) { super(config); } @Override public SerializerFactory withConfig(SerializerFactoryConfig config) { if (_factoryConfig == config) { return this; }"
      },
      {
        "txt": "if (getClass() != BeanSerializerFactory.class) { throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName() +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \" +\"additional serializer definitions\"); } return new BeanSerializerFactory(config); } @Override protected Iterable<Serializers> customSerializers() { return _factoryConfig.serializers();"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); BeanDescription beanDesc = config.introspect(origType); JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());"
      },
      {
        "txt": "if (ser != null) { return (JsonSerializer<Object>) ser; } boolean staticTyping; JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); if (type == origType) { // no changes, won't force static typing staticTyping = false; } else { // changes; assume static typing; plus, need to re-introspect if class differs staticTyping = true; if (!type.hasRawClass(origType.getRawClass())) {"
      },
      {
        "txt": "beanDesc = config.introspect(type); } } Converter<Object,Object> conv = beanDesc.findSerializationConverter(); if (conv == null) { // no, simple return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); } JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); if (!delegateType.hasRawClass(type.getRawClass())) { beanDesc = config.introspect(delegateType);"
      },
      {
        "txt": "ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); } if (ser == null && !delegateType.isJavaLangObject()) { ser = _createSerializer2(prov, delegateType, beanDesc, true); } return new StdDelegatingSerializer(conv, delegateType, ser); } protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException"
      },
      {
        "txt": "{ JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); if (ser != null) { return ser; } final SerializationConfig config = prov.getConfig(); if (type.isContainerType()) { if (!staticTyping) { staticTyping = usesStaticTyping(config, beanDesc, null); if (property == null) {"
      },
      {
        "txt": "JavaType t = origType.getContentType(); if (t != null && !t.hasRawClass(Object.class)) { staticTyping = true; } } } ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); if (ser != null) { return ser; }"
      },
      {
        "txt": "for (Serializers serializers : customSerializers()) { ser = serializers.findSerializer(config, type, beanDesc); if (ser != null) { break; } } <extra_id_0> if (ser == null) { ser = findSerializerByLookup(type, config, beanDesc, staticTyping); if (ser == null) { ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); if (ser == null) { ser = findBeanSerializer(prov, type, beanDesc);"
      },
      {
        "txt": "if (ser == null) { ser = findBeanSerializer(prov, type, beanDesc); if (ser == null) { ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); if (ser == null) { ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass()); } } } }"
      },
      {
        "txt": "} if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifySerializer(config, beanDesc, ser); } } } return ser; }"
      },
      {
        "txt": "public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { if (!isPotentialBeanType(type.getRawClass())) { if (!type.isEnumType()) { return null; } } return constructBeanSerializer(prov, beanDesc); }"
      },
      {
        "txt": "public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType); TypeSerializer typeSer; if (b == null) { typeSer = createTypeSerializer(config, baseType); } else {"
      },
      {
        "txt": "Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass( config, accessor, baseType); typeSer = b.buildTypeSerializer(config, baseType, subtypes); } return typeSer; } public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException {"
      },
      {
        "txt": "JavaType contentType = containerType.getContentType(); AnnotationIntrospector ai = config.getAnnotationIntrospector(); TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType); TypeSerializer typeSer; if (b == null) { typeSer = createTypeSerializer(config, contentType); } else { Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, accessor, contentType); typeSer = b.buildTypeSerializer(config, contentType, subtypes);"
      },
      {
        "txt": "} return typeSer; } @SuppressWarnings(\"unchecked\") protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { if (beanDesc.getBeanClass() == Object.class) { return prov.getUnknownTypeSerializer(Object.class);"
      },
      {
        "txt": "} final SerializationConfig config = prov.getConfig(); BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); builder.setConfig(config); List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); if (props == null) { props = new ArrayList<BeanPropertyWriter>(); } else { props = removeOverlappingTypeIds(prov, beanDesc, builder, props); }"
      },
      {
        "txt": "prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { props = mod.changeProperties(config, beanDesc, props); } } props = filterBeanProperties(config, beanDesc, props); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { props = mod.orderProperties(config, beanDesc, props);"
      },
      {
        "txt": "} } builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); builder.setProperties(props); builder.setFilterId(findFilterId(config, beanDesc)); AnnotatedMember anyGetter = beanDesc.findAnyGetter(); if (anyGetter != null) { if (config.canOverrideAccessModifiers()) { anyGetter.fixAccess(); }"
      },
      {
        "txt": "JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); JavaType valueType = type.getContentType(); TypeSerializer typeSer = createTypeSerializer(config, valueType); JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter); if (anySer == null) { anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping, typeSer, null, null, /*filterId*/ null); } PropertyName name = PropertyName.construct(anyGetter.getName());"
      },
      {
        "txt": "BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL); builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer)); } processViews(config, builder); if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { builder = mod.updateBuilder(config, beanDesc, builder); } }"
      },
      {
        "txt": "JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); if (ser == null) { if (beanDesc.hasKnownClassAnnotations()) { return builder.createDummy(); } } return ser; } protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props)"
      },
      {
        "txt": "throws JsonMappingException { ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); if (objectIdInfo == null) { return null; } ObjectIdGenerator<?> gen; Class<?> implClass = objectIdInfo.getGeneratorType(); if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work String propName = objectIdInfo.getPropertyName().getSimpleName();"
      },
      {
        "txt": "BeanPropertyWriter idProp = null; for (int i = 0, len = props.size() ;; ++i) { if (i == len) { throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName() +\": can not find property with name '\"+propName+\"'\"); } BeanPropertyWriter prop = props.get(i); if (propName.equals(prop.getName())) { idProp = prop; if (i > 0) {"
      },
      {
        "txt": "props.remove(i); props.add(0, idProp); } break; } } JavaType idType = idProp.getType(); gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId()); }"
      },
      {
        "txt": "JavaType type = prov.constructType(implClass); JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); } protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews) { return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);"
      },
      {
        "txt": "} protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc) { return new PropertyBuilder(config, beanDesc); } protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) { return new BeanSerializerBuilder(beanDesc); } protected boolean isPotentialBeanType(Class<?> type)"
      },
      {
        "txt": "{ return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type); } protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { List<BeanPropertyDefinition> properties = beanDesc.findProperties(); final SerializationConfig config = prov.getConfig(); removeIgnorableTypes(config, beanDesc, properties);"
      },
      {
        "txt": "if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { removeSetterlessGetters(config, beanDesc, properties); } if (properties.isEmpty()) { return null; } boolean staticTyping = usesStaticTyping(config, beanDesc, null); PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); TypeBindings typeBind = beanDesc.bindingsForBeanType();"
      },
      {
        "txt": "for (BeanPropertyDefinition property : properties) { final AnnotatedMember accessor = property.getAccessor(); if (property.isTypeId()) { if (accessor != null) { // only add if we can access... but otherwise? if (config.canOverrideAccessModifiers()) { accessor.fixAccess(); } builder.setTypeId(accessor); } continue;"
      },
      {
        "txt": "} AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); if (refType != null && refType.isBackReference()) { continue; } if (accessor instanceof AnnotatedMethod) { result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); } else { result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); }"
      },
      {
        "txt": "} return result; } protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); AnnotatedClass ac = beanDesc.getClassInfo(); String[] ignored = intr.findPropertiesToIgnore(ac, true); if (ignored != null && ignored.length > 0) {"
      },
      {
        "txt": "HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored); Iterator<BeanPropertyWriter> it = props.iterator(); while (it.hasNext()) { if (ignoredSet.contains(it.next().getName())) { it.remove(); } } } return props; }"
      },
      {
        "txt": "protected void processViews(SerializationConfig config, BeanSerializerBuilder builder) { List<BeanPropertyWriter> props = builder.getProperties(); boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION); final int propCount = props.size(); int viewsFound = 0; BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount]; for (int i = 0; i < propCount; ++i) { BeanPropertyWriter bpw = props.get(i); Class<?>[] views = bpw.getViews();"
      },
      {
        "txt": "if (views == null) { // no view info? include or exclude by default? if (includeByDefault) { filtered[i] = bpw; } } else { ++viewsFound; filtered[i] = constructFilteredBeanWriter(bpw, views); } } if (includeByDefault && viewsFound == 0) {"
      },
      {
        "txt": "return; } builder.setFilteredProperties(filtered); } protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { AnnotationIntrospector intr = config.getAnnotationIntrospector(); HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>(); Iterator<BeanPropertyDefinition> it = properties.iterator();"
      },
      {
        "txt": "while (it.hasNext()) { BeanPropertyDefinition property = it.next(); AnnotatedMember accessor = property.getAccessor(); if (accessor == null) { it.remove(); continue; } Class<?> type = accessor.getRawType(); Boolean result = ignores.get(type); if (result == null) {"
      },
      {
        "txt": "BeanDescription desc = config.introspectClassAnnotations(type); AnnotatedClass ac = desc.getClassInfo(); result = intr.isIgnorableType(ac); if (result == null) { result = Boolean.FALSE; } ignores.put(type, result); } if (result.booleanValue()) { it.remove();"
      },
      {
        "txt": "} } } protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { Iterator<BeanPropertyDefinition> it = properties.iterator(); while (it.hasNext()) { BeanPropertyDefinition property = it.next(); if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {"
      },
      {
        "txt": "it.remove(); } } } protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder, List<BeanPropertyWriter> props) { for (int i = 0, end = props.size(); i < end; ++i) { BeanPropertyWriter bpw = props.get(i);"
      },
      {
        "txt": "TypeSerializer td = bpw.getTypeSerializer(); if ((td == null) || (td.getTypeInclusion() != As.EXTERNAL_PROPERTY)) { continue; } String n = td.getPropertyName(); PropertyName typePropName = PropertyName.construct(n); for (BeanPropertyWriter w2 : props) { if ((w2 != bpw) && w2.wouldConflictWithName(typePropName)) { bpw.assignTypeSerializer(null); break;"
      },
      {
        "txt": "} } } return props; } protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException {"
      },
      {
        "txt": "final PropertyName name = propDef.getFullName(); if (prov.canOverrideAccessModifiers()) { accessor.fixAccess(); } JavaType type = accessor.getType(typeContext); BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(), pb.getClassAnnotations(), accessor, propDef.getMetadata()); JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov, accessor); if (annotatedSerializer instanceof ResolvableSerializer) {"
      },
      {
        "txt": "((ResolvableSerializer) annotatedSerializer).resolve(prov); } annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property); TypeSerializer contentTypeSer = null; if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) { contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor); } TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor); BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,"
      },
      {
        "txt": "typeSer, contentTypeSer, accessor, staticTyping); return pbw; }"
      }
    ]
  }
]