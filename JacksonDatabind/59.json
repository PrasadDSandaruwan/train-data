[
  {
    "id": 1573,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/JavaType.java",
    "start-bug-line": 140,
    "end-bug-line": 140,
    "bug": "",
    "fix": "public JavaType withHandlersFrom(JavaType src) { JavaType type = this; Object h = src.getTypeHandler(); if (h != _typeHandler) { type = type.withTypeHandler(h); } h = src.getValueHandler(); if (h != _valueHandler) { type = type.withValueHandler(h); } return type; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.lang.reflect.Modifier; import java.util.List; import com.fasterxml.jackson.core.type.ResolvedType; import com.fasterxml.jackson.databind.type.TypeBindings; import com.fasterxml.jackson.databind.type.TypeFactory; public abstract class JavaType extends ResolvedType implements java.io.Serializable, // 2.1 java.lang.reflect.Type // 2.2 {"
      },
      {
        "txt": "private static final long serialVersionUID = 1; protected final Class<?> _class; protected final int _hash; protected final Object _valueHandler; protected final Object _typeHandler; protected final boolean _asStatic; protected JavaType(Class<?> raw, int additionalHash, Object valueHandler, Object typeHandler, boolean asStatic) { _class = raw;"
      },
      {
        "txt": "_hash = raw.getName().hashCode() + additionalHash; _valueHandler = valueHandler; _typeHandler = typeHandler; _asStatic = asStatic; } protected JavaType(JavaType base) { _class = base._class; _hash = base._hash; _valueHandler = base._valueHandler;"
      },
      {
        "txt": "_asStatic = base._asStatic; } public abstract JavaType withTypeHandler(Object h); public abstract JavaType withContentTypeHandler(Object h); public abstract JavaType withValueHandler(Object h); public abstract JavaType withContentValueHandler(Object h); <extra_id_0> public abstract JavaType withContentType(JavaType contentType); public abstract JavaType withStaticTyping(); public abstract JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces); @Deprecated public JavaType forcedNarrowBy(Class<?> subclass)"
      },
      {
        "txt": "@Deprecated public JavaType forcedNarrowBy(Class<?> subclass) { if (subclass == _class) { // can still optimize for simple case return this; } JavaType result = _narrow(subclass); if (_valueHandler != result.<Object>getValueHandler()) { result = result.withValueHandler(_valueHandler); }"
      },
      {
        "txt": "if (_typeHandler != result.<Object>getTypeHandler()) { result = result.withTypeHandler(_typeHandler); } return result; } @Deprecated // since 2.7 protected abstract JavaType _narrow(Class<?> subclass); @Override public final Class<?> getRawClass() { return _class; } @Override"
      },
      {
        "txt": "public final boolean hasRawClass(Class<?> clz) { return _class == clz; } public boolean hasContentType() { return true; } public final boolean isTypeOrSubTypeOf(Class<?> clz) { return (_class == clz) || (clz.isAssignableFrom(_class)); } @Override public boolean isAbstract() { return Modifier.isAbstract(_class.getModifiers());"
      },
      {
        "txt": "} @Override public boolean isConcrete() { int mod = _class.getModifiers(); if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { return true; } return _class.isPrimitive(); } @Override"
      },
      {
        "txt": "public boolean isThrowable() { return Throwable.class.isAssignableFrom(_class); } @Override public boolean isArrayType() { return false; } @Override public final boolean isEnumType() { return _class.isEnum(); } @Override public final boolean isInterface() { return _class.isInterface(); } @Override public final boolean isPrimitive() { return _class.isPrimitive(); } @Override"
      },
      {
        "txt": "public final boolean isFinal() { return Modifier.isFinal(_class.getModifiers()); } @Override public abstract boolean isContainerType(); @Override public boolean isCollectionLikeType() { return false; } @Override public boolean isMapLikeType() { return false; } public final boolean isJavaLangObject() { return _class == Object.class; } public final boolean useStaticType() { return _asStatic; } @Override"
      },
      {
        "txt": "public boolean hasGenericTypes() { return containedTypeCount() > 0; } @Override public JavaType getKeyType() { return null; } @Override public JavaType getContentType() { return null; } @Override // since 2.6 public JavaType getReferencedType() { return null; } @Override public abstract int containedTypeCount(); @Override"
      },
      {
        "txt": "public abstract JavaType containedType(int index); @Deprecated // since 2.7 @Override public abstract String containedTypeName(int index); @Deprecated // since 2.7 @Override public Class<?> getParameterSource() { return null; } public JavaType containedTypeOrUnknown(int index) {"
      },
      {
        "txt": "JavaType t = containedType(index); return (t == null) ? TypeFactory.unknownType() : t; } public abstract TypeBindings getBindings(); public abstract JavaType findSuperType(Class<?> erasedTarget); public abstract JavaType getSuperClass(); public abstract List<JavaType> getInterfaces(); public abstract JavaType[] findTypeParameters(Class<?> expType); @SuppressWarnings(\"unchecked\") public <T> T getValueHandler() { return (T) _valueHandler; }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T getTypeHandler() { return (T) _typeHandler; } public Object getContentValueHandler() { return null; } public Object getContentTypeHandler() { return null; } public boolean hasValueHandler() { return _valueHandler != null; } public boolean hasHandlers() { return (_typeHandler != null) || (_valueHandler != null); } public String getGenericSignature() { StringBuilder sb = new StringBuilder(40);"
      },
      {
        "txt": "getGenericSignature(sb); return sb.toString(); } public abstract StringBuilder getGenericSignature(StringBuilder sb); public String getErasedSignature() { StringBuilder sb = new StringBuilder(40); getErasedSignature(sb); return sb.toString(); } public abstract StringBuilder getErasedSignature(StringBuilder sb);"
      },
      {
        "txt": "@Override public abstract String toString(); @Override public abstract boolean equals(Object o); @Override public final int hashCode() { return _hash; }"
      }
    ]
  },
  {
    "id": 1574,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java",
    "start-bug-line": 136,
    "end-bug-line": 136,
    "bug": "",
    "fix": "@Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _elementType.withHandlersFrom(srcCt); if (ct != _elementType) { type = type.withContentType(ct); } } return type; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.TypeVariable; import java.util.Collection; import com.fasterxml.jackson.databind.JavaType; public class CollectionLikeType extends TypeBase {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; protected final JavaType _elementType; protected CollectionLikeType(Class<?> collT, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) { super(collT, bindings, superClass, superInts, elemT.hashCode(), valueHandler, typeHandler, asStatic); _elementType = elemT; }"
      },
      {
        "txt": "protected CollectionLikeType(TypeBase base, JavaType elemT) { super(base); _elementType = elemT; } public static CollectionLikeType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT) { return new CollectionLikeType(rawType, bindings, superClass, superInts, elemT, null, null, false); }"
      },
      {
        "txt": "@Deprecated // since 2.7 public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) { TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 1)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, elemT); } return new CollectionLikeType(rawType, bindings,"
      },
      {
        "txt": "_bogusSuperClass(rawType), null, elemT, null, null, false); } public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType) { if (baseType instanceof TypeBase) { return new CollectionLikeType((TypeBase) baseType, elementType); } throw new IllegalArgumentException(\"Can not upgrade from an instance of \"+baseType.getClass()); } @Override"
      },
      {
        "txt": "@Deprecated // since 2.7 protected JavaType _narrow(Class<?> subclass) { return new CollectionLikeType(subclass, _bindings, _superClass, _superInterfaces, _elementType, _valueHandler, _typeHandler, _asStatic); } @Override public JavaType withContentType(JavaType contentType) { if (_elementType == contentType) { return this;"
      },
      {
        "txt": "} return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, contentType, _valueHandler, _typeHandler, _asStatic); } @Override public CollectionLikeType withTypeHandler(Object h) { return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic); } @Override"
      },
      {
        "txt": "public CollectionLikeType withContentTypeHandler(Object h) { return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, _elementType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic); } @Override public CollectionLikeType withValueHandler(Object h) { return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);"
      },
      {
        "txt": "@Override public CollectionLikeType withContentValueHandler(Object h) { return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, _elementType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic); } <extra_id_0> @Override public CollectionLikeType withStaticTyping() { if (_asStatic) { return this; } return new CollectionLikeType(_class, _bindings,"
      },
      {
        "txt": "} return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, _elementType.withStaticTyping(), _valueHandler, _typeHandler, true); } @Override public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new CollectionLikeType(rawType, bindings, superClass, superInterfaces, _elementType,"
      },
      {
        "txt": "_valueHandler, _typeHandler, _asStatic); } @Override public boolean isContainerType() { return true; } @Override public boolean isCollectionLikeType() { return true; } @Override public JavaType getContentType() { return _elementType; } @Override public Object getContentValueHandler() {"
      },
      {
        "txt": "return _elementType.getValueHandler(); } @Override public Object getContentTypeHandler() { return _elementType.getTypeHandler(); } @Override public boolean hasHandlers() { return super.hasHandlers() || _elementType.hasHandlers(); }"
      },
      {
        "txt": "@Override public StringBuilder getErasedSignature(StringBuilder sb) { return _classSignature(_class, sb, true); } @Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); _elementType.getGenericSignature(sb); sb.append(\">;\");"
      },
      {
        "txt": "return sb; } @Override protected String buildCanonicalName() { StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); if (_elementType != null) { sb.append('<'); sb.append(_elementType.toCanonical()); sb.append('>');"
      },
      {
        "txt": "} return sb.toString(); } public boolean isTrueCollectionType() { return Collection.class.isAssignableFrom(_class); } @Override public boolean equals(Object o) { if (o == this) return true;"
      },
      {
        "txt": "if (o == null) return false; if (o.getClass() != getClass()) return false; CollectionLikeType other = (CollectionLikeType) o; return (_class == other._class) && _elementType.equals(other._elementType); } @Override public String toString() { return \"[collection-like type; class \"+_class.getName()+\", contains \"+_elementType+\"]\"; }"
      }
    ]
  },
  {
    "id": 1575,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java",
    "start-bug-line": 148,
    "end-bug-line": 148,
    "bug": "",
    "fix": "@Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcKeyType = src.getKeyType();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.TypeVariable; import java.util.*; import com.fasterxml.jackson.databind.JavaType;"
      },
      {
        "txt": "public class MapLikeType extends TypeBase { private static final long serialVersionUID = 1L; protected final JavaType _keyType; protected final JavaType _valueType; protected MapLikeType(Class<?> mapType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) { super(mapType, bindings, superClass, superInts, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);"
      },
      {
        "txt": "_keyType = keyT; _valueType = valueT; } protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT) { super(base); _keyType = keyT; _valueType = valueT; } public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT) {"
      },
      {
        "txt": "if (baseType instanceof TypeBase) { return new MapLikeType((TypeBase) baseType, keyT, valueT); } throw new IllegalArgumentException( \"Can not upgrade from an instance of \" + baseType.getClass()); } @Deprecated public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT) { TypeVariable<?>[] vars = rawType.getTypeParameters();"
      },
      {
        "txt": "TypeBindings bindings; if ((vars == null) || (vars.length != 2)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, keyT, valueT); } return new MapLikeType(rawType, bindings, _bogusSuperClass(rawType), null, keyT, valueT, null, null, false); } @Deprecated"
      },
      {
        "txt": "@Override protected JavaType _narrow(Class<?> subclass) { return new MapLikeType(subclass, _bindings, _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic); } public MapLikeType withKeyType(JavaType keyType) { if (keyType == _keyType) { return this; }"
      },
      {
        "txt": "return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, keyType, _valueType, _valueHandler, _typeHandler, _asStatic); } @Override public JavaType withContentType(JavaType contentType) { if (_valueType == contentType) { return this; } return new MapLikeType(_class, _bindings, _superClass,"
      },
      {
        "txt": "_superInterfaces, _keyType, contentType, _valueHandler, _typeHandler, _asStatic); } @Override public MapLikeType withTypeHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic); } @Override"
      },
      {
        "txt": "public MapLikeType withContentTypeHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic); } @Override public MapLikeType withValueHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);"
      },
      {
        "txt": "@Override public MapLikeType withContentValueHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic); } <extra_id_0> @Override public MapLikeType withStaticTyping() { if (_asStatic) { return this; } return new MapLikeType(_class, _bindings, _superClass,"
      },
      {
        "txt": "} return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType.withStaticTyping(), _valueHandler, _typeHandler, true); } @Override public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new MapLikeType(rawType, bindings, superClass, superInterfaces, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);"
      },
      {
        "txt": "} @Override protected String buildCanonicalName() { StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); if (_keyType != null) { sb.append('<'); sb.append(_keyType.toCanonical()); sb.append(','); sb.append(_valueType.toCanonical());"
      },
      {
        "txt": "sb.append('>'); } return sb.toString(); } @Override public boolean isContainerType() { return true; } @Override public boolean isMapLikeType() {"
      },
      {
        "txt": "return true; } @Override public JavaType getKeyType() { return _keyType; } @Override public JavaType getContentType() { return _valueType; }"
      },
      {
        "txt": "@Override public Object getContentValueHandler() { return _valueType.getValueHandler(); } @Override public Object getContentTypeHandler() { return _valueType.getTypeHandler(); } @Override public boolean hasHandlers() {"
      },
      {
        "txt": "return super.hasHandlers() || _valueType.hasHandlers() || _keyType.hasHandlers(); } @Override public StringBuilder getErasedSignature(StringBuilder sb) { return _classSignature(_class, sb, true); } @Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false);"
      },
      {
        "txt": "sb.append('<'); _keyType.getGenericSignature(sb); _valueType.getGenericSignature(sb); sb.append(\">;\"); return sb; } public MapLikeType withKeyTypeHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType, _valueHandler, _typeHandler, _asStatic);"
      },
      {
        "txt": "} public MapLikeType withKeyValueHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType, _valueHandler, _typeHandler, _asStatic); } public boolean isTrueMapType() { return Map.class.isAssignableFrom(_class); } @Override"
      },
      {
        "txt": "public String toString() { return String.format(\"[map-like type; class %s, %s -> %s]\", _class.getName(), _keyType, _valueType); } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != getClass()) return false; MapLikeType other = (MapLikeType) o;"
      },
      {
        "txt": "return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); }"
      }
    ]
  },
  {
    "id": 1576,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java",
    "start-bug-line": 149,
    "end-bug-line": 149,
    "bug": "",
    "fix": "if (type instanceof MapLikeType) { if (srcKeyType != null) { JavaType ct = _keyType.withHandlersFrom(srcKeyType); if (ct != _keyType) { type = ((MapLikeType) type).withKeyType(ct); } } } JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _valueType.withHandlersFrom(srcCt); if (ct != _valueType) { type = type.withContentType(ct); } } return type; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.lang.reflect.TypeVariable; import java.util.*; import com.fasterxml.jackson.databind.JavaType;"
      },
      {
        "txt": "public class MapLikeType extends TypeBase { private static final long serialVersionUID = 1L; protected final JavaType _keyType; protected final JavaType _valueType; protected MapLikeType(Class<?> mapType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) { super(mapType, bindings, superClass, superInts, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);"
      },
      {
        "txt": "_keyType = keyT; _valueType = valueT; } protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT) { super(base); _keyType = keyT; _valueType = valueT; } public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT) {"
      },
      {
        "txt": "if (baseType instanceof TypeBase) { return new MapLikeType((TypeBase) baseType, keyT, valueT); } throw new IllegalArgumentException( \"Can not upgrade from an instance of \" + baseType.getClass()); } @Deprecated public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT) { TypeVariable<?>[] vars = rawType.getTypeParameters();"
      },
      {
        "txt": "TypeBindings bindings; if ((vars == null) || (vars.length != 2)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, keyT, valueT); } return new MapLikeType(rawType, bindings, _bogusSuperClass(rawType), null, keyT, valueT, null, null, false); } @Deprecated"
      },
      {
        "txt": "@Override protected JavaType _narrow(Class<?> subclass) { return new MapLikeType(subclass, _bindings, _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic); } public MapLikeType withKeyType(JavaType keyType) { if (keyType == _keyType) { return this; }"
      },
      {
        "txt": "return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, keyType, _valueType, _valueHandler, _typeHandler, _asStatic); } @Override public JavaType withContentType(JavaType contentType) { if (_valueType == contentType) { return this; } return new MapLikeType(_class, _bindings, _superClass,"
      },
      {
        "txt": "_superInterfaces, _keyType, contentType, _valueHandler, _typeHandler, _asStatic); } @Override public MapLikeType withTypeHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic); } @Override"
      },
      {
        "txt": "public MapLikeType withContentTypeHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic); } @Override public MapLikeType withValueHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);"
      },
      {
        "txt": "@Override public MapLikeType withContentValueHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic); } <extra_id_0> @Override public MapLikeType withStaticTyping() { if (_asStatic) { return this; } return new MapLikeType(_class, _bindings, _superClass,"
      },
      {
        "txt": "} return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType, _valueType.withStaticTyping(), _valueHandler, _typeHandler, true); } @Override public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new MapLikeType(rawType, bindings, superClass, superInterfaces, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);"
      },
      {
        "txt": "} @Override protected String buildCanonicalName() { StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); if (_keyType != null) { sb.append('<'); sb.append(_keyType.toCanonical()); sb.append(','); sb.append(_valueType.toCanonical());"
      },
      {
        "txt": "sb.append('>'); } return sb.toString(); } @Override public boolean isContainerType() { return true; } @Override public boolean isMapLikeType() {"
      },
      {
        "txt": "return true; } @Override public JavaType getKeyType() { return _keyType; } @Override public JavaType getContentType() { return _valueType; }"
      },
      {
        "txt": "@Override public Object getContentValueHandler() { return _valueType.getValueHandler(); } @Override public Object getContentTypeHandler() { return _valueType.getTypeHandler(); } @Override public boolean hasHandlers() {"
      },
      {
        "txt": "return super.hasHandlers() || _valueType.hasHandlers() || _keyType.hasHandlers(); } @Override public StringBuilder getErasedSignature(StringBuilder sb) { return _classSignature(_class, sb, true); } @Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false);"
      },
      {
        "txt": "sb.append('<'); _keyType.getGenericSignature(sb); _valueType.getGenericSignature(sb); sb.append(\">;\"); return sb; } public MapLikeType withKeyTypeHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType, _valueHandler, _typeHandler, _asStatic);"
      },
      {
        "txt": "} public MapLikeType withKeyValueHandler(Object h) { return new MapLikeType(_class, _bindings, _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType, _valueHandler, _typeHandler, _asStatic); } public boolean isTrueMapType() { return Map.class.isAssignableFrom(_class); } @Override"
      },
      {
        "txt": "public String toString() { return String.format(\"[map-like type; class %s, %s -> %s]\", _class.getName(), _keyType, _valueType); } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != getClass()) return false; MapLikeType other = (MapLikeType) o;"
      },
      {
        "txt": "return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); }"
      }
    ]
  },
  {
    "id": 1577,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 428,
    "end-bug-line": 428,
    "bug": "",
    "fix": "newType = newType.withHandlersFrom(baseType);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" })"
      },
      {
        "txt": "public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class;"
      },
      {
        "txt": "private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Object,JavaType> _typeCache; protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { this(null); }"
      },
      {
        "txt": "protected TypeFactory(LRUMap<Object,JavaType> typeCache) { if (typeCache == null) { typeCache = new LRUMap<Object,JavaType>(16, 200); } _typeCache = typeCache; _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(LRUMap<Object,JavaType> typeCache, TypeParser p,"
      },
      {
        "txt": "TypeModifier[] mods, ClassLoader classLoader) { if (typeCache == null) { typeCache = new LRUMap<Object,JavaType>(16, 200); } _typeCache = typeCache; _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; }"
      },
      {
        "txt": "public TypeFactory withModifier(TypeModifier mod) { LRUMap<Object,JavaType> typeCache = _typeCache; TypeModifier[] mods; if (mod == null) { // mostly for unit tests mods = null; typeCache = null; } else if (_modifiers == null) { mods = new TypeModifier[] { mod }; } else {"
      },
      {
        "txt": "mods = ArrayBuilders.insertInListNoDup(_modifiers, mod); } return new TypeFactory(typeCache, _parser, mods, _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_typeCache, _parser, _modifiers, classLoader); } public TypeFactory withCache(LRUMap<Object,JavaType> cache) { return new TypeFactory(cache, _parser, _modifiers, _classLoader); }"
      },
      {
        "txt": "public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); }"
      },
      {
        "txt": "public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className);"
      },
      {
        "txt": "if (prim != null) { return prim; } } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) {"
      },
      {
        "txt": "try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) {"
      },
      {
        "txt": "prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {"
      },
      {
        "txt": "return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE;"
      },
      {
        "txt": "if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {"
      },
      {
        "txt": "final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; }"
      },
      {
        "txt": "if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) {"
      },
      {
        "txt": "if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class)"
      },
      {
        "txt": "|| (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; }"
      },
      {
        "txt": "} } int typeParamCount = subclass.getTypeParameters().length; if (typeParamCount == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass); if (baseType.isInterface()) { newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });"
      },
      {
        "txt": "newType = baseType.refine(subclass, tb, baseType, NO_TYPES); } if (newType == null) { newType = _fromClass(null, subclass, tb); } } while (false); <extra_id_0> if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);"
      },
      {
        "txt": "if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) {"
      },
      {
        "txt": "subtype = subtype.withTypeHandler(h); } return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) {"
      },
      {
        "txt": "return baseType; } JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) {"
      },
      {
        "txt": "int baseCount = baseType.containedTypeCount(); if (baseCount == typeParamCount) { if (typeParamCount == 1) { return TypeBindings.create(subclass, baseType.containedType(0)); } if (typeParamCount == 2) { return TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } List<JavaType> types = new ArrayList<JavaType>(baseCount);"
      },
      {
        "txt": "for (int i = 0; i < baseCount; ++i) { types.add(baseType.containedType(i)); } return TypeBindings.create(subclass, types); } return TypeBindings.emptyBindings(); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass();"
      },
      {
        "txt": "if (rawBase == superClass) { return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format("
      },
      {
        "txt": "\"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType)"
      },
      {
        "txt": "{ JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType);"
      },
      {
        "txt": "} @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; }"
      },
      {
        "txt": "if (type2 == null) { return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2;"
      },
      {
        "txt": "} return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef)"
      },
      {
        "txt": "{ return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray();"
      },
      {
        "txt": "if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings);"
      },
      {
        "txt": "} @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); }"
      },
      {
        "txt": "public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType));"
      },
      {
        "txt": "} public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type;"
      },
      {
        "txt": "} return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS);"
      },
      {
        "txt": "} return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {"
      },
      {
        "txt": "return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; }"
      },
      {
        "txt": "return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes);"
      },
      {
        "txt": "} public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } @Deprecated // since 2.8 public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null);"
      },
      {
        "txt": "} public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)"
      },
      {
        "txt": "{ return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)"
      },
      {
        "txt": "{ return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) {"
      },
      {
        "txt": "return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) {"
      },
      {
        "txt": "kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1);"
      },
      {
        "txt": "break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);"
      },
      {
        "txt": "} private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0);"
      },
      {
        "txt": "} else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw);"
      },
      {
        "txt": "if (result != null) { return result; } } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "} protected JavaType _unknownType() { return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else {"
      },
      {
        "txt": "if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);"
      },
      {
        "txt": "} else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); }"
      },
      {
        "txt": "else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null) { TypeBindings b = resultType.getBindings();"
      },
      {
        "txt": "if (b == null) { b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) { JavaType t = mod.modifyType(resultType, type, b, this); if (t == null) { throw new IllegalStateException(String.format( \"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType)); }"
      },
      {
        "txt": "resultType = t; } } return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result;"
      },
      {
        "txt": "} final Object key; if ((bindings == null) || bindings.isEmpty()) { key = rawType; } else { key = bindings.asKey(rawType); } result = _typeCache.get(key); // ok, cache object is synced if (result != null) { return result;"
      },
      {
        "txt": "} if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; }"
      },
      {
        "txt": "context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null;"
      },
      {
        "txt": "superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) {"
      },
      {
        "txt": "result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } }"
      },
      {
        "txt": "} } context.resolveSelfReferences(result); if (!result.hasHandlers()) { _typeCache.putIfAbsent(key, result); // cache object syncs } return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {"
      },
      {
        "txt": "Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) {"
      },
      {
        "txt": "return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; }"
      },
      {
        "txt": "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings == null) { bindings = TypeBindings.emptyBindings(); } if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) {"
      },
      {
        "txt": "return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {"
      },
      {
        "txt": "final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,"
      },
      {
        "txt": "TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) {"
      },
      {
        "txt": "return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount];"
      },
      {
        "txt": "for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);"
      },
      {
        "txt": "return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; } if (bindings.hasUnbound(name)) {"
      },
      {
        "txt": "return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  }
]