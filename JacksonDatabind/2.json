[
  {
    "id": 1305,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 783,
    "end-bug-line": 783,
    "bug": "",
    "fix": "if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed;"
      },
      {
        "txt": "protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext;"
      },
      {
        "txt": "@Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment();"
      },
      {
        "txt": "_appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser jp) { _objectCodec = jp.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = jp.canReadTypeId(); _hasNativeObjectIds = jp.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) {"
      },
      {
        "txt": "Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); }"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser jp = other.asParser(); while (jp.nextToken() != null) { copyCurrentStructure(jp); } return this; } public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds());"
      },
      {
        "txt": "} JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { jgen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) {"
      },
      {
        "txt": "jgen.writeTypeId(id); } } switch (t) { case START_OBJECT: jgen.writeStartObject(); break; case END_OBJECT: jgen.writeEndObject(); break;"
      },
      {
        "txt": "case START_ARRAY: jgen.writeStartArray(); break; case END_ARRAY: jgen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "jgen.writeFieldName((SerializableString) ob); } else { jgen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "jgen.writeString((SerializableString) ob); } else { jgen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) {"
      },
      {
        "txt": "jgen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { jgen.writeNumber((BigInteger) n); } else if (n instanceof Long) { jgen.writeNumber((Long) n); } else if (n instanceof Short) { jgen.writeNumber((Short) n); } else { jgen.writeNumber(((Number) n).intValue()); }"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { jgen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { jgen.writeNumber((BigDecimal) n); } else if (n instanceof Float) {"
      },
      {
        "txt": "jgen.writeNumber(((Float) n).floatValue()); } else if (n == null) { jgen.writeNull(); } else if (n instanceof String) { jgen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break;"
      },
      {
        "txt": "case VALUE_TRUE: jgen.writeBoolean(true); break; case VALUE_FALSE: jgen.writeBoolean(false); break; case VALUE_NULL: jgen.writeNull(); break; case VALUE_EMBEDDED_OBJECT:"
      },
      {
        "txt": "jgen.writeObject(segment.get(ptr)); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "copyCurrentStructure(jp); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \");"
      },
      {
        "txt": "sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break;"
      },
      {
        "txt": "if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('(');"
      },
      {
        "txt": "sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) {"
      },
      {
        "txt": "sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');"
      },
      {
        "txt": "} Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this;"
      },
      {
        "txt": "} @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; }"
      },
      {
        "txt": "@Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override"
      },
      {
        "txt": "public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; }"
      },
      {
        "txt": "@Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException {"
      },
      {
        "txt": "_closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException, JsonGenerationException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext();"
      },
      {
        "txt": "} @Override public final void writeEndArray() throws IOException, JsonGenerationException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; }"
      },
      {
        "txt": "} @Override public final void writeStartObject() throws IOException, JsonGenerationException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject()"
      },
      {
        "txt": "throws IOException, JsonGenerationException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException,JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException, JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char c) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeNumber(short i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); }"
      },
      {
        "txt": "@Override public void writeNumber(int i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException,JsonGenerationException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException { if (dec == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v);"
      },
      {
        "txt": "} } @Override public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException,JsonGenerationException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); }"
      },
      {
        "txt": "public void writeNull() throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { <extra_id_0> } @Override public void writeTree(TreeNode node) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); }"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); }"
      },
      {
        "txt": "@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id;"
      },
      {
        "txt": "_hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (jp.getCurrentToken()) { case START_OBJECT:"
      },
      {
        "txt": "writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray();"
      },
      {
        "txt": "break; case FIELD_NAME: writeFieldName(jp.getCurrentName()); break; case VALUE_STRING: if (jp.hasTextCharacters()) { writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); } else { writeString(jp.getText()); }"
      },
      {
        "txt": "break; case VALUE_NUMBER_INT: switch (jp.getNumberType()) { case INT: writeNumber(jp.getIntValue()); break; case BIG_INTEGER: writeNumber(jp.getBigIntegerValue()); break; default:"
      },
      {
        "txt": "writeNumber(jp.getLongValue()); } break; case VALUE_NUMBER_FLOAT: switch (jp.getNumberType()) { case BIG_DECIMAL: writeNumber(jp.getDecimalValue()); break; case FLOAT: writeNumber(jp.getFloatValue());"
      },
      {
        "txt": "break; default: writeNumber(jp.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(jp.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} @Override public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName());"
      },
      {
        "txt": "t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break;"
      },
      {
        "txt": "default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override"
      },
      {
        "txt": "protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds;"
      },
      {
        "txt": "protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; @Deprecated // since 2.3 protected Parser(Segment firstSeg, ObjectCodec codec) { this(firstSeg, codec, false, false); }"
      },
      {
        "txt": "public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds;"
      },
      {
        "txt": "_hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; }"
      },
      {
        "txt": "@Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException, JsonParseException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true;"
      },
      {
        "txt": "} } @Override public JsonToken nextToken() throws IOException, JsonParseException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) {"
      },
      {
        "txt": "return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location;"
      },
      {
        "txt": "} @Override public String getCurrentName() { return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); }"
      },
      {
        "txt": "try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING"
      },
      {
        "txt": "|| _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; }"
      },
      {
        "txt": "switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override"
      },
      {
        "txt": "public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigInteger) {"
      },
      {
        "txt": "return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n);"
      },
      {
        "txt": "default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException, JsonParseException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); }"
      },
      {
        "txt": "@Override public long getLongValue() throws IOException, JsonParseException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG;"
      },
      {
        "txt": "if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException, JsonParseException { _checkIsNumber();"
      },
      {
        "txt": "Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str);"
      },
      {
        "txt": "} if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {"
      },
      {
        "txt": "Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) {"
      },
      {
        "txt": "return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray();"
      },
      {
        "txt": "} @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; }"
      },
      {
        "txt": "return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; }"
      },
      {
        "txt": "@Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr);"
      },
      {
        "txt": "} protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal();"
      },
      {
        "txt": "} } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));"
      },
      {
        "txt": "} protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) {"
      },
      {
        "txt": "l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2);"
      },
      {
        "txt": "} int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId);"
      },
      {
        "txt": "return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value);"
      },
      {
        "txt": "return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "} private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) {"
      },
      {
        "txt": "_nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; }"
      },
      {
        "txt": "private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1306,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 784,
    "end-bug-line": 784,
    "bug": "",
    "fix": "return; } else if (_objectCodec == null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds;"
      },
      {
        "txt": "protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated"
      },
      {
        "txt": "public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser jp) { _objectCodec = jp.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment();"
      },
      {
        "txt": "_appendAt = 0; _hasNativeTypeIds = jp.canReadTypeId(); _hasNativeObjectIds = jp.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser()"
      },
      {
        "txt": "{ return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);"
      },
      {
        "txt": "p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser jp = other.asParser(); while (jp.nextToken() != null) { copyCurrentStructure(jp); } return this; } public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { Segment segment = _first;"
      },
      {
        "txt": "int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); }"
      },
      {
        "txt": "JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { jgen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { jgen.writeTypeId(id);"
      },
      {
        "txt": "} } switch (t) { case START_OBJECT: jgen.writeStartObject(); break; case END_OBJECT: jgen.writeEndObject(); break; case START_ARRAY:"
      },
      {
        "txt": "jgen.writeStartArray(); break; case END_ARRAY: jgen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeFieldName((SerializableString) ob);"
      },
      {
        "txt": "} else { jgen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeString((SerializableString) ob);"
      },
      {
        "txt": "} else { jgen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { jgen.writeNumber((Integer) n);"
      },
      {
        "txt": "} else if (n instanceof BigInteger) { jgen.writeNumber((BigInteger) n); } else if (n instanceof Long) { jgen.writeNumber((Long) n); } else if (n instanceof Short) { jgen.writeNumber((Short) n); } else { jgen.writeNumber(((Number) n).intValue()); } }"
      },
      {
        "txt": "break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { jgen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { jgen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { jgen.writeNumber(((Float) n).floatValue());"
      },
      {
        "txt": "} else if (n == null) { jgen.writeNull(); } else if (n instanceof String) { jgen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE:"
      },
      {
        "txt": "jgen.writeBoolean(true); break; case VALUE_FALSE: jgen.writeBoolean(false); break; case VALUE_NULL: jgen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: jgen.writeObject(segment.get(ptr));"
      },
      {
        "txt": "break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { copyCurrentStructure(jp);"
      },
      {
        "txt": "return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");"
      },
      {
        "txt": "sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) {"
      },
      {
        "txt": "_appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName());"
      },
      {
        "txt": "sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");"
      },
      {
        "txt": "} sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); }"
      },
      {
        "txt": "Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; }"
      },
      {
        "txt": "@Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override"
      },
      {
        "txt": "public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() {"
      },
      {
        "txt": "return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override"
      },
      {
        "txt": "public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException, JsonGenerationException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); }"
      },
      {
        "txt": "@Override public final void writeEndArray() throws IOException, JsonGenerationException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeStartObject() throws IOException, JsonGenerationException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue());"
      },
      {
        "txt": "} @Override public void writeString(String text) throws IOException,JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override"
      },
      {
        "txt": "public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException, JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); }"
      },
      {
        "txt": "} @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(char c) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeNumber(short i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(int i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException,JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));"
      },
      {
        "txt": "} @Override public void writeNumber(float f) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException { if (dec == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); }"
      },
      {
        "txt": "} @Override public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException,JsonGenerationException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override"
      },
      {
        "txt": "_append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); <extra_id_0> } @Override public void writeTree(TreeNode node) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); }"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); }"
      },
      {
        "txt": "@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id;"
      },
      {
        "txt": "_hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (jp.getCurrentToken()) { case START_OBJECT:"
      },
      {
        "txt": "writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray();"
      },
      {
        "txt": "break; case FIELD_NAME: writeFieldName(jp.getCurrentName()); break; case VALUE_STRING: if (jp.hasTextCharacters()) { writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); } else { writeString(jp.getText()); }"
      },
      {
        "txt": "break; case VALUE_NUMBER_INT: switch (jp.getNumberType()) { case INT: writeNumber(jp.getIntValue()); break; case BIG_INTEGER: writeNumber(jp.getBigIntegerValue()); break; default:"
      },
      {
        "txt": "writeNumber(jp.getLongValue()); } break; case VALUE_NUMBER_FLOAT: switch (jp.getNumberType()) { case BIG_DECIMAL: writeNumber(jp.getDecimalValue()); break; case FLOAT: writeNumber(jp.getFloatValue());"
      },
      {
        "txt": "break; default: writeNumber(jp.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(jp.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} @Override public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName());"
      },
      {
        "txt": "t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break;"
      },
      {
        "txt": "default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override"
      },
      {
        "txt": "protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds;"
      },
      {
        "txt": "protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; @Deprecated // since 2.3 protected Parser(Segment firstSeg, ObjectCodec codec) { this(firstSeg, codec, false, false); }"
      },
      {
        "txt": "public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds;"
      },
      {
        "txt": "_hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; }"
      },
      {
        "txt": "@Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException, JsonParseException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true;"
      },
      {
        "txt": "} } @Override public JsonToken nextToken() throws IOException, JsonParseException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) {"
      },
      {
        "txt": "return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location;"
      },
      {
        "txt": "} @Override public String getCurrentName() { return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); }"
      },
      {
        "txt": "try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING"
      },
      {
        "txt": "|| _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; }"
      },
      {
        "txt": "switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override"
      },
      {
        "txt": "public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigInteger) {"
      },
      {
        "txt": "return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n);"
      },
      {
        "txt": "default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException, JsonParseException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); }"
      },
      {
        "txt": "@Override public long getLongValue() throws IOException, JsonParseException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG;"
      },
      {
        "txt": "if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException, JsonParseException { _checkIsNumber();"
      },
      {
        "txt": "Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str);"
      },
      {
        "txt": "} if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {"
      },
      {
        "txt": "Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) {"
      },
      {
        "txt": "return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray();"
      },
      {
        "txt": "} @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; }"
      },
      {
        "txt": "return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; }"
      },
      {
        "txt": "@Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr);"
      },
      {
        "txt": "} protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal();"
      },
      {
        "txt": "} } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));"
      },
      {
        "txt": "} protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) {"
      },
      {
        "txt": "l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2);"
      },
      {
        "txt": "} int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId);"
      },
      {
        "txt": "return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value);"
      },
      {
        "txt": "return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "} private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) {"
      },
      {
        "txt": "_nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; }"
      },
      {
        "txt": "private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1307,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 788,
    "end-bug-line": 788,
    "bug": "",
    "fix": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds;"
      },
      {
        "txt": "protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated"
      },
      {
        "txt": "public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser jp) { _objectCodec = jp.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment();"
      },
      {
        "txt": "_appendAt = 0; _hasNativeTypeIds = jp.canReadTypeId(); _hasNativeObjectIds = jp.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser()"
      },
      {
        "txt": "{ return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);"
      },
      {
        "txt": "p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser jp = other.asParser(); while (jp.nextToken() != null) { copyCurrentStructure(jp); } return this; } public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { Segment segment = _first;"
      },
      {
        "txt": "int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); }"
      },
      {
        "txt": "JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { jgen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { jgen.writeTypeId(id);"
      },
      {
        "txt": "} } switch (t) { case START_OBJECT: jgen.writeStartObject(); break; case END_OBJECT: jgen.writeEndObject(); break; case START_ARRAY:"
      },
      {
        "txt": "jgen.writeStartArray(); break; case END_ARRAY: jgen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeFieldName((SerializableString) ob);"
      },
      {
        "txt": "} else { jgen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeString((SerializableString) ob);"
      },
      {
        "txt": "} else { jgen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { jgen.writeNumber((Integer) n);"
      },
      {
        "txt": "} else if (n instanceof BigInteger) { jgen.writeNumber((BigInteger) n); } else if (n instanceof Long) { jgen.writeNumber((Long) n); } else if (n instanceof Short) { jgen.writeNumber((Short) n); } else { jgen.writeNumber(((Number) n).intValue()); } }"
      },
      {
        "txt": "break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { jgen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { jgen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { jgen.writeNumber(((Float) n).floatValue());"
      },
      {
        "txt": "} else if (n == null) { jgen.writeNull(); } else if (n instanceof String) { jgen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE:"
      },
      {
        "txt": "jgen.writeBoolean(true); break; case VALUE_FALSE: jgen.writeBoolean(false); break; case VALUE_NULL: jgen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: jgen.writeObject(segment.get(ptr));"
      },
      {
        "txt": "break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { copyCurrentStructure(jp);"
      },
      {
        "txt": "return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");"
      },
      {
        "txt": "sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) {"
      },
      {
        "txt": "_appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName());"
      },
      {
        "txt": "sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");"
      },
      {
        "txt": "} sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); }"
      },
      {
        "txt": "Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; }"
      },
      {
        "txt": "@Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override"
      },
      {
        "txt": "public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() {"
      },
      {
        "txt": "return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override"
      },
      {
        "txt": "public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException, JsonGenerationException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); }"
      },
      {
        "txt": "@Override public final void writeEndArray() throws IOException, JsonGenerationException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeStartObject() throws IOException, JsonGenerationException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue());"
      },
      {
        "txt": "} @Override public void writeString(String text) throws IOException,JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override"
      },
      {
        "txt": "public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException, JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); }"
      },
      {
        "txt": "} @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(char c) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeNumber(short i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(int i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException,JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));"
      },
      {
        "txt": "} @Override public void writeNumber(float f) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException { if (dec == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); }"
      },
      {
        "txt": "} @Override public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException,JsonGenerationException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override"
      },
      {
        "txt": "_append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); <extra_id_0> @Override public void writeTree(TreeNode node) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } @Override"
      },
      {
        "txt": "} @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override"
      },
      {
        "txt": "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (jp.getCurrentToken()) { case START_OBJECT: writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: writeFieldName(jp.getCurrentName()); break; case VALUE_STRING: if (jp.hasTextCharacters()) { writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); } else { writeString(jp.getText()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: switch (jp.getNumberType()) { case INT: writeNumber(jp.getIntValue()); break; case BIG_INTEGER: writeNumber(jp.getBigIntegerValue()); break; default: writeNumber(jp.getLongValue());"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: switch (jp.getNumberType()) { case BIG_DECIMAL: writeNumber(jp.getDecimalValue()); break; case FLOAT: writeNumber(jp.getFloatValue()); break;"
      },
      {
        "txt": "default: writeNumber(jp.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(jp.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } }"
      },
      {
        "txt": "@Override public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken();"
      },
      {
        "txt": "} if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple:"
      },
      {
        "txt": "copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true;"
      },
      {
        "txt": "} } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment;"
      },
      {
        "txt": "protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; @Deprecated // since 2.3 protected Parser(Segment firstSeg, ObjectCodec codec) { this(firstSeg, codec, false, false); } public Parser(Segment firstSeg, ObjectCodec codec,"
      },
      {
        "txt": "boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds;"
      },
      {
        "txt": "_hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException, JsonParseException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; }"
      },
      {
        "txt": "} @Override public JsonToken nextToken() throws IOException, JsonParseException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null;"
      },
      {
        "txt": "} } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; }"
      },
      {
        "txt": "@Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; }"
      },
      {
        "txt": "@Override public String getCurrentName() { return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try {"
      },
      {
        "txt": "ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) {"
      },
      {
        "txt": "case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; }"
      },
      {
        "txt": "@Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n;"
      },
      {
        "txt": "} if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException, JsonParseException { Number n = getNumberValue();"
      },
      {
        "txt": "if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default:"
      },
      {
        "txt": "} return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException, JsonParseException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException, JsonParseException { return getNumberValue().floatValue();"
      },
      {
        "txt": "} @Override public int getIntValue() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override"
      },
      {
        "txt": "public long getLongValue() throws IOException, JsonParseException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE;"
      },
      {
        "txt": "if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException, JsonParseException { _checkIsNumber(); Object value = _currentObject();"
      },
      {
        "txt": "if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); }"
      },
      {
        "txt": "if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {"
      },
      {
        "txt": "return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject();"
      },
      {
        "txt": "if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null;"
      },
      {
        "txt": "} ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); }"
      },
      {
        "txt": "@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0;"
      },
      {
        "txt": "} @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override"
      },
      {
        "txt": "public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); }"
      },
      {
        "txt": "protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); }"
      },
      {
        "txt": "} protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); }"
      },
      {
        "txt": "protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2);"
      },
      {
        "txt": "} int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); }"
      },
      {
        "txt": "int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value);"
      },
      {
        "txt": "return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; }"
      },
      {
        "txt": "private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); }"
      },
      {
        "txt": "private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId);"
      },
      {
        "txt": "} } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; }"
      }
    ]
  },
  {
    "id": 1308,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 793,
    "end-bug-line": 793,
    "bug": "",
    "fix": "if (node == null) { writeNull(); return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator"
      },
      {
        "txt": "{ protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last;"
      },
      {
        "txt": "protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)"
      },
      {
        "txt": "{ _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; }"
      },
      {
        "txt": "public TokenBuffer(JsonParser jp) { _objectCodec = jp.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = jp.canReadTypeId(); _hasNativeObjectIds = jp.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec)"
      },
      {
        "txt": "{ return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() {"
      },
      {
        "txt": "if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { if (!_hasNativeTypeIds) {"
      },
      {
        "txt": "_hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser jp = other.asParser(); while (jp.nextToken() != null) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "return this; } public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) {"
      },
      {
        "txt": "if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr);"
      },
      {
        "txt": "if (id != null) { jgen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { jgen.writeTypeId(id); } } switch (t) { case START_OBJECT:"
      },
      {
        "txt": "jgen.writeStartObject(); break; case END_OBJECT: jgen.writeEndObject(); break; case START_ARRAY: jgen.writeStartArray(); break; case END_ARRAY: jgen.writeEndArray();"
      },
      {
        "txt": "break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeFieldName((SerializableString) ob); } else { jgen.writeFieldName((String) ob); } }"
      },
      {
        "txt": "break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeString((SerializableString) ob); } else { jgen.writeString((String) ob); } }"
      },
      {
        "txt": "break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { jgen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { jgen.writeNumber((BigInteger) n); } else if (n instanceof Long) { jgen.writeNumber((Long) n);"
      },
      {
        "txt": "} else if (n instanceof Short) { jgen.writeNumber((Short) n); } else { jgen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr);"
      },
      {
        "txt": "if (n instanceof Double) { jgen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { jgen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { jgen.writeNumber(((Float) n).floatValue()); } else if (n == null) { jgen.writeNull(); } else if (n instanceof String) { jgen.writeNumber((String) n);"
      },
      {
        "txt": "} else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: jgen.writeBoolean(true); break; case VALUE_FALSE: jgen.writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: jgen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: jgen.writeObject(segment.get(ptr)); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { copyCurrentStructure(jp); return this; } @Override @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;"
      },
      {
        "txt": "while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) {"
      },
      {
        "txt": "sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur"
      },
      {
        "txt": "throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); }"
      },
      {
        "txt": "private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); }"
      },
      {
        "txt": "} @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this;"
      },
      {
        "txt": "} @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override"
      },
      {
        "txt": "public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) {"
      },
      {
        "txt": "_objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true;"
      },
      {
        "txt": "} @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public final void writeStartArray() throws IOException, JsonGenerationException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException, JsonGenerationException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); }"
      },
      {
        "txt": "@Override public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException,JsonGenerationException { if (text == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { writeString(new String(text, offset, len)); } @Override"
      },
      {
        "txt": "public void writeString(SerializableString text) throws IOException, JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRawValue(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeNumber(short i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(long l) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException,JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));"
      },
      {
        "txt": "} @Override public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override"
      },
      {
        "txt": "public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);"
      },
      {
        "txt": "} @Override public void writeBoolean(boolean state) throws IOException,JsonGenerationException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NULL); } @Override"
      },
      {
        "txt": "{ _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } @Override public void writeTree(TreeNode node) throws IOException { <extra_id_0> _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "throws IOException, JsonGenerationException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) {"
      },
      {
        "txt": "_typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException"
      },
      {
        "txt": "{ if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (jp.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(jp.getCurrentName()); break;"
      },
      {
        "txt": "case VALUE_STRING: if (jp.hasTextCharacters()) { writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); } else { writeString(jp.getText()); } break; case VALUE_NUMBER_INT: switch (jp.getNumberType()) { case INT:"
      },
      {
        "txt": "writeNumber(jp.getIntValue()); break; case BIG_INTEGER: writeNumber(jp.getBigIntegerValue()); break; default: writeNumber(jp.getLongValue()); } break; case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "switch (jp.getNumberType()) { case BIG_DECIMAL: writeNumber(jp.getDecimalValue()); break; case FLOAT: writeNumber(jp.getFloatValue()); break; default: writeNumber(jp.getDoubleValue()); }"
      },
      {
        "txt": "break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break;"
      },
      {
        "txt": "case VALUE_EMBEDDED_OBJECT: writeObject(jp.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp);"
      },
      {
        "txt": "} switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT:"
      },
      {
        "txt": "writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } }"
      },
      {
        "txt": "private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type)"
      },
      {
        "txt": "{ Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 }"
      },
      {
        "txt": "} protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next;"
      },
      {
        "txt": "_appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser"
      },
      {
        "txt": "extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed;"
      },
      {
        "txt": "protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; @Deprecated // since 2.3 protected Parser(Segment firstSeg, ObjectCodec codec) { this(firstSeg, codec, false, false); } public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) {"
      },
      {
        "txt": "super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) {"
      },
      {
        "txt": "_location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonToken peekNextToken() throws IOException, JsonParseException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); }"
      },
      {
        "txt": "return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr);"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { return _parsingContext.getCurrentName(); } @Override"
      },
      {
        "txt": "public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e);"
      },
      {
        "txt": "} } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob;"
      },
      {
        "txt": "} return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject();"
      },
      {
        "txt": "return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); }"
      },
      {
        "txt": "@Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false;"
      },
      {
        "txt": "} @Override public BigInteger getBigIntegerValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger();"
      },
      {
        "txt": "} return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; }"
      },
      {
        "txt": "switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); }"
      },
      {
        "txt": "@Override public double getDoubleValue() throws IOException, JsonParseException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException, JsonParseException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException, JsonParseException { return getNumberValue().longValue(); }"
      },
      {
        "txt": "@Override public NumberType getNumberType() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT;"
      },
      {
        "txt": "if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException, JsonParseException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; }"
      },
      {
        "txt": "if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; }"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; }"
      },
      {
        "txt": "} if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) {"
      },
      {
        "txt": "_byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException"
      },
      {
        "txt": "{ byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); }"
      },
      {
        "txt": "@Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment {"
      },
      {
        "txt": "public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];"
      },
      {
        "txt": "protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix];"
      },
      {
        "txt": "} public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; }"
      },
      {
        "txt": "public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) {"
      },
      {
        "txt": "_nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1309,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 794,
    "end-bug-line": 794,
    "bug": "",
    "fix": "if (_objectCodec == null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator"
      },
      {
        "txt": "{ protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last;"
      },
      {
        "txt": "protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)"
      },
      {
        "txt": "{ _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; }"
      },
      {
        "txt": "public TokenBuffer(JsonParser jp) { _objectCodec = jp.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = jp.canReadTypeId(); _hasNativeObjectIds = jp.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec)"
      },
      {
        "txt": "{ return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() {"
      },
      {
        "txt": "if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { if (!_hasNativeTypeIds) {"
      },
      {
        "txt": "_hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser jp = other.asParser(); while (jp.nextToken() != null) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "return this; } public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) {"
      },
      {
        "txt": "if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr);"
      },
      {
        "txt": "if (id != null) { jgen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { jgen.writeTypeId(id); } } switch (t) { case START_OBJECT:"
      },
      {
        "txt": "jgen.writeStartObject(); break; case END_OBJECT: jgen.writeEndObject(); break; case START_ARRAY: jgen.writeStartArray(); break; case END_ARRAY: jgen.writeEndArray();"
      },
      {
        "txt": "break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeFieldName((SerializableString) ob); } else { jgen.writeFieldName((String) ob); } }"
      },
      {
        "txt": "break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeString((SerializableString) ob); } else { jgen.writeString((String) ob); } }"
      },
      {
        "txt": "break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { jgen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { jgen.writeNumber((BigInteger) n); } else if (n instanceof Long) { jgen.writeNumber((Long) n);"
      },
      {
        "txt": "} else if (n instanceof Short) { jgen.writeNumber((Short) n); } else { jgen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr);"
      },
      {
        "txt": "if (n instanceof Double) { jgen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { jgen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { jgen.writeNumber(((Float) n).floatValue()); } else if (n == null) { jgen.writeNull(); } else if (n instanceof String) { jgen.writeNumber((String) n);"
      },
      {
        "txt": "} else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: jgen.writeBoolean(true); break; case VALUE_FALSE: jgen.writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: jgen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: jgen.writeObject(segment.get(ptr)); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { copyCurrentStructure(jp); return this; } @Override @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;"
      },
      {
        "txt": "while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) {"
      },
      {
        "txt": "sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur"
      },
      {
        "txt": "throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); }"
      },
      {
        "txt": "private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); }"
      },
      {
        "txt": "} @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this;"
      },
      {
        "txt": "} @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override"
      },
      {
        "txt": "public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) {"
      },
      {
        "txt": "_objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true;"
      },
      {
        "txt": "} @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public final void writeStartArray() throws IOException, JsonGenerationException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException, JsonGenerationException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); }"
      },
      {
        "txt": "@Override public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException,JsonGenerationException { if (text == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { writeString(new String(text, offset, len)); } @Override"
      },
      {
        "txt": "public void writeString(SerializableString text) throws IOException, JsonGenerationException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRawValue(String text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeNumber(short i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(long l) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException,JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));"
      },
      {
        "txt": "} @Override public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override"
      },
      {
        "txt": "public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);"
      },
      {
        "txt": "} @Override public void writeBoolean(boolean state) throws IOException,JsonGenerationException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NULL); } @Override"
      },
      {
        "txt": "{ _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } @Override public void writeTree(TreeNode node) throws IOException { <extra_id_0> _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "throws IOException, JsonGenerationException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) {"
      },
      {
        "txt": "_typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException"
      },
      {
        "txt": "{ if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (jp.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(jp.getCurrentName()); break;"
      },
      {
        "txt": "case VALUE_STRING: if (jp.hasTextCharacters()) { writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); } else { writeString(jp.getText()); } break; case VALUE_NUMBER_INT: switch (jp.getNumberType()) { case INT:"
      },
      {
        "txt": "writeNumber(jp.getIntValue()); break; case BIG_INTEGER: writeNumber(jp.getBigIntegerValue()); break; default: writeNumber(jp.getLongValue()); } break; case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "switch (jp.getNumberType()) { case BIG_DECIMAL: writeNumber(jp.getDecimalValue()); break; case FLOAT: writeNumber(jp.getFloatValue()); break; default: writeNumber(jp.getDoubleValue()); }"
      },
      {
        "txt": "break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break;"
      },
      {
        "txt": "case VALUE_EMBEDDED_OBJECT: writeObject(jp.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp);"
      },
      {
        "txt": "} switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT:"
      },
      {
        "txt": "writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } }"
      },
      {
        "txt": "private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type)"
      },
      {
        "txt": "{ Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 }"
      },
      {
        "txt": "} protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next;"
      },
      {
        "txt": "_appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser"
      },
      {
        "txt": "extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed;"
      },
      {
        "txt": "protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; @Deprecated // since 2.3 protected Parser(Segment firstSeg, ObjectCodec codec) { this(firstSeg, codec, false, false); } public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) {"
      },
      {
        "txt": "super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) {"
      },
      {
        "txt": "_location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonToken peekNextToken() throws IOException, JsonParseException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); }"
      },
      {
        "txt": "return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr);"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { return _parsingContext.getCurrentName(); } @Override"
      },
      {
        "txt": "public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e);"
      },
      {
        "txt": "} } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob;"
      },
      {
        "txt": "} return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject();"
      },
      {
        "txt": "return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); }"
      },
      {
        "txt": "@Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false;"
      },
      {
        "txt": "} @Override public BigInteger getBigIntegerValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger();"
      },
      {
        "txt": "} return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; }"
      },
      {
        "txt": "switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); }"
      },
      {
        "txt": "@Override public double getDoubleValue() throws IOException, JsonParseException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException, JsonParseException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException, JsonParseException { return getNumberValue().longValue(); }"
      },
      {
        "txt": "@Override public NumberType getNumberType() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT;"
      },
      {
        "txt": "if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException, JsonParseException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; }"
      },
      {
        "txt": "if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; }"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; }"
      },
      {
        "txt": "} if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) {"
      },
      {
        "txt": "_byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException"
      },
      {
        "txt": "{ byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); }"
      },
      {
        "txt": "@Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment {"
      },
      {
        "txt": "public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];"
      },
      {
        "txt": "protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix];"
      },
      {
        "txt": "} public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; }"
      },
      {
        "txt": "public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) {"
      },
      {
        "txt": "_nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1310,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 796,
    "end-bug-line": 796,
    "bug": "",
    "fix": "} else { _objectCodec.writeTree(this, node); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator {"
      },
      {
        "txt": "protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt;"
      },
      {
        "txt": "protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {"
      },
      {
        "txt": "_objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser jp)"
      },
      {
        "txt": "{ _objectCodec = jp.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = jp.canReadTypeId(); _hasNativeObjectIds = jp.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; }"
      },
      {
        "txt": "@Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) {"
      },
      {
        "txt": "return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) {"
      },
      {
        "txt": "return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId();"
      },
      {
        "txt": "} if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser jp = other.asParser(); while (jp.nextToken() != null) { copyCurrentStructure(jp); } return this;"
      },
      {
        "txt": "} public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) {"
      },
      {
        "txt": "jgen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { jgen.writeTypeId(id); } } switch (t) { case START_OBJECT: jgen.writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: jgen.writeEndObject(); break; case START_ARRAY: jgen.writeStartArray(); break; case END_ARRAY: jgen.writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeFieldName((SerializableString) ob); } else { jgen.writeFieldName((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { jgen.writeString((SerializableString) ob); } else { jgen.writeString((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { jgen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { jgen.writeNumber((BigInteger) n); } else if (n instanceof Long) { jgen.writeNumber((Long) n); } else if (n instanceof Short) {"
      },
      {
        "txt": "jgen.writeNumber((Short) n); } else { jgen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) {"
      },
      {
        "txt": "jgen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { jgen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { jgen.writeNumber(((Float) n).floatValue()); } else if (n == null) { jgen.writeNull(); } else if (n instanceof String) { jgen.writeNumber((String) n); } else {"
      },
      {
        "txt": "throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: jgen.writeBoolean(true); break; case VALUE_FALSE: jgen.writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: jgen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: jgen.writeObject(segment.get(ptr)); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } }"
      },
      {
        "txt": "} public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { copyCurrentStructure(jp); return this; } @Override @SuppressWarnings(\"resource\") public String toString()"
      },
      {
        "txt": "{ final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) {"
      },
      {
        "txt": "JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \");"
      },
      {
        "txt": "} sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe);"
      },
      {
        "txt": "} ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb)"
      },
      {
        "txt": "{ Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } }"
      },
      {
        "txt": "@Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; }"
      },
      {
        "txt": "@Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) {"
      },
      {
        "txt": "_generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc;"
      },
      {
        "txt": "return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; }"
      },
      {
        "txt": "@Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray()"
      },
      {
        "txt": "throws IOException, JsonGenerationException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException, JsonGenerationException { _append(JsonToken.END_ARRAY);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException, JsonGenerationException { _append(JsonToken.START_OBJECT);"
      },
      {
        "txt": "_writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException, JsonGenerationException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c;"
      },
      {
        "txt": "} } @Override public final void writeFieldName(String name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override"
      },
      {
        "txt": "public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException,JsonGenerationException { if (text == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeNumber(short i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException,JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); }"
      },
      {
        "txt": "@Override public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); }"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException,JsonGenerationException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException, JsonGenerationException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } @Override public void writeTree(TreeNode node) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); <extra_id_0> @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len);"
      },
      {
        "txt": "byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() {"
      },
      {
        "txt": "return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } switch (jp.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(jp.getCurrentName()); break; case VALUE_STRING: if (jp.hasTextCharacters()) {"
      },
      {
        "txt": "writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); } else { writeString(jp.getText()); } break; case VALUE_NUMBER_INT: switch (jp.getNumberType()) { case INT: writeNumber(jp.getIntValue()); break;"
      },
      {
        "txt": "case BIG_INTEGER: writeNumber(jp.getBigIntegerValue()); break; default: writeNumber(jp.getLongValue()); } break; case VALUE_NUMBER_FLOAT: switch (jp.getNumberType()) { case BIG_DECIMAL:"
      },
      {
        "txt": "writeNumber(jp.getDecimalValue()); break; case FLOAT: writeNumber(jp.getFloatValue()); break; default: writeNumber(jp.getDoubleValue()); } break; case VALUE_TRUE:"
      },
      {
        "txt": "writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(jp.getEmbeddedObject());"
      },
      {
        "txt": "break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) {"
      },
      {
        "txt": "case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) {"
      },
      {
        "txt": "copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value)"
      },
      {
        "txt": "{ Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; }"
      },
      {
        "txt": "} protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next;"
      },
      {
        "txt": "_appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase {"
      },
      {
        "txt": "protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null;"
      },
      {
        "txt": "@Deprecated // since 2.3 protected Parser(Segment firstSeg, ObjectCodec codec) { this(firstSeg, codec, false, false); } public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg;"
      },
      {
        "txt": "_segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; }"
      },
      {
        "txt": "@Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); }"
      },
      {
        "txt": "@Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException, JsonParseException { if (_closed || (_segment == null)) return null;"
      },
      {
        "txt": "if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) {"
      },
      {
        "txt": "_parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override"
      },
      {
        "txt": "public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) {"
      },
      {
        "txt": "JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } }"
      },
      {
        "txt": "@Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString();"
      },
      {
        "txt": "} if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default:"
      },
      {
        "txt": "return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override"
      },
      {
        "txt": "public BigInteger getBigIntegerValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue());"
      },
      {
        "txt": "} @Override public BigDecimal getDecimalValue() throws IOException, JsonParseException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT:"
      },
      {
        "txt": "case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException, JsonParseException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException, JsonParseException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException, JsonParseException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null;"
      },
      {
        "txt": "} @Override public final Number getNumberValue() throws IOException, JsonParseException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value;"
      },
      {
        "txt": "if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName());"
      },
      {
        "txt": "} @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else {"
      },
      {
        "txt": "_byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { byte[] data = getBinaryValue(b64variant);"
      },
      {
        "txt": "if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; }"
      },
      {
        "txt": "@Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() {"
      },
      {
        "txt": "return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); }"
      },
      {
        "txt": "} @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX;"
      },
      {
        "txt": "static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { }"
      },
      {
        "txt": "public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index)"
      },
      {
        "txt": "{ long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index];"
      },
      {
        "txt": "} public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) {"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType;"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); }"
      },
      {
        "txt": "if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); }"
      },
      {
        "txt": "public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  }
]