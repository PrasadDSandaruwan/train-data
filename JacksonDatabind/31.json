[
  {
    "id": 1464,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 672,
    "end-bug-line": 672,
    "bug": "_append(JsonToken.VALUE_STRING, text);",
    "fix": "_appendValue(JsonToken.VALUE_STRING, text);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed;"
      },
      {
        "txt": "protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false;"
      },
      {
        "txt": "protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt)"
      },
      {
        "txt": "{ _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false"
      },
      {
        "txt": ": ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) {"
      },
      {
        "txt": "Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1;"
      },
      {
        "txt": "final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr);"
      },
      {
        "txt": "if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); }"
      },
      {
        "txt": "} switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) {"
      },
      {
        "txt": "gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) {"
      },
      {
        "txt": "gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr);"
      },
      {
        "txt": "if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject();"
      },
      {
        "txt": "do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0;"
      },
      {
        "txt": "final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) {"
      },
      {
        "txt": "if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } }"
      },
      {
        "txt": "} catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString();"
      },
      {
        "txt": "} private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');"
      },
      {
        "txt": "} } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask();"
      },
      {
        "txt": "return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; }"
      },
      {
        "txt": "@Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override"
      },
      {
        "txt": "public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() {"
      },
      {
        "txt": "return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext();"
      },
      {
        "txt": "} @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "} @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { <extra_id_0> } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); }"
      },
      {
        "txt": "writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));"
      },
      {
        "txt": "} @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));"
      },
      {
        "txt": "} @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); }"
      },
      {
        "txt": "} @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override"
      },
      {
        "txt": "public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; }"
      },
      {
        "txt": "Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); }"
      },
      {
        "txt": "} @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);"
      },
      {
        "txt": "} else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy);"
      },
      {
        "txt": "} @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override"
      },
      {
        "txt": "public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) {"
      },
      {
        "txt": "_objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) {"
      },
      {
        "txt": "case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY:"
      },
      {
        "txt": "writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText());"
      },
      {
        "txt": "} break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break;"
      },
      {
        "txt": "default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL:"
      },
      {
        "txt": "writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break;"
      },
      {
        "txt": "case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT:"
      },
      {
        "txt": "writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken();"
      },
      {
        "txt": "if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); }"
      },
      {
        "txt": "switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject();"
      },
      {
        "txt": "while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException"
      },
      {
        "txt": "{ if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } }"
      },
      {
        "txt": "protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1;"
      },
      {
        "txt": "} } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase"
      },
      {
        "txt": "{ protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder;"
      },
      {
        "txt": "protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null);"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override"
      },
      {
        "txt": "public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true;"
      },
      {
        "txt": "} } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) {"
      },
      {
        "txt": "return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken;"
      },
      {
        "txt": "} @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString();"
      },
      {
        "txt": "_parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override"
      },
      {
        "txt": "public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName();"
      },
      {
        "txt": "} return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); }"
      },
      {
        "txt": "try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING"
      },
      {
        "txt": "|| _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; }"
      },
      {
        "txt": "switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override"
      },
      {
        "txt": "public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) {"
      },
      {
        "txt": "return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n);"
      },
      {
        "txt": "default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); }"
      },
      {
        "txt": "@Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG;"
      },
      {
        "txt": "if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber();"
      },
      {
        "txt": "Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str);"
      },
      {
        "txt": "} if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {"
      },
      {
        "txt": "Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) {"
      },
      {
        "txt": "return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray();"
      },
      {
        "txt": "} @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0;"
      },
      {
        "txt": "} @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override"
      },
      {
        "txt": "public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); }"
      },
      {
        "txt": "protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); }"
      },
      {
        "txt": "} protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); }"
      },
      {
        "txt": "protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2);"
      },
      {
        "txt": "} int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); }"
      },
      {
        "txt": "int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value);"
      },
      {
        "txt": "return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; }"
      },
      {
        "txt": "private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); }"
      },
      {
        "txt": "private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId);"
      },
      {
        "txt": "} } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; }"
      }
    ]
  },
  {
    "id": 1465,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 686,
    "end-bug-line": 686,
    "bug": "_append(JsonToken.VALUE_STRING, text);",
    "fix": "_appendValue(JsonToken.VALUE_STRING, text);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated"
      },
      {
        "txt": "public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec();"
      },
      {
        "txt": "_generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); }"
      },
      {
        "txt": "public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() {"
      },
      {
        "txt": "return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation());"
      },
      {
        "txt": "return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException"
      },
      {
        "txt": "{ if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) {"
      },
      {
        "txt": "copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds());"
      },
      {
        "txt": "while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) {"
      },
      {
        "txt": "Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) {"
      },
      {
        "txt": "case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY:"
      },
      {
        "txt": "gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); }"
      },
      {
        "txt": "} break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); }"
      },
      {
        "txt": "} break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) {"
      },
      {
        "txt": "gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: {"
      },
      {
        "txt": "Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) {"
      },
      {
        "txt": "gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE:"
      },
      {
        "txt": "gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen);"
      },
      {
        "txt": "} else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } }"
      },
      {
        "txt": "public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p);"
      },
      {
        "txt": "} while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString()"
      },
      {
        "txt": "{ final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) {"
      },
      {
        "txt": "JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \");"
      },
      {
        "txt": "} sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe);"
      },
      {
        "txt": "} ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb)"
      },
      {
        "txt": "{ Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } }"
      },
      {
        "txt": "@Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; }"
      },
      {
        "txt": "@Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) {"
      },
      {
        "txt": "_generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc;"
      },
      {
        "txt": "return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; }"
      },
      {
        "txt": "@Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override"
      },
      {
        "txt": "public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); }"
      },
      {
        "txt": "@Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "} @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { <extra_id_0> } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override"
      },
      {
        "txt": "public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));"
      },
      {
        "txt": "} @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override"
      },
      {
        "txt": "public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); }"
      },
      {
        "txt": "} @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override"
      },
      {
        "txt": "public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL);"
      },
      {
        "txt": "} @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override"
      },
      {
        "txt": "public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node);"
      },
      {
        "txt": "} } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override"
      },
      {
        "txt": "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue());"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break;"
      },
      {
        "txt": "case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1;"
      },
      {
        "txt": "} } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec;"
      },
      {
        "txt": "protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec,"
      },
      {
        "txt": "boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds;"
      },
      {
        "txt": "_hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0;"
      },
      {
        "txt": "seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } }"
      },
      {
        "txt": "@Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; }"
      },
      {
        "txt": "} _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override"
      },
      {
        "txt": "public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override"
      },
      {
        "txt": "public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName();"
      },
      {
        "txt": "} @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name);"
      },
      {
        "txt": "} catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText();"
      },
      {
        "txt": "return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override"
      },
      {
        "txt": "public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; }"
      },
      {
        "txt": "if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) {"
      },
      {
        "txt": "return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: }"
      },
      {
        "txt": "return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); }"
      },
      {
        "txt": "@Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;"
      },
      {
        "txt": "if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) {"
      },
      {
        "txt": "return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) {"
      },
      {
        "txt": "return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject();"
      },
      {
        "txt": "} return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) {"
      },
      {
        "txt": "return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; }"
      },
      {
        "txt": "ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override"
      },
      {
        "txt": "public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr);"
      },
      {
        "txt": "} @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException {"
      },
      {
        "txt": "if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment"
      },
      {
        "txt": "{ public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes;"
      },
      {
        "txt": "protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF;"
      },
      {
        "txt": "return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix;"
      },
      {
        "txt": "} public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType,"
      },
      {
        "txt": "Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } }"
      },
      {
        "txt": "public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1466,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 731,
    "end-bug-line": 731,
    "bug": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));",
    "fix": "_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt;"
      },
      {
        "txt": "protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {"
      },
      {
        "txt": "_objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) {"
      },
      {
        "txt": "this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId();"
      },
      {
        "txt": "_hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);"
      },
      {
        "txt": "} public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0);"
      },
      {
        "txt": "} return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) {"
      },
      {
        "txt": "_hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException"
      },
      {
        "txt": "{ Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break;"
      },
      {
        "txt": "hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr);"
      },
      {
        "txt": "if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr);"
      },
      {
        "txt": "if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue());"
      },
      {
        "txt": "} } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n);"
      },
      {
        "txt": "} else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } }"
      },
      {
        "txt": "break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break;"
      },
      {
        "txt": "case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this;"
      },
      {
        "txt": "} JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject();"
      },
      {
        "txt": "return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");"
      },
      {
        "txt": "sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) {"
      },
      {
        "txt": "_appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName());"
      },
      {
        "txt": "sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");"
      },
      {
        "txt": "} sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); }"
      },
      {
        "txt": "Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; }"
      },
      {
        "txt": "@Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override"
      },
      {
        "txt": "public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() {"
      },
      {
        "txt": "return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override"
      },
      {
        "txt": "public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override"
      },
      {
        "txt": "public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override"
      },
      {
        "txt": "public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "@Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { <extra_id_0> } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); }"
      },
      {
        "txt": "text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); }"
      },
      {
        "txt": "@Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException {"
      },
      {
        "txt": "if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException {"
      },
      {
        "txt": "_append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) {"
      },
      {
        "txt": "writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);"
      },
      {
        "txt": "} else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return;"
      },
      {
        "txt": "} if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {"
      },
      {
        "txt": "byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() {"
      },
      {
        "txt": "return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) {"
      },
      {
        "txt": "writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break;"
      },
      {
        "txt": "case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue());"
      },
      {
        "txt": "} else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue());"
      },
      {
        "txt": "} } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL:"
      },
      {
        "txt": "writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override"
      },
      {
        "txt": "public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); }"
      },
      {
        "txt": "if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray();"
      },
      {
        "txt": "break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp);"
      },
      {
        "txt": "} } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; }"
      },
      {
        "txt": "} protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next;"
      },
      {
        "txt": "_appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");"
      },
      {
        "txt": "} protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr;"
      },
      {
        "txt": "protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg;"
      },
      {
        "txt": "_segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; }"
      },
      {
        "txt": "@Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException {"
      },
      {
        "txt": "if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override"
      },
      {
        "txt": "public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "_segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString();"
      },
      {
        "txt": "_parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null);"
      },
      {
        "txt": "} } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "_segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() {"
      },
      {
        "txt": "if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext;"
      },
      {
        "txt": "if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override"
      },
      {
        "txt": "public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); }"
      },
      {
        "txt": "if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString();"
      },
      {
        "txt": "} } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText();"
      },
      {
        "txt": "return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); }"
      },
      {
        "txt": "@Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG:"
      },
      {
        "txt": "return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue();"
      },
      {
        "txt": "} @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue();"
      },
      {
        "txt": "} return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; }"
      },
      {
        "txt": "@Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) {"
      },
      {
        "txt": "return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); }"
      },
      {
        "txt": "@Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");"
      },
      {
        "txt": "} final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset();"
      },
      {
        "txt": "} _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length);"
      },
      {
        "txt": "return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() {"
      },
      {
        "txt": "return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); }"
      },
      {
        "txt": "protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override"
      },
      {
        "txt": "protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16];"
      },
      {
        "txt": "JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) {"
      },
      {
        "txt": "long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes;"
      },
      {
        "txt": "if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; }"
      },
      {
        "txt": "public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId);"
      },
      {
        "txt": "} if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));"
      },
      {
        "txt": "} private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1467,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 739,
    "end-bug-line": 739,
    "bug": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));",
    "fix": "_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*;"
      },
      {
        "txt": "import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer"
      },
      {
        "txt": "extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal;"
      },
      {
        "txt": "protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false);"
      },
      {
        "txt": "} public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds;"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b;"
      },
      {
        "txt": "return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); }"
      },
      {
        "txt": "public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; }"
      },
      {
        "txt": "public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) {"
      },
      {
        "txt": "_hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); }"
      },
      {
        "txt": "return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) {"
      },
      {
        "txt": "gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) {"
      },
      {
        "txt": "gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) {"
      },
      {
        "txt": "gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else {"
      },
      {
        "txt": "throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value);"
      },
      {
        "txt": "} } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {"
      },
      {
        "txt": "if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) {"
      },
      {
        "txt": "throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100;"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try {"
      },
      {
        "txt": "t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString());"
      },
      {
        "txt": "if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count;"
      },
      {
        "txt": "} if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1);"
      },
      {
        "txt": "if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) {"
      },
      {
        "txt": "_generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) {"
      },
      {
        "txt": "return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this;"
      },
      {
        "txt": "} @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; }"
      },
      {
        "txt": "@Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ }"
      },
      {
        "txt": "@Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY);"
      },
      {
        "txt": "_writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; }"
      },
      {
        "txt": "} @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException {"
      },
      {
        "txt": "if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); }"
      },
      {
        "txt": "@Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException {"
      },
      {
        "txt": "} @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } <extra_id_0> } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override"
      },
      {
        "txt": "} @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));"
      },
      {
        "txt": "} @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override"
      },
      {
        "txt": "public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);"
      },
      {
        "txt": "} @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override"
      },
      {
        "txt": "public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return;"
      },
      {
        "txt": "} if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException {"
      },
      {
        "txt": "if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } }"
      },
      {
        "txt": "@Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException();"
      },
      {
        "txt": "} @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override"
      },
      {
        "txt": "public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT:"
      },
      {
        "txt": "writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName());"
      },
      {
        "txt": "break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) {"
      },
      {
        "txt": "case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue());"
      },
      {
        "txt": "break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE:"
      },
      {
        "txt": "writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\");"
      },
      {
        "txt": "} } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); }"
      },
      {
        "txt": "writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) {"
      },
      {
        "txt": "copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject();"
      },
      {
        "txt": "break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; }"
      },
      {
        "txt": "if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "@Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds)"
      },
      {
        "txt": "{ super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); }"
      },
      {
        "txt": "public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;"
      },
      {
        "txt": "} public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); }"
      },
      {
        "txt": "return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr);"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException {"
      },
      {
        "txt": "if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location;"
      },
      {
        "txt": "} @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override"
      },
      {
        "txt": "public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e);"
      },
      {
        "txt": "} } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob;"
      },
      {
        "txt": "} return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject();"
      },
      {
        "txt": "return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); }"
      },
      {
        "txt": "@Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false;"
      },
      {
        "txt": "} @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger();"
      },
      {
        "txt": "} return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; }"
      },
      {
        "txt": "switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); }"
      },
      {
        "txt": "@Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); }"
      },
      {
        "txt": "@Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT;"
      },
      {
        "txt": "if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; }"
      },
      {
        "txt": "if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; }"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; }"
      },
      {
        "txt": "} if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) {"
      },
      {
        "txt": "_byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {"
      },
      {
        "txt": "byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override"
      },
      {
        "txt": "public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");"
      },
      {
        "txt": "} } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16;"
      },
      {
        "txt": "private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds;"
      },
      {
        "txt": "public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; }"
      },
      {
        "txt": "public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) {"
      },
      {
        "txt": "return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType;"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>();"
      },
      {
        "txt": "} if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));"
      },
      {
        "txt": "} public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1468,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 744,
    "end-bug-line": 744,
    "bug": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));",
    "fix": "_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec;"
      },
      {
        "txt": "protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId;"
      },
      {
        "txt": "protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec;"
      },
      {
        "txt": "_generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null);"
      },
      {
        "txt": "} public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId();"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() {"
      },
      {
        "txt": "return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); }"
      },
      {
        "txt": "public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); }"
      },
      {
        "txt": "return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId();"
      },
      {
        "txt": "} _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException {"
      },
      {
        "txt": "Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds());"
      },
      {
        "txt": "} JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) {"
      },
      {
        "txt": "gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break;"
      },
      {
        "txt": "case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) {"
      },
      {
        "txt": "gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); }"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) {"
      },
      {
        "txt": "gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break;"
      },
      {
        "txt": "case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT:"
      },
      {
        "txt": "{ Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; }"
      },
      {
        "txt": "JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");"
      },
      {
        "txt": "JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb);"
      },
      {
        "txt": "} if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')');"
      },
      {
        "txt": "} } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); }"
      },
      {
        "txt": "sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1);"
      },
      {
        "txt": "if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override"
      },
      {
        "txt": "public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() {"
      },
      {
        "txt": "return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this;"
      },
      {
        "txt": "} @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; }"
      },
      {
        "txt": "@Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; }"
      },
      {
        "txt": "@Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c;"
      },
      {
        "txt": "} } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException {"
      },
      {
        "txt": "text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { <extra_id_0> } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override"
      },
      {
        "txt": "} @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override"
      },
      {
        "txt": "public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);"
      },
      {
        "txt": "} @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else {"
      },
      {
        "txt": "_objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len];"
      },
      {
        "txt": "System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p);"
      },
      {
        "txt": "} switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());"
      },
      {
        "txt": "} else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER:"
      },
      {
        "txt": "writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else {"
      },
      {
        "txt": "switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); }"
      },
      {
        "txt": "} break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull();"
      },
      {
        "txt": "break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException"
      },
      {
        "txt": "{ JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break;"
      },
      {
        "txt": "case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); }"
      },
      {
        "txt": "} private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } }"
      },
      {
        "txt": "protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0"
      },
      {
        "txt": "} } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); }"
      },
      {
        "txt": "protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext;"
      },
      {
        "txt": "protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read"
      },
      {
        "txt": "_codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override"
      },
      {
        "txt": "public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null;"
      },
      {
        "txt": "Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException {"
      },
      {
        "txt": "if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0;"
      },
      {
        "txt": "_segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); }"
      },
      {
        "txt": "} return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr;"
      },
      {
        "txt": "Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText()"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) {"
      },
      {
        "txt": "return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); }"
      },
      {
        "txt": "} @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length();"
      },
      {
        "txt": "} @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override"
      },
      {
        "txt": "public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue());"
      },
      {
        "txt": "case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); }"
      },
      {
        "txt": "@Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); }"
      },
      {
        "txt": "return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue();"
      },
      {
        "txt": "if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override"
      },
      {
        "txt": "public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str);"
      },
      {
        "txt": "} return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override"
      },
      {
        "txt": "public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); }"
      },
      {
        "txt": "final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); }"
      },
      {
        "txt": "_decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length;"
      },
      {
        "txt": "} return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() {"
      },
      {
        "txt": "return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException {"
      },
      {
        "txt": "_throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values();"
      },
      {
        "txt": "System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes;"
      },
      {
        "txt": "if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) {"
      },
      {
        "txt": "l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() {"
      },
      {
        "txt": "return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType);"
      },
      {
        "txt": "return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); }"
      },
      {
        "txt": "if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); }"
      },
      {
        "txt": "private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1469,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 755,
    "end-bug-line": 755,
    "bug": "_append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated"
      },
      {
        "txt": "public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec();"
      },
      {
        "txt": "_generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); }"
      },
      {
        "txt": "public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() {"
      },
      {
        "txt": "return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation());"
      },
      {
        "txt": "return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException"
      },
      {
        "txt": "{ if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) {"
      },
      {
        "txt": "copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds());"
      },
      {
        "txt": "while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) {"
      },
      {
        "txt": "Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) {"
      },
      {
        "txt": "case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY:"
      },
      {
        "txt": "gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); }"
      },
      {
        "txt": "} break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); }"
      },
      {
        "txt": "} break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) {"
      },
      {
        "txt": "gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: {"
      },
      {
        "txt": "Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) {"
      },
      {
        "txt": "gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE:"
      },
      {
        "txt": "gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen);"
      },
      {
        "txt": "} else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } }"
      },
      {
        "txt": "public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p);"
      },
      {
        "txt": "} while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString()"
      },
      {
        "txt": "{ final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) {"
      },
      {
        "txt": "JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \");"
      },
      {
        "txt": "} sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe);"
      },
      {
        "txt": "} ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb)"
      },
      {
        "txt": "{ Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } }"
      },
      {
        "txt": "@Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; }"
      },
      {
        "txt": "@Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) {"
      },
      {
        "txt": "_generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc;"
      },
      {
        "txt": "return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; }"
      },
      {
        "txt": "@Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override"
      },
      {
        "txt": "public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); }"
      },
      {
        "txt": "@Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));"
      },
      {
        "txt": "@Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { <extra_id_0> } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override"
      },
      {
        "txt": "} @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override"
      },
      {
        "txt": "public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); }"
      },
      {
        "txt": "} @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override"
      },
      {
        "txt": "public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL);"
      },
      {
        "txt": "} @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override"
      },
      {
        "txt": "public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node);"
      },
      {
        "txt": "} } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override"
      },
      {
        "txt": "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue());"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break;"
      },
      {
        "txt": "case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1;"
      },
      {
        "txt": "} } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec;"
      },
      {
        "txt": "protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec,"
      },
      {
        "txt": "boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds;"
      },
      {
        "txt": "_hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0;"
      },
      {
        "txt": "seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } }"
      },
      {
        "txt": "@Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; }"
      },
      {
        "txt": "} _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override"
      },
      {
        "txt": "public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override"
      },
      {
        "txt": "public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName();"
      },
      {
        "txt": "} @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name);"
      },
      {
        "txt": "} catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText();"
      },
      {
        "txt": "return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override"
      },
      {
        "txt": "public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; }"
      },
      {
        "txt": "if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) {"
      },
      {
        "txt": "return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: }"
      },
      {
        "txt": "return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); }"
      },
      {
        "txt": "@Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;"
      },
      {
        "txt": "if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) {"
      },
      {
        "txt": "return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) {"
      },
      {
        "txt": "return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject();"
      },
      {
        "txt": "} return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) {"
      },
      {
        "txt": "return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; }"
      },
      {
        "txt": "ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override"
      },
      {
        "txt": "public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr);"
      },
      {
        "txt": "} @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException {"
      },
      {
        "txt": "if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment"
      },
      {
        "txt": "{ public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes;"
      },
      {
        "txt": "protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF;"
      },
      {
        "txt": "return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix;"
      },
      {
        "txt": "} public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType,"
      },
      {
        "txt": "Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } }"
      },
      {
        "txt": "public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1470,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 760,
    "end-bug-line": 760,
    "bug": "_append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator {"
      },
      {
        "txt": "protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last;"
      },
      {
        "txt": "protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)"
      },
      {
        "txt": "{ _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; }"
      },
      {
        "txt": "public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; }"
      },
      {
        "txt": "@Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) {"
      },
      {
        "txt": "return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) {"
      },
      {
        "txt": "return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); }"
      },
      {
        "txt": "if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; }"
      },
      {
        "txt": "public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next();"
      },
      {
        "txt": "if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); }"
      },
      {
        "txt": "id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT:"
      },
      {
        "txt": "gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: {"
      },
      {
        "txt": "Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: {"
      },
      {
        "txt": "Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: {"
      },
      {
        "txt": "Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else {"
      },
      {
        "txt": "gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) {"
      },
      {
        "txt": "gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); }"
      },
      {
        "txt": "} break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull();"
      },
      {
        "txt": "break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } }"
      },
      {
        "txt": "break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p);"
      },
      {
        "txt": "return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); }"
      },
      {
        "txt": "writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \");"
      },
      {
        "txt": "sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break;"
      },
      {
        "txt": "if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('(');"
      },
      {
        "txt": "sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) {"
      },
      {
        "txt": "sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');"
      },
      {
        "txt": "} Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this;"
      },
      {
        "txt": "} @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; }"
      },
      {
        "txt": "@Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override"
      },
      {
        "txt": "public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; }"
      },
      {
        "txt": "@Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException {"
      },
      {
        "txt": "_closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); }"
      },
      {
        "txt": "@Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override"
      },
      {
        "txt": "public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent();"
      },
      {
        "txt": "if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); }"
      },
      {
        "txt": "@Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException {"
      },
      {
        "txt": "if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); }"
      },
      {
        "txt": "@Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));"
      },
      {
        "txt": "@Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { <extra_id_0> } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override"
      },
      {
        "txt": "} @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override"
      },
      {
        "txt": "public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override"
      },
      {
        "txt": "public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException {"
      },
      {
        "txt": "if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull();"
      },
      {
        "txt": "return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException"
      },
      {
        "txt": "{ byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override"
      },
      {
        "txt": "public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id;"
      },
      {
        "txt": "_hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException {"
      },
      {
        "txt": "if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break;"
      },
      {
        "txt": "case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING:"
      },
      {
        "txt": "if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue());"
      },
      {
        "txt": "break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) {"
      },
      {
        "txt": "writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default:"
      },
      {
        "txt": "writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } }"
      },
      {
        "txt": "@Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken();"
      },
      {
        "txt": "} if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple:"
      },
      {
        "txt": "copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true;"
      },
      {
        "txt": "} } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment;"
      },
      {
        "txt": "protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0);"
      },
      {
        "txt": "_segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l;"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); }"
      },
      {
        "txt": "@Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null;"
      },
      {
        "txt": "if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) {"
      },
      {
        "txt": "_parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override"
      },
      {
        "txt": "public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override"
      },
      {
        "txt": "public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) {"
      },
      {
        "txt": "JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } }"
      },
      {
        "txt": "@Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString();"
      },
      {
        "txt": "} if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default:"
      },
      {
        "txt": "return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override"
      },
      {
        "txt": "public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue());"
      },
      {
        "txt": "} @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT:"
      },
      {
        "txt": "case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null;"
      },
      {
        "txt": "} @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value;"
      },
      {
        "txt": "if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName());"
      },
      {
        "txt": "} @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else {"
      },
      {
        "txt": "_byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) {"
      },
      {
        "txt": "out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr);"
      },
      {
        "txt": "} protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } }"
      },
      {
        "txt": "@Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static {"
      },
      {
        "txt": "TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index)"
      },
      {
        "txt": "{ long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) {"
      },
      {
        "txt": "long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; }"
      },
      {
        "txt": "public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) {"
      },
      {
        "txt": "_nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1471,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 765,
    "end-bug-line": 765,
    "bug": "_append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed;"
      },
      {
        "txt": "protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false;"
      },
      {
        "txt": "protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt)"
      },
      {
        "txt": "{ _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false"
      },
      {
        "txt": ": ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) {"
      },
      {
        "txt": "Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1;"
      },
      {
        "txt": "final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr);"
      },
      {
        "txt": "if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); }"
      },
      {
        "txt": "} switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) {"
      },
      {
        "txt": "gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) {"
      },
      {
        "txt": "gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr);"
      },
      {
        "txt": "if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject();"
      },
      {
        "txt": "do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0;"
      },
      {
        "txt": "final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) {"
      },
      {
        "txt": "if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } }"
      },
      {
        "txt": "} catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString();"
      },
      {
        "txt": "} private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');"
      },
      {
        "txt": "} } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask();"
      },
      {
        "txt": "return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; }"
      },
      {
        "txt": "@Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override"
      },
      {
        "txt": "public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() {"
      },
      {
        "txt": "return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext();"
      },
      {
        "txt": "} @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len);"
      },
      {
        "txt": "} _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));"
      },
      {
        "txt": "@Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { <extra_id_0> } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override"
      },
      {
        "txt": "} @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); }"
      },
      {
        "txt": "} @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override"
      },
      {
        "txt": "public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; }"
      },
      {
        "txt": "Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); }"
      },
      {
        "txt": "} @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);"
      },
      {
        "txt": "} else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy);"
      },
      {
        "txt": "} @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override"
      },
      {
        "txt": "public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) {"
      },
      {
        "txt": "_objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) {"
      },
      {
        "txt": "case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY:"
      },
      {
        "txt": "writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText());"
      },
      {
        "txt": "} break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break;"
      },
      {
        "txt": "default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL:"
      },
      {
        "txt": "writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break;"
      },
      {
        "txt": "case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT:"
      },
      {
        "txt": "writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken();"
      },
      {
        "txt": "if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); }"
      },
      {
        "txt": "switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject();"
      },
      {
        "txt": "while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException"
      },
      {
        "txt": "{ if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } }"
      },
      {
        "txt": "protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1;"
      },
      {
        "txt": "} } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase"
      },
      {
        "txt": "{ protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder;"
      },
      {
        "txt": "protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null);"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override"
      },
      {
        "txt": "public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true;"
      },
      {
        "txt": "} } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) {"
      },
      {
        "txt": "return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken;"
      },
      {
        "txt": "} @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString();"
      },
      {
        "txt": "_parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override"
      },
      {
        "txt": "public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName();"
      },
      {
        "txt": "} return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); }"
      },
      {
        "txt": "try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING"
      },
      {
        "txt": "|| _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; }"
      },
      {
        "txt": "switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override"
      },
      {
        "txt": "public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) {"
      },
      {
        "txt": "return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n);"
      },
      {
        "txt": "default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); }"
      },
      {
        "txt": "@Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG;"
      },
      {
        "txt": "if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber();"
      },
      {
        "txt": "Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str);"
      },
      {
        "txt": "} if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {"
      },
      {
        "txt": "Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) {"
      },
      {
        "txt": "return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray();"
      },
      {
        "txt": "} @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0;"
      },
      {
        "txt": "} @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override"
      },
      {
        "txt": "public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); }"
      },
      {
        "txt": "protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); }"
      },
      {
        "txt": "} protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); }"
      },
      {
        "txt": "protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2);"
      },
      {
        "txt": "} int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); }"
      },
      {
        "txt": "int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next;"
      },
      {
        "txt": "} public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value);"
      },
      {
        "txt": "return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId);"
      },
      {
        "txt": "} private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; }"
      },
      {
        "txt": "private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); }"
      },
      {
        "txt": "private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId);"
      },
      {
        "txt": "} } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; }"
      }
    ]
  },
  {
    "id": 1472,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 770,
    "end-bug-line": 770,
    "bug": "_append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*;"
      },
      {
        "txt": "import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer"
      },
      {
        "txt": "extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal;"
      },
      {
        "txt": "protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false);"
      },
      {
        "txt": "} public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds;"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b;"
      },
      {
        "txt": "return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); }"
      },
      {
        "txt": "public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; }"
      },
      {
        "txt": "public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) {"
      },
      {
        "txt": "_hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); }"
      },
      {
        "txt": "return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) {"
      },
      {
        "txt": "gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) {"
      },
      {
        "txt": "gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) {"
      },
      {
        "txt": "gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else {"
      },
      {
        "txt": "throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value);"
      },
      {
        "txt": "} } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {"
      },
      {
        "txt": "if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) {"
      },
      {
        "txt": "throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100;"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try {"
      },
      {
        "txt": "t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString());"
      },
      {
        "txt": "if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count;"
      },
      {
        "txt": "} if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1);"
      },
      {
        "txt": "if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) {"
      },
      {
        "txt": "_generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) {"
      },
      {
        "txt": "return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this;"
      },
      {
        "txt": "} @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; }"
      },
      {
        "txt": "@Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ }"
      },
      {
        "txt": "@Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY);"
      },
      {
        "txt": "_writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; }"
      },
      {
        "txt": "} @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException {"
      },
      {
        "txt": "if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); }"
      },
      {
        "txt": "@Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override"
      },
      {
        "txt": "public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));"
      },
      {
        "txt": "@Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { <extra_id_0> } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override"
      },
      {
        "txt": "} @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override"
      },
      {
        "txt": "public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);"
      },
      {
        "txt": "} @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override"
      },
      {
        "txt": "public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return;"
      },
      {
        "txt": "} if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException {"
      },
      {
        "txt": "if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } }"
      },
      {
        "txt": "@Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException();"
      },
      {
        "txt": "} @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override"
      },
      {
        "txt": "public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT:"
      },
      {
        "txt": "writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName());"
      },
      {
        "txt": "break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) {"
      },
      {
        "txt": "case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue());"
      },
      {
        "txt": "break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE:"
      },
      {
        "txt": "writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\");"
      },
      {
        "txt": "} } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); }"
      },
      {
        "txt": "writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) {"
      },
      {
        "txt": "copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject();"
      },
      {
        "txt": "break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; }"
      },
      {
        "txt": "if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "@Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds)"
      },
      {
        "txt": "{ super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); }"
      },
      {
        "txt": "public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;"
      },
      {
        "txt": "} public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); }"
      },
      {
        "txt": "return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr);"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException {"
      },
      {
        "txt": "if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location;"
      },
      {
        "txt": "} @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override"
      },
      {
        "txt": "public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e);"
      },
      {
        "txt": "} } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob;"
      },
      {
        "txt": "} return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject();"
      },
      {
        "txt": "return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); }"
      },
      {
        "txt": "@Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false;"
      },
      {
        "txt": "} @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger();"
      },
      {
        "txt": "} return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; }"
      },
      {
        "txt": "switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); }"
      },
      {
        "txt": "@Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); }"
      },
      {
        "txt": "@Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT;"
      },
      {
        "txt": "if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; }"
      },
      {
        "txt": "if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; }"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; }"
      },
      {
        "txt": "} if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) {"
      },
      {
        "txt": "_byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {"
      },
      {
        "txt": "byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override"
      },
      {
        "txt": "public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");"
      },
      {
        "txt": "} } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16;"
      },
      {
        "txt": "private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds;"
      },
      {
        "txt": "public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; }"
      },
      {
        "txt": "public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) {"
      },
      {
        "txt": "return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType;"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>();"
      },
      {
        "txt": "} if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));"
      },
      {
        "txt": "} public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1473,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 775,
    "end-bug-line": 775,
    "bug": "_append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec;"
      },
      {
        "txt": "protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId;"
      },
      {
        "txt": "protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec;"
      },
      {
        "txt": "_generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null);"
      },
      {
        "txt": "} public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId();"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() {"
      },
      {
        "txt": "return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); }"
      },
      {
        "txt": "public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); }"
      },
      {
        "txt": "return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId();"
      },
      {
        "txt": "} _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException {"
      },
      {
        "txt": "Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds());"
      },
      {
        "txt": "} JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) {"
      },
      {
        "txt": "gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break;"
      },
      {
        "txt": "case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) {"
      },
      {
        "txt": "gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); }"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) {"
      },
      {
        "txt": "gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break;"
      },
      {
        "txt": "case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT:"
      },
      {
        "txt": "{ Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; }"
      },
      {
        "txt": "JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");"
      },
      {
        "txt": "JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb);"
      },
      {
        "txt": "} if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')');"
      },
      {
        "txt": "} } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); }"
      },
      {
        "txt": "sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1);"
      },
      {
        "txt": "if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override"
      },
      {
        "txt": "public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() {"
      },
      {
        "txt": "return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this;"
      },
      {
        "txt": "} @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; }"
      },
      {
        "txt": "@Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; }"
      },
      {
        "txt": "@Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c;"
      },
      {
        "txt": "} } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException {"
      },
      {
        "txt": "if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override"
      },
      {
        "txt": "public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));"
      },
      {
        "txt": "@Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { <extra_id_0> } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);"
      },
      {
        "txt": "} @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else {"
      },
      {
        "txt": "_objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len];"
      },
      {
        "txt": "System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p);"
      },
      {
        "txt": "} switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());"
      },
      {
        "txt": "} else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER:"
      },
      {
        "txt": "writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else {"
      },
      {
        "txt": "switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); }"
      },
      {
        "txt": "} break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull();"
      },
      {
        "txt": "break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException"
      },
      {
        "txt": "{ JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break;"
      },
      {
        "txt": "case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); }"
      },
      {
        "txt": "} private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } }"
      },
      {
        "txt": "protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0"
      },
      {
        "txt": "} } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); }"
      },
      {
        "txt": "protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext;"
      },
      {
        "txt": "protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read"
      },
      {
        "txt": "_codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override"
      },
      {
        "txt": "public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null;"
      },
      {
        "txt": "Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException {"
      },
      {
        "txt": "if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0;"
      },
      {
        "txt": "_segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); }"
      },
      {
        "txt": "} return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr;"
      },
      {
        "txt": "Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText()"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) {"
      },
      {
        "txt": "return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); }"
      },
      {
        "txt": "} @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length();"
      },
      {
        "txt": "} @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override"
      },
      {
        "txt": "public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue());"
      },
      {
        "txt": "case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); }"
      },
      {
        "txt": "@Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); }"
      },
      {
        "txt": "return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue();"
      },
      {
        "txt": "if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override"
      },
      {
        "txt": "public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str);"
      },
      {
        "txt": "} return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override"
      },
      {
        "txt": "public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); }"
      },
      {
        "txt": "final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); }"
      },
      {
        "txt": "_decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length;"
      },
      {
        "txt": "} return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() {"
      },
      {
        "txt": "return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException {"
      },
      {
        "txt": "_throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values();"
      },
      {
        "txt": "System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes;"
      },
      {
        "txt": "if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) {"
      },
      {
        "txt": "l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() {"
      },
      {
        "txt": "return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType);"
      },
      {
        "txt": "return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); }"
      },
      {
        "txt": "if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); }"
      },
      {
        "txt": "private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1474,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 783,
    "end-bug-line": 783,
    "bug": "_append(JsonToken.VALUE_NUMBER_FLOAT, dec);",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_FLOAT, dec);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator"
      },
      {
        "txt": "{ protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first;"
      },
      {
        "txt": "protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); }"
      },
      {
        "txt": "public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "} public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment();"
      },
      {
        "txt": "_appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this;"
      },
      {
        "txt": "} @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec)"
      },
      {
        "txt": "{ return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() {"
      },
      {
        "txt": "if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId();"
      },
      {
        "txt": "} if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this;"
      },
      {
        "txt": "} public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0;"
      },
      {
        "txt": "segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id);"
      },
      {
        "txt": "} id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break;"
      },
      {
        "txt": "case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME:"
      },
      {
        "txt": "{ Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING:"
      },
      {
        "txt": "{ Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT:"
      },
      {
        "txt": "{ Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n);"
      },
      {
        "txt": "} else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue());"
      },
      {
        "txt": "} else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");"
      },
      {
        "txt": "} } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL:"
      },
      {
        "txt": "gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); }"
      },
      {
        "txt": "} break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {"
      },
      {
        "txt": "copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);"
      },
      {
        "txt": "} writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken();"
      },
      {
        "txt": "if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; }"
      },
      {
        "txt": "if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) {"
      },
      {
        "txt": "sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask();"
      },
      {
        "txt": "return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0;"
      },
      {
        "txt": "} @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; }"
      },
      {
        "txt": "@Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override"
      },
      {
        "txt": "public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override"
      },
      {
        "txt": "public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext();"
      },
      {
        "txt": "} @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name);"
      },
      {
        "txt": "} @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override"
      },
      {
        "txt": "public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));"
      },
      {
        "txt": "} @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); }"
      },
      {
        "txt": "@Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException {"
      },
      {
        "txt": "} @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { <extra_id_0> } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull();"
      },
      {
        "txt": "if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); }"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException"
      },
      {
        "txt": "{ if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) {"
      },
      {
        "txt": "writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override"
      },
      {
        "txt": "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) {"
      },
      {
        "txt": "_typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException"
      },
      {
        "txt": "{ if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break;"
      },
      {
        "txt": "case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT:"
      },
      {
        "txt": "writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break;"
      },
      {
        "txt": "default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName());"
      },
      {
        "txt": "t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break;"
      },
      {
        "txt": "default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override"
      },
      {
        "txt": "protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds;"
      },
      {
        "txt": "protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) {"
      },
      {
        "txt": "super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) {"
      },
      {
        "txt": "_location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr);"
      },
      {
        "txt": "} @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException {"
      },
      {
        "txt": "if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null;"
      },
      {
        "txt": "int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; }"
      },
      {
        "txt": "@Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; }"
      },
      {
        "txt": "@Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name)"
      },
      {
        "txt": "{ JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); }"
      },
      {
        "txt": "} @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; }"
      },
      {
        "txt": "return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString();"
      },
      {
        "txt": "default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override"
      },
      {
        "txt": "public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; }"
      },
      {
        "txt": "@Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); }"
      },
      {
        "txt": "return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) {"
      },
      {
        "txt": "case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override"
      },
      {
        "txt": "public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override"
      },
      {
        "txt": "public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT"
      },
      {
        "txt": "return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) {"
      },
      {
        "txt": "String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \""
      },
      {
        "txt": "+value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; }"
      },
      {
        "txt": "@Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } }"
      },
      {
        "txt": "if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100);"
      },
      {
        "txt": "} else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant);"
      },
      {
        "txt": "if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; }"
      },
      {
        "txt": "@Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() {"
      },
      {
        "txt": "return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); }"
      },
      {
        "txt": "} @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX;"
      },
      {
        "txt": "static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { }"
      },
      {
        "txt": "public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index)"
      },
      {
        "txt": "{ long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index];"
      },
      {
        "txt": "} public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) {"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType;"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); }"
      },
      {
        "txt": "if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); }"
      },
      {
        "txt": "public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1475,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 792,
    "end-bug-line": 792,
    "bug": "_append(JsonToken.VALUE_NUMBER_INT, v);",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_INT, v);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*;"
      },
      {
        "txt": "public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds;"
      },
      {
        "txt": "protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) {"
      },
      {
        "txt": "this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds;"
      },
      {
        "txt": "_hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES;"
      },
      {
        "txt": "_writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) {"
      },
      {
        "txt": "_forceBigDecimal = b; return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec);"
      },
      {
        "txt": "} public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p;"
      },
      {
        "txt": "} public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException {"
      },
      {
        "txt": "if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p);"
      },
      {
        "txt": "} return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) {"
      },
      {
        "txt": "if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr);"
      },
      {
        "txt": "if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT:"
      },
      {
        "txt": "gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray();"
      },
      {
        "txt": "break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } }"
      },
      {
        "txt": "break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } }"
      },
      {
        "txt": "break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n);"
      },
      {
        "txt": "} else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr);"
      },
      {
        "txt": "if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n);"
      },
      {
        "txt": "} else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else {"
      },
      {
        "txt": "gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException"
      },
      {
        "txt": "{ if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);"
      },
      {
        "txt": "if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() {"
      },
      {
        "txt": "final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t;"
      },
      {
        "txt": "try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); }"
      },
      {
        "txt": "sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); }"
      },
      {
        "txt": "++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) {"
      },
      {
        "txt": "Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override"
      },
      {
        "txt": "public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override"
      },
      {
        "txt": "public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask;"
      },
      {
        "txt": "return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this;"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override"
      },
      {
        "txt": "public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c;"
      },
      {
        "txt": "} } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override"
      },
      {
        "txt": "public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len));"
      },
      {
        "txt": "} @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override"
      },
      {
        "txt": "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); }"
      },
      {
        "txt": "@Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); }"
      },
      {
        "txt": "@Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec);"
      },
      {
        "txt": "} @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { <extra_id_0> } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); }"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); }"
      },
      {
        "txt": "@Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);"
      },
      {
        "txt": "return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException"
      },
      {
        "txt": "{ if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }"
      },
      {
        "txt": "} @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {"
      },
      {
        "txt": "throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; }"
      },
      {
        "txt": "@Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break;"
      },
      {
        "txt": "case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME:"
      },
      {
        "txt": "writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT:"
      },
      {
        "txt": "switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); }"
      },
      {
        "txt": "break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT:"
      },
      {
        "txt": "writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break;"
      },
      {
        "txt": "case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp);"
      },
      {
        "txt": "} writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true;"
      },
      {
        "txt": "} if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value)"
      },
      {
        "txt": "{ Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; }"
      },
      {
        "txt": "} @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds;"
      },
      {
        "txt": "protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds,"
      },
      {
        "txt": "boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);"
      },
      {
        "txt": "} public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() {"
      },
      {
        "txt": "return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next();"
      },
      {
        "txt": "} return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override"
      },
      {
        "txt": "public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } }"
      },
      {
        "txt": "_currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT"
      },
      {
        "txt": "|| _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() {"
      },
      {
        "txt": "return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); }"
      },
      {
        "txt": "@Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) {"
      },
      {
        "txt": "throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) {"
      },
      {
        "txt": "return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray();"
      },
      {
        "txt": "} @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() {"
      },
      {
        "txt": "return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) {"
      },
      {
        "txt": "return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n;"
      },
      {
        "txt": "} switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue());"
      },
      {
        "txt": "} @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override"
      },
      {
        "txt": "public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue();"
      },
      {
        "txt": "} @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER;"
      },
      {
        "txt": "if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value;"
      },
      {
        "txt": "} if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null;"
      },
      {
        "txt": "} throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); }"
      },
      {
        "txt": "return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob;"
      },
      {
        "txt": "} } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder;"
      },
      {
        "txt": "if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException"
      },
      {
        "txt": "{ byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); }"
      },
      {
        "txt": "@Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment {"
      },
      {
        "txt": "public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];"
      },
      {
        "txt": "protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix];"
      },
      {
        "txt": "} public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; }"
      },
      {
        "txt": "public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) {"
      },
      {
        "txt": "_nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1476,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 801,
    "end-bug-line": 801,
    "bug": "_append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);",
    "fix": "_appendValue(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec;"
      },
      {
        "txt": "protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId;"
      },
      {
        "txt": "protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec;"
      },
      {
        "txt": "_generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null);"
      },
      {
        "txt": "} public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId();"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() {"
      },
      {
        "txt": "return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); }"
      },
      {
        "txt": "public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); }"
      },
      {
        "txt": "return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId();"
      },
      {
        "txt": "} _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException {"
      },
      {
        "txt": "Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds());"
      },
      {
        "txt": "} JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) {"
      },
      {
        "txt": "gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break;"
      },
      {
        "txt": "case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) {"
      },
      {
        "txt": "gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) {"
      },
      {
        "txt": "gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); }"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) {"
      },
      {
        "txt": "gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break;"
      },
      {
        "txt": "case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT:"
      },
      {
        "txt": "{ Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; }"
      },
      {
        "txt": "JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");"
      },
      {
        "txt": "JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb);"
      },
      {
        "txt": "} if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')');"
      },
      {
        "txt": "} } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); }"
      },
      {
        "txt": "sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1);"
      },
      {
        "txt": "if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override"
      },
      {
        "txt": "public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() {"
      },
      {
        "txt": "return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this;"
      },
      {
        "txt": "} @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; }"
      },
      {
        "txt": "@Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; }"
      },
      {
        "txt": "@Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c;"
      },
      {
        "txt": "} } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException {"
      },
      {
        "txt": "if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override"
      },
      {
        "txt": "public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));"
      },
      {
        "txt": "} @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override"
      },
      {
        "txt": "public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) {"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { <extra_id_0> } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override"
      },
      {
        "txt": "} @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else {"
      },
      {
        "txt": "_objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len];"
      },
      {
        "txt": "System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p);"
      },
      {
        "txt": "} switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());"
      },
      {
        "txt": "} else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER:"
      },
      {
        "txt": "writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else {"
      },
      {
        "txt": "switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); }"
      },
      {
        "txt": "} break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull();"
      },
      {
        "txt": "break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException"
      },
      {
        "txt": "{ JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break;"
      },
      {
        "txt": "case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); }"
      },
      {
        "txt": "} private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } }"
      },
      {
        "txt": "protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0"
      },
      {
        "txt": "} } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); }"
      },
      {
        "txt": "protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext;"
      },
      {
        "txt": "protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read"
      },
      {
        "txt": "_codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override"
      },
      {
        "txt": "public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null;"
      },
      {
        "txt": "Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException {"
      },
      {
        "txt": "if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0;"
      },
      {
        "txt": "_segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); }"
      },
      {
        "txt": "} return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr;"
      },
      {
        "txt": "Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText()"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) {"
      },
      {
        "txt": "return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); }"
      },
      {
        "txt": "} @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length();"
      },
      {
        "txt": "} @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override"
      },
      {
        "txt": "public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue());"
      },
      {
        "txt": "case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); }"
      },
      {
        "txt": "@Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); }"
      },
      {
        "txt": "return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue();"
      },
      {
        "txt": "if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override"
      },
      {
        "txt": "public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str);"
      },
      {
        "txt": "} return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override"
      },
      {
        "txt": "public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); }"
      },
      {
        "txt": "final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); }"
      },
      {
        "txt": "_decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length;"
      },
      {
        "txt": "} return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() {"
      },
      {
        "txt": "return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException {"
      },
      {
        "txt": "_throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values();"
      },
      {
        "txt": "System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes;"
      },
      {
        "txt": "if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) {"
      },
      {
        "txt": "l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() {"
      },
      {
        "txt": "return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType);"
      },
      {
        "txt": "return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode;"
      },
      {
        "txt": "assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); }"
      },
      {
        "txt": "if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); }"
      },
      {
        "txt": "private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1477,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 806,
    "end-bug-line": 806,
    "bug": "_append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);",
    "fix": "_appendValue(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated"
      },
      {
        "txt": "public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec();"
      },
      {
        "txt": "_generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); }"
      },
      {
        "txt": "public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() {"
      },
      {
        "txt": "return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation());"
      },
      {
        "txt": "return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException"
      },
      {
        "txt": "{ if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) {"
      },
      {
        "txt": "copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds());"
      },
      {
        "txt": "while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) {"
      },
      {
        "txt": "Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) {"
      },
      {
        "txt": "case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY:"
      },
      {
        "txt": "gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); }"
      },
      {
        "txt": "} break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); }"
      },
      {
        "txt": "} break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) {"
      },
      {
        "txt": "gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: {"
      },
      {
        "txt": "Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) {"
      },
      {
        "txt": "gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE:"
      },
      {
        "txt": "gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen);"
      },
      {
        "txt": "} else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } }"
      },
      {
        "txt": "public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p);"
      },
      {
        "txt": "} while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString()"
      },
      {
        "txt": "{ final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) {"
      },
      {
        "txt": "JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \");"
      },
      {
        "txt": "} sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe);"
      },
      {
        "txt": "} ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb)"
      },
      {
        "txt": "{ Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } }"
      },
      {
        "txt": "@Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; }"
      },
      {
        "txt": "@Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) {"
      },
      {
        "txt": "_generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc;"
      },
      {
        "txt": "return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; }"
      },
      {
        "txt": "@Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override"
      },
      {
        "txt": "public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); }"
      },
      {
        "txt": "@Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));"
      },
      {
        "txt": "} @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));"
      },
      {
        "txt": "} @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); }"
      },
      {
        "txt": "@Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { <extra_id_0> } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override"
      },
      {
        "txt": "} @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override"
      },
      {
        "txt": "public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node);"
      },
      {
        "txt": "} } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override"
      },
      {
        "txt": "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue());"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break;"
      },
      {
        "txt": "case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1;"
      },
      {
        "txt": "} } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec;"
      },
      {
        "txt": "protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec,"
      },
      {
        "txt": "boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds;"
      },
      {
        "txt": "_hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0;"
      },
      {
        "txt": "seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } }"
      },
      {
        "txt": "@Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; }"
      },
      {
        "txt": "} _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override"
      },
      {
        "txt": "public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override"
      },
      {
        "txt": "public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName();"
      },
      {
        "txt": "} @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name);"
      },
      {
        "txt": "} catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText();"
      },
      {
        "txt": "return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override"
      },
      {
        "txt": "public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; }"
      },
      {
        "txt": "if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) {"
      },
      {
        "txt": "return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: }"
      },
      {
        "txt": "return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); }"
      },
      {
        "txt": "@Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;"
      },
      {
        "txt": "if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) {"
      },
      {
        "txt": "return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) {"
      },
      {
        "txt": "return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject();"
      },
      {
        "txt": "} return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) {"
      },
      {
        "txt": "return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; }"
      },
      {
        "txt": "ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override"
      },
      {
        "txt": "public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr);"
      },
      {
        "txt": "} @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException {"
      },
      {
        "txt": "if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment"
      },
      {
        "txt": "{ public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes;"
      },
      {
        "txt": "protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF;"
      },
      {
        "txt": "return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix;"
      },
      {
        "txt": "} public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType,"
      },
      {
        "txt": "Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } }"
      },
      {
        "txt": "public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1478,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 811,
    "end-bug-line": 811,
    "bug": "_append(JsonToken.VALUE_NULL);",
    "fix": "_appendValue(JsonToken.VALUE_NULL);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator {"
      },
      {
        "txt": "protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last;"
      },
      {
        "txt": "protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)"
      },
      {
        "txt": "{ _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; }"
      },
      {
        "txt": "public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; }"
      },
      {
        "txt": "@Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) {"
      },
      {
        "txt": "return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) {"
      },
      {
        "txt": "return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); }"
      },
      {
        "txt": "if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; }"
      },
      {
        "txt": "public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next();"
      },
      {
        "txt": "if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); }"
      },
      {
        "txt": "id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT:"
      },
      {
        "txt": "gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: {"
      },
      {
        "txt": "Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: {"
      },
      {
        "txt": "Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: {"
      },
      {
        "txt": "Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else {"
      },
      {
        "txt": "gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) {"
      },
      {
        "txt": "gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); }"
      },
      {
        "txt": "} break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull();"
      },
      {
        "txt": "break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } }"
      },
      {
        "txt": "break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p);"
      },
      {
        "txt": "return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); }"
      },
      {
        "txt": "writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \");"
      },
      {
        "txt": "sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break;"
      },
      {
        "txt": "if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('(');"
      },
      {
        "txt": "sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) {"
      },
      {
        "txt": "sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');"
      },
      {
        "txt": "} Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this;"
      },
      {
        "txt": "} @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; }"
      },
      {
        "txt": "@Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override"
      },
      {
        "txt": "public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; }"
      },
      {
        "txt": "@Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException {"
      },
      {
        "txt": "_closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); }"
      },
      {
        "txt": "@Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override"
      },
      {
        "txt": "public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent();"
      },
      {
        "txt": "if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); }"
      },
      {
        "txt": "@Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException {"
      },
      {
        "txt": "if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); }"
      },
      {
        "txt": "@Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));"
      },
      {
        "txt": "} @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override"
      },
      {
        "txt": "public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));"
      },
      {
        "txt": "} @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override"
      },
      {
        "txt": "public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { <extra_id_0> } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull();"
      },
      {
        "txt": "return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException"
      },
      {
        "txt": "{ byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override"
      },
      {
        "txt": "public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id;"
      },
      {
        "txt": "_hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException {"
      },
      {
        "txt": "if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break;"
      },
      {
        "txt": "case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING:"
      },
      {
        "txt": "if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue());"
      },
      {
        "txt": "break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) {"
      },
      {
        "txt": "writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default:"
      },
      {
        "txt": "writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } }"
      },
      {
        "txt": "@Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken();"
      },
      {
        "txt": "} if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple:"
      },
      {
        "txt": "copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true;"
      },
      {
        "txt": "} } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment;"
      },
      {
        "txt": "protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0);"
      },
      {
        "txt": "_segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l;"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); }"
      },
      {
        "txt": "@Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null;"
      },
      {
        "txt": "if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) {"
      },
      {
        "txt": "_parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override"
      },
      {
        "txt": "public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override"
      },
      {
        "txt": "public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) {"
      },
      {
        "txt": "JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } }"
      },
      {
        "txt": "@Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString();"
      },
      {
        "txt": "} if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default:"
      },
      {
        "txt": "return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override"
      },
      {
        "txt": "public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue());"
      },
      {
        "txt": "} @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT:"
      },
      {
        "txt": "case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null;"
      },
      {
        "txt": "} @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value;"
      },
      {
        "txt": "if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName());"
      },
      {
        "txt": "} @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else {"
      },
      {
        "txt": "_byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) {"
      },
      {
        "txt": "out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr);"
      },
      {
        "txt": "} protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } }"
      },
      {
        "txt": "@Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static {"
      },
      {
        "txt": "TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index)"
      },
      {
        "txt": "{ long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) {"
      },
      {
        "txt": "long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; }"
      },
      {
        "txt": "public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) {"
      },
      {
        "txt": "_nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1479,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 829,
    "end-bug-line": 829,
    "bug": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value);",
    "fix": "_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt;"
      },
      {
        "txt": "protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {"
      },
      {
        "txt": "_objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) {"
      },
      {
        "txt": "this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId();"
      },
      {
        "txt": "_hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);"
      },
      {
        "txt": "} public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0);"
      },
      {
        "txt": "} return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) {"
      },
      {
        "txt": "_hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException"
      },
      {
        "txt": "{ Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break;"
      },
      {
        "txt": "hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr);"
      },
      {
        "txt": "if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr);"
      },
      {
        "txt": "if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue());"
      },
      {
        "txt": "} } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n);"
      },
      {
        "txt": "} else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } }"
      },
      {
        "txt": "break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break;"
      },
      {
        "txt": "case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this;"
      },
      {
        "txt": "} JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject();"
      },
      {
        "txt": "return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");"
      },
      {
        "txt": "sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) {"
      },
      {
        "txt": "_appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName());"
      },
      {
        "txt": "sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");"
      },
      {
        "txt": "} sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); }"
      },
      {
        "txt": "Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; }"
      },
      {
        "txt": "@Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override"
      },
      {
        "txt": "public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() {"
      },
      {
        "txt": "return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override"
      },
      {
        "txt": "public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override"
      },
      {
        "txt": "public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override"
      },
      {
        "txt": "public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override"
      },
      {
        "txt": "public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); }"
      },
      {
        "txt": "@Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); }"
      },
      {
        "txt": "@Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException {"
      },
      {
        "txt": "if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); }"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException"
      },
      {
        "txt": "if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { <extra_id_0> return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value);"
      },
      {
        "txt": "} else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return;"
      },
      {
        "txt": "} if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {"
      },
      {
        "txt": "byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() {"
      },
      {
        "txt": "return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) {"
      },
      {
        "txt": "writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break;"
      },
      {
        "txt": "case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue());"
      },
      {
        "txt": "} else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue());"
      },
      {
        "txt": "} } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL:"
      },
      {
        "txt": "writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override"
      },
      {
        "txt": "public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); }"
      },
      {
        "txt": "if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray();"
      },
      {
        "txt": "break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp);"
      },
      {
        "txt": "} } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; }"
      },
      {
        "txt": "} protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next;"
      },
      {
        "txt": "_appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");"
      },
      {
        "txt": "} protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr;"
      },
      {
        "txt": "protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg;"
      },
      {
        "txt": "_segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; }"
      },
      {
        "txt": "@Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException {"
      },
      {
        "txt": "if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override"
      },
      {
        "txt": "public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "_segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString();"
      },
      {
        "txt": "_parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null);"
      },
      {
        "txt": "} } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "_segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() {"
      },
      {
        "txt": "if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext;"
      },
      {
        "txt": "if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override"
      },
      {
        "txt": "public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); }"
      },
      {
        "txt": "if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString();"
      },
      {
        "txt": "} } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText();"
      },
      {
        "txt": "return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); }"
      },
      {
        "txt": "@Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG:"
      },
      {
        "txt": "return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue();"
      },
      {
        "txt": "} @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue();"
      },
      {
        "txt": "} return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException {"
      },
      {
        "txt": "Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; }"
      },
      {
        "txt": "@Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) {"
      },
      {
        "txt": "return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); }"
      },
      {
        "txt": "@Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");"
      },
      {
        "txt": "} final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset();"
      },
      {
        "txt": "} _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length);"
      },
      {
        "txt": "return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() {"
      },
      {
        "txt": "return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); }"
      },
      {
        "txt": "protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override"
      },
      {
        "txt": "protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16];"
      },
      {
        "txt": "JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) {"
      },
      {
        "txt": "long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes;"
      },
      {
        "txt": "if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; }"
      },
      {
        "txt": "public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment();"
      },
      {
        "txt": "_next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); }"
      },
      {
        "txt": "_tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId);"
      },
      {
        "txt": "} if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));"
      },
      {
        "txt": "} private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1480,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 837,
    "end-bug-line": 837,
    "bug": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value);",
    "fix": "_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds;"
      },
      {
        "txt": "protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext;"
      },
      {
        "txt": "@Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment();"
      },
      {
        "txt": "_appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) {"
      },
      {
        "txt": "_objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);"
      },
      {
        "txt": "} public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser()"
      },
      {
        "txt": "{ return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);"
      },
      {
        "txt": "p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser();"
      },
      {
        "txt": "while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds;"
      },
      {
        "txt": "boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break;"
      },
      {
        "txt": "if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } }"
      },
      {
        "txt": "switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break;"
      },
      {
        "txt": "case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob);"
      },
      {
        "txt": "} } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob);"
      },
      {
        "txt": "} } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n);"
      },
      {
        "txt": "} else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "{ Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull();"
      },
      {
        "txt": "} else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break;"
      },
      {
        "txt": "case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) {"
      },
      {
        "txt": "((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } }"
      },
      {
        "txt": "} public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do {"
      },
      {
        "txt": "copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;"
      },
      {
        "txt": "while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) {"
      },
      {
        "txt": "sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur"
      },
      {
        "txt": "throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); }"
      },
      {
        "txt": "private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); }"
      },
      {
        "txt": "} @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this;"
      },
      {
        "txt": "} @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override"
      },
      {
        "txt": "public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) {"
      },
      {
        "txt": "_objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true;"
      },
      {
        "txt": "} @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override"
      },
      {
        "txt": "public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent();"
      },
      {
        "txt": "if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); }"
      },
      {
        "txt": "@Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override"
      },
      {
        "txt": "public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue());"
      },
      {
        "txt": "} @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override"
      },
      {
        "txt": "public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); }"
      },
      {
        "txt": "} @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); }"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); }"
      },
      {
        "txt": "@Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v);"
      },
      {
        "txt": "} } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); }"
      },
      {
        "txt": "@Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return;"
      },
      {
        "txt": "Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { <extra_id_0> } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException"
      },
      {
        "txt": "@Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else {"
      },
      {
        "txt": "_objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); }"
      },
      {
        "txt": "@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id;"
      },
      {
        "txt": "_hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT:"
      },
      {
        "txt": "writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray();"
      },
      {
        "txt": "break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); }"
      },
      {
        "txt": "break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default:"
      },
      {
        "txt": "writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue());"
      },
      {
        "txt": "break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE:"
      },
      {
        "txt": "writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject());"
      },
      {
        "txt": "break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) {"
      },
      {
        "txt": "case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) {"
      },
      {
        "txt": "copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException {"
      },
      {
        "txt": "if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value)"
      },
      {
        "txt": "{ Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; }"
      },
      {
        "txt": "} protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next;"
      },
      {
        "txt": "_appendAt = 1; } } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase {"
      },
      {
        "txt": "protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null;"
      },
      {
        "txt": "public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds;"
      },
      {
        "txt": "_hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; }"
      },
      {
        "txt": "@Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; }"
      },
      {
        "txt": "} @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null;"
      },
      {
        "txt": "} } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; }"
      },
      {
        "txt": "@Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name);"
      },
      {
        "txt": "return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); }"
      },
      {
        "txt": "@Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); }"
      },
      {
        "txt": "return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try {"
      },
      {
        "txt": "ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) {"
      },
      {
        "txt": "case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; }"
      },
      {
        "txt": "@Override public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n;"
      },
      {
        "txt": "} if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue();"
      },
      {
        "txt": "if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default:"
      },
      {
        "txt": "} return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue();"
      },
      {
        "txt": "} @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override"
      },
      {
        "txt": "public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE;"
      },
      {
        "txt": "if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject();"
      },
      {
        "txt": "if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); }"
      },
      {
        "txt": "if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {"
      },
      {
        "txt": "return _currentObject(); } return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject();"
      },
      {
        "txt": "if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null;"
      },
      {
        "txt": "} ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); }"
      },
      {
        "txt": "@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; }"
      },
      {
        "txt": "@Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() {"
      },
      {
        "txt": "return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException"
      },
      {
        "txt": "{ if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } }"
      },
      {
        "txt": "protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next;"
      },
      {
        "txt": "protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); }"
      },
      {
        "txt": "int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF;"
      },
      {
        "txt": "return ix; } public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; }"
      },
      {
        "txt": "public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next;"
      },
      {
        "txt": "} public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next;"
      },
      {
        "txt": "} public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId);"
      },
      {
        "txt": "return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); }"
      },
      {
        "txt": "private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); }"
      },
      {
        "txt": "} public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1481,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 853,
    "end-bug-line": 853,
    "bug": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, node);",
    "fix": "_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, node);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*;"
      },
      {
        "txt": "import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer"
      },
      {
        "txt": "extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal;"
      },
      {
        "txt": "protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false);"
      },
      {
        "txt": "} public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds;"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b;"
      },
      {
        "txt": "return this; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); }"
      },
      {
        "txt": "public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; }"
      },
      {
        "txt": "public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) {"
      },
      {
        "txt": "_hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); }"
      },
      {
        "txt": "return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) {"
      },
      {
        "txt": "gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) {"
      },
      {
        "txt": "gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) {"
      },
      {
        "txt": "gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else {"
      },
      {
        "txt": "throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value);"
      },
      {
        "txt": "} } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {"
      },
      {
        "txt": "if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) {"
      },
      {
        "txt": "throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100;"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try {"
      },
      {
        "txt": "t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString());"
      },
      {
        "txt": "if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count;"
      },
      {
        "txt": "} if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1);"
      },
      {
        "txt": "if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) {"
      },
      {
        "txt": "_generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) {"
      },
      {
        "txt": "return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this;"
      },
      {
        "txt": "} @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; }"
      },
      {
        "txt": "@Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ }"
      },
      {
        "txt": "@Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY);"
      },
      {
        "txt": "_writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; }"
      },
      {
        "txt": "} @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException {"
      },
      {
        "txt": "if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); }"
      },
      {
        "txt": "@Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override"
      },
      {
        "txt": "public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));"
      },
      {
        "txt": "} @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override"
      },
      {
        "txt": "public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); }"
      },
      {
        "txt": "} @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override"
      },
      {
        "txt": "public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL);"
      },
      {
        "txt": "} @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override"
      },
      {
        "txt": "{ if (node == null) { writeNull(); return; } if (_objectCodec == null) { <extra_id_0> } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException"
      },
      {
        "txt": "@Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException();"
      },
      {
        "txt": "} @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override"
      },
      {
        "txt": "public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT:"
      },
      {
        "txt": "writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName());"
      },
      {
        "txt": "break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) {"
      },
      {
        "txt": "case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue());"
      },
      {
        "txt": "break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE:"
      },
      {
        "txt": "writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\");"
      },
      {
        "txt": "} } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); }"
      },
      {
        "txt": "writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) {"
      },
      {
        "txt": "copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject();"
      },
      {
        "txt": "break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; }"
      },
      {
        "txt": "if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "@Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds)"
      },
      {
        "txt": "{ super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); }"
      },
      {
        "txt": "public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;"
      },
      {
        "txt": "} public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); }"
      },
      {
        "txt": "return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr);"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException {"
      },
      {
        "txt": "if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location;"
      },
      {
        "txt": "} @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override"
      },
      {
        "txt": "public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e);"
      },
      {
        "txt": "} } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob;"
      },
      {
        "txt": "} return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject();"
      },
      {
        "txt": "return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); }"
      },
      {
        "txt": "@Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false;"
      },
      {
        "txt": "} @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger();"
      },
      {
        "txt": "} return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; }"
      },
      {
        "txt": "switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); }"
      },
      {
        "txt": "@Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); }"
      },
      {
        "txt": "@Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT;"
      },
      {
        "txt": "if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; }"
      },
      {
        "txt": "if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; }"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; }"
      },
      {
        "txt": "} if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) {"
      },
      {
        "txt": "_byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {"
      },
      {
        "txt": "byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override"
      },
      {
        "txt": "public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");"
      },
      {
        "txt": "} } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16;"
      },
      {
        "txt": "private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds;"
      },
      {
        "txt": "public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; }"
      },
      {
        "txt": "public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) {"
      },
      {
        "txt": "return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType;"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>();"
      },
      {
        "txt": "} if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));"
      },
      {
        "txt": "} public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1482,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 1091,
    "end-bug-line": 1091,
    "bug": "",
    "fix": "protected final void _appendValue(JsonToken type) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt;"
      },
      {
        "txt": "protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {"
      },
      {
        "txt": "_objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) {"
      },
      {
        "txt": "this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId();"
      },
      {
        "txt": "_hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);"
      },
      {
        "txt": "} public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0);"
      },
      {
        "txt": "} return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) {"
      },
      {
        "txt": "_hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException"
      },
      {
        "txt": "{ Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break;"
      },
      {
        "txt": "hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr);"
      },
      {
        "txt": "if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr);"
      },
      {
        "txt": "if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue());"
      },
      {
        "txt": "} } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n);"
      },
      {
        "txt": "} else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } }"
      },
      {
        "txt": "break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break;"
      },
      {
        "txt": "case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this;"
      },
      {
        "txt": "} JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject();"
      },
      {
        "txt": "return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");"
      },
      {
        "txt": "sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) {"
      },
      {
        "txt": "_appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName());"
      },
      {
        "txt": "sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");"
      },
      {
        "txt": "} sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); }"
      },
      {
        "txt": "Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; }"
      },
      {
        "txt": "@Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override"
      },
      {
        "txt": "public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() {"
      },
      {
        "txt": "return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override"
      },
      {
        "txt": "public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override"
      },
      {
        "txt": "public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override"
      },
      {
        "txt": "public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override"
      },
      {
        "txt": "public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); }"
      },
      {
        "txt": "@Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); }"
      },
      {
        "txt": "@Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException {"
      },
      {
        "txt": "if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); }"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException"
      },
      {
        "txt": "{ if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) {"
      },
      {
        "txt": "writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override"
      },
      {
        "txt": "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) {"
      },
      {
        "txt": "_typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException"
      },
      {
        "txt": "{ if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break;"
      },
      {
        "txt": "case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT:"
      },
      {
        "txt": "writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break;"
      },
      {
        "txt": "default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName());"
      },
      {
        "txt": "t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break;"
      },
      {
        "txt": "default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value);"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } <extra_id_0> protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) {"
      },
      {
        "txt": ": _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment;"
      },
      {
        "txt": "protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0);"
      },
      {
        "txt": "_segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l;"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); }"
      },
      {
        "txt": "@Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null;"
      },
      {
        "txt": "if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) {"
      },
      {
        "txt": "_parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override"
      },
      {
        "txt": "public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override"
      },
      {
        "txt": "public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) {"
      },
      {
        "txt": "JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } }"
      },
      {
        "txt": "@Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString();"
      },
      {
        "txt": "} if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default:"
      },
      {
        "txt": "return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override"
      },
      {
        "txt": "public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue());"
      },
      {
        "txt": "} @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT:"
      },
      {
        "txt": "case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null;"
      },
      {
        "txt": "} @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value;"
      },
      {
        "txt": "if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName());"
      },
      {
        "txt": "} @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else {"
      },
      {
        "txt": "_byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) {"
      },
      {
        "txt": "out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr);"
      },
      {
        "txt": "} protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } }"
      },
      {
        "txt": "@Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static {"
      },
      {
        "txt": "TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index)"
      },
      {
        "txt": "{ long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) {"
      },
      {
        "txt": "long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; }"
      },
      {
        "txt": "public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) {"
      },
      {
        "txt": "_nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1483,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 1098,
    "end-bug-line": 1098,
    "bug": "",
    "fix": "protected final void _appendValue(JsonToken type, Object value) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt;"
      },
      {
        "txt": "protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {"
      },
      {
        "txt": "_objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) {"
      },
      {
        "txt": "this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId();"
      },
      {
        "txt": "_hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);"
      },
      {
        "txt": "} public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0);"
      },
      {
        "txt": "} return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) {"
      },
      {
        "txt": "_hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException"
      },
      {
        "txt": "{ Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break;"
      },
      {
        "txt": "hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr);"
      },
      {
        "txt": "if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr);"
      },
      {
        "txt": "if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr);"
      },
      {
        "txt": "if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue());"
      },
      {
        "txt": "} } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n);"
      },
      {
        "txt": "} else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } }"
      },
      {
        "txt": "break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break;"
      },
      {
        "txt": "case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this;"
      },
      {
        "txt": "} JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject();"
      },
      {
        "txt": "return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");"
      },
      {
        "txt": "sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) {"
      },
      {
        "txt": "_appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName());"
      },
      {
        "txt": "sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");"
      },
      {
        "txt": "} sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); }"
      },
      {
        "txt": "Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; }"
      },
      {
        "txt": "@Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override"
      },
      {
        "txt": "public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() {"
      },
      {
        "txt": "return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override"
      },
      {
        "txt": "public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override"
      },
      {
        "txt": "public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException"
      },
      {
        "txt": "{ _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) {"
      },
      {
        "txt": "_writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override"
      },
      {
        "txt": "public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override"
      },
      {
        "txt": "public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); }"
      },
      {
        "txt": "@Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); }"
      },
      {
        "txt": "@Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException {"
      },
      {
        "txt": "if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); }"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException"
      },
      {
        "txt": "{ if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) {"
      },
      {
        "txt": "writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override"
      },
      {
        "txt": "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) {"
      },
      {
        "txt": "_typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException"
      },
      {
        "txt": "{ if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject();"
      },
      {
        "txt": "break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break;"
      },
      {
        "txt": "case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT:"
      },
      {
        "txt": "writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break;"
      },
      {
        "txt": "default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false);"
      },
      {
        "txt": "break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName());"
      },
      {
        "txt": "t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break;"
      },
      {
        "txt": "default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt;"
      },
      {
        "txt": "} else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value);"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } <extra_id_0> protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) {"
      },
      {
        "txt": ": _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment;"
      },
      {
        "txt": "protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0);"
      },
      {
        "txt": "_segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l;"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); }"
      },
      {
        "txt": "@Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null;"
      },
      {
        "txt": "if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) {"
      },
      {
        "txt": "_parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override"
      },
      {
        "txt": "public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override"
      },
      {
        "txt": "public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) {"
      },
      {
        "txt": "JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } }"
      },
      {
        "txt": "@Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString();"
      },
      {
        "txt": "} if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default:"
      },
      {
        "txt": "return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override"
      },
      {
        "txt": "public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue());"
      },
      {
        "txt": "} @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT:"
      },
      {
        "txt": "case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null;"
      },
      {
        "txt": "} @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value;"
      },
      {
        "txt": "if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName());"
      },
      {
        "txt": "} @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else {"
      },
      {
        "txt": "_byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) {"
      },
      {
        "txt": "out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr);"
      },
      {
        "txt": "} protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } }"
      },
      {
        "txt": "@Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static {"
      },
      {
        "txt": "TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index)"
      },
      {
        "txt": "{ long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) {"
      },
      {
        "txt": "long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; }"
      },
      {
        "txt": "public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) {"
      },
      {
        "txt": "_nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  }
]