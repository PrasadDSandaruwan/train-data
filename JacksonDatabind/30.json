[
  {
    "id": 1456,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
    "start-bug-line": 2510,
    "end-bug-line": 2510,
    "bug": "",
    "fix": "if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.*; import java.lang.reflect.Type; import java.net.URL; import java.text.DateFormat; import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.CharacterEscapes;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.io.SegmentedStringWriter; import com.fasterxml.jackson.core.type.ResolvedType; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.core.util.*; import com.fasterxml.jackson.databind.cfg.BaseSettings; import com.fasterxml.jackson.databind.cfg.ContextAttributes; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.deser.*; import com.fasterxml.jackson.databind.introspect.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper; import com.fasterxml.jackson.databind.jsontype.*; import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver; import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder; import com.fasterxml.jackson.databind.node.*; import com.fasterxml.jackson.databind.ser.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.RootNameLookup; import com.fasterxml.jackson.databind.util.StdDateFormat; import com.fasterxml.jackson.databind.util.TokenBuffer;"
      },
      {
        "txt": "Simplest usage is of form: <pre> final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse! MyValue value = new MyValue(); File newState = new File(\"my-stuff.json\"); mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class); JsonNode root = mapper.readTree(newState); int age = root.at(\"/personal/age\").getValueAsInt(); </pre>"
      },
      {
        "txt": "public class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable // as of 2.1 { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS,"
      },
      {
        "txt": "NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) { _appliesFor = t;"
      },
      {
        "txt": "} @Override public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null; } @Override public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)"
      },
      {
        "txt": "{ return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null; } public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); }"
      },
      {
        "txt": "case OBJECT_AND_NON_CONCRETE: return t.isJavaLangObject() || (!t.isConcrete() && !TreeNode.class.isAssignableFrom(t.getRawClass())); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()); default:"
      },
      {
        "txt": "return t.isJavaLangObject(); } } } private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); @Deprecated protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings("
      },
      {
        "txt": "null, // can not share global ClassIntrospector any more (2.5+) DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), null, // to indicate \"use default TimeZone\" Base64Variants.getDefaultVariant() // 2.1 ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory;"
      },
      {
        "txt": "protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected SimpleMixInResolver _mixIns; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; protected Set<Object> _registeredModuleTypes; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers"
      },
      {
        "txt": "= new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() { this(null, null, null); } public ObjectMapper(JsonFactory jf) { this(jf, null, null); } protected ObjectMapper(ObjectMapper src) { _jsonFactory = src._jsonFactory.copy();"
      },
      {
        "txt": "_jsonFactory.setCodec(this); _subtypeResolver = src._subtypeResolver; _typeFactory = src._typeFactory; _injectableValues = src._injectableValues; SimpleMixInResolver mixins = src._mixIns.copy(); _mixIns = mixins; RootNameLookup rootNames = new RootNameLookup(); _serializationConfig = new SerializationConfig(src._serializationConfig, mixins, rootNames); _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins, rootNames); _serializerProvider = src._serializerProvider.copy();"
      },
      {
        "txt": "_deserializationContext = src._deserializationContext.copy(); _serializerFactory = src._serializerFactory; Set<Object> reg = _registeredModuleTypes; if (reg == null) { _registeredModuleTypes = null; } else { _registeredModuleTypes = new LinkedHashSet<Object>(reg); } } public ObjectMapper(JsonFactory jf,"
      },
      {
        "txt": "DefaultSerializerProvider sp, DefaultDeserializationContext dc) { if (jf == null) { _jsonFactory = new MappingJsonFactory(this); } else { _jsonFactory = jf; if (jf.getCodec() == null) { // as per [JACKSON-741] _jsonFactory.setCodec(this); } }"
      },
      {
        "txt": "_subtypeResolver = new StdSubtypeResolver(); RootNameLookup rootNames = new RootNameLookup(); _typeFactory = TypeFactory.defaultInstance(); SimpleMixInResolver mixins = new SimpleMixInResolver(null); _mixIns = mixins; BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector()); _serializationConfig = new SerializationConfig(base, _subtypeResolver, mixins, rootNames); _deserializationConfig = new DeserializationConfig(base, _subtypeResolver, mixins, rootNames);"
      },
      {
        "txt": "final boolean needOrder = _jsonFactory.requiresPropertyOrdering(); if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) { configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder); } _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; _serializerFactory = BeanSerializerFactory.instance; } protected ClassIntrospector defaultClassIntrospector() {"
      },
      {
        "txt": "return new BasicClassIntrospector(); } public ObjectMapper copy() { _checkInvalidCopy(ObjectMapper.class); return new ObjectMapper(this); } protected void _checkInvalidCopy(Class<?> exp) { if (getClass() != exp) { throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()"
      },
      {
        "txt": "+\" (version: \"+version()+\") does not override copy(); it has to\"); } } protected ObjectReader _newReader(DeserializationConfig config) { return new ObjectReader(this, config); } protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) { return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);"
      },
      {
        "txt": "} protected ObjectWriter _newWriter(SerializationConfig config) { return new ObjectWriter(this, config); } protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) { return new ObjectWriter(this, config, schema); } protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp) { return new ObjectWriter(this, config, rootType, pp);"
      },
      {
        "txt": "} @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public ObjectMapper registerModule(Module module) { if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) { Object typeId = module.getTypeId(); if (typeId != null) {"
      },
      {
        "txt": "if (_registeredModuleTypes == null) { _registeredModuleTypes = new LinkedHashSet<Object>(); } if (!_registeredModuleTypes.add(typeId)) { return this; } } } String name = module.getModuleName(); if (name == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Module without defined name\"); } Version version = module.version(); if (version == null) { throw new IllegalArgumentException(\"Module without defined version\"); } final ObjectMapper mapper = this; module.setupModule(new Module.SetupContext() { @Override"
      },
      {
        "txt": "public Version getMapperVersion() { return version(); } @SuppressWarnings(\"unchecked\") @Override public <C extends ObjectCodec> C getOwner() { return (C) mapper; } @Override public TypeFactory getTypeFactory() {"
      },
      {
        "txt": "return _typeFactory; } @Override public boolean isEnabled(MapperFeature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(DeserializationFeature f) { return mapper.isEnabled(f); }"
      },
      {
        "txt": "@Override public boolean isEnabled(SerializationFeature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(JsonFactory.Feature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(JsonParser.Feature f) {"
      },
      {
        "txt": "return mapper.isEnabled(f); } @Override public boolean isEnabled(JsonGenerator.Feature f) { return mapper.isEnabled(f); } @Override public void addDeserializers(Deserializers d) { DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); mapper._deserializationContext = mapper._deserializationContext.with(df);"
      },
      {
        "txt": "} @Override public void addKeyDeserializers(KeyDeserializers d) { DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); mapper._deserializationContext = mapper._deserializationContext.with(df);"
      },
      {
        "txt": "} @Override public void addSerializers(Serializers s) { mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); } @Override public void addKeySerializers(Serializers s) { mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); } @Override"
      },
      {
        "txt": "public void addBeanSerializerModifier(BeanSerializerModifier modifier) { mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); } @Override public void addAbstractTypeResolver(AbstractTypeResolver resolver) { DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void addTypeModifier(TypeModifier modifier) {"
      },
      {
        "txt": "TypeFactory f = mapper._typeFactory; f = f.withModifier(modifier); mapper.setTypeFactory(f); } @Override public void addValueInstantiators(ValueInstantiators instantiators) { DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override"
      },
      {
        "txt": "public void setClassIntrospector(ClassIntrospector ci) { mapper._deserializationConfig = mapper._deserializationConfig.with(ci); mapper._serializationConfig = mapper._serializationConfig.with(ci); } @Override public void insertAnnotationIntrospector(AnnotationIntrospector ai) { mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); } @Override"
      },
      {
        "txt": "public void appendAnnotationIntrospector(AnnotationIntrospector ai) { mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); } @Override public void registerSubtypes(Class<?>... subtypes) { mapper.registerSubtypes(subtypes); } @Override public void registerSubtypes(NamedType... subtypes) {"
      },
      {
        "txt": "mapper.registerSubtypes(subtypes); } @Override public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { mapper.addMixIn(target, mixinSource); } @Override public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { mapper.addHandler(handler); }"
      },
      {
        "txt": "@Override public void setNamingStrategy(PropertyNamingStrategy naming) { mapper.setPropertyNamingStrategy(naming); } }); return this; } public ObjectMapper registerModules(Module... modules) { for (Module module : modules) {"
      },
      {
        "txt": "registerModule(module); } return this; } public ObjectMapper registerModules(Iterable<Module> modules) { for (Module module : modules) { registerModule(module); } return this;"
      },
      {
        "txt": "} public static List<Module> findModules() { return findModules(null); } public static List<Module> findModules(ClassLoader classLoader) { ArrayList<Module> modules = new ArrayList<Module>(); ServiceLoader<Module> loader = (classLoader == null) ? ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader); for (Module module : loader) {"
      },
      {
        "txt": "modules.add(module); } return modules; } public ObjectMapper findAndRegisterModules() { return registerModules(findModules()); } public SerializationConfig getSerializationConfig() { return _serializationConfig; }"
      },
      {
        "txt": "public DeserializationConfig getDeserializationConfig() { return _deserializationConfig; } public DeserializationContext getDeserializationContext() { return _deserializationContext; } public ObjectMapper setSerializerFactory(SerializerFactory f) { _serializerFactory = f; return this; }"
      },
      {
        "txt": "public SerializerFactory getSerializerFactory() { return _serializerFactory; } public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) { _serializerProvider = p; return this; } public SerializerProvider getSerializerProvider() { return _serializerProvider; }"
      },
      {
        "txt": "public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins) { _mixIns.setLocalDefinitions(sourceMixins); return this; } public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) { _mixIns.addLocalDefinition(target, mixinSource); return this; }"
      },
      {
        "txt": "public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) { SimpleMixInResolver r = _mixIns.withOverrides(resolver); if (r != _mixIns) { _mixIns = r; _deserializationConfig = new DeserializationConfig(_deserializationConfig, r); _serializationConfig = new SerializationConfig(_serializationConfig, r); } return this; }"
      },
      {
        "txt": "public Class<?> findMixInClassFor(Class<?> cls) { return _mixIns.findMixInClassFor(cls); } public int mixInCount() { return _mixIns.localSize(); } @Deprecated public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) { setMixIns(sourceMixins); }"
      },
      {
        "txt": "@Deprecated public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) { addMixIn(target, mixinSource); } public VisibilityChecker<?> getVisibilityChecker() { return _serializationConfig.getDefaultVisibilityChecker(); } @Deprecated public void setVisibilityChecker(VisibilityChecker<?> vc) { setVisibility(vc);"
      },
      {
        "txt": "} public ObjectMapper setVisibility(VisibilityChecker<?> vc) { _deserializationConfig = _deserializationConfig.with(vc); _serializationConfig = _serializationConfig.with(vc); return this; } public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility); _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);"
      },
      {
        "txt": "return this; } public SubtypeResolver getSubtypeResolver() { return _subtypeResolver; } public ObjectMapper setSubtypeResolver(SubtypeResolver str) { _subtypeResolver = str; _deserializationConfig = _deserializationConfig.with(str); _serializationConfig = _serializationConfig.with(str); return this;"
      },
      {
        "txt": "} public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) { _serializationConfig = _serializationConfig.with(ai); _deserializationConfig = _deserializationConfig.with(ai); return this; } public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) { _serializationConfig = _serializationConfig.with(serializerAI); _deserializationConfig = _deserializationConfig.with(deserializerAI);"
      },
      {
        "txt": "return this; } public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) { _serializationConfig = _serializationConfig.with(s); _deserializationConfig = _deserializationConfig.with(s); return this; } public PropertyNamingStrategy getPropertyNamingStrategy() { return _serializationConfig.getPropertyNamingStrategy(); }"
      },
      {
        "txt": "public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) { _serializationConfig = _serializationConfig.withSerializationInclusion(incl); return this; } public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) { _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp); return this; } public ObjectMapper enableDefaultTyping() { return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);"
      },
      {
        "txt": "} public ObjectMapper enableDefaultTyping(DefaultTyping dti) { return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY); } public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) { if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) { throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs); } TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);"
      },
      {
        "txt": "typer = typer.init(JsonTypeInfo.Id.CLASS, null); typer = typer.inclusion(includeAs); return setDefaultTyping(typer); } public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) { TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); typer = typer.init(JsonTypeInfo.Id.CLASS, null); typer = typer.inclusion(JsonTypeInfo.As.PROPERTY); typer = typer.typeProperty(propertyName);"
      },
      {
        "txt": "return setDefaultTyping(typer); } public ObjectMapper disableDefaultTyping() { return setDefaultTyping(null); } public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) { _deserializationConfig = _deserializationConfig.with(typer); _serializationConfig = _serializationConfig.with(typer); return this; }"
      },
      {
        "txt": "public void registerSubtypes(Class<?>... classes) { getSubtypeResolver().registerSubtypes(classes); } public void registerSubtypes(NamedType... types) { getSubtypeResolver().registerSubtypes(types); } public TypeFactory getTypeFactory() { return _typeFactory; } public ObjectMapper setTypeFactory(TypeFactory f)"
      },
      {
        "txt": "{ _typeFactory = f; _deserializationConfig = _deserializationConfig.with(f); _serializationConfig = _serializationConfig.with(f); return this; } public JavaType constructType(Type t) { return _typeFactory.constructType(t); } public JsonNodeFactory getNodeFactory() {"
      },
      {
        "txt": "return _deserializationConfig.getNodeFactory(); } public ObjectMapper setNodeFactory(JsonNodeFactory f) { _deserializationConfig = _deserializationConfig.with(f); return this; } public ObjectMapper addHandler(DeserializationProblemHandler h) { _deserializationConfig = _deserializationConfig.withHandler(h); return this; }"
      },
      {
        "txt": "public ObjectMapper clearProblemHandlers() { _deserializationConfig = _deserializationConfig.withNoProblemHandlers(); return this; } public ObjectMapper setConfig(DeserializationConfig config) { _deserializationConfig = config; return this; } @Deprecated public void setFilters(FilterProvider filterProvider) {"
      },
      {
        "txt": "_serializationConfig = _serializationConfig.withFilters(filterProvider); } public ObjectMapper setFilterProvider(FilterProvider filterProvider) { _serializationConfig = _serializationConfig.withFilters(filterProvider); return this; } public ObjectMapper setBase64Variant(Base64Variant v) { _serializationConfig = _serializationConfig.with(v); _deserializationConfig = _deserializationConfig.with(v); return this;"
      },
      {
        "txt": "} public ObjectMapper setConfig(SerializationConfig config) { _serializationConfig = config; return this; } @Override public JsonFactory getFactory() { return _jsonFactory; } @Deprecated @Override public JsonFactory getJsonFactory() { return getFactory(); }"
      },
      {
        "txt": "public ObjectMapper setDateFormat(DateFormat dateFormat) { _deserializationConfig = _deserializationConfig.with(dateFormat); _serializationConfig = _serializationConfig.with(dateFormat); return this; } public DateFormat getDateFormat() { return _serializationConfig.getDateFormat(); } public Object setHandlerInstantiator(HandlerInstantiator hi)"
      },
      {
        "txt": "{ _deserializationConfig = _deserializationConfig.with(hi); _serializationConfig = _serializationConfig.with(hi); return this; } public ObjectMapper setInjectableValues(InjectableValues injectableValues) { _injectableValues = injectableValues; return this; } public InjectableValues getInjectableValues() {"
      },
      {
        "txt": "return _injectableValues; } public ObjectMapper setLocale(Locale l) { _deserializationConfig = _deserializationConfig.with(l); _serializationConfig = _serializationConfig.with(l); return this; } public ObjectMapper setTimeZone(TimeZone tz) { _deserializationConfig = _deserializationConfig.with(tz); _serializationConfig = _serializationConfig.with(tz);"
      },
      {
        "txt": "return this; } public boolean isEnabled(MapperFeature f) { return _serializationConfig.isEnabled(f); } public ObjectMapper configure(MapperFeature f, boolean state) { _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f); _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);"
      },
      {
        "txt": "return this; } public ObjectMapper enable(MapperFeature... f) { _deserializationConfig = _deserializationConfig.with(f); _serializationConfig = _serializationConfig.with(f); return this; } public ObjectMapper disable(MapperFeature... f) { _deserializationConfig = _deserializationConfig.without(f); _serializationConfig = _serializationConfig.without(f);"
      },
      {
        "txt": "return this; } public boolean isEnabled(SerializationFeature f) { return _serializationConfig.isEnabled(f); } public ObjectMapper configure(SerializationFeature f, boolean state) { _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f); return this; }"
      },
      {
        "txt": "public ObjectMapper enable(SerializationFeature f) { _serializationConfig = _serializationConfig.with(f); return this; } public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) { _serializationConfig = _serializationConfig.with(first, f); return this; } public ObjectMapper disable(SerializationFeature f) {"
      },
      {
        "txt": "_serializationConfig = _serializationConfig.without(f); return this; } public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) { _serializationConfig = _serializationConfig.without(first, f); return this; } public boolean isEnabled(DeserializationFeature f) { return _deserializationConfig.isEnabled(f);"
      },
      {
        "txt": "} public ObjectMapper configure(DeserializationFeature f, boolean state) { _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); return this; } public ObjectMapper enable(DeserializationFeature feature) { _deserializationConfig = _deserializationConfig.with(feature); return this; }"
      },
      {
        "txt": "public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) { _deserializationConfig = _deserializationConfig.with(first, f); return this; } public ObjectMapper disable(DeserializationFeature feature) { _deserializationConfig = _deserializationConfig.without(feature); return this; } public ObjectMapper disable(DeserializationFeature first,"
      },
      {
        "txt": "DeserializationFeature... f) { _deserializationConfig = _deserializationConfig.without(first, f); return this; } public boolean isEnabled(JsonParser.Feature f) { return _deserializationConfig.isEnabled(f, _jsonFactory); } public ObjectMapper configure(JsonParser.Feature f, boolean state) { _jsonFactory.configure(f, state); return this;"
      },
      {
        "txt": "} public ObjectMapper enable(JsonParser.Feature... features) { for (JsonParser.Feature f : features) { _jsonFactory.enable(f); } return this; } public ObjectMapper disable(JsonParser.Feature... features) { for (JsonParser.Feature f : features) { _jsonFactory.disable(f);"
      },
      {
        "txt": "} return this; } public boolean isEnabled(JsonGenerator.Feature f) { return _serializationConfig.isEnabled(f, _jsonFactory); } public ObjectMapper configure(JsonGenerator.Feature f, boolean state) { _jsonFactory.configure(f, state); return this; }"
      },
      {
        "txt": "public ObjectMapper enable(JsonGenerator.Feature... features) { for (JsonGenerator.Feature f : features) { _jsonFactory.enable(f); } return this; } public ObjectMapper disable(JsonGenerator.Feature... features) { for (JsonGenerator.Feature f : features) { _jsonFactory.disable(f); }"
      },
      {
        "txt": "return this; } public boolean isEnabled(JsonFactory.Feature f) { return _jsonFactory.isEnabled(f); } @Override @SuppressWarnings(\"unchecked\") public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType)); } @Override @SuppressWarnings(\"unchecked\") public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef)); } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readValue(getDeserializationConfig(), jp, valueType); } @Override public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { DeserializationConfig cfg = getDeserializationConfig(); JsonToken t = jp.getCurrentToken(); if (t == null) { t = jp.nextToken();"
      },
      {
        "txt": "if (t == null) { return null; } } JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); if (n == null) { n = getNodeFactory().nullNode(); } @SuppressWarnings(\"unchecked\") T result = (T) n;"
      },
      {
        "txt": "return result; } @Override public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException { return readValues(jp, (JavaType) valueType); } public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException"
      },
      {
        "txt": "{ DeserializationConfig config = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(jp, config); JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType); return new MappingIterator<T>(valueType, jp, ctxt, deser, false, null); } @Override public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException"
      },
      {
        "txt": "{ return readValues(jp, _typeFactory.constructType(valueType)); } @Override public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException { return readValues(jp, _typeFactory.constructType(valueTypeRef)); } public JsonNode readTree(InputStream in)"
      },
      {
        "txt": "throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(Reader r) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n;"
      },
      {
        "txt": "} public JsonNode readTree(String content) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(File file) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(URL source)"
      },
      {
        "txt": "throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } @Override public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException { SerializationConfig config = getSerializationConfig();"
      },
      {
        "txt": "if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { if (g.getPrettyPrinter() == null) { g.setPrettyPrinter(config.constructDefaultPrettyPrinter()); } } if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _writeCloseableValue(g, value, config); } else { _serializerProvider(config).serializeValue(g, value); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {"
      },
      {
        "txt": "g.flush(); } } } @Override public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException { SerializationConfig config = getSerializationConfig(); _serializerProvider(config).serializeValue(jgen, rootNode);"
      },
      {
        "txt": "if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { jgen.flush(); } } public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException { SerializationConfig config = getSerializationConfig(); _serializerProvider(config).serializeValue(jgen, rootNode); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {"
      },
      {
        "txt": "jgen.flush(); } } @Override public ObjectNode createObjectNode() { return _deserializationConfig.getNodeFactory().objectNode(); } @Override public ArrayNode createArrayNode() { return _deserializationConfig.getNodeFactory().arrayNode();"
      },
      {
        "txt": "} @Override public JsonParser treeAsTokens(TreeNode n) { return new TreeTraversingParser((JsonNode) n, this); } @SuppressWarnings(\"unchecked\") @Override public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {"
      },
      {
        "txt": "try { if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { return (T) n; } return readValue(treeAsTokens(n), valueType); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); }"
      },
      {
        "txt": "@SuppressWarnings({ \"unchecked\", \"resource\" }) public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException { if (fromValue == null) return null; TokenBuffer buf = new TokenBuffer(this, false); <extra_id_0> try { writeValue(buf, fromValue); JsonParser jp = buf.asParser(); result = readTree(jp); jp.close(); } catch (IOException e) { // should not occur, no real i/o..."
      },
      {
        "txt": "jp.close(); } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); } return (T) result; } public boolean canSerialize(Class<?> type) { return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null); } public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {"
      },
      {
        "txt": "return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause); } public boolean canDeserialize(JavaType type) { return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, null); } public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) { return createDeserializationContext(null,"
      },
      {
        "txt": "getDeserializationConfig()).hasValueDeserializerFor(type, cause); } @SuppressWarnings(\"unchecked\") public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(File src, TypeReference valueTypeRef)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(String content, Class<T> valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(Reader src, JavaType valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); }"
      },
      {
        "txt": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, int offset, int len,"
      },
      {
        "txt": "Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));"
      },
      {
        "txt": "} @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, JavaType valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);"
      },
      {
        "txt": "} public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value); } public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);"
      },
      {
        "txt": "} public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(w), value); } @SuppressWarnings(\"resource\") public String writeValueAsString(Object value) throws JsonProcessingException {"
      },
      {
        "txt": "SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); try { _configAndWriteValue(_jsonFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { // to support [JACKSON-758] throw e; } catch (IOException e) { // shouldn't really happen, but is declared as possibility so: throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); try { _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); } catch (JsonProcessingException e) { // to support [JACKSON-758] throw e; } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:"
      },
      {
        "txt": "throw JsonMappingException.fromUnexpectedIOE(e); } byte[] result = bb.toByteArray(); bb.release(); return result; } public ObjectWriter writer() { return _newWriter(getSerializationConfig()); } public ObjectWriter writer(SerializationFeature feature) {"
      },
      {
        "txt": "return _newWriter(getSerializationConfig().with(feature)); } public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) { return _newWriter(getSerializationConfig().with(first, other)); } public ObjectWriter writer(DateFormat df) { return _newWriter(getSerializationConfig().with(df)); } public ObjectWriter writerWithView(Class<?> serializationView) {"
      },
      {
        "txt": "return _newWriter(getSerializationConfig().withView(serializationView)); } public ObjectWriter writerFor(Class<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null :_typeFactory.constructType(rootType)), } public ObjectWriter writerFor(TypeReference<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), }"
      },
      {
        "txt": "public ObjectWriter writerFor(JavaType rootType) { return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null); } public ObjectWriter writer(PrettyPrinter pp) { if (pp == null) { // need to use a marker to indicate explicit disabling of pp pp = ObjectWriter.NULL_PRETTY_PRINTER; } return _newWriter(getSerializationConfig(), /*root type*/ null, pp); } public ObjectWriter writerWithDefaultPrettyPrinter() {"
      },
      {
        "txt": "SerializationConfig config = getSerializationConfig(); return _newWriter(config, } public ObjectWriter writer(FilterProvider filterProvider) { return _newWriter(getSerializationConfig().withFilters(filterProvider)); } public ObjectWriter writer(FormatSchema schema) { _verifySchemaType(schema); return _newWriter(getSerializationConfig(), schema); }"
      },
      {
        "txt": "public ObjectWriter writer(Base64Variant defaultBase64) { return _newWriter(getSerializationConfig().with(defaultBase64)); } public ObjectWriter writer(CharacterEscapes escapes) { return _newWriter(getSerializationConfig()).with(escapes); } public ObjectWriter writer(ContextAttributes attrs) { return _newWriter(getSerializationConfig().with(attrs)); } @Deprecated"
      },
      {
        "txt": "public ObjectWriter writerWithType(Class<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null :_typeFactory.constructType(rootType)), } @Deprecated public ObjectWriter writerWithType(TypeReference<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), } @Deprecated"
      },
      {
        "txt": "public ObjectWriter writerWithType(JavaType rootType) { return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null); } public ObjectReader reader() { return _newReader(getDeserializationConfig()).with(_injectableValues); } public ObjectReader reader(DeserializationFeature feature) { return _newReader(getDeserializationConfig().with(feature)); } public ObjectReader reader(DeserializationFeature first,"
      },
      {
        "txt": "DeserializationFeature... other) { return _newReader(getDeserializationConfig().with(first, other)); } public ObjectReader readerForUpdating(Object valueToUpdate) { JavaType t = _typeFactory.constructType(valueToUpdate.getClass()); return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues); } public ObjectReader readerFor(JavaType type) { return _newReader(getDeserializationConfig(), type, null,"
      },
      {
        "txt": "null, _injectableValues); } public ObjectReader readerFor(Class<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); } public ObjectReader readerFor(TypeReference<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); }"
      },
      {
        "txt": "public ObjectReader reader(JsonNodeFactory f) { return _newReader(getDeserializationConfig()).with(f); } public ObjectReader reader(FormatSchema schema) { _verifySchemaType(schema); return _newReader(getDeserializationConfig(), null, null, schema, _injectableValues); } public ObjectReader reader(InjectableValues injectableValues) { return _newReader(getDeserializationConfig(), null, null,"
      },
      {
        "txt": "null, injectableValues); } public ObjectReader readerWithView(Class<?> view) { return _newReader(getDeserializationConfig().withView(view)); } public ObjectReader reader(Base64Variant defaultBase64) { return _newReader(getDeserializationConfig().with(defaultBase64)); } public ObjectReader reader(ContextAttributes attrs) { return _newReader(getDeserializationConfig().with(attrs));"
      },
      {
        "txt": "} @Deprecated public ObjectReader reader(JavaType type) { return _newReader(getDeserializationConfig(), type, null, null, _injectableValues); } @Deprecated public ObjectReader reader(Class<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues);"
      },
      {
        "txt": "} @Deprecated public ObjectReader reader(TypeReference<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); } @SuppressWarnings(\"unchecked\") public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {"
      },
      {
        "txt": "if (fromValue == null) return null; return (T) _convert(fromValue, _typeFactory.constructType(toValueType)); } @SuppressWarnings(\"unchecked\") public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException { return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef)); } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException { if (fromValue == null) return null; return (T) _convert(fromValue, toValueType); } @SuppressWarnings(\"resource\") protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {"
      },
      {
        "txt": "Class<?> targetType = toValueType.getRawClass(); if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { return fromValue; } TokenBuffer buf = new TokenBuffer(this, false); try { SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); _serializerProvider(config).serializeValue(buf, fromValue);"
      },
      {
        "txt": "final JsonParser jp = buf.asParser(); Object result; final DeserializationConfig deserConfig = getDeserializationConfig(); JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { // pointing to event other than null"
      },
      {
        "txt": "DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); result = deser.deserialize(jp, ctxt); } jp.close(); return result; } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); } }"
      },
      {
        "txt": "@Deprecated public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException { return _serializerProvider(getSerializationConfig()).generateJsonSchema(t); } public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException { acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor); }"
      },
      {
        "txt": "public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException { if (type == null) { throw new IllegalArgumentException(\"type must be provided\"); } _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor); } protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { return _serializerProvider.createInstance(config, _serializerFactory);"
      },
      {
        "txt": "} @Deprecated protected PrettyPrinter _defaultPrettyPrinter() { return _serializationConfig.constructDefaultPrettyPrinter(); } protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException { SerializationConfig cfg = getSerializationConfig(); cfg.initialize(g); // since 2.5"
      },
      {
        "txt": "if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _configAndWriteCloseable(g, value, cfg); return; } boolean closed = false; try { _serializerProvider(cfg).serializeValue(g, value); closed = true; g.close(); } finally {"
      },
      {
        "txt": "if (!closed) { g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); try { g.close(); } catch (IOException ioe) { } } } } protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException"
      },
      {
        "txt": "{ SerializationConfig cfg = getSerializationConfig().withView(viewClass); cfg.initialize(g); // since 2.5 if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _configAndWriteCloseable(g, value, cfg); return; } boolean closed = false; try { _serializerProvider(cfg).serializeValue(g, value);"
      },
      {
        "txt": "closed = true; g.close(); } finally { if (!closed) { g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); try { g.close(); } catch (IOException ioe) { } } }"
      },
      {
        "txt": "} private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { Closeable toClose = (Closeable) value; try { _serializerProvider(cfg).serializeValue(g, value); JsonGenerator tmpGen = g; g = null; tmpGen.close();"
      },
      {
        "txt": "Closeable tmpToClose = toClose; toClose = null; tmpToClose.close(); } finally { if (g != null) { g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); try { g.close(); } catch (IOException ioe) { } }"
      },
      {
        "txt": "if (toClose != null) { try { toClose.close(); } catch (IOException ioe) { } } } } private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {"
      },
      {
        "txt": "Closeable toClose = (Closeable) value; try { _serializerProvider(cfg).serializeValue(g, value); if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { g.flush(); } Closeable tmpToClose = toClose; toClose = null; tmpToClose.close(); } finally {"
      },
      {
        "txt": "if (toClose != null) { try { toClose.close(); } catch (IOException ioe) { } } } } protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) { return _deserializationContext.createInstance(cfg, jp, _injectableValues);"
      },
      {
        "txt": "} protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { Object result; JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { DeserializationContext ctxt = createDeserializationContext(jp, cfg); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {"
      },
      {
        "txt": "result = null; } else { // pointing to event other than null DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(jp, ctxt); } }"
      },
      {
        "txt": "jp.clearCurrentToken(); return result; } protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { try { Object result; JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) {"
      },
      {
        "txt": "DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) {"
      },
      {
        "txt": "result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(jp, ctxt); } ctxt.checkUnresolvedObjectId(); } jp.clearCurrentToken(); return result; } finally { try {"
      },
      {
        "txt": "jp.close(); } catch (IOException ioe) { } } } protected JsonToken _initForReading(JsonParser p) throws IOException { _deserializationConfig.initialize(p); // since 2.5 JsonToken t = p.getCurrentToken(); if (t == null) { t = p.nextToken();"
      },
      {
        "txt": "if (t == null) { throw JsonMappingException.from(p, \"No content to map due to end-of-input\"); } } return t; } protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException"
      },
      {
        "txt": "{ PropertyName expRootName = config.findRootName(rootType); String expSimpleName = expRootName.getSimpleName(); if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\" +expSimpleName+\"'), but \"+p.getCurrentToken()); } if (p.nextToken() != JsonToken.FIELD_NAME) { throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\" +expSimpleName+\"'), but \"+p.getCurrentToken());"
      },
      {
        "txt": "} String actualName = p.getCurrentName(); if (!expSimpleName.equals(actualName)) { throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\" +expSimpleName+\"') for type \"+rootType); } p.nextToken(); Object result = deser.deserialize(p, ctxt); if (p.nextToken() != JsonToken.END_OBJECT) { throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\""
      },
      {
        "txt": "+expSimpleName+\"'), but \"+p.getCurrentToken()); } return result; } protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); if (deser != null) {"
      },
      {
        "txt": "return deser; } deser = ctxt.findRootValueDeserializer(valueType); if (deser == null) { // can this happen? throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType); } _rootDeserializers.put(valueType, deser); return deser; } protected void _verifySchemaType(FormatSchema schema)"
      },
      {
        "txt": "{ if (schema != null) { if (!_jsonFactory.canUseSchema(schema)) { throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName() +\" for format \"+_jsonFactory.getFormatName()); } } }"
      }
    ]
  },
  {
    "id": 1457,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
    "start-bug-line": 3426,
    "end-bug-line": 3426,
    "bug": "",
    "fix": "if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind; import java.io.*; import java.lang.reflect.Type;"
      },
      {
        "txt": "import java.net.URL; import java.text.DateFormat; import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.atomic.AtomicReference; import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.CharacterEscapes; import com.fasterxml.jackson.core.io.SegmentedStringWriter; import com.fasterxml.jackson.core.type.ResolvedType;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.core.util.*; import com.fasterxml.jackson.databind.cfg.BaseSettings; import com.fasterxml.jackson.databind.cfg.ContextAttributes; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.deser.*; import com.fasterxml.jackson.databind.introspect.*; import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper; import com.fasterxml.jackson.databind.jsontype.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver; import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder; import com.fasterxml.jackson.databind.node.*; import com.fasterxml.jackson.databind.ser.*; import com.fasterxml.jackson.databind.type.*; import com.fasterxml.jackson.databind.util.RootNameLookup; import com.fasterxml.jackson.databind.util.StdDateFormat; import com.fasterxml.jackson.databind.util.TokenBuffer; Simplest usage is of form: <pre>"
      },
      {
        "txt": "final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse! MyValue value = new MyValue(); File newState = new File(\"my-stuff.json\"); mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class); JsonNode root = mapper.readTree(newState); int age = root.at(\"/personal/age\").getValueAsInt(); </pre> public class ObjectMapper extends ObjectCodec"
      },
      {
        "txt": "implements Versioned, java.io.Serializable // as of 2.1 { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL }"
      },
      {
        "txt": "public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) { _appliesFor = t; } @Override"
      },
      {
        "txt": "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null; } @Override public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;"
      },
      {
        "txt": "} public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return t.isJavaLangObject()"
      },
      {
        "txt": "|| (!t.isConcrete() && !TreeNode.class.isAssignableFrom(t.getRawClass())); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()); default: return t.isJavaLangObject(); }"
      },
      {
        "txt": "} } private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); @Deprecated protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings( null, // can not share global ClassIntrospector any more (2.5+) DEFAULT_ANNOTATION_INTROSPECTOR,"
      },
      {
        "txt": "STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), null, // to indicate \"use default TimeZone\" Base64Variants.getDefaultVariant() // 2.1 ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver;"
      },
      {
        "txt": "protected SimpleMixInResolver _mixIns; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; protected Set<Object> _registeredModuleTypes; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() {"
      },
      {
        "txt": "this(null, null, null); } public ObjectMapper(JsonFactory jf) { this(jf, null, null); } protected ObjectMapper(ObjectMapper src) { _jsonFactory = src._jsonFactory.copy(); _jsonFactory.setCodec(this); _subtypeResolver = src._subtypeResolver;"
      },
      {
        "txt": "_typeFactory = src._typeFactory; _injectableValues = src._injectableValues; SimpleMixInResolver mixins = src._mixIns.copy(); _mixIns = mixins; RootNameLookup rootNames = new RootNameLookup(); _serializationConfig = new SerializationConfig(src._serializationConfig, mixins, rootNames); _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins, rootNames); _serializerProvider = src._serializerProvider.copy(); _deserializationContext = src._deserializationContext.copy(); _serializerFactory = src._serializerFactory;"
      },
      {
        "txt": "Set<Object> reg = _registeredModuleTypes; if (reg == null) { _registeredModuleTypes = null; } else { _registeredModuleTypes = new LinkedHashSet<Object>(reg); } } public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) {"
      },
      {
        "txt": "if (jf == null) { _jsonFactory = new MappingJsonFactory(this); } else { _jsonFactory = jf; if (jf.getCodec() == null) { // as per [JACKSON-741] _jsonFactory.setCodec(this); } } _subtypeResolver = new StdSubtypeResolver(); RootNameLookup rootNames = new RootNameLookup();"
      },
      {
        "txt": "_typeFactory = TypeFactory.defaultInstance(); SimpleMixInResolver mixins = new SimpleMixInResolver(null); _mixIns = mixins; BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector()); _serializationConfig = new SerializationConfig(base, _subtypeResolver, mixins, rootNames); _deserializationConfig = new DeserializationConfig(base, _subtypeResolver, mixins, rootNames); final boolean needOrder = _jsonFactory.requiresPropertyOrdering(); if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {"
      },
      {
        "txt": "configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder); } _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; _serializerFactory = BeanSerializerFactory.instance; } protected ClassIntrospector defaultClassIntrospector() { return new BasicClassIntrospector(); }"
      },
      {
        "txt": "public ObjectMapper copy() { _checkInvalidCopy(ObjectMapper.class); return new ObjectMapper(this); } protected void _checkInvalidCopy(Class<?> exp) { if (getClass() != exp) { throw new IllegalStateException(\"Failed copy(): \"+getClass().getName() +\" (version: \"+version()+\") does not override copy(); it has to\"); }"
      },
      {
        "txt": "} protected ObjectReader _newReader(DeserializationConfig config) { return new ObjectReader(this, config); } protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) { return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues); } protected ObjectWriter _newWriter(SerializationConfig config) {"
      },
      {
        "txt": "return new ObjectWriter(this, config); } protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) { return new ObjectWriter(this, config, schema); } protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp) { return new ObjectWriter(this, config, rootType, pp); } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public ObjectMapper registerModule(Module module) { if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) { Object typeId = module.getTypeId(); if (typeId != null) { if (_registeredModuleTypes == null) { _registeredModuleTypes = new LinkedHashSet<Object>();"
      },
      {
        "txt": "} if (!_registeredModuleTypes.add(typeId)) { return this; } } } String name = module.getModuleName(); if (name == null) { throw new IllegalArgumentException(\"Module without defined name\"); }"
      },
      {
        "txt": "Version version = module.version(); if (version == null) { throw new IllegalArgumentException(\"Module without defined version\"); } final ObjectMapper mapper = this; module.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return version();"
      },
      {
        "txt": "} @SuppressWarnings(\"unchecked\") @Override public <C extends ObjectCodec> C getOwner() { return (C) mapper; } @Override public TypeFactory getTypeFactory() { return _typeFactory; }"
      },
      {
        "txt": "@Override public boolean isEnabled(MapperFeature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(DeserializationFeature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(SerializationFeature f) {"
      },
      {
        "txt": "return mapper.isEnabled(f); } @Override public boolean isEnabled(JsonFactory.Feature f) { return mapper.isEnabled(f); } @Override public boolean isEnabled(JsonParser.Feature f) { return mapper.isEnabled(f); }"
      },
      {
        "txt": "@Override public boolean isEnabled(JsonGenerator.Feature f) { return mapper.isEnabled(f); } @Override public void addDeserializers(Deserializers d) { DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override"
      },
      {
        "txt": "public void addKeyDeserializers(KeyDeserializers d) { DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override"
      },
      {
        "txt": "public void addSerializers(Serializers s) { mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); } @Override public void addKeySerializers(Serializers s) { mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); } @Override public void addBeanSerializerModifier(BeanSerializerModifier modifier) { mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);"
      },
      {
        "txt": "} @Override public void addAbstractTypeResolver(AbstractTypeResolver resolver) { DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void addTypeModifier(TypeModifier modifier) { TypeFactory f = mapper._typeFactory; f = f.withModifier(modifier);"
      },
      {
        "txt": "mapper.setTypeFactory(f); } @Override public void addValueInstantiators(ValueInstantiators instantiators) { DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); mapper._deserializationContext = mapper._deserializationContext.with(df); } @Override public void setClassIntrospector(ClassIntrospector ci) { mapper._deserializationConfig = mapper._deserializationConfig.with(ci);"
      },
      {
        "txt": "mapper._serializationConfig = mapper._serializationConfig.with(ci); } @Override public void insertAnnotationIntrospector(AnnotationIntrospector ai) { mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); } @Override public void appendAnnotationIntrospector(AnnotationIntrospector ai) { mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);"
      },
      {
        "txt": "mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); } @Override public void registerSubtypes(Class<?>... subtypes) { mapper.registerSubtypes(subtypes); } @Override public void registerSubtypes(NamedType... subtypes) { mapper.registerSubtypes(subtypes); }"
      },
      {
        "txt": "@Override public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { mapper.addMixIn(target, mixinSource); } @Override public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { mapper.addHandler(handler); } @Override public void setNamingStrategy(PropertyNamingStrategy naming) {"
      },
      {
        "txt": "mapper.setPropertyNamingStrategy(naming); } }); return this; } public ObjectMapper registerModules(Module... modules) { for (Module module : modules) { registerModule(module); }"
      },
      {
        "txt": "return this; } public ObjectMapper registerModules(Iterable<Module> modules) { for (Module module : modules) { registerModule(module); } return this; } public static List<Module> findModules() {"
      },
      {
        "txt": "return findModules(null); } public static List<Module> findModules(ClassLoader classLoader) { ArrayList<Module> modules = new ArrayList<Module>(); ServiceLoader<Module> loader = (classLoader == null) ? ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader); for (Module module : loader) { modules.add(module); }"
      },
      {
        "txt": "return modules; } public ObjectMapper findAndRegisterModules() { return registerModules(findModules()); } public SerializationConfig getSerializationConfig() { return _serializationConfig; } public DeserializationConfig getDeserializationConfig() { return _deserializationConfig;"
      },
      {
        "txt": "} public DeserializationContext getDeserializationContext() { return _deserializationContext; } public ObjectMapper setSerializerFactory(SerializerFactory f) { _serializerFactory = f; return this; } public SerializerFactory getSerializerFactory() { return _serializerFactory;"
      },
      {
        "txt": "} public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) { _serializerProvider = p; return this; } public SerializerProvider getSerializerProvider() { return _serializerProvider; } public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins) {"
      },
      {
        "txt": "_mixIns.setLocalDefinitions(sourceMixins); return this; } public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) { _mixIns.addLocalDefinition(target, mixinSource); return this; } public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) {"
      },
      {
        "txt": "SimpleMixInResolver r = _mixIns.withOverrides(resolver); if (r != _mixIns) { _mixIns = r; _deserializationConfig = new DeserializationConfig(_deserializationConfig, r); _serializationConfig = new SerializationConfig(_serializationConfig, r); } return this; } public Class<?> findMixInClassFor(Class<?> cls) { return _mixIns.findMixInClassFor(cls);"
      },
      {
        "txt": "} public int mixInCount() { return _mixIns.localSize(); } @Deprecated public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) { setMixIns(sourceMixins); } @Deprecated public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {"
      },
      {
        "txt": "addMixIn(target, mixinSource); } public VisibilityChecker<?> getVisibilityChecker() { return _serializationConfig.getDefaultVisibilityChecker(); } @Deprecated public void setVisibilityChecker(VisibilityChecker<?> vc) { setVisibility(vc); } public ObjectMapper setVisibility(VisibilityChecker<?> vc) {"
      },
      {
        "txt": "_deserializationConfig = _deserializationConfig.with(vc); _serializationConfig = _serializationConfig.with(vc); return this; } public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility); _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility); return this; }"
      },
      {
        "txt": "public SubtypeResolver getSubtypeResolver() { return _subtypeResolver; } public ObjectMapper setSubtypeResolver(SubtypeResolver str) { _subtypeResolver = str; _deserializationConfig = _deserializationConfig.with(str); _serializationConfig = _serializationConfig.with(str); return this; } public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {"
      },
      {
        "txt": "_serializationConfig = _serializationConfig.with(ai); _deserializationConfig = _deserializationConfig.with(ai); return this; } public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) { _serializationConfig = _serializationConfig.with(serializerAI); _deserializationConfig = _deserializationConfig.with(deserializerAI); return this; }"
      },
      {
        "txt": "public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) { _serializationConfig = _serializationConfig.with(s); _deserializationConfig = _deserializationConfig.with(s); return this; } public PropertyNamingStrategy getPropertyNamingStrategy() { return _serializationConfig.getPropertyNamingStrategy(); } public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) { _serializationConfig = _serializationConfig.withSerializationInclusion(incl);"
      },
      {
        "txt": "return this; } public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) { _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp); return this; } public ObjectMapper enableDefaultTyping() { return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE); } public ObjectMapper enableDefaultTyping(DefaultTyping dti) {"
      },
      {
        "txt": "return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY); } public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) { if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) { throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs); } TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); typer = typer.init(JsonTypeInfo.Id.CLASS, null); typer = typer.inclusion(includeAs);"
      },
      {
        "txt": "return setDefaultTyping(typer); } public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) { TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); typer = typer.init(JsonTypeInfo.Id.CLASS, null); typer = typer.inclusion(JsonTypeInfo.As.PROPERTY); typer = typer.typeProperty(propertyName); return setDefaultTyping(typer); }"
      },
      {
        "txt": "public ObjectMapper disableDefaultTyping() { return setDefaultTyping(null); } public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) { _deserializationConfig = _deserializationConfig.with(typer); _serializationConfig = _serializationConfig.with(typer); return this; } public void registerSubtypes(Class<?>... classes) { getSubtypeResolver().registerSubtypes(classes);"
      },
      {
        "txt": "} public void registerSubtypes(NamedType... types) { getSubtypeResolver().registerSubtypes(types); } public TypeFactory getTypeFactory() { return _typeFactory; } public ObjectMapper setTypeFactory(TypeFactory f) { _typeFactory = f;"
      },
      {
        "txt": "_deserializationConfig = _deserializationConfig.with(f); _serializationConfig = _serializationConfig.with(f); return this; } public JavaType constructType(Type t) { return _typeFactory.constructType(t); } public JsonNodeFactory getNodeFactory() { return _deserializationConfig.getNodeFactory(); }"
      },
      {
        "txt": "public ObjectMapper setNodeFactory(JsonNodeFactory f) { _deserializationConfig = _deserializationConfig.with(f); return this; } public ObjectMapper addHandler(DeserializationProblemHandler h) { _deserializationConfig = _deserializationConfig.withHandler(h); return this; } public ObjectMapper clearProblemHandlers() { _deserializationConfig = _deserializationConfig.withNoProblemHandlers();"
      },
      {
        "txt": "return this; } public ObjectMapper setConfig(DeserializationConfig config) { _deserializationConfig = config; return this; } @Deprecated public void setFilters(FilterProvider filterProvider) { _serializationConfig = _serializationConfig.withFilters(filterProvider); }"
      },
      {
        "txt": "public ObjectMapper setFilterProvider(FilterProvider filterProvider) { _serializationConfig = _serializationConfig.withFilters(filterProvider); return this; } public ObjectMapper setBase64Variant(Base64Variant v) { _serializationConfig = _serializationConfig.with(v); _deserializationConfig = _deserializationConfig.with(v); return this; } public ObjectMapper setConfig(SerializationConfig config) {"
      },
      {
        "txt": "_serializationConfig = config; return this; } @Override public JsonFactory getFactory() { return _jsonFactory; } @Deprecated @Override public JsonFactory getJsonFactory() { return getFactory(); } public ObjectMapper setDateFormat(DateFormat dateFormat) {"
      },
      {
        "txt": "_deserializationConfig = _deserializationConfig.with(dateFormat); _serializationConfig = _serializationConfig.with(dateFormat); return this; } public DateFormat getDateFormat() { return _serializationConfig.getDateFormat(); } public Object setHandlerInstantiator(HandlerInstantiator hi) { _deserializationConfig = _deserializationConfig.with(hi);"
      },
      {
        "txt": "_serializationConfig = _serializationConfig.with(hi); return this; } public ObjectMapper setInjectableValues(InjectableValues injectableValues) { _injectableValues = injectableValues; return this; } public InjectableValues getInjectableValues() { return _injectableValues; }"
      },
      {
        "txt": "public ObjectMapper setLocale(Locale l) { _deserializationConfig = _deserializationConfig.with(l); _serializationConfig = _serializationConfig.with(l); return this; } public ObjectMapper setTimeZone(TimeZone tz) { _deserializationConfig = _deserializationConfig.with(tz); _serializationConfig = _serializationConfig.with(tz); return this; }"
      },
      {
        "txt": "public boolean isEnabled(MapperFeature f) { return _serializationConfig.isEnabled(f); } public ObjectMapper configure(MapperFeature f, boolean state) { _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f); _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); return this; }"
      },
      {
        "txt": "public ObjectMapper enable(MapperFeature... f) { _deserializationConfig = _deserializationConfig.with(f); _serializationConfig = _serializationConfig.with(f); return this; } public ObjectMapper disable(MapperFeature... f) { _deserializationConfig = _deserializationConfig.without(f); _serializationConfig = _serializationConfig.without(f); return this; }"
      },
      {
        "txt": "public boolean isEnabled(SerializationFeature f) { return _serializationConfig.isEnabled(f); } public ObjectMapper configure(SerializationFeature f, boolean state) { _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f); return this; } public ObjectMapper enable(SerializationFeature f) { _serializationConfig = _serializationConfig.with(f);"
      },
      {
        "txt": "return this; } public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) { _serializationConfig = _serializationConfig.with(first, f); return this; } public ObjectMapper disable(SerializationFeature f) { _serializationConfig = _serializationConfig.without(f); return this;"
      },
      {
        "txt": "} public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) { _serializationConfig = _serializationConfig.without(first, f); return this; } public boolean isEnabled(DeserializationFeature f) { return _deserializationConfig.isEnabled(f); } public ObjectMapper configure(DeserializationFeature f, boolean state) {"
      },
      {
        "txt": "_deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); return this; } public ObjectMapper enable(DeserializationFeature feature) { _deserializationConfig = _deserializationConfig.with(feature); return this; } public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {"
      },
      {
        "txt": "_deserializationConfig = _deserializationConfig.with(first, f); return this; } public ObjectMapper disable(DeserializationFeature feature) { _deserializationConfig = _deserializationConfig.without(feature); return this; } public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) { _deserializationConfig = _deserializationConfig.without(first, f);"
      },
      {
        "txt": "return this; } public boolean isEnabled(JsonParser.Feature f) { return _deserializationConfig.isEnabled(f, _jsonFactory); } public ObjectMapper configure(JsonParser.Feature f, boolean state) { _jsonFactory.configure(f, state); return this; } public ObjectMapper enable(JsonParser.Feature... features) {"
      },
      {
        "txt": "for (JsonParser.Feature f : features) { _jsonFactory.enable(f); } return this; } public ObjectMapper disable(JsonParser.Feature... features) { for (JsonParser.Feature f : features) { _jsonFactory.disable(f); } return this;"
      },
      {
        "txt": "} public boolean isEnabled(JsonGenerator.Feature f) { return _serializationConfig.isEnabled(f, _jsonFactory); } public ObjectMapper configure(JsonGenerator.Feature f, boolean state) { _jsonFactory.configure(f, state); return this; } public ObjectMapper enable(JsonGenerator.Feature... features) { for (JsonGenerator.Feature f : features) {"
      },
      {
        "txt": "_jsonFactory.enable(f); } return this; } public ObjectMapper disable(JsonGenerator.Feature... features) { for (JsonGenerator.Feature f : features) { _jsonFactory.disable(f); } return this; }"
      },
      {
        "txt": "public boolean isEnabled(JsonFactory.Feature f) { return _jsonFactory.isEnabled(f); } @Override @SuppressWarnings(\"unchecked\") public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType)); }"
      },
      {
        "txt": "@Override @SuppressWarnings(\"unchecked\") public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef)); } @Override @SuppressWarnings(\"unchecked\") public final <T> T readValue(JsonParser jp, ResolvedType valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readValue(getDeserializationConfig(), jp, valueType); }"
      },
      {
        "txt": "@Override public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { DeserializationConfig cfg = getDeserializationConfig(); JsonToken t = jp.getCurrentToken(); if (t == null) { t = jp.nextToken(); if (t == null) { return null;"
      },
      {
        "txt": "} } JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); if (n == null) { n = getNodeFactory().nullNode(); } @SuppressWarnings(\"unchecked\") T result = (T) n; return result; }"
      },
      {
        "txt": "@Override public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException { return readValues(jp, (JavaType) valueType); } public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException { DeserializationConfig config = getDeserializationConfig();"
      },
      {
        "txt": "DeserializationContext ctxt = createDeserializationContext(jp, config); JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType); return new MappingIterator<T>(valueType, jp, ctxt, deser, false, null); } @Override public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException { return readValues(jp, _typeFactory.constructType(valueType));"
      },
      {
        "txt": "} @Override public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException { return readValues(jp, _typeFactory.constructType(valueTypeRef)); } public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(Reader r) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(String content)"
      },
      {
        "txt": "throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n;"
      },
      {
        "txt": "} public JsonNode readTree(File file) throws IOException, JsonProcessingException { JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } public JsonNode readTree(URL source) throws IOException, JsonProcessingException {"
      },
      {
        "txt": "JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE); return (n == null) ? NullNode.instance : n; } @Override public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException { SerializationConfig config = getSerializationConfig(); if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { if (g.getPrettyPrinter() == null) {"
      },
      {
        "txt": "g.setPrettyPrinter(config.constructDefaultPrettyPrinter()); } } if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _writeCloseableValue(g, value, config); } else { _serializerProvider(config).serializeValue(g, value); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { g.flush(); }"
      },
      {
        "txt": "} } @Override public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException { SerializationConfig config = getSerializationConfig(); _serializerProvider(config).serializeValue(jgen, rootNode); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { jgen.flush();"
      },
      {
        "txt": "} } public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException { SerializationConfig config = getSerializationConfig(); _serializerProvider(config).serializeValue(jgen, rootNode); if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { jgen.flush(); }"
      },
      {
        "txt": "} @Override public ObjectNode createObjectNode() { return _deserializationConfig.getNodeFactory().objectNode(); } @Override public ArrayNode createArrayNode() { return _deserializationConfig.getNodeFactory().arrayNode(); } @Override"
      },
      {
        "txt": "public JsonParser treeAsTokens(TreeNode n) { return new TreeTraversingParser((JsonNode) n, this); } @SuppressWarnings(\"unchecked\") @Override public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { try { if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {"
      },
      {
        "txt": "return (T) n; } return readValue(treeAsTokens(n), valueType); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); } } @SuppressWarnings({ \"unchecked\", \"resource\" })"
      },
      {
        "txt": "public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException { if (fromValue == null) return null; TokenBuffer buf = new TokenBuffer(this, false); JsonNode result; try { writeValue(buf, fromValue); JsonParser jp = buf.asParser(); result = readTree(jp);"
      },
      {
        "txt": "jp.close(); } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); } return (T) result; } public boolean canSerialize(Class<?> type) { return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null); } public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {"
      },
      {
        "txt": "return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause); } public boolean canDeserialize(JavaType type) { return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, null); } public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) { return createDeserializationContext(null,"
      },
      {
        "txt": "getDeserializationConfig()).hasValueDeserializerFor(type, cause); } @SuppressWarnings(\"unchecked\") public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(File src, TypeReference valueTypeRef)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(String content, Class<T> valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); }"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(Reader src, JavaType valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); }"
      },
      {
        "txt": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {"
      },
      {
        "txt": "return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, int offset, int len,"
      },
      {
        "txt": "Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType)); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));"
      },
      {
        "txt": "} @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef)); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, JavaType valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); } @SuppressWarnings(\"unchecked\") public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);"
      },
      {
        "txt": "} public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value); } public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);"
      },
      {
        "txt": "} public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { _configAndWriteValue(_jsonFactory.createGenerator(w), value); } @SuppressWarnings(\"resource\") public String writeValueAsString(Object value) throws JsonProcessingException {"
      },
      {
        "txt": "SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); try { _configAndWriteValue(_jsonFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { // to support [JACKSON-758] throw e; } catch (IOException e) { // shouldn't really happen, but is declared as possibility so: throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); try { _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); } catch (JsonProcessingException e) { // to support [JACKSON-758] throw e; } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:"
      },
      {
        "txt": "throw JsonMappingException.fromUnexpectedIOE(e); } byte[] result = bb.toByteArray(); bb.release(); return result; } public ObjectWriter writer() { return _newWriter(getSerializationConfig()); } public ObjectWriter writer(SerializationFeature feature) {"
      },
      {
        "txt": "return _newWriter(getSerializationConfig().with(feature)); } public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) { return _newWriter(getSerializationConfig().with(first, other)); } public ObjectWriter writer(DateFormat df) { return _newWriter(getSerializationConfig().with(df)); } public ObjectWriter writerWithView(Class<?> serializationView) {"
      },
      {
        "txt": "return _newWriter(getSerializationConfig().withView(serializationView)); } public ObjectWriter writerFor(Class<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null :_typeFactory.constructType(rootType)), } public ObjectWriter writerFor(TypeReference<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), }"
      },
      {
        "txt": "public ObjectWriter writerFor(JavaType rootType) { return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null); } public ObjectWriter writer(PrettyPrinter pp) { if (pp == null) { // need to use a marker to indicate explicit disabling of pp pp = ObjectWriter.NULL_PRETTY_PRINTER; } return _newWriter(getSerializationConfig(), /*root type*/ null, pp); } public ObjectWriter writerWithDefaultPrettyPrinter() {"
      },
      {
        "txt": "SerializationConfig config = getSerializationConfig(); return _newWriter(config, } public ObjectWriter writer(FilterProvider filterProvider) { return _newWriter(getSerializationConfig().withFilters(filterProvider)); } public ObjectWriter writer(FormatSchema schema) { _verifySchemaType(schema); return _newWriter(getSerializationConfig(), schema); }"
      },
      {
        "txt": "public ObjectWriter writer(Base64Variant defaultBase64) { return _newWriter(getSerializationConfig().with(defaultBase64)); } public ObjectWriter writer(CharacterEscapes escapes) { return _newWriter(getSerializationConfig()).with(escapes); } public ObjectWriter writer(ContextAttributes attrs) { return _newWriter(getSerializationConfig().with(attrs)); } @Deprecated"
      },
      {
        "txt": "public ObjectWriter writerWithType(Class<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null :_typeFactory.constructType(rootType)), } @Deprecated public ObjectWriter writerWithType(TypeReference<?> rootType) { return _newWriter(getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), } @Deprecated"
      },
      {
        "txt": "public ObjectWriter writerWithType(JavaType rootType) { return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null); } public ObjectReader reader() { return _newReader(getDeserializationConfig()).with(_injectableValues); } public ObjectReader reader(DeserializationFeature feature) { return _newReader(getDeserializationConfig().with(feature)); } public ObjectReader reader(DeserializationFeature first,"
      },
      {
        "txt": "DeserializationFeature... other) { return _newReader(getDeserializationConfig().with(first, other)); } public ObjectReader readerForUpdating(Object valueToUpdate) { JavaType t = _typeFactory.constructType(valueToUpdate.getClass()); return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues); } public ObjectReader readerFor(JavaType type) { return _newReader(getDeserializationConfig(), type, null,"
      },
      {
        "txt": "null, _injectableValues); } public ObjectReader readerFor(Class<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); } public ObjectReader readerFor(TypeReference<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); }"
      },
      {
        "txt": "public ObjectReader reader(JsonNodeFactory f) { return _newReader(getDeserializationConfig()).with(f); } public ObjectReader reader(FormatSchema schema) { _verifySchemaType(schema); return _newReader(getDeserializationConfig(), null, null, schema, _injectableValues); } public ObjectReader reader(InjectableValues injectableValues) { return _newReader(getDeserializationConfig(), null, null,"
      },
      {
        "txt": "null, injectableValues); } public ObjectReader readerWithView(Class<?> view) { return _newReader(getDeserializationConfig().withView(view)); } public ObjectReader reader(Base64Variant defaultBase64) { return _newReader(getDeserializationConfig().with(defaultBase64)); } public ObjectReader reader(ContextAttributes attrs) { return _newReader(getDeserializationConfig().with(attrs));"
      },
      {
        "txt": "} @Deprecated public ObjectReader reader(JavaType type) { return _newReader(getDeserializationConfig(), type, null, null, _injectableValues); } @Deprecated public ObjectReader reader(Class<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues);"
      },
      {
        "txt": "} @Deprecated public ObjectReader reader(TypeReference<?> type) { return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues); } @SuppressWarnings(\"unchecked\") public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {"
      },
      {
        "txt": "if (fromValue == null) return null; return (T) _convert(fromValue, _typeFactory.constructType(toValueType)); } @SuppressWarnings(\"unchecked\") public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException { return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef)); } @SuppressWarnings(\"unchecked\")"
      },
      {
        "txt": "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException { if (fromValue == null) return null; return (T) _convert(fromValue, toValueType); } @SuppressWarnings(\"resource\") protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {"
      },
      {
        "txt": "if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { return fromValue; } TokenBuffer buf = new TokenBuffer(this, false); <extra_id_0> SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); _serializerProvider(config).serializeValue(buf, fromValue); final JsonParser jp = buf.asParser(); Object result; final DeserializationConfig deserConfig = getDeserializationConfig(); JsonToken t = _initForReading(jp);"
      },
      {
        "txt": "final DeserializationConfig deserConfig = getDeserializationConfig(); JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { // pointing to event other than null DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);"
      },
      {
        "txt": "result = deser.deserialize(jp, ctxt); } jp.close(); return result; } catch (IOException e) { // should not occur, no real i/o... throw new IllegalArgumentException(e.getMessage(), e); } } @Deprecated public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)"
      },
      {
        "txt": "throws JsonMappingException { return _serializerProvider(getSerializationConfig()).generateJsonSchema(t); } public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException { acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor); } public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException"
      },
      {
        "txt": "{ if (type == null) { throw new IllegalArgumentException(\"type must be provided\"); } _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor); } protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { return _serializerProvider.createInstance(config, _serializerFactory); } @Deprecated"
      },
      {
        "txt": "protected PrettyPrinter _defaultPrettyPrinter() { return _serializationConfig.constructDefaultPrettyPrinter(); } protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException { SerializationConfig cfg = getSerializationConfig(); cfg.initialize(g); // since 2.5 if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _configAndWriteCloseable(g, value, cfg);"
      },
      {
        "txt": "return; } boolean closed = false; try { _serializerProvider(cfg).serializeValue(g, value); closed = true; g.close(); } finally { if (!closed) { g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);"
      },
      {
        "txt": "try { g.close(); } catch (IOException ioe) { } } } } protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException { SerializationConfig cfg = getSerializationConfig().withView(viewClass);"
      },
      {
        "txt": "cfg.initialize(g); // since 2.5 if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { _configAndWriteCloseable(g, value, cfg); return; } boolean closed = false; try { _serializerProvider(cfg).serializeValue(g, value); closed = true; g.close();"
      },
      {
        "txt": "} finally { if (!closed) { g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); try { g.close(); } catch (IOException ioe) { } } } } private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg)"
      },
      {
        "txt": "throws IOException, JsonGenerationException, JsonMappingException { Closeable toClose = (Closeable) value; try { _serializerProvider(cfg).serializeValue(g, value); JsonGenerator tmpGen = g; g = null; tmpGen.close(); Closeable tmpToClose = toClose; toClose = null;"
      },
      {
        "txt": "tmpToClose.close(); } finally { if (g != null) { g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); try { g.close(); } catch (IOException ioe) { } } if (toClose != null) { try {"
      },
      {
        "txt": "toClose.close(); } catch (IOException ioe) { } } } } private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { Closeable toClose = (Closeable) value; try {"
      },
      {
        "txt": "_serializerProvider(cfg).serializeValue(g, value); if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { g.flush(); } Closeable tmpToClose = toClose; toClose = null; tmpToClose.close(); } finally { if (toClose != null) { try {"
      },
      {
        "txt": "toClose.close(); } catch (IOException ioe) { } } } } protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) { return _deserializationContext.createInstance(cfg, jp, _injectableValues); } protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)"
      },
      {
        "txt": "throws IOException, JsonParseException, JsonMappingException { Object result; JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { DeserializationContext ctxt = createDeserializationContext(jp, cfg); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { // pointing to event other than null"
      },
      {
        "txt": "DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(jp, ctxt); } } jp.clearCurrentToken(); return result;"
      },
      {
        "txt": "} protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { try { Object result; JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig());"
      },
      {
        "txt": "result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else {"
      },
      {
        "txt": "result = deser.deserialize(jp, ctxt); } ctxt.checkUnresolvedObjectId(); } jp.clearCurrentToken(); return result; } finally { try { jp.close(); } catch (IOException ioe) { }"
      },
      {
        "txt": "} } protected JsonToken _initForReading(JsonParser p) throws IOException { _deserializationConfig.initialize(p); // since 2.5 JsonToken t = p.getCurrentToken(); if (t == null) { t = p.nextToken(); if (t == null) { throw JsonMappingException.from(p, \"No content to map due to end-of-input\");"
      },
      {
        "txt": "} } return t; } protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException { PropertyName expRootName = config.findRootName(rootType);"
      },
      {
        "txt": "String expSimpleName = expRootName.getSimpleName(); if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\" +expSimpleName+\"'), but \"+p.getCurrentToken()); } if (p.nextToken() != JsonToken.FIELD_NAME) { throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\" +expSimpleName+\"'), but \"+p.getCurrentToken()); } String actualName = p.getCurrentName();"
      },
      {
        "txt": "if (!expSimpleName.equals(actualName)) { throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\" +expSimpleName+\"') for type \"+rootType); } p.nextToken(); Object result = deser.deserialize(p, ctxt); if (p.nextToken() != JsonToken.END_OBJECT) { throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\" +expSimpleName+\"'), but \"+p.getCurrentToken()); }"
      },
      {
        "txt": "return result; } protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); if (deser != null) { return deser; }"
      },
      {
        "txt": "deser = ctxt.findRootValueDeserializer(valueType); if (deser == null) { // can this happen? throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType); } _rootDeserializers.put(valueType, deser); return deser; } protected void _verifySchemaType(FormatSchema schema) { if (schema != null) {"
      },
      {
        "txt": "if (!_jsonFactory.canUseSchema(schema)) { throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName() +\" for format \"+_jsonFactory.getFormatName()); } } }"
      }
    ]
  },
  {
    "id": 1458,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 80,
    "end-bug-line": 80,
    "bug": "",
    "fix": "protected boolean _forceBigDecimal;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator {"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; <extra_id_0> protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false;"
      },
      {
        "txt": "protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec;"
      },
      {
        "txt": "_generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null);"
      },
      {
        "txt": "} public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId();"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() { return asParser(_objectCodec); }"
      },
      {
        "txt": "public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) { Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; }"
      },
      {
        "txt": "public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; } @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) {"
      },
      {
        "txt": "_hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); }"
      },
      {
        "txt": "return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) {"
      },
      {
        "txt": "gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); } } switch (t) { case START_OBJECT: gen.writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else { gen.writeFieldName((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else { gen.writeString((String) ob); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) {"
      },
      {
        "txt": "gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) {"
      },
      {
        "txt": "gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else {"
      },
      {
        "txt": "throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value);"
      },
      {
        "txt": "} } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {"
      },
      {
        "txt": "if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) {"
      },
      {
        "txt": "throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100;"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try {"
      },
      {
        "txt": "t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString());"
      },
      {
        "txt": "if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } } } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count;"
      },
      {
        "txt": "} if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1);"
      },
      {
        "txt": "if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) {"
      },
      {
        "txt": "_generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) {"
      },
      {
        "txt": "return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; } @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this;"
      },
      {
        "txt": "} @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; }"
      },
      {
        "txt": "@Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ }"
      },
      {
        "txt": "@Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY);"
      },
      {
        "txt": "_writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; }"
      },
      {
        "txt": "} @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException {"
      },
      {
        "txt": "if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); }"
      },
      {
        "txt": "@Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override"
      },
      {
        "txt": "public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));"
      },
      {
        "txt": "} @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override"
      },
      {
        "txt": "public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); }"
      },
      {
        "txt": "} @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override"
      },
      {
        "txt": "public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL);"
      },
      {
        "txt": "} @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) {"
      },
      {
        "txt": "_append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override"
      },
      {
        "txt": "public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node);"
      },
      {
        "txt": "} } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override"
      },
      {
        "txt": "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; } @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject();"
      },
      {
        "txt": "break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray(); break; case END_ARRAY: writeEndArray(); break;"
      },
      {
        "txt": "case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break;"
      },
      {
        "txt": "case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue());"
      },
      {
        "txt": "} break; case VALUE_NUMBER_FLOAT: switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break;"
      },
      {
        "txt": "default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false); break;"
      },
      {
        "txt": "case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } }"
      },
      {
        "txt": "@Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken();"
      },
      {
        "txt": "} if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject(); break; default: // others are simple:"
      },
      {
        "txt": "copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true;"
      },
      {
        "txt": "} } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else {"
      },
      {
        "txt": "_last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } @Override protected void _reportUnsupportedOperation() {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment;"
      },
      {
        "txt": "protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0);"
      },
      {
        "txt": "_segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l;"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); }"
      },
      {
        "txt": "@Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null;"
      },
      {
        "txt": "if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) {"
      },
      {
        "txt": "_parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1;"
      },
      {
        "txt": "if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override"
      },
      {
        "txt": "public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override"
      },
      {
        "txt": "public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) {"
      },
      {
        "txt": "JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e); } }"
      },
      {
        "txt": "@Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString();"
      },
      {
        "txt": "} if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default:"
      },
      {
        "txt": "return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() {"
      },
      {
        "txt": "String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false; } @Override"
      },
      {
        "txt": "public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue());"
      },
      {
        "txt": "} @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; } switch (getNumberType()) { case INT:"
      },
      {
        "txt": "case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException"
      },
      {
        "txt": "{ Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null;"
      },
      {
        "txt": "} @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; } if (value instanceof String) { String str = (String) value;"
      },
      {
        "txt": "if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName());"
      },
      {
        "txt": "} @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else {"
      },
      {
        "txt": "_byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) {"
      },
      {
        "txt": "out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override"
      },
      {
        "txt": "public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr);"
      },
      {
        "txt": "} protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } }"
      },
      {
        "txt": "@Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static {"
      },
      {
        "txt": "TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index)"
      },
      {
        "txt": "{ long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) {"
      },
      {
        "txt": "long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) { return _tokens[index]; }"
      },
      {
        "txt": "public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; }"
      },
      {
        "txt": "_next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null;"
      },
      {
        "txt": "} _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal();"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) {"
      },
      {
        "txt": "typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2);"
      },
      {
        "txt": "} _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) {"
      },
      {
        "txt": "_nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1459,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 188,
    "end-bug-line": 188,
    "bug": "",
    "fix": "_forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds;"
      },
      {
        "txt": "protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated"
      },
      {
        "txt": "public TokenBuffer(ObjectCodec codec) { this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0;"
      },
      {
        "txt": "_hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec();"
      },
      {
        "txt": "_writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; <extra_id_0> @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() {"
      },
      {
        "txt": "public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) {"
      },
      {
        "txt": "Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1;"
      },
      {
        "txt": "final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr);"
      },
      {
        "txt": "if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); }"
      },
      {
        "txt": "} switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) {"
      },
      {
        "txt": "gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) {"
      },
      {
        "txt": "gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr);"
      },
      {
        "txt": "if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject();"
      },
      {
        "txt": "do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0;"
      },
      {
        "txt": "final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) {"
      },
      {
        "txt": "if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } }"
      },
      {
        "txt": "} catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString();"
      },
      {
        "txt": "} private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');"
      },
      {
        "txt": "} } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask();"
      },
      {
        "txt": "return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; }"
      },
      {
        "txt": "@Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override"
      },
      {
        "txt": "public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() {"
      },
      {
        "txt": "return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext();"
      },
      {
        "txt": "} @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len);"
      },
      {
        "txt": "} _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));"
      },
      {
        "txt": "} @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override"
      },
      {
        "txt": "public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);"
      },
      {
        "txt": "} @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else {"
      },
      {
        "txt": "_objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len];"
      },
      {
        "txt": "System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p);"
      },
      {
        "txt": "} switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());"
      },
      {
        "txt": "} else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER:"
      },
      {
        "txt": "writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue());"
      },
      {
        "txt": "break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1;"
      },
      {
        "txt": "} } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec;"
      },
      {
        "txt": "protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec,"
      },
      {
        "txt": "boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds;"
      },
      {
        "txt": "_hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0;"
      },
      {
        "txt": "seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } }"
      },
      {
        "txt": "@Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; }"
      },
      {
        "txt": "} _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override"
      },
      {
        "txt": "public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override"
      },
      {
        "txt": "public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName();"
      },
      {
        "txt": "} @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name);"
      },
      {
        "txt": "} catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText();"
      },
      {
        "txt": "return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override"
      },
      {
        "txt": "public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; }"
      },
      {
        "txt": "if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) {"
      },
      {
        "txt": "return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: }"
      },
      {
        "txt": "return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); }"
      },
      {
        "txt": "@Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;"
      },
      {
        "txt": "if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) {"
      },
      {
        "txt": "return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) {"
      },
      {
        "txt": "return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject();"
      },
      {
        "txt": "} return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) {"
      },
      {
        "txt": "return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; }"
      },
      {
        "txt": "ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override"
      },
      {
        "txt": "public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr);"
      },
      {
        "txt": "} @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException {"
      },
      {
        "txt": "if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment"
      },
      {
        "txt": "{ public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes;"
      },
      {
        "txt": "protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF;"
      },
      {
        "txt": "return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix;"
      },
      {
        "txt": "} public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType,"
      },
      {
        "txt": "Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } }"
      },
      {
        "txt": "public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1460,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 193,
    "end-bug-line": 193,
    "bug": "",
    "fix": "public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) {"
      },
      {
        "txt": "this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds;"
      },
      {
        "txt": "_hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES;"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } <extra_id_0> @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonParser asParser() {"
      },
      {
        "txt": "public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) {"
      },
      {
        "txt": "Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1;"
      },
      {
        "txt": "final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr);"
      },
      {
        "txt": "if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); }"
      },
      {
        "txt": "} switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) {"
      },
      {
        "txt": "gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) {"
      },
      {
        "txt": "gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr);"
      },
      {
        "txt": "if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject();"
      },
      {
        "txt": "do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0;"
      },
      {
        "txt": "final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) {"
      },
      {
        "txt": "if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } }"
      },
      {
        "txt": "} catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString();"
      },
      {
        "txt": "} private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');"
      },
      {
        "txt": "} } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask();"
      },
      {
        "txt": "return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; }"
      },
      {
        "txt": "@Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override"
      },
      {
        "txt": "public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() {"
      },
      {
        "txt": "return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext();"
      },
      {
        "txt": "} @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len);"
      },
      {
        "txt": "} _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));"
      },
      {
        "txt": "} @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override"
      },
      {
        "txt": "public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);"
      },
      {
        "txt": "} @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else {"
      },
      {
        "txt": "_objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len];"
      },
      {
        "txt": "System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p);"
      },
      {
        "txt": "} switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());"
      },
      {
        "txt": "} else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER:"
      },
      {
        "txt": "writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue());"
      },
      {
        "txt": "break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(jp); } writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp);"
      },
      {
        "txt": "} writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) {"
      },
      {
        "txt": "_hasNativeId = true; } if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "protected final void _appendRaw(int rawType, Object value) { Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1;"
      },
      {
        "txt": "} } @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec;"
      },
      {
        "txt": "protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec,"
      },
      {
        "txt": "boolean hasNativeTypeIds, boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds;"
      },
      {
        "txt": "_hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); } public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override"
      },
      {
        "txt": "public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0;"
      },
      {
        "txt": "seg = (seg == null) ? null : seg.next(); } return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } }"
      },
      {
        "txt": "@Override public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; }"
      },
      {
        "txt": "} _currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1);"
      },
      {
        "txt": "} else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override"
      },
      {
        "txt": "public String nextFieldName() throws IOException { if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override"
      },
      {
        "txt": "public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName();"
      },
      {
        "txt": "} @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name);"
      },
      {
        "txt": "} catch (IOException e) { throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject();"
      },
      {
        "txt": "if (ob instanceof String) { return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText();"
      },
      {
        "txt": "return (str == null) ? null : str.toCharArray(); } @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override"
      },
      {
        "txt": "public boolean hasTextCharacters() { return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; }"
      },
      {
        "txt": "if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) {"
      },
      {
        "txt": "return (BigDecimal) n; } switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: }"
      },
      {
        "txt": "return BigDecimal.valueOf(n.doubleValue()); } @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); }"
      },
      {
        "txt": "@Override public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException {"
      },
      {
        "txt": "return getNumberValue().longValue(); } @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;"
      },
      {
        "txt": "if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) {"
      },
      {
        "txt": "return (Number) value; } if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) {"
      },
      {
        "txt": "return null; } throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject();"
      },
      {
        "txt": "} return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) {"
      },
      {
        "txt": "return (byte[]) ob; } } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; }"
      },
      {
        "txt": "ByteArrayBuilder builder = _byteBuilder; if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override"
      },
      {
        "txt": "public boolean canReadObjectId() { return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr);"
      },
      {
        "txt": "} @Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException {"
      },
      {
        "txt": "if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment"
      },
      {
        "txt": "{ public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes;"
      },
      {
        "txt": "protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF;"
      },
      {
        "txt": "return TOKEN_TYPES_BY_INDEX[ix]; } public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix;"
      },
      {
        "txt": "} public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; }"
      },
      {
        "txt": "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next;"
      },
      {
        "txt": "} private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType,"
      },
      {
        "txt": "Object objectId, Object typeId) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ _tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } }"
      },
      {
        "txt": "public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1461,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 959,
    "end-bug-line": 959,
    "bug": "",
    "fix": "if (_forceBigDecimal) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*;"
      },
      {
        "txt": "public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds;"
      },
      {
        "txt": "protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false);"
      },
      {
        "txt": "} public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds;"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) {"
      },
      {
        "txt": "Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1;"
      },
      {
        "txt": "final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr);"
      },
      {
        "txt": "if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); }"
      },
      {
        "txt": "} switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) {"
      },
      {
        "txt": "gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) {"
      },
      {
        "txt": "gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr);"
      },
      {
        "txt": "if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject();"
      },
      {
        "txt": "do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0;"
      },
      {
        "txt": "final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) {"
      },
      {
        "txt": "if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } }"
      },
      {
        "txt": "} catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString();"
      },
      {
        "txt": "} private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');"
      },
      {
        "txt": "} } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask();"
      },
      {
        "txt": "return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; }"
      },
      {
        "txt": "@Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override"
      },
      {
        "txt": "public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() {"
      },
      {
        "txt": "return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext();"
      },
      {
        "txt": "} @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len);"
      },
      {
        "txt": "} _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));"
      },
      {
        "txt": "} @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override"
      },
      {
        "txt": "public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);"
      },
      {
        "txt": "} @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else {"
      },
      {
        "txt": "_objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len];"
      },
      {
        "txt": "System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p);"
      },
      {
        "txt": "} switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());"
      },
      {
        "txt": "} else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER:"
      },
      {
        "txt": "break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: <extra_id_0> switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue());"
      },
      {
        "txt": "case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true); break;"
      },
      {
        "txt": "case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp);"
      },
      {
        "txt": "} writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true;"
      },
      {
        "txt": "} if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value)"
      },
      {
        "txt": "{ Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; }"
      },
      {
        "txt": "} @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds;"
      },
      {
        "txt": "protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds,"
      },
      {
        "txt": "boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);"
      },
      {
        "txt": "} public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() {"
      },
      {
        "txt": "return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next();"
      },
      {
        "txt": "} return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override"
      },
      {
        "txt": "public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } }"
      },
      {
        "txt": "_currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT"
      },
      {
        "txt": "|| _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() {"
      },
      {
        "txt": "return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); }"
      },
      {
        "txt": "@Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) {"
      },
      {
        "txt": "throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) {"
      },
      {
        "txt": "return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray();"
      },
      {
        "txt": "} @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() {"
      },
      {
        "txt": "return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) {"
      },
      {
        "txt": "return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n;"
      },
      {
        "txt": "} switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue());"
      },
      {
        "txt": "} @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override"
      },
      {
        "txt": "public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue();"
      },
      {
        "txt": "} @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER;"
      },
      {
        "txt": "if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value;"
      },
      {
        "txt": "} if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null;"
      },
      {
        "txt": "} throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); }"
      },
      {
        "txt": "return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob;"
      },
      {
        "txt": "} } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder;"
      },
      {
        "txt": "if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException"
      },
      {
        "txt": "{ byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); }"
      },
      {
        "txt": "@Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment {"
      },
      {
        "txt": "public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];"
      },
      {
        "txt": "protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix];"
      },
      {
        "txt": "} public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; }"
      },
      {
        "txt": "public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) {"
      },
      {
        "txt": "_nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1462,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 964,
    "end-bug-line": 964,
    "bug": "",
    "fix": "writeNumber(p.getDecimalValue()); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.databind.*;"
      },
      {
        "txt": "public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds;"
      },
      {
        "txt": "protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) { this(codec, false);"
      },
      {
        "txt": "} public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds; _hasNativeObjectIds = hasNativeIds;"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null);"
      },
      {
        "txt": "_first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; }"
      },
      {
        "txt": "public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src) {"
      },
      {
        "txt": "Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null; }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); } _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;"
      },
      {
        "txt": "JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first; int ptr = -1;"
      },
      {
        "txt": "final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); } JsonToken t = segment.type(ptr);"
      },
      {
        "txt": "if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id); }"
      },
      {
        "txt": "} switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY: gen.writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob); } else {"
      },
      {
        "txt": "gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n); } else if (n instanceof BigInteger) {"
      },
      {
        "txt": "gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } } break;"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue()); } else if (n == null) {"
      },
      {
        "txt": "gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE: gen.writeBoolean(true);"
      },
      {
        "txt": "break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: { Object value = segment.get(ptr);"
      },
      {
        "txt": "if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\"); }"
      },
      {
        "txt": "} } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t; writeStartObject();"
      },
      {
        "txt": "do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; } @Override"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser(); int count = 0;"
      },
      {
        "txt": "final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); } if (count < MAX_COUNT) {"
      },
      {
        "txt": "if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); } }"
      },
      {
        "txt": "} catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']'); return sb.toString();"
      },
      {
        "txt": "} private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) { sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');"
      },
      {
        "txt": "} } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) { _generatorFeatures &= ~f.getMask();"
      },
      {
        "txt": "return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures; }"
      },
      {
        "txt": "@Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; } @Override"
      },
      {
        "txt": "public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override public boolean canWriteBinaryNatively() {"
      },
      {
        "txt": "return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException { _append(JsonToken.END_ARRAY);"
      },
      {
        "txt": "JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT); _writeContext = _writeContext.createChildObjectContext();"
      },
      {
        "txt": "} @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } }"
      },
      {
        "txt": "@Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException { _append(JsonToken.FIELD_NAME, name);"
      },
      {
        "txt": "_writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text);"
      },
      {
        "txt": "} } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation(); }"
      },
      {
        "txt": "@Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char c) throws IOException {"
      },
      {
        "txt": "_reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len);"
      },
      {
        "txt": "} _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));"
      },
      {
        "txt": "} @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override"
      },
      {
        "txt": "public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException { if (dec == null) {"
      },
      {
        "txt": "writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);"
      },
      {
        "txt": "} @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull();"
      },
      {
        "txt": "return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else {"
      },
      {
        "txt": "_objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; }"
      },
      {
        "txt": "if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException { byte[] copy = new byte[len];"
      },
      {
        "txt": "System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() { return _hasNativeTypeIds;"
      },
      {
        "txt": "} @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true; }"
      },
      {
        "txt": "@Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) { _checkNativeIds(p);"
      },
      {
        "txt": "} switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) { writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());"
      },
      {
        "txt": "} else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break; case BIG_INTEGER:"
      },
      {
        "txt": "break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: <extra_id_0> case BIG_DECIMAL: writeNumber(p.getDecimalValue()); break; case FLOAT: writeNumber(p.getFloatValue()); break;"
      },
      {
        "txt": "writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE:"
      },
      {
        "txt": "writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\");"
      },
      {
        "txt": "} } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp); }"
      },
      {
        "txt": "writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray(); while (jp.nextToken() != JsonToken.END_ARRAY) {"
      },
      {
        "txt": "copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); } writeEndObject();"
      },
      {
        "txt": "break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true; }"
      },
      {
        "txt": "if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) {"
      },
      {
        "txt": "++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId)"
      },
      {
        "txt": ": _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) {"
      },
      {
        "txt": "Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }"
      },
      {
        "txt": "@Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds)"
      },
      {
        "txt": "{ super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds); }"
      },
      {
        "txt": "public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;"
      },
      {
        "txt": "} public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next(); }"
      },
      {
        "txt": "return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override public JsonToken nextToken() throws IOException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } } _currToken = _segment.type(_segmentPtr);"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException {"
      },
      {
        "txt": "if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; } return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;"
      },
      {
        "txt": "} @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() { return (_location == null) ? JsonLocation.NA : _location;"
      },
      {
        "txt": "} @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); } @Override"
      },
      {
        "txt": "public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new RuntimeException(e);"
      },
      {
        "txt": "} } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) { return (String) ob;"
      },
      {
        "txt": "} return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: Object ob = _currentObject();"
      },
      {
        "txt": "return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray(); }"
      },
      {
        "txt": "@Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() { return false;"
      },
      {
        "txt": "} @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) { return ((BigDecimal) n).toBigInteger();"
      },
      {
        "txt": "} return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n; }"
      },
      {
        "txt": "switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue()); }"
      },
      {
        "txt": "@Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override public int getIntValue() throws IOException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue(); }"
      },
      {
        "txt": "@Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER; if (n instanceof Float) return NumberType.FLOAT;"
      },
      {
        "txt": "if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value; }"
      },
      {
        "txt": "if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null; }"
      },
      {
        "txt": "throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); } return null;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob; }"
      },
      {
        "txt": "} if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder; if (builder == null) {"
      },
      {
        "txt": "_byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {"
      },
      {
        "txt": "byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() { return _hasNativeObjectIds;"
      },
      {
        "txt": "} @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); } @Override"
      },
      {
        "txt": "public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) { throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");"
      },
      {
        "txt": "} } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16;"
      },
      {
        "txt": "private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds;"
      },
      {
        "txt": "public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix]; }"
      },
      {
        "txt": "public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; } public Object get(int index) {"
      },
      {
        "txt": "return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) { set(index, tokenType);"
      },
      {
        "txt": "return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; } private void set(int index, JsonToken tokenType)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value; long typeCode = (long) rawTokenType;"
      },
      {
        "txt": "if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) { _nativeIds = new TreeMap<Integer,Object>();"
      },
      {
        "txt": "} if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));"
      },
      {
        "txt": "} public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  },
  {
    "id": 1463,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
    "start-bug-line": 973,
    "end-bug-line": 973,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.TreeMap; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserMinimalBase; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.ByteArrayBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.*; public class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds;"
      },
      {
        "txt": "protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) {"
      },
      {
        "txt": "this(codec, false); } public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) { _objectCodec = codec; _generatorFeatures = DEFAULT_GENERATOR_FEATURES; _writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = hasNativeIds;"
      },
      {
        "txt": "_hasNativeObjectIds = hasNativeIds; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } public TokenBuffer(JsonParser p) { this(p, null); } public TokenBuffer(JsonParser p, DeserializationContext ctxt) { _objectCodec = p.getCodec(); _generatorFeatures = DEFAULT_GENERATOR_FEATURES;"
      },
      {
        "txt": "_writeContext = JsonWriteContext.createRootContext(null); _first = _last = new Segment(); _appendAt = 0; _hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } @Override public Version version() { return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;"
      },
      {
        "txt": "} public JsonParser asParser() { return asParser(_objectCodec); } public JsonParser asParser(ObjectCodec codec) { return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds); } public JsonParser asParser(JsonParser src)"
      },
      {
        "txt": "{ Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds); p.setLocation(src.getTokenLocation()); return p; } public JsonToken firstToken() { if (_first != null) { return _first.type(0); } return null;"
      },
      {
        "txt": "} @SuppressWarnings(\"resource\") public TokenBuffer append(TokenBuffer other) throws IOException { if (!_hasNativeTypeIds) { _hasNativeTypeIds = other.canWriteTypeId(); } if (!_hasNativeObjectIds) { _hasNativeObjectIds = other.canWriteObjectId(); }"
      },
      {
        "txt": "_mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; JsonParser p = other.asParser(); while (p.nextToken() != null) { copyCurrentStructure(p); } return this; } public void serialize(JsonGenerator gen) throws IOException { Segment segment = _first;"
      },
      {
        "txt": "int ptr = -1; final boolean checkIds = _mayHaveNativeIds; boolean hasIds = checkIds && (segment.hasIds()); while (true) { if (++ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; segment = segment.next(); if (segment == null) break; hasIds = checkIds && (segment.hasIds()); }"
      },
      {
        "txt": "JsonToken t = segment.type(ptr); if (t == null) break; if (hasIds) { Object id = segment.findObjectId(ptr); if (id != null) { gen.writeObjectId(id); } id = segment.findTypeId(ptr); if (id != null) { gen.writeTypeId(id);"
      },
      {
        "txt": "} } switch (t) { case START_OBJECT: gen.writeStartObject(); break; case END_OBJECT: gen.writeEndObject(); break; case START_ARRAY:"
      },
      {
        "txt": "gen.writeStartArray(); break; case END_ARRAY: gen.writeEndArray(); break; case FIELD_NAME: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeFieldName((SerializableString) ob);"
      },
      {
        "txt": "} else { gen.writeFieldName((String) ob); } } break; case VALUE_STRING: { Object ob = segment.get(ptr); if (ob instanceof SerializableString) { gen.writeString((SerializableString) ob);"
      },
      {
        "txt": "} else { gen.writeString((String) ob); } } break; case VALUE_NUMBER_INT: { Object n = segment.get(ptr); if (n instanceof Integer) { gen.writeNumber((Integer) n);"
      },
      {
        "txt": "} else if (n instanceof BigInteger) { gen.writeNumber((BigInteger) n); } else if (n instanceof Long) { gen.writeNumber((Long) n); } else if (n instanceof Short) { gen.writeNumber((Short) n); } else { gen.writeNumber(((Number) n).intValue()); } }"
      },
      {
        "txt": "break; case VALUE_NUMBER_FLOAT: { Object n = segment.get(ptr); if (n instanceof Double) { gen.writeNumber(((Double) n).doubleValue()); } else if (n instanceof BigDecimal) { gen.writeNumber((BigDecimal) n); } else if (n instanceof Float) { gen.writeNumber(((Float) n).floatValue());"
      },
      {
        "txt": "} else if (n == null) { gen.writeNull(); } else if (n instanceof String) { gen.writeNumber((String) n); } else { throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\"); } } break; case VALUE_TRUE:"
      },
      {
        "txt": "gen.writeBoolean(true); break; case VALUE_FALSE: gen.writeBoolean(false); break; case VALUE_NULL: gen.writeNull(); break; case VALUE_EMBEDDED_OBJECT: {"
      },
      {
        "txt": "Object value = segment.get(ptr); if (value instanceof RawValue) { ((RawValue) value).serialize(gen); } else { gen.writeObject(value); } } break; default: throw new RuntimeException(\"Internal error: should never end up through this code path\");"
      },
      {
        "txt": "} } } public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(p); return this; } JsonToken t;"
      },
      {
        "txt": "writeStartObject(); do { copyCurrentStructure(p); } while ((t = p.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject(); return this; }"
      },
      {
        "txt": "@Override @SuppressWarnings(\"resource\") public String toString() { final int MAX_COUNT = 100; StringBuilder sb = new StringBuilder(); sb.append(\"[TokenBuffer: \"); sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\"); sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\"); JsonParser jp = asParser();"
      },
      {
        "txt": "int count = 0; final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds; while (true) { JsonToken t; try { t = jp.nextToken(); if (t == null) break; if (hasNativeIds) { _appendNativeIds(sb); }"
      },
      {
        "txt": "if (count < MAX_COUNT) { if (count > 0) { sb.append(\", \"); } sb.append(t.toString()); if (t == JsonToken.FIELD_NAME) { sb.append('('); sb.append(jp.getCurrentName()); sb.append(')'); }"
      },
      {
        "txt": "} } catch (IOException ioe) { // should never occur throw new IllegalStateException(ioe); } ++count; } if (count >= MAX_COUNT) { sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\"); } sb.append(']');"
      },
      {
        "txt": "return sb.toString(); } private final void _appendNativeIds(StringBuilder sb) { Object objectId = _last.findObjectId(_appendAt-1); if (objectId != null) { sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']'); } Object typeId = _last.findTypeId(_appendAt-1); if (typeId != null) {"
      },
      {
        "txt": "sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']'); } } @Override public JsonGenerator enable(Feature f) { _generatorFeatures |= f.getMask(); return this; } @Override public JsonGenerator disable(Feature f) {"
      },
      {
        "txt": "_generatorFeatures &= ~f.getMask(); return this; } @Override public boolean isEnabled(Feature f) { return (_generatorFeatures & f.getMask()) != 0; } @Override public int getFeatureMask() { return _generatorFeatures;"
      },
      {
        "txt": "} @Override public JsonGenerator setFeatureMask(int mask) { _generatorFeatures = mask; return this; } @Override public JsonGenerator useDefaultPrettyPrinter() { return this; }"
      },
      {
        "txt": "@Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public final JsonWriteContext getOutputContext() { return _writeContext; } @Override"
      },
      {
        "txt": "public boolean canWriteBinaryNatively() { return true; } @Override public void flush() throws IOException { /* NOP */ } @Override public void close() throws IOException { _closed = true; } @Override"
      },
      {
        "txt": "public boolean isClosed() { return _closed; } @Override public final void writeStartArray() throws IOException { _append(JsonToken.START_ARRAY); _writeContext = _writeContext.createChildArrayContext(); } @Override public final void writeEndArray() throws IOException {"
      },
      {
        "txt": "_append(JsonToken.END_ARRAY); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; } } @Override public final void writeStartObject() throws IOException { _append(JsonToken.START_OBJECT);"
      },
      {
        "txt": "_writeContext = _writeContext.createChildObjectContext(); } @Override public final void writeEndObject() throws IOException { _append(JsonToken.END_OBJECT); JsonWriteContext c = _writeContext.getParent(); if (c != null) { _writeContext = c; }"
      },
      {
        "txt": "} @Override public final void writeFieldName(String name) throws IOException { _append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name); } @Override public void writeFieldName(SerializableString name) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.FIELD_NAME, name); _writeContext.writeFieldName(name.getValue()); } @Override public void writeString(String text) throws IOException { if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); }"
      },
      {
        "txt": "} @Override public void writeString(char[] text, int offset, int len) throws IOException { writeString(new String(text, offset, len)); } @Override public void writeString(SerializableString text) throws IOException { if (text == null) { writeNull(); } else {"
      },
      {
        "txt": "_append(JsonToken.VALUE_STRING, text); } } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException"
      },
      {
        "txt": "{ _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text, int offset, int len) throws IOException { _reportUnsupportedOperation();"
      },
      {
        "txt": "} @Override public void writeRaw(SerializableString text) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { _reportUnsupportedOperation(); } @Override"
      },
      {
        "txt": "public void writeRaw(char c) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { if (offset > 0 || len != text.length()) {"
      },
      {
        "txt": "text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } @Override public void writeNumber(short i) throws IOException {"
      },
      {
        "txt": "_append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); }"
      },
      {
        "txt": "@Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override public void writeNumber(BigDecimal dec) throws IOException {"
      },
      {
        "txt": "if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } } @Override public void writeNumber(BigInteger v) throws IOException { if (v == null) { writeNull();"
      },
      {
        "txt": "} else { _append(JsonToken.VALUE_NUMBER_INT, v); } } @Override public void writeNumber(String encodedValue) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException {"
      },
      {
        "txt": "_append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } @Override public void writeObject(Object value) throws IOException { if (value == null) {"
      },
      {
        "txt": "writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);"
      },
      {
        "txt": "} else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return;"
      },
      {
        "txt": "} if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {"
      },
      {
        "txt": "byte[] copy = new byte[len]; System.arraycopy(data, offset, copy, 0, len); writeObject(copy); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { throw new UnsupportedOperationException(); } @Override public boolean canWriteTypeId() {"
      },
      {
        "txt": "return _hasNativeTypeIds; } @Override public boolean canWriteObjectId() { return _hasNativeObjectIds; } @Override public void writeTypeId(Object id) { _typeId = id; _hasNativeId = true;"
      },
      {
        "txt": "} @Override public void writeObjectId(Object id) { _objectId = id; _hasNativeId = true; } @Override public void copyCurrentEvent(JsonParser p) throws IOException { if (_mayHaveNativeIds) {"
      },
      {
        "txt": "_checkNativeIds(p); } switch (p.getCurrentToken()) { case START_OBJECT: writeStartObject(); break; case END_OBJECT: writeEndObject(); break; case START_ARRAY:"
      },
      {
        "txt": "writeStartArray(); break; case END_ARRAY: writeEndArray(); break; case FIELD_NAME: writeFieldName(p.getCurrentName()); break; case VALUE_STRING: if (p.hasTextCharacters()) {"
      },
      {
        "txt": "writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength()); } else { writeString(p.getText()); } break; case VALUE_NUMBER_INT: switch (p.getNumberType()) { case INT: writeNumber(p.getIntValue()); break;"
      },
      {
        "txt": "case BIG_INTEGER: writeNumber(p.getBigIntegerValue()); break; default: writeNumber(p.getLongValue()); } break; case VALUE_NUMBER_FLOAT: switch (p.getNumberType()) { case BIG_DECIMAL:"
      },
      {
        "txt": "break; case FLOAT: writeNumber(p.getFloatValue()); break; default: writeNumber(p.getDoubleValue()); <extra_id_0> break; case VALUE_TRUE: writeBoolean(true); break; case VALUE_FALSE: writeBoolean(false);"
      },
      {
        "txt": "case VALUE_FALSE: writeBoolean(false); break; case VALUE_NULL: writeNull(); break; case VALUE_EMBEDDED_OBJECT: writeObject(p.getEmbeddedObject()); break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Internal error: should never end up through this code path\"); } } @Override public void copyCurrentStructure(JsonParser jp) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.FIELD_NAME) { if (_mayHaveNativeIds) { _checkNativeIds(jp);"
      },
      {
        "txt": "} writeFieldName(jp.getCurrentName()); t = jp.nextToken(); } if (_mayHaveNativeIds) { _checkNativeIds(jp); } switch (t) { case START_ARRAY: writeStartArray();"
      },
      {
        "txt": "while (jp.nextToken() != JsonToken.END_ARRAY) { copyCurrentStructure(jp); } writeEndArray(); break; case START_OBJECT: writeStartObject(); while (jp.nextToken() != JsonToken.END_OBJECT) { copyCurrentStructure(jp); }"
      },
      {
        "txt": "writeEndObject(); break; default: // others are simple: copyCurrentEvent(jp); } } private final void _checkNativeIds(JsonParser jp) throws IOException { if ((_typeId = jp.getTypeId()) != null) { _hasNativeId = true;"
      },
      {
        "txt": "} if ((_objectId = jp.getObjectId()) != null) { _hasNativeId = true; } } protected final void _append(JsonToken type) { Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type);"
      },
      {
        "txt": "if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } protected final void _append(JsonToken type, Object value) { Segment next = _hasNativeId"
      },
      {
        "txt": "? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value)"
      },
      {
        "txt": "{ Segment next = _hasNativeId ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId) : _last.appendRaw(_appendAt, rawType, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; }"
      },
      {
        "txt": "} @Override protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\"); } protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds;"
      },
      {
        "txt": "protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds,"
      },
      {
        "txt": "boolean hasNativeObjectIds) { super(0); _segment = firstSeg; _segmentPtr = -1; // not yet read _codec = codec; _parsingContext = JsonReadContext.createRootContext(null); _hasNativeTypeIds = hasNativeTypeIds; _hasNativeObjectIds = hasNativeObjectIds; _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);"
      },
      {
        "txt": "} public void setLocation(JsonLocation l) { _location = l; } @Override public ObjectCodec getCodec() { return _codec; } @Override public void setCodec(ObjectCodec c) { _codec = c; } @Override public Version version() {"
      },
      {
        "txt": "return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; } public JsonToken peekNextToken() throws IOException { if (_closed) return null; Segment seg = _segment; int ptr = _segmentPtr+1; if (ptr >= Segment.TOKENS_PER_SEGMENT) { ptr = 0; seg = (seg == null) ? null : seg.next();"
      },
      {
        "txt": "} return (seg == null) ? null : seg.type(ptr); } @Override public void close() throws IOException { if (!_closed) { _closed = true; } } @Override"
      },
      {
        "txt": "public JsonToken nextToken() throws IOException { if (_closed || (_segment == null)) return null; if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { _segmentPtr = 0; _segment = _segment.next(); if (_segment == null) { return null; } }"
      },
      {
        "txt": "_currToken = _segment.type(_segmentPtr); if (_currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); } else if (_currToken == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(-1, -1); } else if (_currToken == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(-1, -1); } else if (_currToken == JsonToken.END_OBJECT"
      },
      {
        "txt": "|| _currToken == JsonToken.END_ARRAY) { _parsingContext = _parsingContext.getParent(); if (_parsingContext == null) { _parsingContext = JsonReadContext.createRootContext(null); } } return _currToken; } @Override public String nextFieldName() throws IOException"
      },
      {
        "txt": "{ if (_closed || (_segment == null)) return null; int ptr = _segmentPtr+1; if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) { _segmentPtr = ptr; Object ob = _segment.get(ptr); // inlined _currentObject(); String name = (ob instanceof String) ? ((String) ob) : ob.toString(); _parsingContext.setCurrentName(name); return name; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; } @Override public boolean isClosed() { return _closed; } @Override public JsonStreamContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return getCurrentLocation(); } @Override public JsonLocation getCurrentLocation() {"
      },
      {
        "txt": "return (_location == null) ? JsonLocation.NA : _location; } @Override public String getCurrentName() { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); return parent.getCurrentName(); } return _parsingContext.getCurrentName(); }"
      },
      {
        "txt": "@Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) {"
      },
      {
        "txt": "throw new RuntimeException(e); } } @Override public String getText() { if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { Object ob = _currentObject(); if (ob instanceof String) {"
      },
      {
        "txt": "return (String) ob; } return (ob == null) ? null : ob.toString(); } if (_currToken == null) { return null; } switch (_currToken) { case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "Object ob = _currentObject(); return (ob == null) ? null : ob.toString(); default: return _currToken.asString(); } } @Override public char[] getTextCharacters() { String str = getText(); return (str == null) ? null : str.toCharArray();"
      },
      {
        "txt": "} @Override public int getTextLength() { String str = getText(); return (str == null) ? 0 : str.length(); } @Override public int getTextOffset() { return 0; } @Override public boolean hasTextCharacters() {"
      },
      {
        "txt": "return false; } @Override public BigInteger getBigIntegerValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigInteger) { return (BigInteger) n; } if (getNumberType() == NumberType.BIG_DECIMAL) {"
      },
      {
        "txt": "return ((BigDecimal) n).toBigInteger(); } return BigInteger.valueOf(n.longValue()); } @Override public BigDecimal getDecimalValue() throws IOException { Number n = getNumberValue(); if (n instanceof BigDecimal) { return (BigDecimal) n;"
      },
      {
        "txt": "} switch (getNumberType()) { case INT: case LONG: return BigDecimal.valueOf(n.longValue()); case BIG_INTEGER: return new BigDecimal((BigInteger) n); default: } return BigDecimal.valueOf(n.doubleValue());"
      },
      {
        "txt": "} @Override public double getDoubleValue() throws IOException { return getNumberValue().doubleValue(); } @Override public float getFloatValue() throws IOException { return getNumberValue().floatValue(); } @Override"
      },
      {
        "txt": "public int getIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { return ((Number) _currentObject()).intValue(); } return getNumberValue().intValue(); } @Override public long getLongValue() throws IOException { return getNumberValue().longValue();"
      },
      {
        "txt": "} @Override public NumberType getNumberType() throws IOException { Number n = getNumberValue(); if (n instanceof Integer) return NumberType.INT; if (n instanceof Long) return NumberType.LONG; if (n instanceof Double) return NumberType.DOUBLE; if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL; if (n instanceof BigInteger) return NumberType.BIG_INTEGER;"
      },
      {
        "txt": "if (n instanceof Float) return NumberType.FLOAT; if (n instanceof Short) return NumberType.INT; // should be SHORT return null; } @Override public final Number getNumberValue() throws IOException { _checkIsNumber(); Object value = _currentObject(); if (value instanceof Number) { return (Number) value;"
      },
      {
        "txt": "} if (value instanceof String) { String str = (String) value; if (str.indexOf('.') >= 0) { return Double.parseDouble(str); } return Long.parseLong(str); } if (value == null) { return null;"
      },
      {
        "txt": "} throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \" +value.getClass().getName()); } @Override public Object getEmbeddedObject() { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { return _currentObject(); }"
      },
      {
        "txt": "return null; } @Override @SuppressWarnings(\"resource\") public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = _currentObject(); if (ob instanceof byte[]) { return (byte[]) ob;"
      },
      {
        "txt": "} } if (_currToken != JsonToken.VALUE_STRING) { throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\"); } final String str = getText(); if (str == null) { return null; } ByteArrayBuilder builder = _byteBuilder;"
      },
      {
        "txt": "if (builder == null) { _byteBuilder = builder = new ByteArrayBuilder(100); } else { _byteBuilder.reset(); } _decodeBase64(str, builder, b64variant); return builder.toByteArray(); } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException"
      },
      {
        "txt": "{ byte[] data = getBinaryValue(b64variant); if (data != null) { out.write(data, 0, data.length); return data.length; } return 0; } @Override public boolean canReadObjectId() {"
      },
      {
        "txt": "return _hasNativeObjectIds; } @Override public boolean canReadTypeId() { return _hasNativeTypeIds; } @Override public Object getTypeId() { return _segment.findTypeId(_segmentPtr); }"
      },
      {
        "txt": "@Override public Object getObjectId() { return _segment.findObjectId(_segmentPtr); } protected final Object _currentObject() { return _segment.get(_segmentPtr); } protected final void _checkIsNumber() throws JsonParseException { if (_currToken == null || !_currToken.isNumeric()) {"
      },
      {
        "txt": "throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\"); } } @Override protected void _handleEOF() throws JsonParseException { _throwInternal(); } } protected final static class Segment {"
      },
      {
        "txt": "public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];"
      },
      {
        "txt": "protected TreeMap<Integer,Object> _nativeIds; public Segment() { } public JsonToken type(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return TOKEN_TYPES_BY_INDEX[ix];"
      },
      {
        "txt": "} public int rawType(int index) { long l = _tokenTypes; if (index > 0) { l >>= (index << 2); } int ix = ((int) l) & 0xF; return ix; }"
      },
      {
        "txt": "public Object get(int index) { return _tokens[index]; } public Segment next() { return _next; } public boolean hasIds() { return _nativeIds != null; } public Segment append(int index, JsonToken tokenType) { if (index < TOKENS_PER_SEGMENT) {"
      },
      {
        "txt": "set(index, tokenType); return null; } _next = new Segment(); _next.set(0, tokenType); return _next; } public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, objectId, typeId); return _next; } public Segment append(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value); return null; } _next = new Segment(); _next.set(0, tokenType, value); return _next; } public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, tokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, tokenType, value, objectId, typeId); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value)"
      },
      {
        "txt": "{ if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value); return null; } _next = new Segment(); _next.set(0, rawTokenType, value); return _next; } public Segment appendRaw(int index, int rawTokenType, Object value,"
      },
      {
        "txt": "Object objectId, Object typeId) { if (index < TOKENS_PER_SEGMENT) { set(index, rawTokenType, value, objectId, typeId); return null; } _next = new Segment(); _next.set(0, rawTokenType, value, objectId, typeId); return _next; }"
      },
      {
        "txt": "private void set(int index, JsonToken tokenType) { long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object objectId, Object typeId)"
      },
      {
        "txt": "{ long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, JsonToken tokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = tokenType.ordinal(); if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private void set(int index, int rawTokenType, Object value) {"
      },
      {
        "txt": "_tokens[index] = value; long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; } private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) { _tokens[index] = value;"
      },
      {
        "txt": "long typeCode = (long) rawTokenType; if (index > 0) { typeCode <<= (index << 2); } _tokenTypes |= typeCode; assignNativeIds(index, objectId, typeId); } private final void assignNativeIds(int index, Object objectId, Object typeId) { if (_nativeIds == null) {"
      },
      {
        "txt": "_nativeIds = new TreeMap<Integer,Object>(); } if (objectId != null) { _nativeIds.put(_objectIdIndex(index), objectId); } if (typeId != null) { _nativeIds.put(_typeIdIndex(index), typeId); } } public Object findObjectId(int index) {"
      },
      {
        "txt": "return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index)); } public Object findTypeId(int index) { return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index)); } private final int _typeIdIndex(int i) { return i+i; } private final int _objectIdIndex(int i) { return i+i+1; } }"
      }
    ]
  }
]