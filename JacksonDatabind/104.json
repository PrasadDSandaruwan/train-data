[
  {
    "id": 1778,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 441,
    "end-bug-line": 441,
    "bug": "",
    "fix": "if (cal.get(Calendar.ERA) == GregorianCalendar.BC) { _formatBCEYear(buffer, year); } else { if (year > 9999) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Matcher; import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput;"
      },
      {
        "txt": "@SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static { Pattern p = null; try {"
      },
      {
        "txt": "p = Pattern.compile(PATTERN_PLAIN_STR +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds +\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t); } PATTERN_ISO8601 = p; }"
      },
      {
        "txt": "public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE;"
      },
      {
        "txt": "static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);"
      },
      {
        "txt": "DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false;"
      },
      {
        "txt": "public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false);"
      },
      {
        "txt": "} protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE;"
      },
      {
        "txt": "} public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); }"
      },
      {
        "txt": "public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) { if (_equals(b, _lenient)) { return this; }"
      },
      {
        "txt": "return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon); } public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b); } @Override public StdDateFormat clone() {"
      },
      {
        "txt": "return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon); } @Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9 public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null);"
      },
      {
        "txt": "} @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats();"
      },
      {
        "txt": "_timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) { _lenient = newValue; _clearFormats(); }"
      },
      {
        "txt": "} @Override // since 2.7 public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon; } @Override public Date parse(String dateStr) throws ParseException"
      },
      {
        "txt": "{ dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) {"
      },
      {
        "txt": "sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex());"
      },
      {
        "txt": "} @Override public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) { } return null; }"
      },
      {
        "txt": "protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') {"
      },
      {
        "txt": "break; } } } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos); } return parseAsRFC1123(dateStr, pos); }"
      },
      {
        "txt": "@Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE; } _format(tz, _locale, date, toAppendTo); return toAppendTo;"
      },
      {
        "txt": "protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR); <extra_id_0> pad4(buffer, year); buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH)); buffer.append('T');"
      },
      {
        "txt": "pad2(buffer, cal.get(Calendar.DAY_OF_MONTH)); buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':'); pad2(buffer, cal.get(Calendar.SECOND)); buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis());"
      },
      {
        "txt": "if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) { buffer.append(':'); } pad2(buffer, minutes); } else {"
      },
      {
        "txt": "if( _tzSerializedWithColon ) { buffer.append(\"+00:00\"); } else { buffer.append(\"+0000\"); } } } private static void pad2(StringBuffer buffer, int value) { int tens = value / 10;"
      },
      {
        "txt": "if (tens == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + tens)); value -= 10 * tens; } buffer.append((char) ('0' + value)); } private static void pad3(StringBuffer buffer, int value) { int h = value / 100;"
      },
      {
        "txt": "if (h == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + h)); value -= (h * 100); } pad2(buffer, value); } private static void pad4(StringBuffer buffer, int value) { int h = value / 100;"
      },
      {
        "txt": "if (h == 0) { buffer.append('0').append('0'); } else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value); } @Override public String toString() {"
      },
      {
        "txt": "return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\", getClass().getName(), _timezone, _locale, _lenient); } public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\") .append(DATE_FORMAT_STR_RFC1123) .append(\"' (\")"
      },
      {
        "txt": "; sb.append(Boolean.FALSE.equals(_lenient) ? \"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); }"
      },
      {
        "txt": "@Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-'"
      },
      {
        "txt": "&& Character.isDigit(dateStr.charAt(5)) ) { return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException { long ts; try {"
      },
      {
        "txt": "ts = NumberInput.parseLong(longStr); } catch (NumberFormatException e) { throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); } protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException"
      },
      {
        "txt": "{ try { return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); } } protected Date _parseAsISO8601(String dateStr, ParsePosition bogus)"
      },
      {
        "txt": "throws IllegalArgumentException, ParseException { final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz); cal.clear(); String formatStr;"
      },
      {
        "txt": "if (totalLen <= 10) { Matcher m = PATTERN_PLAIN.matcher(dateStr); if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); }"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_PLAIN; } else { Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z' int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours if (len >= 5) {"
      },
      {
        "txt": "offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes } if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs); cal.set(Calendar.DST_OFFSET, 0); }"
      },
      {
        "txt": "int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17); } else { seconds = 0;"
      },
      {
        "txt": "} cal.set(year, month, day, hour, minute, seconds); start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else { msecs = 0; final int fractLen = end-start;"
      },
      {
        "txt": "switch (fractLen) { default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); } case 3: msecs += (dateStr.charAt(start+2) - '0');"
      },
      {
        "txt": "case 2: msecs += 10 * (dateStr.charAt(start+1) - '0'); case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; } cal.set(Calendar.MILLISECOND, msecs); }"
      },
      {
        "txt": "return cal.getTime(); } formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0); } private static int _parse4D(String str, int index) {"
      },
      {
        "txt": "return (1000 * (str.charAt(index) - '0')) + (100 * (str.charAt(index+1) - '0')) + (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0'); } protected Date parseAsRFC1123(String dateStr, ParsePosition pos)"
      },
      {
        "txt": "{ if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {"
      },
      {
        "txt": "if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) {"
      },
      {
        "txt": "df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) { Calendar cal = _calendar; if (cal == null ) {"
      },
      {
        "txt": "_calendar = cal = (Calendar)CALENDAR.clone(); } if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; } protected static <T> boolean _equals(T value1, T value2) { if (value1 == value2) {"
      },
      {
        "txt": "return true; } return (value1 != null) && value1.equals(value2); }"
      }
    ]
  },
  {
    "id": 1779,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 446,
    "end-bug-line": 446,
    "bug": "",
    "fix": "buffer.append('+'); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Matcher; import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput;"
      },
      {
        "txt": "@SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static { Pattern p = null; try {"
      },
      {
        "txt": "p = Pattern.compile(PATTERN_PLAIN_STR +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds +\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t); } PATTERN_ISO8601 = p; }"
      },
      {
        "txt": "public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE;"
      },
      {
        "txt": "static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);"
      },
      {
        "txt": "DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false;"
      },
      {
        "txt": "public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false);"
      },
      {
        "txt": "} protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE;"
      },
      {
        "txt": "} public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); }"
      },
      {
        "txt": "public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) { if (_equals(b, _lenient)) { return this; }"
      },
      {
        "txt": "return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon); } public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b); } @Override public StdDateFormat clone() {"
      },
      {
        "txt": "return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon); } @Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9 public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null);"
      },
      {
        "txt": "} @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats();"
      },
      {
        "txt": "_timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) { _lenient = newValue; _clearFormats(); }"
      },
      {
        "txt": "} @Override // since 2.7 public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon; } @Override public Date parse(String dateStr) throws ParseException"
      },
      {
        "txt": "{ dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) {"
      },
      {
        "txt": "sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex());"
      },
      {
        "txt": "} @Override public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) { } return null; }"
      },
      {
        "txt": "protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') {"
      },
      {
        "txt": "break; } } } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos); } return parseAsRFC1123(dateStr, pos); }"
      },
      {
        "txt": "@Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE; } _format(tz, _locale, date, toAppendTo); return toAppendTo;"
      },
      {
        "txt": "protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR); <extra_id_0> buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH)); buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));"
      },
      {
        "txt": "buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':'); pad2(buffer, cal.get(Calendar.SECOND)); buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis()); if (offset != 0) {"
      },
      {
        "txt": "int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) { buffer.append(':'); } pad2(buffer, minutes); } else { if( _tzSerializedWithColon ) {"
      },
      {
        "txt": "buffer.append(\"+00:00\"); } else { buffer.append(\"+0000\"); } } } private static void pad2(StringBuffer buffer, int value) { int tens = value / 10; if (tens == 0) {"
      },
      {
        "txt": "buffer.append('0'); } else { buffer.append((char) ('0' + tens)); value -= 10 * tens; } buffer.append((char) ('0' + value)); } private static void pad3(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) {"
      },
      {
        "txt": "buffer.append('0'); } else { buffer.append((char) ('0' + h)); value -= (h * 100); } pad2(buffer, value); } private static void pad4(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) {"
      },
      {
        "txt": "buffer.append('0').append('0'); } else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value); } @Override public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\","
      },
      {
        "txt": "getClass().getName(), _timezone, _locale, _lenient); } public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\") .append(DATE_FORMAT_STR_RFC1123) .append(\"' (\") ;"
      },
      {
        "txt": "sb.append(Boolean.FALSE.equals(_lenient) ? \"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130]"
      },
      {
        "txt": "public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' && Character.isDigit(dateStr.charAt(5))"
      },
      {
        "txt": ") { return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException { long ts; try { ts = NumberInput.parseLong(longStr);"
      },
      {
        "txt": "} catch (NumberFormatException e) { throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); } protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException {"
      },
      {
        "txt": "try { return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); } } protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException"
      },
      {
        "txt": "{ final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz); cal.clear(); String formatStr; if (totalLen <= 10) {"
      },
      {
        "txt": "Matcher m = PATTERN_PLAIN.matcher(dateStr); if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); } formatStr = DATE_FORMAT_STR_PLAIN;"
      },
      {
        "txt": "} else { Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z' int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours if (len >= 5) { offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes"
      },
      {
        "txt": "} if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs); cal.set(Calendar.DST_OFFSET, 0); } int year = _parse4D(dateStr, 0);"
      },
      {
        "txt": "int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17); } else { seconds = 0; }"
      },
      {
        "txt": "cal.set(year, month, day, hour, minute, seconds); start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else { msecs = 0; final int fractLen = end-start; switch (fractLen) {"
      },
      {
        "txt": "default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); } case 3: msecs += (dateStr.charAt(start+2) - '0'); case 2:"
      },
      {
        "txt": "msecs += 10 * (dateStr.charAt(start+1) - '0'); case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; } cal.set(Calendar.MILLISECOND, msecs); } return cal.getTime();"
      },
      {
        "txt": "} formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0); } private static int _parse4D(String str, int index) { return (1000 * (str.charAt(index) - '0'))"
      },
      {
        "txt": "+ (100 * (str.charAt(index+1) - '0')) + (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0'); } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {"
      },
      {
        "txt": "if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) {"
      },
      {
        "txt": "df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue());"
      },
      {
        "txt": "} return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) { Calendar cal = _calendar; if (cal == null ) { _calendar = cal = (Calendar)CALENDAR.clone();"
      },
      {
        "txt": "} if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; } protected static <T> boolean _equals(T value1, T value2) { if (value1 == value2) { return true;"
      },
      {
        "txt": "} return (value1 != null) && value1.equals(value2); }"
      }
    ]
  },
  {
    "id": 1780,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 447,
    "end-bug-line": 447,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Matcher; import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\")"
      },
      {
        "txt": "public class StdDateFormat extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static { Pattern p = null; try { p = Pattern.compile(PATTERN_PLAIN_STR"
      },
      {
        "txt": "+\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds +\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t); } PATTERN_ISO8601 = p; } public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE; static {"
      },
      {
        "txt": "DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);"
      },
      {
        "txt": "} public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() {"
      },
      {
        "txt": "_locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false); }"
      },
      {
        "txt": "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; }"
      },
      {
        "txt": "public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); } public StdDateFormat withLocale(Locale loc) {"
      },
      {
        "txt": "if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) { if (_equals(b, _lenient)) { return this; } return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon);"
      },
      {
        "txt": "} public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon);"
      },
      {
        "txt": "} @Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9 public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); }"
      },
      {
        "txt": "@Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz;"
      },
      {
        "txt": "} } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) { _lenient = newValue; _clearFormats(); } }"
      },
      {
        "txt": "@Override // since 2.7 public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon; } @Override public Date parse(String dateStr) throws ParseException {"
      },
      {
        "txt": "dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\");"
      },
      {
        "txt": "} else { sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); }"
      },
      {
        "txt": "@Override public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) { } return null; } protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException"
      },
      {
        "txt": "{ if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break;"
      },
      {
        "txt": "} } } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos); } return parseAsRFC1123(dateStr, pos); } @Override"
      },
      {
        "txt": "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE; } _format(tz, _locale, date, toAppendTo); return toAppendTo; }"
      },
      {
        "txt": "StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR); pad4(buffer, year); <extra_id_0> pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH)); buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':');"
      },
      {
        "txt": "pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':'); pad2(buffer, cal.get(Calendar.SECOND)); buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60);"
      },
      {
        "txt": "int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) { buffer.append(':'); } pad2(buffer, minutes); } else { if( _tzSerializedWithColon ) { buffer.append(\"+00:00\");"
      },
      {
        "txt": "} else { buffer.append(\"+0000\"); } } } private static void pad2(StringBuffer buffer, int value) { int tens = value / 10; if (tens == 0) { buffer.append('0');"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + tens)); value -= 10 * tens; } buffer.append((char) ('0' + value)); } private static void pad3(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0');"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + h)); value -= (h * 100); } pad2(buffer, value); } private static void pad4(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0').append('0');"
      },
      {
        "txt": "} else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value); } @Override public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\", getClass().getName(), _timezone, _locale, _lenient);"
      },
      {
        "txt": "} public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\") .append(DATE_FORMAT_STR_RFC1123) .append(\"' (\") ; sb.append(Boolean.FALSE.equals(_lenient) ?"
      },
      {
        "txt": "\"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() {"
      },
      {
        "txt": "return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' && Character.isDigit(dateStr.charAt(5)) ) {"
      },
      {
        "txt": "return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException { long ts; try { ts = NumberInput.parseLong(longStr); } catch (NumberFormatException e) {"
      },
      {
        "txt": "throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); } protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException { try {"
      },
      {
        "txt": "return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); } } protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException {"
      },
      {
        "txt": "final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz); cal.clear(); String formatStr; if (totalLen <= 10) { Matcher m = PATTERN_PLAIN.matcher(dateStr);"
      },
      {
        "txt": "if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); } formatStr = DATE_FORMAT_STR_PLAIN; } else {"
      },
      {
        "txt": "Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z' int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours if (len >= 5) { offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes }"
      },
      {
        "txt": "if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs); cal.set(Calendar.DST_OFFSET, 0); } int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1;"
      },
      {
        "txt": "int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17); } else { seconds = 0; } cal.set(year, month, day, hour, minute, seconds);"
      },
      {
        "txt": "start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else { msecs = 0; final int fractLen = end-start; switch (fractLen) { default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho"
      },
      {
        "txt": "if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); } case 3: msecs += (dateStr.charAt(start+2) - '0'); case 2: msecs += 10 * (dateStr.charAt(start+1) - '0');"
      },
      {
        "txt": "case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; } cal.set(Calendar.MILLISECOND, msecs); } return cal.getTime(); }"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0); } private static int _parse4D(String str, int index) { return (1000 * (str.charAt(index) - '0')) + (100 * (str.charAt(index+1) - '0'))"
      },
      {
        "txt": "+ (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0'); } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) {"
      },
      {
        "txt": "_formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc);"
      },
      {
        "txt": "df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); }"
      },
      {
        "txt": "return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) { Calendar cal = _calendar; if (cal == null ) { _calendar = cal = (Calendar)CALENDAR.clone(); }"
      },
      {
        "txt": "if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; } protected static <T> boolean _equals(T value1, T value2) { if (value1 == value2) { return true; }"
      },
      {
        "txt": "return (value1 != null) && value1.equals(value2); }"
      }
    ]
  },
  {
    "id": 1781,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 483,
    "end-bug-line": 483,
    "bug": "",
    "fix": "protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat;"
      },
      {
        "txt": "import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Matcher; import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat"
      },
      {
        "txt": "extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static { Pattern p = null; try { p = Pattern.compile(PATTERN_PLAIN_STR +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds"
      },
      {
        "txt": "+\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t); } PATTERN_ISO8601 = p; } public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7"
      },
      {
        "txt": "} protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); }"
      },
      {
        "txt": "public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() { _locale = DEFAULT_LOCALE;"
      },
      {
        "txt": "} @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false); } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient,"
      },
      {
        "txt": "boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) {"
      },
      {
        "txt": "if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) {"
      },
      {
        "txt": "return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) { if (_equals(b, _lenient)) { return this; } return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon); }"
      },
      {
        "txt": "public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon); }"
      },
      {
        "txt": "@Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9 public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Override // since 2.6"
      },
      {
        "txt": "public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; }"
      },
      {
        "txt": "} @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7"
      },
      {
        "txt": "public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon; } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim();"
      },
      {
        "txt": "ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else {"
      },
      {
        "txt": "sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override"
      },
      {
        "txt": "public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) { } return null; } protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException {"
      },
      {
        "txt": "if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; }"
      },
      {
        "txt": "} } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos); } return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo,"
      },
      {
        "txt": "FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE; } _format(tz, _locale, date, toAppendTo); return toAppendTo; } protected void _format(TimeZone tz, Locale loc, Date date,"
      },
      {
        "txt": "StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR); pad4(buffer, year); buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));"
      },
      {
        "txt": "buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':'); pad2(buffer, cal.get(Calendar.SECOND)); buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis()); if (offset != 0) {"
      },
      {
        "txt": "int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) { buffer.append(':'); } pad2(buffer, minutes); } else { if( _tzSerializedWithColon ) {"
      },
      {
        "txt": "} else { buffer.append(\"+0000\"); } } } <extra_id_0> private static void pad2(StringBuffer buffer, int value) { int tens = value / 10; if (tens == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + tens));"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + tens)); value -= 10 * tens; } buffer.append((char) ('0' + value)); } private static void pad3(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0');"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + h)); value -= (h * 100); } pad2(buffer, value); } private static void pad4(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0').append('0');"
      },
      {
        "txt": "} else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value); } @Override public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\", getClass().getName(), _timezone, _locale, _lenient);"
      },
      {
        "txt": "} public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\") .append(DATE_FORMAT_STR_RFC1123) .append(\"' (\") ; sb.append(Boolean.FALSE.equals(_lenient) ?"
      },
      {
        "txt": "\"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() {"
      },
      {
        "txt": "return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' && Character.isDigit(dateStr.charAt(5)) ) {"
      },
      {
        "txt": "return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException { long ts; try { ts = NumberInput.parseLong(longStr); } catch (NumberFormatException e) {"
      },
      {
        "txt": "throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); } protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException { try {"
      },
      {
        "txt": "return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); } } protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException {"
      },
      {
        "txt": "final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz); cal.clear(); String formatStr; if (totalLen <= 10) { Matcher m = PATTERN_PLAIN.matcher(dateStr);"
      },
      {
        "txt": "if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); } formatStr = DATE_FORMAT_STR_PLAIN; } else {"
      },
      {
        "txt": "Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z' int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours if (len >= 5) { offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes }"
      },
      {
        "txt": "if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs); cal.set(Calendar.DST_OFFSET, 0); } int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1;"
      },
      {
        "txt": "int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17); } else { seconds = 0; } cal.set(year, month, day, hour, minute, seconds);"
      },
      {
        "txt": "start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else { msecs = 0; final int fractLen = end-start; switch (fractLen) { default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho"
      },
      {
        "txt": "if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); } case 3: msecs += (dateStr.charAt(start+2) - '0'); case 2: msecs += 10 * (dateStr.charAt(start+1) - '0');"
      },
      {
        "txt": "case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; } cal.set(Calendar.MILLISECOND, msecs); } return cal.getTime(); }"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0); } private static int _parse4D(String str, int index) { return (1000 * (str.charAt(index) - '0')) + (100 * (str.charAt(index+1) - '0'))"
      },
      {
        "txt": "+ (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0'); } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) {"
      },
      {
        "txt": "_formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc);"
      },
      {
        "txt": "df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); }"
      },
      {
        "txt": "return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) { Calendar cal = _calendar; if (cal == null ) { _calendar = cal = (Calendar)CALENDAR.clone(); }"
      },
      {
        "txt": "if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; } protected static <T> boolean _equals(T value1, T value2) { if (value1 == value2) { return true; }"
      },
      {
        "txt": "return (value1 != null) && value1.equals(value2); }"
      }
    ]
  },
  {
    "id": 1782,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 485,
    "end-bug-line": 485,
    "bug": "",
    "fix": "if (bceYearNoSign == 1) { buffer.append(\"+0000\"); return; } final int isoYear = bceYearNoSign - 1; buffer.append('-');",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat;"
      },
      {
        "txt": "import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Matcher; import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat"
      },
      {
        "txt": "extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static { Pattern p = null; try { p = Pattern.compile(PATTERN_PLAIN_STR +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds"
      },
      {
        "txt": "+\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t); } PATTERN_ISO8601 = p; } public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7"
      },
      {
        "txt": "} protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); }"
      },
      {
        "txt": "public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() { _locale = DEFAULT_LOCALE;"
      },
      {
        "txt": "} @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false); } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient,"
      },
      {
        "txt": "boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) {"
      },
      {
        "txt": "if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) {"
      },
      {
        "txt": "return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) { if (_equals(b, _lenient)) { return this; } return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon); }"
      },
      {
        "txt": "public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon); }"
      },
      {
        "txt": "@Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9 public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Override // since 2.6"
      },
      {
        "txt": "public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; }"
      },
      {
        "txt": "} @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7"
      },
      {
        "txt": "public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon; } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim();"
      },
      {
        "txt": "ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else {"
      },
      {
        "txt": "sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override"
      },
      {
        "txt": "public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) { } return null; } protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException {"
      },
      {
        "txt": "if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; }"
      },
      {
        "txt": "} } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos); } return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo,"
      },
      {
        "txt": "FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE; } _format(tz, _locale, date, toAppendTo); return toAppendTo; } protected void _format(TimeZone tz, Locale loc, Date date,"
      },
      {
        "txt": "StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR); pad4(buffer, year); buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));"
      },
      {
        "txt": "buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':'); pad2(buffer, cal.get(Calendar.SECOND)); buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis()); if (offset != 0) {"
      },
      {
        "txt": "int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) { buffer.append(':'); } pad2(buffer, minutes); } else { if( _tzSerializedWithColon ) {"
      },
      {
        "txt": "} else { buffer.append(\"+0000\"); } } } <extra_id_0> private static void pad2(StringBuffer buffer, int value) { int tens = value / 10; if (tens == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + tens));"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + tens)); value -= 10 * tens; } buffer.append((char) ('0' + value)); } private static void pad3(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0');"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + h)); value -= (h * 100); } pad2(buffer, value); } private static void pad4(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0').append('0');"
      },
      {
        "txt": "} else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value); } @Override public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\", getClass().getName(), _timezone, _locale, _lenient);"
      },
      {
        "txt": "} public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\") .append(DATE_FORMAT_STR_RFC1123) .append(\"' (\") ; sb.append(Boolean.FALSE.equals(_lenient) ?"
      },
      {
        "txt": "\"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() {"
      },
      {
        "txt": "return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' && Character.isDigit(dateStr.charAt(5)) ) {"
      },
      {
        "txt": "return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException { long ts; try { ts = NumberInput.parseLong(longStr); } catch (NumberFormatException e) {"
      },
      {
        "txt": "throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); } protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException { try {"
      },
      {
        "txt": "return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); } } protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException {"
      },
      {
        "txt": "final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz); cal.clear(); String formatStr; if (totalLen <= 10) { Matcher m = PATTERN_PLAIN.matcher(dateStr);"
      },
      {
        "txt": "if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); } formatStr = DATE_FORMAT_STR_PLAIN; } else {"
      },
      {
        "txt": "Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z' int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours if (len >= 5) { offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes }"
      },
      {
        "txt": "if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs); cal.set(Calendar.DST_OFFSET, 0); } int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1;"
      },
      {
        "txt": "int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17); } else { seconds = 0; } cal.set(year, month, day, hour, minute, seconds);"
      },
      {
        "txt": "start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else { msecs = 0; final int fractLen = end-start; switch (fractLen) { default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho"
      },
      {
        "txt": "if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); } case 3: msecs += (dateStr.charAt(start+2) - '0'); case 2: msecs += 10 * (dateStr.charAt(start+1) - '0');"
      },
      {
        "txt": "case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; } cal.set(Calendar.MILLISECOND, msecs); } return cal.getTime(); }"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0); } private static int _parse4D(String str, int index) { return (1000 * (str.charAt(index) - '0')) + (100 * (str.charAt(index+1) - '0'))"
      },
      {
        "txt": "+ (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0'); } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) {"
      },
      {
        "txt": "_formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc);"
      },
      {
        "txt": "df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); }"
      },
      {
        "txt": "return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) { Calendar cal = _calendar; if (cal == null ) { _calendar = cal = (Calendar)CALENDAR.clone(); }"
      },
      {
        "txt": "if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; } protected static <T> boolean _equals(T value1, T value2) { if (value1 == value2) { return true; }"
      },
      {
        "txt": "return (value1 != null) && value1.equals(value2); }"
      }
    ]
  },
  {
    "id": 1783,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 488,
    "end-bug-line": 488,
    "bug": "",
    "fix": "pad4(buffer, isoYear); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat;"
      },
      {
        "txt": "import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Matcher; import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat"
      },
      {
        "txt": "extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static { Pattern p = null; try { p = Pattern.compile(PATTERN_PLAIN_STR +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds"
      },
      {
        "txt": "+\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t); } PATTERN_ISO8601 = p; } public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";"
      },
      {
        "txt": "protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7"
      },
      {
        "txt": "} protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); }"
      },
      {
        "txt": "public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() { _locale = DEFAULT_LOCALE;"
      },
      {
        "txt": "} @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false); } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient,"
      },
      {
        "txt": "boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon; } public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) {"
      },
      {
        "txt": "if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; } return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) {"
      },
      {
        "txt": "return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) { if (_equals(b, _lenient)) { return this; } return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon); }"
      },
      {
        "txt": "public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b); } @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon); }"
      },
      {
        "txt": "@Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9 public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Override // since 2.6"
      },
      {
        "txt": "public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) { if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; }"
      },
      {
        "txt": "} @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) { _lenient = newValue; _clearFormats(); } } @Override // since 2.7"
      },
      {
        "txt": "public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon; } @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim();"
      },
      {
        "txt": "ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; } StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else {"
      },
      {
        "txt": "sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override"
      },
      {
        "txt": "public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) { } return null; } protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException {"
      },
      {
        "txt": "if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; }"
      },
      {
        "txt": "} } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos); } return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo,"
      },
      {
        "txt": "FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE; } _format(tz, _locale, date, toAppendTo); return toAppendTo; } protected void _format(TimeZone tz, Locale loc, Date date,"
      },
      {
        "txt": "StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR); pad4(buffer, year); buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));"
      },
      {
        "txt": "buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':'); pad2(buffer, cal.get(Calendar.SECOND)); buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis()); if (offset != 0) {"
      },
      {
        "txt": "int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) { buffer.append(':'); } pad2(buffer, minutes); } else { if( _tzSerializedWithColon ) {"
      },
      {
        "txt": "} else { buffer.append(\"+0000\"); } } } <extra_id_0> private static void pad2(StringBuffer buffer, int value) { int tens = value / 10; if (tens == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + tens));"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + tens)); value -= 10 * tens; } buffer.append((char) ('0' + value)); } private static void pad3(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0');"
      },
      {
        "txt": "} else { buffer.append((char) ('0' + h)); value -= (h * 100); } pad2(buffer, value); } private static void pad4(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0').append('0');"
      },
      {
        "txt": "} else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value); } @Override public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\", getClass().getName(), _timezone, _locale, _lenient);"
      },
      {
        "txt": "} public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\") .append(DATE_FORMAT_STR_RFC1123) .append(\"' (\") ; sb.append(Boolean.FALSE.equals(_lenient) ?"
      },
      {
        "txt": "\"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() {"
      },
      {
        "txt": "return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' && Character.isDigit(dateStr.charAt(5)) ) {"
      },
      {
        "txt": "return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException { long ts; try { ts = NumberInput.parseLong(longStr); } catch (NumberFormatException e) {"
      },
      {
        "txt": "throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); } protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException { try {"
      },
      {
        "txt": "return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); } } protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException {"
      },
      {
        "txt": "final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz); cal.clear(); String formatStr; if (totalLen <= 10) { Matcher m = PATTERN_PLAIN.matcher(dateStr);"
      },
      {
        "txt": "if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); } formatStr = DATE_FORMAT_STR_PLAIN; } else {"
      },
      {
        "txt": "Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z' int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours if (len >= 5) { offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes }"
      },
      {
        "txt": "if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs); cal.set(Calendar.DST_OFFSET, 0); } int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1;"
      },
      {
        "txt": "int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17); } else { seconds = 0; } cal.set(year, month, day, hour, minute, seconds);"
      },
      {
        "txt": "start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else { msecs = 0; final int fractLen = end-start; switch (fractLen) { default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho"
      },
      {
        "txt": "if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); } case 3: msecs += (dateStr.charAt(start+2) - '0'); case 2: msecs += 10 * (dateStr.charAt(start+1) - '0');"
      },
      {
        "txt": "case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; } cal.set(Calendar.MILLISECOND, msecs); } return cal.getTime(); }"
      },
      {
        "txt": "formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0); } private static int _parse4D(String str, int index) { return (1000 * (str.charAt(index) - '0')) + (100 * (str.charAt(index+1) - '0'))"
      },
      {
        "txt": "+ (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0'); } protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) {"
      },
      {
        "txt": "_formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc);"
      },
      {
        "txt": "df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); }"
      },
      {
        "txt": "return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) { Calendar cal = _calendar; if (cal == null ) { _calendar = cal = (Calendar)CALENDAR.clone(); }"
      },
      {
        "txt": "if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; } protected static <T> boolean _equals(T value1, T value2) { if (value1 == value2) { return true; }"
      },
      {
        "txt": "return (value1 != null) && value1.equals(value2); }"
      }
    ]
  },
  {
    "id": 1784,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 516,
    "end-bug-line": 516,
    "bug": "",
    "fix": "if (h > 99) { // [databind#2167]: handle above 9999 correctly buffer.append(h); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*;"
      },
      {
        "txt": "import java.util.regex.Matcher; import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601;"
      },
      {
        "txt": "static { Pattern p = null; try { p = Pattern.compile(PATTERN_PLAIN_STR +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds +\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t);"
      },
      {
        "txt": "} PATTERN_ISO8601 = p; } public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123,"
      },
      {
        "txt": "DATE_FORMAT_STR_PLAIN }; protected final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static {"
      },
      {
        "txt": "DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE); DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient;"
      },
      {
        "txt": "private transient Calendar _calendar; private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc;"
      },
      {
        "txt": "} protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false); } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon;"
      },
      {
        "txt": "} public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this;"
      },
      {
        "txt": "} return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) {"
      },
      {
        "txt": "if (_equals(b, _lenient)) { return this; } return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon); } public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b);"
      },
      {
        "txt": "} @Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon); } @Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9"
      },
      {
        "txt": "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz)"
      },
      {
        "txt": "{ if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) {"
      },
      {
        "txt": "_lenient = newValue; _clearFormats(); } } @Override // since 2.7 public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon;"
      },
      {
        "txt": "} @Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; }"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"');"
      },
      {
        "txt": "throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) {"
      },
      {
        "txt": "} return null; } protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) {"
      },
      {
        "txt": "char ch = dateStr.charAt(i); if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos);"
      },
      {
        "txt": "} return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE;"
      },
      {
        "txt": "} _format(tz, _locale, date, toAppendTo); return toAppendTo; } protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR);"
      },
      {
        "txt": "pad4(buffer, year); buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH)); buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':');"
      },
      {
        "txt": "pad2(buffer, cal.get(Calendar.SECOND)); buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) {"
      },
      {
        "txt": "buffer.append(':'); } pad2(buffer, minutes); } else { if( _tzSerializedWithColon ) { buffer.append(\"+00:00\"); } else { buffer.append(\"+0000\"); }"
      },
      {
        "txt": "} } private static void pad2(StringBuffer buffer, int value) { int tens = value / 10; if (tens == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + tens)); value -= 10 * tens; }"
      },
      {
        "txt": "buffer.append((char) ('0' + value)); } private static void pad3(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + h)); value -= (h * 100); }"
      },
      {
        "txt": "} private static void pad4(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0').append('0'); } else { <extra_id_0> value -= (100 * h); } pad2(buffer, value); } @Override public String toString() {"
      },
      {
        "txt": "@Override public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\", getClass().getName(), _timezone, _locale, _lenient); } public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\")"
      },
      {
        "txt": ".append(DATE_FORMAT_STR_RFC1123) .append(\"' (\") ; sb.append(Boolean.FALSE.equals(_lenient) ? \"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) {"
      },
      {
        "txt": "return (o == this); } @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0))"
      },
      {
        "txt": "&& Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' && Character.isDigit(dateStr.charAt(5)) ) { return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException {"
      },
      {
        "txt": "long ts; try { ts = NumberInput.parseLong(longStr); } catch (NumberFormatException e) { throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); }"
      },
      {
        "txt": "protected Date parseAsISO8601(String dateStr, ParsePosition pos) throws ParseException { try { return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); }"
      },
      {
        "txt": "} protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException { final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz);"
      },
      {
        "txt": "cal.clear(); String formatStr; if (totalLen <= 10) { Matcher m = PATTERN_PLAIN.matcher(dateStr); if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0);"
      },
      {
        "txt": "return cal.getTime(); } formatStr = DATE_FORMAT_STR_PLAIN; } else { Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z'"
      },
      {
        "txt": "int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours if (len >= 5) { offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes } if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs);"
      },
      {
        "txt": "cal.set(Calendar.DST_OFFSET, 0); } int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17);"
      },
      {
        "txt": "} else { seconds = 0; } cal.set(year, month, day, hour, minute, seconds); start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else {"
      },
      {
        "txt": "msecs = 0; final int fractLen = end-start; switch (fractLen) { default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); }"
      },
      {
        "txt": "case 3: msecs += (dateStr.charAt(start+2) - '0'); case 2: msecs += 10 * (dateStr.charAt(start+1) - '0'); case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; }"
      },
      {
        "txt": "cal.set(Calendar.MILLISECOND, msecs); } return cal.getTime(); } formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0);"
      },
      {
        "txt": "} private static int _parse4D(String str, int index) { return (1000 * (str.charAt(index) - '0')) + (100 * (str.charAt(index+1) - '0')) + (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0');"
      },
      {
        "txt": "} protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format,"
      },
      {
        "txt": "TimeZone tz, Locale loc, Boolean lenient) { if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); }"
      },
      {
        "txt": "} if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) {"
      },
      {
        "txt": "Calendar cal = _calendar; if (cal == null ) { _calendar = cal = (Calendar)CALENDAR.clone(); } if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; }"
      },
      {
        "txt": "protected static <T> boolean _equals(T value1, T value2) { if (value1 == value2) { return true; } return (value1 != null) && value1.equals(value2); }"
      }
    ]
  },
  {
    "id": 1785,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "start-bug-line": 517,
    "end-bug-line": 517,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.util; import java.text.DateFormat; import java.text.FieldPosition; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import com.fasterxml.jackson.core.io.NumberInput; @SuppressWarnings(\"serial\") public class StdDateFormat extends DateFormat { protected final static String PATTERN_PLAIN_STR = \"\\\\d\\\\d\\\\d\\\\d[-]\\\\d\\\\d[-]\\\\d\\\\d\"; protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR); protected final static Pattern PATTERN_ISO8601; static {"
      },
      {
        "txt": "Pattern p = null; try { p = Pattern.compile(PATTERN_PLAIN_STR +\"[T]\\\\d\\\\d[:]\\\\d\\\\d(?:[:]\\\\d\\\\d)?\" // hours, minutes, optional seconds +\"(\\\\.\\\\d+)?\" // optional second fractions +\"(Z|[+-]\\\\d\\\\d(?:[:]?\\\\d\\\\d)?)?\" // optional timeoffset/Z ); } catch (Throwable t) { throw new RuntimeException(t); }"
      },
      {
        "txt": "PATTERN_ISO8601 = p; } public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, \"yyyy-MM-dd'T'HH:mm:ss.SSS\", // ISO-8601 but no timezone DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN"
      },
      {
        "txt": "}; protected final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7 } protected final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; static { DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);"
      },
      {
        "txt": "DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE); DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); } public final static StdDateFormat instance = new StdDateFormat(); protected static final Calendar CALENDAR = new GregorianCalendar(DEFAULT_TIMEZONE, DEFAULT_LOCALE); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; private transient Calendar _calendar;"
      },
      {
        "txt": "private transient DateFormat _formatRFC1123; private boolean _tzSerializedWithColon = false; public StdDateFormat() { _locale = DEFAULT_LOCALE; } @Deprecated // since 2.7 public StdDateFormat(TimeZone tz, Locale loc) { _timezone = tz; _locale = loc; }"
      },
      {
        "txt": "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) { this(tz, loc, lenient, false); } protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient, boolean formatTzOffsetWithColon) { _timezone = tz; _locale = loc; _lenient = lenient; _tzSerializedWithColon = formatTzOffsetWithColon; }"
      },
      {
        "txt": "public static TimeZone getDefaultTimeZone() { return DEFAULT_TIMEZONE; } public StdDateFormat withTimeZone(TimeZone tz) { if (tz == null) { tz = DEFAULT_TIMEZONE; } if ((tz == _timezone) || tz.equals(_timezone)) { return this; }"
      },
      {
        "txt": "return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon); } public StdDateFormat withLocale(Locale loc) { if (loc.equals(_locale)) { return this; } return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon); } public StdDateFormat withLenient(Boolean b) { if (_equals(b, _lenient)) {"
      },
      {
        "txt": "return this; } return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon); } public StdDateFormat withColonInTimeZone(boolean b) { if (_tzSerializedWithColon == b) { return this; } return new StdDateFormat(_timezone, _locale, _lenient, b); }"
      },
      {
        "txt": "@Override public StdDateFormat clone() { return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon); } @Deprecated // since 2.9 public static DateFormat getISO8601Format(TimeZone tz, Locale loc) { return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null); } @Deprecated // since 2.9 public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {"
      },
      {
        "txt": "return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc, null); } @Override // since 2.6 public TimeZone getTimeZone() { return _timezone; } @Override public void setTimeZone(TimeZone tz) {"
      },
      {
        "txt": "if (!tz.equals(_timezone)) { _clearFormats(); _timezone = tz; } } @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = Boolean.valueOf(enabled); if (!_equals(newValue, _lenient)) { _lenient = newValue;"
      },
      {
        "txt": "_clearFormats(); } } @Override // since 2.7 public boolean isLenient() { return (_lenient == null) || _lenient.booleanValue(); } public boolean isColonIncludedInTimeZone() { return _tzSerializedWithColon; }"
      },
      {
        "txt": "@Override public Date parse(String dateStr) throws ParseException { dateStr = dateStr.trim(); ParsePosition pos = new ParsePosition(0); Date dt = _parseDate(dateStr, pos); if (dt != null) { return dt; } StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "for (String f : ALL_FORMATS) { if (sb.length() > 0) { sb.append(\"\\\", \\\"\"); } else { sb.append('\"'); } sb.append(f); } sb.append('\"'); throw new ParseException"
      },
      {
        "txt": "(String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\", dateStr, sb.toString()), pos.getErrorIndex()); } @Override public Date parse(String dateStr, ParsePosition pos) { try { return _parseDate(dateStr, pos); } catch (ParseException e) { }"
      },
      {
        "txt": "return null; } protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException { if (looksLikeISO8601(dateStr)) { // also includes \"plain\" return parseAsISO8601(dateStr, pos); } int i = dateStr.length(); while (--i >= 0) { char ch = dateStr.charAt(i);"
      },
      {
        "txt": "if (ch < '0' || ch > '9') { if (i > 0 || ch != '-') { break; } } } if ((i < 0) && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) { return _parseDateFromLong(dateStr, pos); }"
      },
      {
        "txt": "return parseAsRFC1123(dateStr, pos); } @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { TimeZone tz = _timezone; if (tz == null) { tz = DEFAULT_TIMEZONE; }"
      },
      {
        "txt": "_format(tz, _locale, date, toAppendTo); return toAppendTo; } protected void _format(TimeZone tz, Locale loc, Date date, StringBuffer buffer) { Calendar cal = _getCalendar(tz); cal.setTime(date); final int year = cal.get(Calendar.YEAR); pad4(buffer, year);"
      },
      {
        "txt": "buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-'); pad2(buffer, cal.get(Calendar.DAY_OF_MONTH)); buffer.append('T'); pad2(buffer, cal.get(Calendar.HOUR_OF_DAY)); buffer.append(':'); pad2(buffer, cal.get(Calendar.MINUTE)); buffer.append(':'); pad2(buffer, cal.get(Calendar.SECOND));"
      },
      {
        "txt": "buffer.append('.'); pad3(buffer, cal.get(Calendar.MILLISECOND)); int offset = tz.getOffset(cal.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); buffer.append(offset < 0 ? '-' : '+'); pad2(buffer, hours); if( _tzSerializedWithColon ) { buffer.append(':');"
      },
      {
        "txt": "} pad2(buffer, minutes); } else { if( _tzSerializedWithColon ) { buffer.append(\"+00:00\"); } else { buffer.append(\"+0000\"); } }"
      },
      {
        "txt": "} private static void pad2(StringBuffer buffer, int value) { int tens = value / 10; if (tens == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + tens)); value -= 10 * tens; } buffer.append((char) ('0' + value));"
      },
      {
        "txt": "} private static void pad3(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0'); } else { buffer.append((char) ('0' + h)); value -= (h * 100); } pad2(buffer, value);"
      },
      {
        "txt": "private static void pad4(StringBuffer buffer, int value) { int h = value / 100; if (h == 0) { buffer.append('0').append('0'); } else { pad2(buffer, h); <extra_id_0> } pad2(buffer, value); } @Override public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\","
      },
      {
        "txt": "public String toString() { return String.format(\"DateFormat %s: (timezone: %s, locale: %s, lenient: %s)\", getClass().getName(), _timezone, _locale, _lenient); } public String toPattern() { // same as SimpleDateFormat StringBuilder sb = new StringBuilder(100); sb.append(\"[one of: '\") .append(DATE_FORMAT_STR_ISO8601) .append(\"', '\") .append(DATE_FORMAT_STR_RFC1123)"
      },
      {
        "txt": ".append(\"' (\") ; sb.append(Boolean.FALSE.equals(_lenient) ? \"strict\" : \"lenient\") .append(\")]\"); return sb.toString(); } @Override // since 2.7[.2], as per [databind#1130] public boolean equals(Object o) { return (o == this);"
      },
      {
        "txt": "} @Override // since 2.7[.2], as per [databind#1130] public int hashCode() { return System.identityHashCode(this); } protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 7 // really need 10, but... && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3))"
      },
      {
        "txt": "&& dateStr.charAt(4) == '-' && Character.isDigit(dateStr.charAt(5)) ) { return true; } return false; } private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException { long ts;"
      },
      {
        "txt": "try { ts = NumberInput.parseLong(longStr); } catch (NumberFormatException e) { throw new ParseException(String.format( \"Timestamp value %s out of 64-bit value range\", longStr), pos.getErrorIndex()); } return new Date(ts); } protected Date parseAsISO8601(String dateStr, ParsePosition pos)"
      },
      {
        "txt": "throws ParseException { try { return _parseAsISO8601(dateStr, pos); } catch (IllegalArgumentException e) { throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\", problem: %s\", dateStr, e.getMessage()), pos.getErrorIndex()); } }"
      },
      {
        "txt": "protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException { final int totalLen = dateStr.length(); TimeZone tz = DEFAULT_TIMEZONE; if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) { tz = _timezone; } Calendar cal = _getCalendar(tz); cal.clear();"
      },
      {
        "txt": "String formatStr; if (totalLen <= 10) { Matcher m = PATTERN_PLAIN.matcher(dateStr); if (m.matches()) { int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); cal.set(year, month, day, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime();"
      },
      {
        "txt": "} formatStr = DATE_FORMAT_STR_PLAIN; } else { Matcher m = PATTERN_ISO8601.matcher(dateStr); if (m.matches()) { int start = m.start(2); int end = m.end(2); int len = end-start; if (len > 1) { // 0 -> none, 1 -> 'Z' int offsetSecs = _parse2D(dateStr, start+1) * 3600; // hours"
      },
      {
        "txt": "if (len >= 5) { offsetSecs += _parse2D(dateStr, end-2) * 60; // minutes } if (dateStr.charAt(start) == '-') { offsetSecs *= -1000; } else { offsetSecs *= 1000; } cal.set(Calendar.ZONE_OFFSET, offsetSecs); cal.set(Calendar.DST_OFFSET, 0);"
      },
      {
        "txt": "} int year = _parse4D(dateStr, 0); int month = _parse2D(dateStr, 5)-1; int day = _parse2D(dateStr, 8); int hour = _parse2D(dateStr, 11); int minute = _parse2D(dateStr, 14); int seconds; if ((totalLen > 16) && dateStr.charAt(16) == ':') { seconds = _parse2D(dateStr, 17); } else {"
      },
      {
        "txt": "seconds = 0; } cal.set(year, month, day, hour, minute, seconds); start = m.start(1) + 1; end = m.end(1); int msecs = 0; if (start >= end) { // no fractional cal.set(Calendar.MILLISECOND, 0); } else { msecs = 0;"
      },
      {
        "txt": "final int fractLen = end-start; switch (fractLen) { default: // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho if (fractLen > 9) { // only allow up to nanos throw new ParseException(String.format( \"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1) ), start); } case 3:"
      },
      {
        "txt": "msecs += (dateStr.charAt(start+2) - '0'); case 2: msecs += 10 * (dateStr.charAt(start+1) - '0'); case 1: msecs += 100 * (dateStr.charAt(start) - '0'); break; case 0: break; } cal.set(Calendar.MILLISECOND, msecs);"
      },
      {
        "txt": "} return cal.getTime(); } formatStr = DATE_FORMAT_STR_ISO8601; } throw new ParseException (String.format(\"Cannot parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), 0); }"
      },
      {
        "txt": "private static int _parse4D(String str, int index) { return (1000 * (str.charAt(index) - '0')) + (100 * (str.charAt(index+1) - '0')) + (10 * (str.charAt(index+2) - '0')) + (str.charAt(index+3) - '0'); } private static int _parse2D(String str, int index) { return (10 * (str.charAt(index) - '0')) + (str.charAt(index+1) - '0'); }"
      },
      {
        "txt": "protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale, _lenient); } return _formatRFC1123.parse(dateStr, pos); } private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)"
      },
      {
        "txt": "{ if (!loc.equals(DEFAULT_LOCALE)) { df = new SimpleDateFormat(format, loc); df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz); } else { df = (DateFormat) df.clone(); if (tz != null) { df.setTimeZone(tz); } }"
      },
      {
        "txt": "if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; } protected void _clearFormats() { _formatRFC1123 = null; } protected Calendar _getCalendar(TimeZone tz) { Calendar cal = _calendar;"
      },
      {
        "txt": "if (cal == null ) { _calendar = cal = (Calendar)CALENDAR.clone(); } if (!cal.getTimeZone().equals(tz) ) { cal.setTimeZone(tz); } cal.setLenient(isLenient()); return cal; } protected static <T> boolean _equals(T value1, T value2) {"
      },
      {
        "txt": "if (value1 == value2) { return true; } return (value1 != null) && value1.equals(value2); }"
      }
    ]
  }
]