[
  {
    "id": 1506,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 602,
    "end-bug-line": 602,
    "bug": "return constructType(type, constructType(contextClass));",
    "fix": "TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType;"
      },
      {
        "txt": "import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" }) public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory();"
      },
      {
        "txt": "protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser;"
      },
      {
        "txt": "protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null; _classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {"
      },
      {
        "txt": "_parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; } public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) {"
      },
      {
        "txt": "return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); } public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear();"
      },
      {
        "txt": "} public ClassLoader getClassLoader() { return _classLoader; } public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t;"
      },
      {
        "txt": "} return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException { if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim; }"
      },
      {
        "txt": "} Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) { loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader); } catch (Exception e) {"
      },
      {
        "txt": "prob = ClassUtil.getRootCause(e); } } try { return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); } }"
      },
      {
        "txt": "if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob); } protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException {"
      },
      {
        "txt": "return Class.forName(name); } protected Class<?> _findPrimitive(String className) { if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE;"
      },
      {
        "txt": "if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null; } public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType;"
      },
      {
        "txt": "} JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType));"
      },
      {
        "txt": "} if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class)"
      },
      {
        "txt": "|| (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break; } } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; } if (rawBase == EnumSet.class) { return baseType; } } } if (subclass.getTypeParameters().length == 0) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); }"
      },
      {
        "txt": "if (newType == null) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); } } while (false); return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler(); if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h);"
      },
      {
        "txt": "} return subtype; } } if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType;"
      },
      {
        "txt": "} JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); } } return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass();"
      },
      {
        "txt": "if (rawBase == superClass) { return baseType; } JavaType superType = baseType.findSuperType(superClass); if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format("
      },
      {
        "txt": "\"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); } return superType; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType)"
      },
      {
        "txt": "{ JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES; } return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType);"
      },
      {
        "txt": "} @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType); } public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; }"
      },
      {
        "txt": "if (type2 == null) { return type1; } Class<?> raw1 = type1.getRawClass(); Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2;"
      },
      {
        "txt": "} return type1; } public JavaType constructType(Type type) { return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef)"
      },
      {
        "txt": "{ return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS); JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray();"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0]; } @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { <extra_id_0> } @Deprecated public JavaType constructType(Type type, JavaType contextType) { return _fromAny(null, type, contextType.getBindings()); } public ArrayType constructArrayType(Class<?> elementType) {"
      },
      {
        "txt": "} public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS));"
      },
      {
        "txt": "} public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {"
      },
      {
        "txt": "JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type; } return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) {"
      },
      {
        "txt": "kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS); } return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] {"
      },
      {
        "txt": "keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass,"
      },
      {
        "txt": "TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; } return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated"
      },
      {
        "txt": "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes); } public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType);"
      },
      {
        "txt": "} public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); } public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); }"
      },
      {
        "txt": "return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes);"
      },
      {
        "txt": "} public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) { return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {"
      },
      {
        "txt": "return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType()); } public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)"
      },
      {
        "txt": "{ JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break;"
      },
      {
        "txt": "case 2: kt = typeParams.get(0); vt = typeParams.get(1); break; default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); }"
      },
      {
        "txt": "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); } private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) {"
      },
      {
        "txt": "ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)"
      },
      {
        "txt": "{ if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) { return result; } } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,"
      },
      {
        "txt": "JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _unknownType() { return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL;"
      },
      {
        "txt": "if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING; if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {"
      },
      {
        "txt": "JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); } else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; }"
      },
      {
        "txt": "else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) { resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));"
      },
      {
        "txt": "} if (_modifiers != null && !resultType.isContainerType()) { TypeBindings b = resultType.getBindings(); if (b == null) { b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) { resultType = mod.modifyType(resultType, type, b, this); } }"
      },
      {
        "txt": "return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) { JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) {"
      },
      {
        "txt": "result = _typeCache.get(rawType); // ok, cache object is synced if (result != null) { return result; } } if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) {"
      },
      {
        "txt": "ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; } context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else {"
      },
      {
        "txt": "JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null; superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) {"
      },
      {
        "txt": "result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) { result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } } } } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); // cache object syncs }"
      },
      {
        "txt": "return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); }"
      },
      {
        "txt": "protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) { return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i];"
      },
      {
        "txt": "resolved[i] = _fromAny(context, type, parentBindings); } return resolved; } protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); }"
      },
      {
        "txt": "if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) { return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)"
      },
      {
        "txt": "{ final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces); if (result != null) { return result; } } return null; }"
      },
      {
        "txt": "protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType(); if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; }"
      },
      {
        "txt": "if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments(); int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else {"
      },
      {
        "txt": "pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); } newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) {"
      },
      {
        "txt": "JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) { final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; }"
      },
      {
        "txt": "if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name); Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings);"
      }
    ]
  },
  {
    "id": 1507,
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
    "start-bug-line": 610,
    "end-bug-line": 610,
    "bug": "return _fromAny(null, type, contextType.getBindings());",
    "fix": "TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.databind.type; import java.util.*; import java.util.concurrent.atomic.AtomicReference; import java.lang.reflect.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.util.ArrayBuilders; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.LRUMap; @SuppressWarnings({\"rawtypes\" })"
      },
      {
        "txt": "public final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class;"
      },
      {
        "txt": "private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);"
      },
      {
        "txt": "protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() { _parser = new TypeParser(this); _modifiers = null;"
      },
      {
        "txt": "_classLoader = null; } protected TypeFactory(TypeParser p, TypeModifier[] mods) { this(p, mods, null); } protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) { _parser = p.withFactory(this); _modifiers = mods; _classLoader = classLoader; }"
      },
      {
        "txt": "public TypeFactory withModifier(TypeModifier mod) { if (mod == null) { // mostly for unit tests return new TypeFactory(_parser, _modifiers, _classLoader); } if (_modifiers == null) { return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader); } return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader); }"
      },
      {
        "txt": "public TypeFactory withClassLoader(ClassLoader classLoader) { return new TypeFactory(_parser, _modifiers, classLoader); } public static TypeFactory defaultInstance() { return instance; } public void clearCache() { _typeCache.clear(); } public ClassLoader getClassLoader() { return _classLoader; }"
      },
      {
        "txt": "public static JavaType unknownType() { return defaultInstance()._unknownType(); } public static Class<?> rawClass(Type t) { if (t instanceof Class<?>) { return (Class<?>) t; } return defaultInstance().constructType(t).getRawClass(); } public Class<?> findClass(String className) throws ClassNotFoundException"
      },
      {
        "txt": "{ if (className.indexOf('.') < 0) { Class<?> prim = _findPrimitive(className); if (prim != null) { return prim; } } Throwable prob = null; ClassLoader loader = this.getClassLoader(); if (loader == null) {"
      },
      {
        "txt": "loader = Thread.currentThread().getContextClassLoader(); } if (loader != null) { try { return classForName(className, true, loader); } catch (Exception e) { prob = ClassUtil.getRootCause(e); } } try {"
      },
      {
        "txt": "return classForName(className); } catch (Exception e) { if (prob == null) { prob = ClassUtil.getRootCause(e); } } if (prob instanceof RuntimeException) { throw (RuntimeException) prob; } throw new ClassNotFoundException(prob.getMessage(), prob);"
      },
      {
        "txt": "} protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException { return Class.forName(name, true, loader); } protected Class<?> classForName(String name) throws ClassNotFoundException { return Class.forName(name); } protected Class<?> _findPrimitive(String className) {"
      },
      {
        "txt": "if (\"int\".equals(className)) return Integer.TYPE; if (\"long\".equals(className)) return Long.TYPE; if (\"float\".equals(className)) return Float.TYPE; if (\"double\".equals(className)) return Double.TYPE; if (\"boolean\".equals(className)) return Boolean.TYPE; if (\"byte\".equals(className)) return Byte.TYPE; if (\"char\".equals(className)) return Character.TYPE; if (\"short\".equals(className)) return Short.TYPE; if (\"void\".equals(className)) return Void.TYPE; return null;"
      },
      {
        "txt": "} public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == subclass) { return baseType; } JavaType newType; do { // bogus loop to be able to break if (rawBase == Object.class) {"
      },
      {
        "txt": "newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) { throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", subclass.getName(), baseType)); } if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break;"
      },
      {
        "txt": "} if (baseType.isContainerType()) { if (baseType.isMapLikeType()) { if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType())); break;"
      },
      {
        "txt": "} } else if (baseType.isCollectionLikeType()) { if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) { newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType())); break; }"
      },
      {
        "txt": "if (rawBase == EnumSet.class) { return baseType; } } } if (subclass.getTypeParameters().length == 0) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (baseType.isInterface()) {"
      },
      {
        "txt": "newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } if (newType == null) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); } } while (false);"
      },
      {
        "txt": "return newType; if (baseType instanceof SimpleType) { if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { if (!baseType.getRawClass().isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType); } JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings()); Object h = baseType.getValueHandler();"
      },
      {
        "txt": "if (h != null) { subtype = subtype.withValueHandler(h); } h = baseType.getTypeHandler(); if (h != null) { subtype = subtype.withTypeHandler(h); } return subtype; } }"
      },
      {
        "txt": "if (baseType instanceof ArrayType) { if (subclass.isArray()) { ArrayType at = (ArrayType) baseType; Class<?> rawComp = subclass.getComponentType(); if (at.getContentType().getRawClass() == rawComp) { return baseType; } JavaType componentType = _fromAny(null, rawComp, null); return ((ArrayType) baseType).withComponentType(componentType); }"
      },
      {
        "txt": "} return baseType.narrowBy(subclass); } public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) { final Class<?> rawBase = baseType.getRawClass(); if (rawBase == superClass) { return baseType; } JavaType superType = baseType.findSuperType(superClass);"
      },
      {
        "txt": "if (superType == null) { if (!superClass.isAssignableFrom(rawBase)) { throw new IllegalArgumentException(String.format( \"Class %s not a super-type of %s\", superClass.getName(), baseType)); } throw new IllegalArgumentException(String.format( \"Internal error: class %s not included as super-type for %s\", superClass.getName(), baseType)); } return superType;"
      },
      {
        "txt": "} public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { return _parser.parse(canonical); } public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { JavaType match = type.findSuperType(expType); if (match == null) { return NO_TYPES;"
      },
      {
        "txt": "} return match.getBindings().typeParameterArray(); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { return findTypeParameters(constructType(clz, bindings), expType); } @Deprecated // since 2.7 public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { return findTypeParameters(constructType(clz), expType);"
      },
      {
        "txt": "} public JavaType moreSpecificType(JavaType type1, JavaType type2) { if (type1 == null) { return type2; } if (type2 == null) { return type1; } Class<?> raw1 = type1.getRawClass();"
      },
      {
        "txt": "Class<?> raw2 = type2.getRawClass(); if (raw1 == raw2) { return type1; } if (raw1.isAssignableFrom(raw2)) { return type2; } return type1; } public JavaType constructType(Type type) {"
      },
      {
        "txt": "return _fromAny(null, type, EMPTY_BINDINGS); } public JavaType constructType(Type type, TypeBindings bindings) { return _fromAny(null, type, bindings); } public JavaType constructType(TypeReference<?> typeRef) { return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS); final Class<?> refdRawType = typeRef.getClass(); JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);"
      },
      {
        "txt": "JavaType genType = type.findSuperType(TypeReference.class); if (genType == null) { // sanity check; shouldn't occur throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } TypeBindings b = genType.getBindings(); JavaType[] params = b.typeParameterArray(); if (params.length == 0) { throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\"); } return params[0];"
      },
      {
        "txt": "@Deprecated public JavaType constructType(Type type, Class<?> contextClass) { return constructType(type, constructType(contextClass)); } @Deprecated public JavaType constructType(Type type, JavaType contextType) { <extra_id_0> } public ArrayType constructArrayType(Class<?> elementType) { return ArrayType.construct(_fromAny(null, elementType, null), null); } public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null);"
      },
      {
        "txt": "public ArrayType constructArrayType(JavaType elementType) { return ArrayType.construct(elementType, null); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { return constructCollectionType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { return (CollectionType) _fromClass(null, collectionClass, TypeBindings.create(collectionClass, elementType));"
      },
      {
        "txt": "} public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { return constructCollectionLikeType(collectionClass, _fromClass(null, elementClass, EMPTY_BINDINGS)); } public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { JavaType type = _fromClass(null, collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType)); if (type instanceof CollectionLikeType) { return (CollectionLikeType) type;"
      },
      {
        "txt": "} return CollectionLikeType.upgradeFrom(type, elementType); } public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { JavaType kt, vt; if (mapClass == Properties.class) { kt = vt = CORE_TYPE_STRING; } else { kt = _fromClass(null, keyClass, EMPTY_BINDINGS); vt = _fromClass(null, valueClass, EMPTY_BINDINGS);"
      },
      {
        "txt": "} return constructMapType(mapClass, kt, vt); } public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { return (MapType) _fromClass(null, mapClass, TypeBindings.create(mapClass, new JavaType[] { keyType, valueType })); } public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {"
      },
      {
        "txt": "return constructMapLikeType(mapClass, _fromClass(null, keyClass, EMPTY_BINDINGS), _fromClass(null, valueClass, EMPTY_BINDINGS)); } public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { JavaType type = _fromClass(null, mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType })); if (type instanceof MapLikeType) { return (MapLikeType) type; }"
      },
      {
        "txt": "return MapLikeType.upgradeFrom(type, keyType, valueType); } public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } @Deprecated public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) { return constructSimpleType(rawType, parameterTypes);"
      },
      {
        "txt": "} public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) { return ReferenceType.construct(rawType, null, // no bindings null, null, // or super-class, interfaces? referredType); } public JavaType uncheckedSimpleType(Class<?> cls) { return _constructSimple(cls, EMPTY_BINDINGS, null, null); }"
      },
      {
        "txt": "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); } public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {"
      },
      {
        "txt": "return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes)); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) { return constructParametricType(parametrized, parameterTypes); } public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {"
      },
      {
        "txt": "return constructParametricType(parametrized, parameterClasses); } public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { return constructCollectionType(collectionClass, unknownType()); } public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { return constructCollectionLikeType(collectionClass, unknownType()); } public MapType constructRawMapType(Class<? extends Map> mapClass) { return constructMapType(mapClass, unknownType(), unknownType());"
      },
      {
        "txt": "} public MapLikeType constructRawMapLikeType(Class<?> mapClass) { return constructMapLikeType(mapClass, unknownType(), unknownType()); } private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { JavaType kt, vt; if (rawClass == Properties.class) { kt = vt = CORE_TYPE_STRING;"
      },
      {
        "txt": "} else { List<JavaType> typeParams = bindings.getTypeParameters(); switch (typeParams.size()) { case 0: // acceptable? kt = vt = _unknownType(); break; case 2: kt = typeParams.get(0); vt = typeParams.get(1); break;"
      },
      {
        "txt": "default: throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\"); } } return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt); } private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters();"
      },
      {
        "txt": "JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else { throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\"); } return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct); }"
      },
      {
        "txt": "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { List<JavaType> typeParams = bindings.getTypeParameters(); JavaType ct; if (typeParams.isEmpty()) { ct = _unknownType(); } else if (typeParams.size() == 1) { ct = typeParams.get(0); } else {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\"); } return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct); } protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (bindings.isEmpty()) { JavaType result = _findWellKnownSimple(raw); if (result != null) {"
      },
      {
        "txt": "return result; } } return _newSimpleType(raw, bindings, superClass, superInterfaces); } protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { return new SimpleType(raw, bindings, superClass, superInterfaces); }"
      },
      {
        "txt": "protected JavaType _unknownType() { return CORE_TYPE_OBJECT; } protected JavaType _findWellKnownSimple(Class<?> clz) { if (clz.isPrimitive()) { if (clz == CLS_BOOL) return CORE_TYPE_BOOL; if (clz == CLS_INT) return CORE_TYPE_INT; if (clz == CLS_LONG) return CORE_TYPE_LONG; } else { if (clz == CLS_STRING) return CORE_TYPE_STRING;"
      },
      {
        "txt": "if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7 } return null; } protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) { JavaType resultType; if (type instanceof Class<?>) { resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS); }"
      },
      {
        "txt": "else if (type instanceof ParameterizedType) { resultType = _fromParamType(context, (ParameterizedType) type, bindings); } else if (type instanceof JavaType) { // [databind#116] return (JavaType) type; } else if (type instanceof GenericArrayType) { resultType = _fromArrayType(context, (GenericArrayType) type, bindings); } else if (type instanceof TypeVariable<?>) {"
      },
      {
        "txt": "resultType = _fromVariable(context, (TypeVariable<?>) type, bindings); } else if (type instanceof WildcardType) { resultType = _fromWildcard(context, (WildcardType) type, bindings); } else { throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString())); } if (_modifiers != null && !resultType.isContainerType()) { TypeBindings b = resultType.getBindings(); if (b == null) {"
      },
      {
        "txt": "b = EMPTY_BINDINGS; } for (TypeModifier mod : _modifiers) { resultType = mod.modifyType(resultType, type, b, this); } } return resultType; } protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {"
      },
      {
        "txt": "JavaType result = _findWellKnownSimple(rawType); if (result != null) { return result; } boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); // ok, cache object is synced if (result != null) { return result; }"
      },
      {
        "txt": "} if (context == null) { context = new ClassStack(rawType); } else { ClassStack prev = context.find(rawType); if (prev != null) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS); prev.addSelfReference(selfRef); return selfRef; }"
      },
      {
        "txt": "context = context.child(rawType); } if (rawType.isArray()) { result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings); } else { JavaType superClass; JavaType[] superInterfaces; if (rawType.isInterface()) { superClass = null;"
      },
      {
        "txt": "superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } else { superClass = _resolveSuperClass(context, rawType, bindings); superInterfaces = _resolveSuperInterfaces(context, rawType, bindings); } if (rawType == Properties.class) { result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING); } else if (superClass != null) {"
      },
      {
        "txt": "result = superClass.refine(rawType, bindings, superClass, superInterfaces); } if (result == null) { result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces); if (result == null) { result = _newSimpleType(rawType, bindings, superClass, superInterfaces); } }"
      },
      {
        "txt": "} } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); // cache object syncs } return result; } protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {"
      },
      {
        "txt": "Type parent = ClassUtil.getGenericSuperclass(rawType); if (parent == null) { return null; } return _fromAny(context, parent, parentBindings); } protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) { Type[] types = ClassUtil.getGenericInterfaces(rawType); if (types == null || types.length == 0) {"
      },
      {
        "txt": "return NO_TYPES; } int len = types.length; JavaType[] resolved = new JavaType[len]; for (int i = 0; i < len; ++i) { Type type = types[i]; resolved[i] = _fromAny(context, type, parentBindings); } return resolved; }"
      },
      {
        "txt": "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { if (rawType == Map.class) { return _mapType(rawType, bindings, superClass, superInterfaces); } if (rawType == Collection.class) { return _collectionType(rawType, bindings, superClass, superInterfaces); } if (rawType == AtomicReference.class) {"
      },
      {
        "txt": "return _referenceType(rawType, bindings, superClass, superInterfaces); } return null; } protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { final int intCount = superInterfaces.length; for (int i = 0; i < intCount; ++i) { JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);"
      },
      {
        "txt": "if (result != null) { return result; } } return null; } protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) { Class<?> rawType = (Class<?>) ptype.getRawType();"
      },
      {
        "txt": "if (rawType == CLS_ENUM) { return CORE_TYPE_ENUM; } if (rawType == CLS_COMPARABLE) { return CORE_TYPE_COMPARABLE; } if (rawType == CLS_CLASS) { return CORE_TYPE_CLASS; } Type[] args = ptype.getActualTypeArguments();"
      },
      {
        "txt": "int paramCount = (args == null) ? 0 : args.length; JavaType[] pt; TypeBindings newBindings; if (paramCount == 0) { newBindings = EMPTY_BINDINGS; } else { pt = new JavaType[paramCount]; for (int i = 0; i < paramCount; ++i) { pt[i] = _fromAny(context, args[i], parentBindings); }"
      },
      {
        "txt": "newBindings = TypeBindings.create(rawType, pt); } return _fromClass(context, rawType, newBindings); } protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) { JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings); return ArrayType.construct(elementType, bindings); } protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)"
      },
      {
        "txt": "{ final String name = var.getName(); JavaType type = bindings.findBoundType(name); if (type != null) { return type; } if (bindings.hasUnbound(name)) { return CORE_TYPE_OBJECT; } bindings = bindings.withUnboundVariable(name);"
      },
      {
        "txt": "Type[] bounds = var.getBounds(); return _fromAny(context, bounds[0], bindings); } protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) { return _fromAny(context, type.getUpperBounds()[0], bindings); }"
      }
    ]
  }
]