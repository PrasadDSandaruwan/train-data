[
  {
    "id": 2027,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 89,
    "end-bug-line": 89,
    "bug": "childNodes = new NodeList(4);",
    "fix": "childNodes = new NodeList(this, 4);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.jsoup.helper.ChangeNotifyingArrayList; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate;"
      },
      {
        "txt": "import org.jsoup.parser.ParseSettings; import org.jsoup.parser.Parser; import org.jsoup.parser.Tag; import org.jsoup.select.Collector; import org.jsoup.select.Elements; import org.jsoup.select.Evaluator; import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import org.jsoup.select.QueryParser; import org.jsoup.select.Selector;"
      },
      {
        "txt": "import java.io.IOException; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException; import static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children List<Node> childNodes; private Attributes attributes;"
      },
      {
        "txt": "private String baseUri; public Element(String tag) { this(Tag.valueOf(tag), \"\", new Attributes()); } public Element(Tag tag, String baseUri, Attributes attributes) { Validate.notNull(tag); Validate.notNull(baseUri); childNodes = EMPTY_NODES; this.baseUri = baseUri; this.attributes = attributes;"
      },
      {
        "txt": "} public Element(Tag tag, String baseUri) { this(tag, baseUri, null); } protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { <extra_id_0> } return childNodes; } @Override protected boolean hasAttributes() { return attributes != null;"
      },
      {
        "txt": "protected boolean hasAttributes() { return attributes != null; } @Override public Attributes attributes() { if (!hasAttributes()) attributes = new Attributes(); return attributes; } @Override"
      },
      {
        "txt": "public String baseUri() { return baseUri; } @Override protected void doSetBaseUri(String baseUri) { this.baseUri = baseUri; } @Override public int childNodeSize() { return childNodes.size();"
      },
      {
        "txt": "} @Override public String nodeName() { return tag.getName(); } public String tagName() { return tag.getName(); } public Element tagName(String tagName) { Validate.notEmpty(tagName, \"Tag name must not be empty.\");"
      },
      {
        "txt": "tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case return this; } public Tag tag() { return tag; } public boolean isBlock() { return tag.isBlock(); } public String id() {"
      },
      {
        "txt": "return attributes().getIgnoreCase(\"id\"); } public Element attr(String attributeKey, String attributeValue) { super.attr(attributeKey, attributeValue); return this; } public Element attr(String attributeKey, boolean attributeValue) { attributes().put(attributeKey, attributeValue); return this; }"
      },
      {
        "txt": "public Map<String, String> dataset() { return attributes().dataset(); } @Override public final Element parent() { return (Element) parentNode; } public Elements parents() { Elements parents = new Elements(); accumulateParents(this, parents);"
      },
      {
        "txt": "return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent(); if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents); } } public Element child(int index) {"
      },
      {
        "txt": "return childElementsList().get(index); } public Elements children() { return new Elements(childElementsList()); } private List<Element> childElementsList() { List<Element> children; if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) { final int size = childNodes.size(); children = new ArrayList<>(size);"
      },
      {
        "txt": "for (int i = 0; i < size; i++) { final Node node = childNodes.get(i); if (node instanceof Element) children.add((Element) node); } shadowChildrenRef = new WeakReference<>(children); } return children; } @Override"
      },
      {
        "txt": "void nodelistChanged() { super.nodelistChanged(); shadowChildrenRef = null; } public List<TextNode> textNodes() { List<TextNode> textNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof TextNode) textNodes.add((TextNode) node); }"
      },
      {
        "txt": "return Collections.unmodifiableList(textNodes); } public List<DataNode> dataNodes() { List<DataNode> dataNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof DataNode) dataNodes.add((DataNode) node); } return Collections.unmodifiableList(dataNodes); }"
      },
      {
        "txt": "public Elements select(String cssQuery) { return Selector.select(cssQuery, this); } public Element selectFirst(String cssQuery) { return Selector.selectFirst(cssQuery, this); } public boolean is(String cssQuery) { return is(QueryParser.parse(cssQuery)); } public boolean is(Evaluator evaluator) {"
      },
      {
        "txt": "return evaluator.matches((Element)this.root(), this); } public Element appendChild(Node child) { Validate.notNull(child); reparentChild(child); ensureChildNodes(); childNodes.add(child); child.setSiblingIndex(childNodes.size() - 1); return this; }"
      },
      {
        "txt": "public Element appendTo(Element parent) { Validate.notNull(parent); parent.appendChild(this); return this; } public Element prependChild(Node child) { Validate.notNull(child); addChildren(0, child); return this; }"
      },
      {
        "txt": "public Element insertChildren(int index, Collection<? extends Node> children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); ArrayList<Node> nodes = new ArrayList<>(children); Node[] nodeArray = nodes.toArray(new Node[nodes.size()]); addChildren(index, nodeArray); return this; }"
      },
      {
        "txt": "public Element insertChildren(int index, Node... children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); addChildren(index, children); return this; } public Element appendElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri());"
      },
      {
        "txt": "appendChild(child); return child; } public Element prependElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child; } public Element appendText(String text) { Validate.notNull(text);"
      },
      {
        "txt": "TextNode node = new TextNode(text); appendChild(node); return this; } public Element prependText(String text) { Validate.notNull(text); TextNode node = new TextNode(text); prependChild(node); return this; }"
      },
      {
        "txt": "public Element append(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(nodes.toArray(new Node[nodes.size()])); return this; } public Element prepend(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(0, nodes.toArray(new Node[nodes.size()]));"
      },
      {
        "txt": "return this; } @Override public Element before(String html) { return (Element) super.before(html); } @Override public Element before(Node node) { return (Element) super.before(node); }"
      },
      {
        "txt": "@Override public Element after(String html) { return (Element) super.after(html); } @Override public Element after(Node node) { return (Element) super.after(node); } public Element empty() { childNodes.clear();"
      },
      {
        "txt": "return this; } @Override public Element wrap(String html) { return (Element) super.wrap(html); } public String cssSelector() { if (id().length() > 0) return \"#\" + id(); String tagName = tagName().replace(':', '|');"
      },
      {
        "txt": "StringBuilder selector = new StringBuilder(tagName); String classes = StringUtil.join(classNames(), \".\"); if (classes.length() > 0) selector.append('.').append(classes); if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node return selector.toString(); selector.insert(0, \" > \"); if (parent().select(selector.toString()).size() > 1) selector.append(String.format( \":nth-child(%d)\", elementSiblingIndex() + 1));"
      },
      {
        "txt": "return parent().cssSelector() + selector.toString(); } public Elements siblingElements() { if (parentNode == null) return new Elements(0); List<Element> elements = parent().childElementsList(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this) siblings.add(el);"
      },
      {
        "txt": "return siblings; } public Element nextElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); else"
      },
      {
        "txt": "return null; } public Element previousElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1); else"
      },
      {
        "txt": "return null; } public Element firstElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(0) : null; } public int elementSiblingIndex() { if (parent() == null) return 0; return indexInList(this, parent().childElementsList()); }"
      },
      {
        "txt": "public Element lastElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; } private static <E extends Element> int indexInList(Element search, List<E> elements) { for (int i = 0; i < elements.size(); i++) { if (elements.get(i) == search) return i; } return 0;"
      },
      {
        "txt": "} public Elements getElementsByTag(String tagName) { Validate.notEmpty(tagName); tagName = normalize(tagName); return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) { Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this); if (elements.size() > 0)"
      },
      {
        "txt": "return elements.get(0); else return null; } public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this); } public Elements getElementsByAttribute(String key) { Validate.notEmpty(key);"
      },
      {
        "txt": "key = key.trim(); return Collector.collect(new Evaluator.Attribute(key), this); } public Elements getElementsByAttributeStarting(String keyPrefix) { Validate.notEmpty(keyPrefix); keyPrefix = keyPrefix.trim(); return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this); } public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);"
      },
      {
        "txt": "} public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); } public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); } public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); }"
      },
      {
        "txt": "public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) { return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this); } public Elements getElementsByAttributeValueMatching(String key, String regex) { Pattern pattern; try { pattern = Pattern.compile(regex);"
      },
      {
        "txt": "} catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsByAttributeValueMatching(key, pattern); } public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this); } public Elements getElementsByIndexGreaterThan(int index) { return Collector.collect(new Evaluator.IndexGreaterThan(index), this);"
      },
      {
        "txt": "} public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); } public Elements getElementsContainingText(String searchText) { return Collector.collect(new Evaluator.ContainsText(searchText), this); } public Elements getElementsContainingOwnText(String searchText) { return Collector.collect(new Evaluator.ContainsOwnText(searchText), this); }"
      },
      {
        "txt": "public Elements getElementsMatchingText(Pattern pattern) { return Collector.collect(new Evaluator.Matches(pattern), this); } public Elements getElementsMatchingText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); }"
      },
      {
        "txt": "return getElementsMatchingText(pattern); } public Elements getElementsMatchingOwnText(Pattern pattern) { return Collector.collect(new Evaluator.MatchesOwn(pattern), this); } public Elements getElementsMatchingOwnText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsMatchingOwnText(pattern); } public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); } public String text() { final StringBuilder accum = new StringBuilder(); NodeTraversor.traverse(new NodeVisitor() {"
      },
      {
        "txt": "public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; appendNormalisedText(accum, textNode); } else if (node instanceof Element) { Element element = (Element) node; if (accum.length() > 0 && (element.isBlock() || element.tag.getName().equals(\"br\")) && !TextNode.lastCharIsWhitespace(accum)) accum.append(' ');"
      },
      {
        "txt": "} } public void tail(Node node, int depth) { } }, this); return accum.toString().trim(); } public String ownText() { StringBuilder sb = new StringBuilder(); ownText(sb);"
      },
      {
        "txt": "return sb.toString().trim(); } private void ownText(StringBuilder accum) { for (Node child : childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; appendNormalisedText(accum, textNode); } else if (child instanceof Element) { appendWhitespaceIfBr((Element) child, accum); }"
      },
      {
        "txt": "} } private static void appendNormalisedText(StringBuilder accum, TextNode textNode) { String text = textNode.getWholeText(); if (preserveWhitespace(textNode.parentNode)) accum.append(text); else StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum)); } private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {"
      },
      {
        "txt": "if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum)) accum.append(\" \"); } static boolean preserveWhitespace(Node node) { if (node != null && node instanceof Element) { Element element = (Element) node; return element.tag.preserveWhitespace() || element.parent() != null && element.parent().tag.preserveWhitespace(); } return false;"
      },
      {
        "txt": "} public Element text(String text) { Validate.notNull(text); empty(); TextNode textNode = new TextNode(text); appendChild(textNode); return this; } Test if this element has any text content (that is not just whitespace). @return true if element has non-blank text content."
      },
      {
        "txt": "public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; if (!textNode.isBlank()) return true; } else if (child instanceof Element) { Element el = (Element) child; if (el.hasText()) return true;"
      },
      {
        "txt": "} } return false; } public String data() { StringBuilder sb = new StringBuilder(); for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData());"
      },
      {
        "txt": "} else if (childNode instanceof Comment) { Comment comment = (Comment) childNode; sb.append(comment.getData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } } return sb.toString();"
      },
      {
        "txt": "} public String className() { return attr(\"class\").trim(); } public Set<String> classNames() { String[] names = classSplit.split(className()); Set<String> classNames = new LinkedHashSet<>(Arrays.asList(names)); classNames.remove(\"\"); // if classNames() was empty, would include an empty class return classNames; }"
      },
      {
        "txt": "Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) { Validate.notNull(classNames); attributes().put(\"class\", StringUtil.join(classNames, \" \")); return this; } public boolean hasClass(String className) { final String classAttr = attributes().getIgnoreCase(\"class\");"
      },
      {
        "txt": "final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0;"
      },
      {
        "txt": "for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) {"
      },
      {
        "txt": "inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }"
      },
      {
        "txt": "Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.add(className); classNames(classes); return this; }"
      },
      {
        "txt": "Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.remove(className); classNames(classes); return this; }"
      },
      {
        "txt": "Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); if (classes.contains(className)) classes.remove(className); else classes.add(className);"
      },
      {
        "txt": "classNames(classes); return this; } public String val() { if (tagName().equals(\"textarea\")) return text(); else return attr(\"value\"); } public Element val(String value) {"
      },
      {
        "txt": "if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value); return this; } void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException { if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) { if (accum instanceof StringBuilder) { if (((StringBuilder) accum).length() > 0)"
      },
      {
        "txt": "indent(accum, depth, out); } else { indent(accum, depth, out); } } accum.append('<').append(tagName()); if (attributes != null) attributes.html(accum, out); if (childNodes.isEmpty() && tag.isSelfClosing()) { if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty()) accum.append('>');"
      },
      {
        "txt": "else accum.append(\" />\"); // <img> in html, <img /> in xml } else accum.append('>'); } void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (!(childNodes.isEmpty() && tag.isSelfClosing())) { if (out.prettyPrint() && (!childNodes.isEmpty() && ( tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))"
      },
      {
        "txt": "))) indent(accum, depth, out); accum.append(\"</\").append(tagName()).append('>'); } } public String html() { StringBuilder accum = StringUtil.stringBuilder(); html(accum); return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString(); }"
      },
      {
        "txt": "private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); } @Override public <T extends Appendable> T html(T appendable) { for (Node node : childNodes) node.outerHtml(appendable); return appendable; }"
      },
      {
        "txt": "public Element html(String html) { empty(); append(html); return this; } public String toString() { return outerHtml(); } @Override public Element clone() {"
      },
      {
        "txt": "return (Element) super.clone(); } @Override protected Element doClone(Node parent) { Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; clone.childNodes = new NodeList(childNodes.size()); clone.childNodes.addAll(childNodes); return clone;"
      },
      {
        "txt": "} private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { super(initialCapacity); } public void onContentsChanged() { nodelistChanged(); } }"
      }
    ]
  },
  {
    "id": 2028,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 1402,
    "end-bug-line": 1402,
    "bug": "clone.childNodes = new NodeList(childNodes.size());",
    "fix": "clone.childNodes = new NodeList(clone, childNodes.size());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.jsoup.helper.ChangeNotifyingArrayList; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate; import org.jsoup.parser.ParseSettings; import org.jsoup.parser.Parser;"
      },
      {
        "txt": "import org.jsoup.parser.Tag; import org.jsoup.select.Collector; import org.jsoup.select.Elements; import org.jsoup.select.Evaluator; import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import org.jsoup.select.QueryParser; import org.jsoup.select.Selector; import java.io.IOException; import java.lang.ref.WeakReference;"
      },
      {
        "txt": "import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException;"
      },
      {
        "txt": "import static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children List<Node> childNodes; private Attributes attributes; private String baseUri; public Element(String tag) {"
      },
      {
        "txt": "this(Tag.valueOf(tag), \"\", new Attributes()); } public Element(Tag tag, String baseUri, Attributes attributes) { Validate.notNull(tag); Validate.notNull(baseUri); childNodes = EMPTY_NODES; this.baseUri = baseUri; this.attributes = attributes; this.tag = tag; }"
      },
      {
        "txt": "public Element(Tag tag, String baseUri) { this(tag, baseUri, null); } protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { childNodes = new NodeList(4); } return childNodes; } @Override"
      },
      {
        "txt": "protected boolean hasAttributes() { return attributes != null; } @Override public Attributes attributes() { if (!hasAttributes()) attributes = new Attributes(); return attributes; } @Override"
      },
      {
        "txt": "public String baseUri() { return baseUri; } @Override protected void doSetBaseUri(String baseUri) { this.baseUri = baseUri; } @Override public int childNodeSize() { return childNodes.size();"
      },
      {
        "txt": "} @Override public String nodeName() { return tag.getName(); } public String tagName() { return tag.getName(); } public Element tagName(String tagName) { Validate.notEmpty(tagName, \"Tag name must not be empty.\");"
      },
      {
        "txt": "tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case return this; } public Tag tag() { return tag; } public boolean isBlock() { return tag.isBlock(); } public String id() {"
      },
      {
        "txt": "return attributes().getIgnoreCase(\"id\"); } public Element attr(String attributeKey, String attributeValue) { super.attr(attributeKey, attributeValue); return this; } public Element attr(String attributeKey, boolean attributeValue) { attributes().put(attributeKey, attributeValue); return this; }"
      },
      {
        "txt": "public Map<String, String> dataset() { return attributes().dataset(); } @Override public final Element parent() { return (Element) parentNode; } public Elements parents() { Elements parents = new Elements(); accumulateParents(this, parents);"
      },
      {
        "txt": "return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent(); if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents); } } public Element child(int index) {"
      },
      {
        "txt": "return childElementsList().get(index); } public Elements children() { return new Elements(childElementsList()); } private List<Element> childElementsList() { List<Element> children; if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) { final int size = childNodes.size(); children = new ArrayList<>(size);"
      },
      {
        "txt": "for (int i = 0; i < size; i++) { final Node node = childNodes.get(i); if (node instanceof Element) children.add((Element) node); } shadowChildrenRef = new WeakReference<>(children); } return children; } @Override"
      },
      {
        "txt": "void nodelistChanged() { super.nodelistChanged(); shadowChildrenRef = null; } public List<TextNode> textNodes() { List<TextNode> textNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof TextNode) textNodes.add((TextNode) node); }"
      },
      {
        "txt": "return Collections.unmodifiableList(textNodes); } public List<DataNode> dataNodes() { List<DataNode> dataNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof DataNode) dataNodes.add((DataNode) node); } return Collections.unmodifiableList(dataNodes); }"
      },
      {
        "txt": "public Elements select(String cssQuery) { return Selector.select(cssQuery, this); } public Element selectFirst(String cssQuery) { return Selector.selectFirst(cssQuery, this); } public boolean is(String cssQuery) { return is(QueryParser.parse(cssQuery)); } public boolean is(Evaluator evaluator) {"
      },
      {
        "txt": "return evaluator.matches((Element)this.root(), this); } public Element appendChild(Node child) { Validate.notNull(child); reparentChild(child); ensureChildNodes(); childNodes.add(child); child.setSiblingIndex(childNodes.size() - 1); return this; }"
      },
      {
        "txt": "public Element appendTo(Element parent) { Validate.notNull(parent); parent.appendChild(this); return this; } public Element prependChild(Node child) { Validate.notNull(child); addChildren(0, child); return this; }"
      },
      {
        "txt": "public Element insertChildren(int index, Collection<? extends Node> children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); ArrayList<Node> nodes = new ArrayList<>(children); Node[] nodeArray = nodes.toArray(new Node[nodes.size()]); addChildren(index, nodeArray); return this; }"
      },
      {
        "txt": "public Element insertChildren(int index, Node... children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); addChildren(index, children); return this; } public Element appendElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri());"
      },
      {
        "txt": "appendChild(child); return child; } public Element prependElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child; } public Element appendText(String text) { Validate.notNull(text);"
      },
      {
        "txt": "TextNode node = new TextNode(text); appendChild(node); return this; } public Element prependText(String text) { Validate.notNull(text); TextNode node = new TextNode(text); prependChild(node); return this; }"
      },
      {
        "txt": "public Element append(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(nodes.toArray(new Node[nodes.size()])); return this; } public Element prepend(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(0, nodes.toArray(new Node[nodes.size()]));"
      },
      {
        "txt": "return this; } @Override public Element before(String html) { return (Element) super.before(html); } @Override public Element before(Node node) { return (Element) super.before(node); }"
      },
      {
        "txt": "@Override public Element after(String html) { return (Element) super.after(html); } @Override public Element after(Node node) { return (Element) super.after(node); } public Element empty() { childNodes.clear();"
      },
      {
        "txt": "return this; } @Override public Element wrap(String html) { return (Element) super.wrap(html); } public String cssSelector() { if (id().length() > 0) return \"#\" + id(); String tagName = tagName().replace(':', '|');"
      },
      {
        "txt": "StringBuilder selector = new StringBuilder(tagName); String classes = StringUtil.join(classNames(), \".\"); if (classes.length() > 0) selector.append('.').append(classes); if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node return selector.toString(); selector.insert(0, \" > \"); if (parent().select(selector.toString()).size() > 1) selector.append(String.format( \":nth-child(%d)\", elementSiblingIndex() + 1));"
      },
      {
        "txt": "return parent().cssSelector() + selector.toString(); } public Elements siblingElements() { if (parentNode == null) return new Elements(0); List<Element> elements = parent().childElementsList(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this) siblings.add(el);"
      },
      {
        "txt": "return siblings; } public Element nextElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); else"
      },
      {
        "txt": "return null; } public Element previousElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1); else"
      },
      {
        "txt": "return null; } public Element firstElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(0) : null; } public int elementSiblingIndex() { if (parent() == null) return 0; return indexInList(this, parent().childElementsList()); }"
      },
      {
        "txt": "public Element lastElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; } private static <E extends Element> int indexInList(Element search, List<E> elements) { for (int i = 0; i < elements.size(); i++) { if (elements.get(i) == search) return i; } return 0;"
      },
      {
        "txt": "} public Elements getElementsByTag(String tagName) { Validate.notEmpty(tagName); tagName = normalize(tagName); return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) { Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this); if (elements.size() > 0)"
      },
      {
        "txt": "return elements.get(0); else return null; } public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this); } public Elements getElementsByAttribute(String key) { Validate.notEmpty(key);"
      },
      {
        "txt": "key = key.trim(); return Collector.collect(new Evaluator.Attribute(key), this); } public Elements getElementsByAttributeStarting(String keyPrefix) { Validate.notEmpty(keyPrefix); keyPrefix = keyPrefix.trim(); return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this); } public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);"
      },
      {
        "txt": "} public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); } public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); } public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); }"
      },
      {
        "txt": "public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) { return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this); } public Elements getElementsByAttributeValueMatching(String key, String regex) { Pattern pattern; try { pattern = Pattern.compile(regex);"
      },
      {
        "txt": "} catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsByAttributeValueMatching(key, pattern); } public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this); } public Elements getElementsByIndexGreaterThan(int index) { return Collector.collect(new Evaluator.IndexGreaterThan(index), this);"
      },
      {
        "txt": "} public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); } public Elements getElementsContainingText(String searchText) { return Collector.collect(new Evaluator.ContainsText(searchText), this); } public Elements getElementsContainingOwnText(String searchText) { return Collector.collect(new Evaluator.ContainsOwnText(searchText), this); }"
      },
      {
        "txt": "public Elements getElementsMatchingText(Pattern pattern) { return Collector.collect(new Evaluator.Matches(pattern), this); } public Elements getElementsMatchingText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); }"
      },
      {
        "txt": "return getElementsMatchingText(pattern); } public Elements getElementsMatchingOwnText(Pattern pattern) { return Collector.collect(new Evaluator.MatchesOwn(pattern), this); } public Elements getElementsMatchingOwnText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsMatchingOwnText(pattern); } public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); } public String text() { final StringBuilder accum = new StringBuilder(); NodeTraversor.traverse(new NodeVisitor() {"
      },
      {
        "txt": "public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; appendNormalisedText(accum, textNode); } else if (node instanceof Element) { Element element = (Element) node; if (accum.length() > 0 && (element.isBlock() || element.tag.getName().equals(\"br\")) && !TextNode.lastCharIsWhitespace(accum)) accum.append(' ');"
      },
      {
        "txt": "} } public void tail(Node node, int depth) { } }, this); return accum.toString().trim(); } public String ownText() { StringBuilder sb = new StringBuilder(); ownText(sb);"
      },
      {
        "txt": "return sb.toString().trim(); } private void ownText(StringBuilder accum) { for (Node child : childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; appendNormalisedText(accum, textNode); } else if (child instanceof Element) { appendWhitespaceIfBr((Element) child, accum); }"
      },
      {
        "txt": "} } private static void appendNormalisedText(StringBuilder accum, TextNode textNode) { String text = textNode.getWholeText(); if (preserveWhitespace(textNode.parentNode)) accum.append(text); else StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum)); } private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {"
      },
      {
        "txt": "if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum)) accum.append(\" \"); } static boolean preserveWhitespace(Node node) { if (node != null && node instanceof Element) { Element element = (Element) node; return element.tag.preserveWhitespace() || element.parent() != null && element.parent().tag.preserveWhitespace(); } return false;"
      },
      {
        "txt": "} public Element text(String text) { Validate.notNull(text); empty(); TextNode textNode = new TextNode(text); appendChild(textNode); return this; } Test if this element has any text content (that is not just whitespace). @return true if element has non-blank text content."
      },
      {
        "txt": "public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; if (!textNode.isBlank()) return true; } else if (child instanceof Element) { Element el = (Element) child; if (el.hasText()) return true;"
      },
      {
        "txt": "} } return false; } public String data() { StringBuilder sb = new StringBuilder(); for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData());"
      },
      {
        "txt": "} else if (childNode instanceof Comment) { Comment comment = (Comment) childNode; sb.append(comment.getData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } } return sb.toString();"
      },
      {
        "txt": "} public String className() { return attr(\"class\").trim(); } public Set<String> classNames() { String[] names = classSplit.split(className()); Set<String> classNames = new LinkedHashSet<>(Arrays.asList(names)); classNames.remove(\"\"); // if classNames() was empty, would include an empty class return classNames; }"
      },
      {
        "txt": "Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) { Validate.notNull(classNames); attributes().put(\"class\", StringUtil.join(classNames, \" \")); return this; } public boolean hasClass(String className) { final String classAttr = attributes().getIgnoreCase(\"class\");"
      },
      {
        "txt": "final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0;"
      },
      {
        "txt": "for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) {"
      },
      {
        "txt": "inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }"
      },
      {
        "txt": "Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.add(className); classNames(classes); return this; }"
      },
      {
        "txt": "Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.remove(className); classNames(classes); return this; }"
      },
      {
        "txt": "Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); if (classes.contains(className)) classes.remove(className); else classes.add(className);"
      },
      {
        "txt": "classNames(classes); return this; } public String val() { if (tagName().equals(\"textarea\")) return text(); else return attr(\"value\"); } public Element val(String value) {"
      },
      {
        "txt": "if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value); return this; } void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException { if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) { if (accum instanceof StringBuilder) { if (((StringBuilder) accum).length() > 0)"
      },
      {
        "txt": "indent(accum, depth, out); } else { indent(accum, depth, out); } } accum.append('<').append(tagName()); if (attributes != null) attributes.html(accum, out); if (childNodes.isEmpty() && tag.isSelfClosing()) { if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty()) accum.append('>');"
      },
      {
        "txt": "else accum.append(\" />\"); // <img> in html, <img /> in xml } else accum.append('>'); } void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (!(childNodes.isEmpty() && tag.isSelfClosing())) { if (out.prettyPrint() && (!childNodes.isEmpty() && ( tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))"
      },
      {
        "txt": "))) indent(accum, depth, out); accum.append(\"</\").append(tagName()).append('>'); } } public String html() { StringBuilder accum = StringUtil.stringBuilder(); html(accum); return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString(); }"
      },
      {
        "txt": "private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); } @Override public <T extends Appendable> T html(T appendable) { for (Node node : childNodes) node.outerHtml(appendable); return appendable; }"
      },
      {
        "txt": "public Element html(String html) { empty(); append(html); return this; } public String toString() { return outerHtml(); } @Override public Element clone() {"
      },
      {
        "txt": "} @Override protected Element doClone(Node parent) { Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; <extra_id_0> clone.childNodes.addAll(childNodes); return clone; } private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { super(initialCapacity);"
      },
      {
        "txt": "NodeList(int initialCapacity) { super(initialCapacity); } public void onContentsChanged() { nodelistChanged(); } }"
      }
    ]
  },
  {
    "id": 2029,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 1408,
    "end-bug-line": 1409,
    "bug": "private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) {",
    "fix": "private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner;  NodeList(Element owner, int initialCapacity) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.jsoup.helper.ChangeNotifyingArrayList; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate; import org.jsoup.parser.ParseSettings; import org.jsoup.parser.Parser; import org.jsoup.parser.Tag; import org.jsoup.select.Collector; import org.jsoup.select.Elements; import org.jsoup.select.Evaluator;"
      },
      {
        "txt": "import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import org.jsoup.select.QueryParser; import org.jsoup.select.Selector; import java.io.IOException; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections;"
      },
      {
        "txt": "import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException; import static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");"
      },
      {
        "txt": "private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children List<Node> childNodes; private Attributes attributes; private String baseUri; public Element(String tag) { this(Tag.valueOf(tag), \"\", new Attributes()); } public Element(Tag tag, String baseUri, Attributes attributes) { Validate.notNull(tag);"
      },
      {
        "txt": "Validate.notNull(baseUri); childNodes = EMPTY_NODES; this.baseUri = baseUri; this.attributes = attributes; this.tag = tag; } public Element(Tag tag, String baseUri) { this(tag, baseUri, null); } protected List<Node> ensureChildNodes() {"
      },
      {
        "txt": "if (childNodes == EMPTY_NODES) { childNodes = new NodeList(4); } return childNodes; } @Override protected boolean hasAttributes() { return attributes != null; } @Override"
      },
      {
        "txt": "public Attributes attributes() { if (!hasAttributes()) attributes = new Attributes(); return attributes; } @Override public String baseUri() { return baseUri; } @Override"
      },
      {
        "txt": "protected void doSetBaseUri(String baseUri) { this.baseUri = baseUri; } @Override public int childNodeSize() { return childNodes.size(); } @Override public String nodeName() { return tag.getName();"
      },
      {
        "txt": "} public String tagName() { return tag.getName(); } public Element tagName(String tagName) { Validate.notEmpty(tagName, \"Tag name must not be empty.\"); tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case return this; } public Tag tag() {"
      },
      {
        "txt": "return tag; } public boolean isBlock() { return tag.isBlock(); } public String id() { return attributes().getIgnoreCase(\"id\"); } public Element attr(String attributeKey, String attributeValue) { super.attr(attributeKey, attributeValue);"
      },
      {
        "txt": "return this; } public Element attr(String attributeKey, boolean attributeValue) { attributes().put(attributeKey, attributeValue); return this; } public Map<String, String> dataset() { return attributes().dataset(); } @Override"
      },
      {
        "txt": "public final Element parent() { return (Element) parentNode; } public Elements parents() { Elements parents = new Elements(); accumulateParents(this, parents); return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent();"
      },
      {
        "txt": "if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents); } } public Element child(int index) { return childElementsList().get(index); } public Elements children() { return new Elements(childElementsList());"
      },
      {
        "txt": "} private List<Element> childElementsList() { List<Element> children; if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) { final int size = childNodes.size(); children = new ArrayList<>(size); for (int i = 0; i < size; i++) { final Node node = childNodes.get(i); if (node instanceof Element) children.add((Element) node);"
      },
      {
        "txt": "} shadowChildrenRef = new WeakReference<>(children); } return children; } @Override void nodelistChanged() { super.nodelistChanged(); shadowChildrenRef = null; }"
      },
      {
        "txt": "public List<TextNode> textNodes() { List<TextNode> textNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof TextNode) textNodes.add((TextNode) node); } return Collections.unmodifiableList(textNodes); } public List<DataNode> dataNodes() { List<DataNode> dataNodes = new ArrayList<>();"
      },
      {
        "txt": "for (Node node : childNodes) { if (node instanceof DataNode) dataNodes.add((DataNode) node); } return Collections.unmodifiableList(dataNodes); } public Elements select(String cssQuery) { return Selector.select(cssQuery, this); } public Element selectFirst(String cssQuery) {"
      },
      {
        "txt": "return Selector.selectFirst(cssQuery, this); } public boolean is(String cssQuery) { return is(QueryParser.parse(cssQuery)); } public boolean is(Evaluator evaluator) { return evaluator.matches((Element)this.root(), this); } public Element appendChild(Node child) { Validate.notNull(child);"
      },
      {
        "txt": "reparentChild(child); ensureChildNodes(); childNodes.add(child); child.setSiblingIndex(childNodes.size() - 1); return this; } public Element appendTo(Element parent) { Validate.notNull(parent); parent.appendChild(this); return this;"
      },
      {
        "txt": "} public Element prependChild(Node child) { Validate.notNull(child); addChildren(0, child); return this; } public Element insertChildren(int index, Collection<? extends Node> children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around"
      },
      {
        "txt": "Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); ArrayList<Node> nodes = new ArrayList<>(children); Node[] nodeArray = nodes.toArray(new Node[nodes.size()]); addChildren(index, nodeArray); return this; } public Element insertChildren(int index, Node... children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around"
      },
      {
        "txt": "Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); addChildren(index, children); return this; } public Element appendElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); appendChild(child); return child; } public Element prependElement(String tagName) {"
      },
      {
        "txt": "Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child; } public Element appendText(String text) { Validate.notNull(text); TextNode node = new TextNode(text); appendChild(node); return this; }"
      },
      {
        "txt": "public Element prependText(String text) { Validate.notNull(text); TextNode node = new TextNode(text); prependChild(node); return this; } public Element append(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(nodes.toArray(new Node[nodes.size()]));"
      },
      {
        "txt": "return this; } public Element prepend(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(0, nodes.toArray(new Node[nodes.size()])); return this; } @Override public Element before(String html) {"
      },
      {
        "txt": "return (Element) super.before(html); } @Override public Element before(Node node) { return (Element) super.before(node); } @Override public Element after(String html) { return (Element) super.after(html); }"
      },
      {
        "txt": "@Override public Element after(Node node) { return (Element) super.after(node); } public Element empty() { childNodes.clear(); return this; } @Override public Element wrap(String html) {"
      },
      {
        "txt": "return (Element) super.wrap(html); } public String cssSelector() { if (id().length() > 0) return \"#\" + id(); String tagName = tagName().replace(':', '|'); StringBuilder selector = new StringBuilder(tagName); String classes = StringUtil.join(classNames(), \".\"); if (classes.length() > 0) selector.append('.').append(classes);"
      },
      {
        "txt": "if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node return selector.toString(); selector.insert(0, \" > \"); if (parent().select(selector.toString()).size() > 1) selector.append(String.format( \":nth-child(%d)\", elementSiblingIndex() + 1)); return parent().cssSelector() + selector.toString(); } public Elements siblingElements() { if (parentNode == null)"
      },
      {
        "txt": "return new Elements(0); List<Element> elements = parent().childElementsList(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this) siblings.add(el); return siblings; } public Element nextElementSibling() { if (parentNode == null) return null;"
      },
      {
        "txt": "List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); else return null; } public Element previousElementSibling() { if (parentNode == null) return null;"
      },
      {
        "txt": "List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1); else return null; } public Element firstElementSibling() { List<Element> siblings = parent().childElementsList();"
      },
      {
        "txt": "return siblings.size() > 1 ? siblings.get(0) : null; } public int elementSiblingIndex() { if (parent() == null) return 0; return indexInList(this, parent().childElementsList()); } public Element lastElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; }"
      },
      {
        "txt": "private static <E extends Element> int indexInList(Element search, List<E> elements) { for (int i = 0; i < elements.size(); i++) { if (elements.get(i) == search) return i; } return 0; } public Elements getElementsByTag(String tagName) { Validate.notEmpty(tagName); tagName = normalize(tagName);"
      },
      {
        "txt": "return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) { Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this); if (elements.size() > 0) return elements.get(0); else return null; }"
      },
      {
        "txt": "public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this); } public Elements getElementsByAttribute(String key) { Validate.notEmpty(key); key = key.trim(); return Collector.collect(new Evaluator.Attribute(key), this); } public Elements getElementsByAttributeStarting(String keyPrefix) {"
      },
      {
        "txt": "Validate.notEmpty(keyPrefix); keyPrefix = keyPrefix.trim(); return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this); } public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); } public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); }"
      },
      {
        "txt": "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); } public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); } public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {"
      },
      {
        "txt": "return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this); } public Elements getElementsByAttributeValueMatching(String key, String regex) { Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsByAttributeValueMatching(key, pattern);"
      },
      {
        "txt": "} public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this); } public Elements getElementsByIndexGreaterThan(int index) { return Collector.collect(new Evaluator.IndexGreaterThan(index), this); } public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); }"
      },
      {
        "txt": "public Elements getElementsContainingText(String searchText) { return Collector.collect(new Evaluator.ContainsText(searchText), this); } public Elements getElementsContainingOwnText(String searchText) { return Collector.collect(new Evaluator.ContainsOwnText(searchText), this); } public Elements getElementsMatchingText(Pattern pattern) { return Collector.collect(new Evaluator.Matches(pattern), this); } public Elements getElementsMatchingText(String regex) {"
      },
      {
        "txt": "Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsMatchingText(pattern); } public Elements getElementsMatchingOwnText(Pattern pattern) { return Collector.collect(new Evaluator.MatchesOwn(pattern), this);"
      },
      {
        "txt": "} public Elements getElementsMatchingOwnText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsMatchingOwnText(pattern); }"
      },
      {
        "txt": "public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); } public String text() { final StringBuilder accum = new StringBuilder(); NodeTraversor.traverse(new NodeVisitor() { public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; appendNormalisedText(accum, textNode);"
      },
      {
        "txt": "} else if (node instanceof Element) { Element element = (Element) node; if (accum.length() > 0 && (element.isBlock() || element.tag.getName().equals(\"br\")) && !TextNode.lastCharIsWhitespace(accum)) accum.append(' '); } } public void tail(Node node, int depth) { }"
      },
      {
        "txt": "}, this); return accum.toString().trim(); } public String ownText() { StringBuilder sb = new StringBuilder(); ownText(sb); return sb.toString().trim(); } private void ownText(StringBuilder accum) { for (Node child : childNodes) {"
      },
      {
        "txt": "if (child instanceof TextNode) { TextNode textNode = (TextNode) child; appendNormalisedText(accum, textNode); } else if (child instanceof Element) { appendWhitespaceIfBr((Element) child, accum); } } } private static void appendNormalisedText(StringBuilder accum, TextNode textNode) { String text = textNode.getWholeText();"
      },
      {
        "txt": "if (preserveWhitespace(textNode.parentNode)) accum.append(text); else StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum)); } private static void appendWhitespaceIfBr(Element element, StringBuilder accum) { if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum)) accum.append(\" \"); } static boolean preserveWhitespace(Node node) {"
      },
      {
        "txt": "if (node != null && node instanceof Element) { Element element = (Element) node; return element.tag.preserveWhitespace() || element.parent() != null && element.parent().tag.preserveWhitespace(); } return false; } public Element text(String text) { Validate.notNull(text); empty();"
      },
      {
        "txt": "TextNode textNode = new TextNode(text); appendChild(textNode); return this; } Test if this element has any text content (that is not just whitespace). @return true if element has non-blank text content. public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child;"
      },
      {
        "txt": "if (!textNode.isBlank()) return true; } else if (child instanceof Element) { Element el = (Element) child; if (el.hasText()) return true; } } return false; }"
      },
      {
        "txt": "public String data() { StringBuilder sb = new StringBuilder(); for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Comment) { Comment comment = (Comment) childNode; sb.append(comment.getData()); } else if (childNode instanceof Element) {"
      },
      {
        "txt": "Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } } return sb.toString(); } public String className() { return attr(\"class\").trim(); }"
      },
      {
        "txt": "public Set<String> classNames() { String[] names = classSplit.split(className()); Set<String> classNames = new LinkedHashSet<>(Arrays.asList(names)); classNames.remove(\"\"); // if classNames() was empty, would include an empty class return classNames; } Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) {"
      },
      {
        "txt": "Validate.notNull(classNames); attributes().put(\"class\", StringUtil.join(classNames, \" \")); return this; } public boolean hasClass(String className) { final String classAttr = attributes().getIgnoreCase(\"class\"); final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false;"
      },
      {
        "txt": "} if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {"
      },
      {
        "txt": "return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } }"
      },
      {
        "txt": "} if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; } Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) {"
      },
      {
        "txt": "Validate.notNull(className); Set<String> classes = classNames(); classes.add(className); classNames(classes); return this; } Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) {"
      },
      {
        "txt": "Validate.notNull(className); Set<String> classes = classNames(); classes.remove(className); classNames(classes); return this; } Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) {"
      },
      {
        "txt": "Validate.notNull(className); Set<String> classes = classNames(); if (classes.contains(className)) classes.remove(className); else classes.add(className); classNames(classes); return this; } public String val() {"
      },
      {
        "txt": "if (tagName().equals(\"textarea\")) return text(); else return attr(\"value\"); } public Element val(String value) { if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value);"
      },
      {
        "txt": "return this; } void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException { if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) { if (accum instanceof StringBuilder) { if (((StringBuilder) accum).length() > 0) indent(accum, depth, out); } else { indent(accum, depth, out); }"
      },
      {
        "txt": "} accum.append('<').append(tagName()); if (attributes != null) attributes.html(accum, out); if (childNodes.isEmpty() && tag.isSelfClosing()) { if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty()) accum.append('>'); else accum.append(\" />\"); // <img> in html, <img /> in xml } else"
      },
      {
        "txt": "accum.append('>'); } void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (!(childNodes.isEmpty() && tag.isSelfClosing())) { if (out.prettyPrint() && (!childNodes.isEmpty() && ( tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode)))) ))) indent(accum, depth, out); accum.append(\"</\").append(tagName()).append('>'); }"
      },
      {
        "txt": "} public String html() { StringBuilder accum = StringUtil.stringBuilder(); html(accum); return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString(); } private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); }"
      },
      {
        "txt": "@Override public <T extends Appendable> T html(T appendable) { for (Node node : childNodes) node.outerHtml(appendable); return appendable; } public Element html(String html) { empty(); append(html); return this;"
      },
      {
        "txt": "} public String toString() { return outerHtml(); } @Override public Element clone() { return (Element) super.clone(); } @Override protected Element doClone(Node parent) {"
      },
      {
        "txt": "clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; clone.childNodes = new NodeList(childNodes.size()); clone.childNodes.addAll(childNodes); return clone; } <extra_id_0> super(initialCapacity); } public void onContentsChanged() { nodelistChanged(); } }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2030,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 1411,
    "end-bug-line": 1411,
    "bug": "",
    "fix": "this.owner = owner;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.jsoup.helper.ChangeNotifyingArrayList; import org.jsoup.helper.StringUtil;"
      },
      {
        "txt": "import org.jsoup.helper.Validate; import org.jsoup.parser.ParseSettings; import org.jsoup.parser.Parser; import org.jsoup.parser.Tag; import org.jsoup.select.Collector; import org.jsoup.select.Elements; import org.jsoup.select.Evaluator; import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import org.jsoup.select.QueryParser;"
      },
      {
        "txt": "import org.jsoup.select.Selector; import java.io.IOException; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.LinkedHashSet; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException; import static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children List<Node> childNodes;"
      },
      {
        "txt": "private Attributes attributes; private String baseUri; public Element(String tag) { this(Tag.valueOf(tag), \"\", new Attributes()); } public Element(Tag tag, String baseUri, Attributes attributes) { Validate.notNull(tag); Validate.notNull(baseUri); childNodes = EMPTY_NODES; this.baseUri = baseUri;"
      },
      {
        "txt": "this.attributes = attributes; this.tag = tag; } public Element(Tag tag, String baseUri) { this(tag, baseUri, null); } protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { childNodes = new NodeList(4); }"
      },
      {
        "txt": "return childNodes; } @Override protected boolean hasAttributes() { return attributes != null; } @Override public Attributes attributes() { if (!hasAttributes()) attributes = new Attributes();"
      },
      {
        "txt": "return attributes; } @Override public String baseUri() { return baseUri; } @Override protected void doSetBaseUri(String baseUri) { this.baseUri = baseUri; }"
      },
      {
        "txt": "@Override public int childNodeSize() { return childNodes.size(); } @Override public String nodeName() { return tag.getName(); } public String tagName() { return tag.getName();"
      },
      {
        "txt": "} public Element tagName(String tagName) { Validate.notEmpty(tagName, \"Tag name must not be empty.\"); tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case return this; } public Tag tag() { return tag; } public boolean isBlock() {"
      },
      {
        "txt": "return tag.isBlock(); } public String id() { return attributes().getIgnoreCase(\"id\"); } public Element attr(String attributeKey, String attributeValue) { super.attr(attributeKey, attributeValue); return this; } public Element attr(String attributeKey, boolean attributeValue) {"
      },
      {
        "txt": "attributes().put(attributeKey, attributeValue); return this; } public Map<String, String> dataset() { return attributes().dataset(); } @Override public final Element parent() { return (Element) parentNode; }"
      },
      {
        "txt": "public Elements parents() { Elements parents = new Elements(); accumulateParents(this, parents); return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent(); if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents);"
      },
      {
        "txt": "} } public Element child(int index) { return childElementsList().get(index); } public Elements children() { return new Elements(childElementsList()); } private List<Element> childElementsList() { List<Element> children;"
      },
      {
        "txt": "if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) { final int size = childNodes.size(); children = new ArrayList<>(size); for (int i = 0; i < size; i++) { final Node node = childNodes.get(i); if (node instanceof Element) children.add((Element) node); } shadowChildrenRef = new WeakReference<>(children); }"
      },
      {
        "txt": "return children; } @Override void nodelistChanged() { super.nodelistChanged(); shadowChildrenRef = null; } public List<TextNode> textNodes() { List<TextNode> textNodes = new ArrayList<>(); for (Node node : childNodes) {"
      },
      {
        "txt": "if (node instanceof TextNode) textNodes.add((TextNode) node); } return Collections.unmodifiableList(textNodes); } public List<DataNode> dataNodes() { List<DataNode> dataNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof DataNode) dataNodes.add((DataNode) node);"
      },
      {
        "txt": "} return Collections.unmodifiableList(dataNodes); } public Elements select(String cssQuery) { return Selector.select(cssQuery, this); } public Element selectFirst(String cssQuery) { return Selector.selectFirst(cssQuery, this); } public boolean is(String cssQuery) {"
      },
      {
        "txt": "return is(QueryParser.parse(cssQuery)); } public boolean is(Evaluator evaluator) { return evaluator.matches((Element)this.root(), this); } public Element appendChild(Node child) { Validate.notNull(child); reparentChild(child); ensureChildNodes(); childNodes.add(child);"
      },
      {
        "txt": "child.setSiblingIndex(childNodes.size() - 1); return this; } public Element appendTo(Element parent) { Validate.notNull(parent); parent.appendChild(this); return this; } public Element prependChild(Node child) { Validate.notNull(child);"
      },
      {
        "txt": "addChildren(0, child); return this; } public Element insertChildren(int index, Collection<? extends Node> children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); ArrayList<Node> nodes = new ArrayList<>(children); Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);"
      },
      {
        "txt": "addChildren(index, nodeArray); return this; } public Element insertChildren(int index, Node... children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); addChildren(index, children); return this;"
      },
      {
        "txt": "} public Element appendElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); appendChild(child); return child; } public Element prependElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child;"
      },
      {
        "txt": "} public Element appendText(String text) { Validate.notNull(text); TextNode node = new TextNode(text); appendChild(node); return this; } public Element prependText(String text) { Validate.notNull(text); TextNode node = new TextNode(text);"
      },
      {
        "txt": "prependChild(node); return this; } public Element append(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(nodes.toArray(new Node[nodes.size()])); return this; } public Element prepend(String html) {"
      },
      {
        "txt": "Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(0, nodes.toArray(new Node[nodes.size()])); return this; } @Override public Element before(String html) { return (Element) super.before(html); } @Override"
      },
      {
        "txt": "public Element before(Node node) { return (Element) super.before(node); } @Override public Element after(String html) { return (Element) super.after(html); } @Override public Element after(Node node) { return (Element) super.after(node);"
      },
      {
        "txt": "} public Element empty() { childNodes.clear(); return this; } @Override public Element wrap(String html) { return (Element) super.wrap(html); } public String cssSelector() {"
      },
      {
        "txt": "if (id().length() > 0) return \"#\" + id(); String tagName = tagName().replace(':', '|'); StringBuilder selector = new StringBuilder(tagName); String classes = StringUtil.join(classNames(), \".\"); if (classes.length() > 0) selector.append('.').append(classes); if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node return selector.toString(); selector.insert(0, \" > \");"
      },
      {
        "txt": "if (parent().select(selector.toString()).size() > 1) selector.append(String.format( \":nth-child(%d)\", elementSiblingIndex() + 1)); return parent().cssSelector() + selector.toString(); } public Elements siblingElements() { if (parentNode == null) return new Elements(0); List<Element> elements = parent().childElementsList(); Elements siblings = new Elements(elements.size() - 1);"
      },
      {
        "txt": "for (Element el: elements) if (el != this) siblings.add(el); return siblings; } public Element nextElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index);"
      },
      {
        "txt": "if (siblings.size() > index+1) return siblings.get(index+1); else return null; } public Element previousElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index);"
      },
      {
        "txt": "if (index > 0) return siblings.get(index-1); else return null; } public Element firstElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(0) : null; } public int elementSiblingIndex() {"
      },
      {
        "txt": "if (parent() == null) return 0; return indexInList(this, parent().childElementsList()); } public Element lastElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; } private static <E extends Element> int indexInList(Element search, List<E> elements) { for (int i = 0; i < elements.size(); i++) { if (elements.get(i) == search)"
      },
      {
        "txt": "return i; } return 0; } public Elements getElementsByTag(String tagName) { Validate.notEmpty(tagName); tagName = normalize(tagName); return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) {"
      },
      {
        "txt": "Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this); if (elements.size() > 0) return elements.get(0); else return null; } public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this);"
      },
      {
        "txt": "} public Elements getElementsByAttribute(String key) { Validate.notEmpty(key); key = key.trim(); return Collector.collect(new Evaluator.Attribute(key), this); } public Elements getElementsByAttributeStarting(String keyPrefix) { Validate.notEmpty(keyPrefix); keyPrefix = keyPrefix.trim(); return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);"
      },
      {
        "txt": "} public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); } public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); } public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); }"
      },
      {
        "txt": "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); } public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) { return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this); } public Elements getElementsByAttributeValueMatching(String key, String regex) {"
      },
      {
        "txt": "Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsByAttributeValueMatching(key, pattern); } public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this);"
      },
      {
        "txt": "} public Elements getElementsByIndexGreaterThan(int index) { return Collector.collect(new Evaluator.IndexGreaterThan(index), this); } public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); } public Elements getElementsContainingText(String searchText) { return Collector.collect(new Evaluator.ContainsText(searchText), this); }"
      },
      {
        "txt": "public Elements getElementsContainingOwnText(String searchText) { return Collector.collect(new Evaluator.ContainsOwnText(searchText), this); } public Elements getElementsMatchingText(Pattern pattern) { return Collector.collect(new Evaluator.Matches(pattern), this); } public Elements getElementsMatchingText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex);"
      },
      {
        "txt": "} catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsMatchingText(pattern); } public Elements getElementsMatchingOwnText(Pattern pattern) { return Collector.collect(new Evaluator.MatchesOwn(pattern), this); } public Elements getElementsMatchingOwnText(String regex) { Pattern pattern;"
      },
      {
        "txt": "try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsMatchingOwnText(pattern); } public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); }"
      },
      {
        "txt": "public String text() { final StringBuilder accum = new StringBuilder(); NodeTraversor.traverse(new NodeVisitor() { public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; appendNormalisedText(accum, textNode); } else if (node instanceof Element) { Element element = (Element) node; if (accum.length() > 0 &&"
      },
      {
        "txt": "(element.isBlock() || element.tag.getName().equals(\"br\")) && !TextNode.lastCharIsWhitespace(accum)) accum.append(' '); } } public void tail(Node node, int depth) { } }, this); return accum.toString().trim(); }"
      },
      {
        "txt": "public String ownText() { StringBuilder sb = new StringBuilder(); ownText(sb); return sb.toString().trim(); } private void ownText(StringBuilder accum) { for (Node child : childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; appendNormalisedText(accum, textNode);"
      },
      {
        "txt": "} else if (child instanceof Element) { appendWhitespaceIfBr((Element) child, accum); } } } private static void appendNormalisedText(StringBuilder accum, TextNode textNode) { String text = textNode.getWholeText(); if (preserveWhitespace(textNode.parentNode)) accum.append(text); else"
      },
      {
        "txt": "StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum)); } private static void appendWhitespaceIfBr(Element element, StringBuilder accum) { if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum)) accum.append(\" \"); } static boolean preserveWhitespace(Node node) { if (node != null && node instanceof Element) { Element element = (Element) node; return element.tag.preserveWhitespace() ||"
      },
      {
        "txt": "element.parent() != null && element.parent().tag.preserveWhitespace(); } return false; } public Element text(String text) { Validate.notNull(text); empty(); TextNode textNode = new TextNode(text); appendChild(textNode); return this;"
      },
      {
        "txt": "} Test if this element has any text content (that is not just whitespace). @return true if element has non-blank text content. public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; if (!textNode.isBlank()) return true; } else if (child instanceof Element) {"
      },
      {
        "txt": "Element el = (Element) child; if (el.hasText()) return true; } } return false; } public String data() { StringBuilder sb = new StringBuilder(); for (Node childNode : childNodes) {"
      },
      {
        "txt": "if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Comment) { Comment comment = (Comment) childNode; sb.append(comment.getData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData);"
      },
      {
        "txt": "} } return sb.toString(); } public String className() { return attr(\"class\").trim(); } public Set<String> classNames() { String[] names = classSplit.split(className()); Set<String> classNames = new LinkedHashSet<>(Arrays.asList(names));"
      },
      {
        "txt": "classNames.remove(\"\"); // if classNames() was empty, would include an empty class return classNames; } Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) { Validate.notNull(classNames); attributes().put(\"class\", StringUtil.join(classNames, \" \")); return this;"
      },
      {
        "txt": "} public boolean hasClass(String className) { final String classAttr = attributes().getIgnoreCase(\"class\"); final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr);"
      },
      {
        "txt": "} boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false;"
      },
      {
        "txt": "} } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen);"
      },
      {
        "txt": "} return false; } Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.add(className);"
      },
      {
        "txt": "classNames(classes); return this; } Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.remove(className);"
      },
      {
        "txt": "classNames(classes); return this; } Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); if (classes.contains(className))"
      },
      {
        "txt": "classes.remove(className); else classes.add(className); classNames(classes); return this; } public String val() { if (tagName().equals(\"textarea\")) return text(); else"
      },
      {
        "txt": "return attr(\"value\"); } public Element val(String value) { if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value); return this; } void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {"
      },
      {
        "txt": "if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) { if (accum instanceof StringBuilder) { if (((StringBuilder) accum).length() > 0) indent(accum, depth, out); } else { indent(accum, depth, out); } } accum.append('<').append(tagName()); if (attributes != null) attributes.html(accum, out);"
      },
      {
        "txt": "if (childNodes.isEmpty() && tag.isSelfClosing()) { if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty()) accum.append('>'); else accum.append(\" />\"); // <img> in html, <img /> in xml } else accum.append('>'); } void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {"
      },
      {
        "txt": "if (!(childNodes.isEmpty() && tag.isSelfClosing())) { if (out.prettyPrint() && (!childNodes.isEmpty() && ( tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode)))) ))) indent(accum, depth, out); accum.append(\"</\").append(tagName()).append('>'); } } public String html() { StringBuilder accum = StringUtil.stringBuilder();"
      },
      {
        "txt": "html(accum); return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString(); } private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); } @Override public <T extends Appendable> T html(T appendable) { for (Node node : childNodes)"
      },
      {
        "txt": "node.outerHtml(appendable); return appendable; } public Element html(String html) { empty(); append(html); return this; } public String toString() { return outerHtml();"
      },
      {
        "txt": "} @Override public Element clone() { return (Element) super.clone(); } @Override protected Element doClone(Node parent) { Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri;"
      },
      {
        "txt": "clone.childNodes.addAll(childNodes); return clone; } private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { super(initialCapacity); <extra_id_0> public void onContentsChanged() { nodelistChanged(); } } }"
      }
    ]
  },
  {
    "id": 2031,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 1414,
    "end-bug-line": 1414,
    "bug": "nodelistChanged();",
    "fix": "owner.nodelistChanged();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.jsoup.helper.ChangeNotifyingArrayList; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate; import org.jsoup.parser.ParseSettings;"
      },
      {
        "txt": "import org.jsoup.parser.Parser; import org.jsoup.parser.Tag; import org.jsoup.select.Collector; import org.jsoup.select.Elements; import org.jsoup.select.Evaluator; import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import org.jsoup.select.QueryParser; import org.jsoup.select.Selector; import java.io.IOException;"
      },
      {
        "txt": "import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.regex.Pattern;"
      },
      {
        "txt": "import java.util.regex.PatternSyntaxException; import static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children List<Node> childNodes; private Attributes attributes; private String baseUri;"
      },
      {
        "txt": "public Element(String tag) { this(Tag.valueOf(tag), \"\", new Attributes()); } public Element(Tag tag, String baseUri, Attributes attributes) { Validate.notNull(tag); Validate.notNull(baseUri); childNodes = EMPTY_NODES; this.baseUri = baseUri; this.attributes = attributes; this.tag = tag;"
      },
      {
        "txt": "} public Element(Tag tag, String baseUri) { this(tag, baseUri, null); } protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { childNodes = new NodeList(4); } return childNodes; }"
      },
      {
        "txt": "@Override protected boolean hasAttributes() { return attributes != null; } @Override public Attributes attributes() { if (!hasAttributes()) attributes = new Attributes(); return attributes; }"
      },
      {
        "txt": "@Override public String baseUri() { return baseUri; } @Override protected void doSetBaseUri(String baseUri) { this.baseUri = baseUri; } @Override public int childNodeSize() {"
      },
      {
        "txt": "return childNodes.size(); } @Override public String nodeName() { return tag.getName(); } public String tagName() { return tag.getName(); } public Element tagName(String tagName) {"
      },
      {
        "txt": "Validate.notEmpty(tagName, \"Tag name must not be empty.\"); tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case return this; } public Tag tag() { return tag; } public boolean isBlock() { return tag.isBlock(); }"
      },
      {
        "txt": "public String id() { return attributes().getIgnoreCase(\"id\"); } public Element attr(String attributeKey, String attributeValue) { super.attr(attributeKey, attributeValue); return this; } public Element attr(String attributeKey, boolean attributeValue) { attributes().put(attributeKey, attributeValue); return this;"
      },
      {
        "txt": "} public Map<String, String> dataset() { return attributes().dataset(); } @Override public final Element parent() { return (Element) parentNode; } public Elements parents() { Elements parents = new Elements();"
      },
      {
        "txt": "accumulateParents(this, parents); return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent(); if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents); } }"
      },
      {
        "txt": "public Element child(int index) { return childElementsList().get(index); } public Elements children() { return new Elements(childElementsList()); } private List<Element> childElementsList() { List<Element> children; if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) { final int size = childNodes.size();"
      },
      {
        "txt": "children = new ArrayList<>(size); for (int i = 0; i < size; i++) { final Node node = childNodes.get(i); if (node instanceof Element) children.add((Element) node); } shadowChildrenRef = new WeakReference<>(children); } return children; }"
      },
      {
        "txt": "@Override void nodelistChanged() { super.nodelistChanged(); shadowChildrenRef = null; } public List<TextNode> textNodes() { List<TextNode> textNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof TextNode) textNodes.add((TextNode) node);"
      },
      {
        "txt": "} return Collections.unmodifiableList(textNodes); } public List<DataNode> dataNodes() { List<DataNode> dataNodes = new ArrayList<>(); for (Node node : childNodes) { if (node instanceof DataNode) dataNodes.add((DataNode) node); } return Collections.unmodifiableList(dataNodes);"
      },
      {
        "txt": "} public Elements select(String cssQuery) { return Selector.select(cssQuery, this); } public Element selectFirst(String cssQuery) { return Selector.selectFirst(cssQuery, this); } public boolean is(String cssQuery) { return is(QueryParser.parse(cssQuery)); }"
      },
      {
        "txt": "public boolean is(Evaluator evaluator) { return evaluator.matches((Element)this.root(), this); } public Element appendChild(Node child) { Validate.notNull(child); reparentChild(child); ensureChildNodes(); childNodes.add(child); child.setSiblingIndex(childNodes.size() - 1); return this;"
      },
      {
        "txt": "} public Element appendTo(Element parent) { Validate.notNull(parent); parent.appendChild(this); return this; } public Element prependChild(Node child) { Validate.notNull(child); addChildren(0, child); return this;"
      },
      {
        "txt": "} public Element insertChildren(int index, Collection<? extends Node> children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); ArrayList<Node> nodes = new ArrayList<>(children); Node[] nodeArray = nodes.toArray(new Node[nodes.size()]); addChildren(index, nodeArray); return this;"
      },
      {
        "txt": "} public Element insertChildren(int index, Node... children) { Validate.notNull(children, \"Children collection to be inserted must not be null.\"); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; // roll around Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\"); addChildren(index, children); return this; } public Element appendElement(String tagName) {"
      },
      {
        "txt": "Element child = new Element(Tag.valueOf(tagName), baseUri()); appendChild(child); return child; } public Element prependElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child; } public Element appendText(String text) {"
      },
      {
        "txt": "Validate.notNull(text); TextNode node = new TextNode(text); appendChild(node); return this; } public Element prependText(String text) { Validate.notNull(text); TextNode node = new TextNode(text); prependChild(node); return this;"
      },
      {
        "txt": "} public Element append(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri()); addChildren(nodes.toArray(new Node[nodes.size()])); return this; } public Element prepend(String html) { Validate.notNull(html); List<Node> nodes = Parser.parseFragment(html, this, baseUri());"
      },
      {
        "txt": "addChildren(0, nodes.toArray(new Node[nodes.size()])); return this; } @Override public Element before(String html) { return (Element) super.before(html); } @Override public Element before(Node node) { return (Element) super.before(node);"
      },
      {
        "txt": "} @Override public Element after(String html) { return (Element) super.after(html); } @Override public Element after(Node node) { return (Element) super.after(node); } public Element empty() {"
      },
      {
        "txt": "childNodes.clear(); return this; } @Override public Element wrap(String html) { return (Element) super.wrap(html); } public String cssSelector() { if (id().length() > 0) return \"#\" + id();"
      },
      {
        "txt": "String tagName = tagName().replace(':', '|'); StringBuilder selector = new StringBuilder(tagName); String classes = StringUtil.join(classNames(), \".\"); if (classes.length() > 0) selector.append('.').append(classes); if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node return selector.toString(); selector.insert(0, \" > \"); if (parent().select(selector.toString()).size() > 1) selector.append(String.format("
      },
      {
        "txt": "\":nth-child(%d)\", elementSiblingIndex() + 1)); return parent().cssSelector() + selector.toString(); } public Elements siblingElements() { if (parentNode == null) return new Elements(0); List<Element> elements = parent().childElementsList(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this)"
      },
      {
        "txt": "siblings.add(el); return siblings; } public Element nextElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1);"
      },
      {
        "txt": "else return null; } public Element previousElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1);"
      },
      {
        "txt": "else return null; } public Element firstElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(0) : null; } public int elementSiblingIndex() { if (parent() == null) return 0; return indexInList(this, parent().childElementsList());"
      },
      {
        "txt": "} public Element lastElementSibling() { List<Element> siblings = parent().childElementsList(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; } private static <E extends Element> int indexInList(Element search, List<E> elements) { for (int i = 0; i < elements.size(); i++) { if (elements.get(i) == search) return i; }"
      },
      {
        "txt": "return 0; } public Elements getElementsByTag(String tagName) { Validate.notEmpty(tagName); tagName = normalize(tagName); return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) { Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this);"
      },
      {
        "txt": "if (elements.size() > 0) return elements.get(0); else return null; } public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this); } public Elements getElementsByAttribute(String key) {"
      },
      {
        "txt": "Validate.notEmpty(key); key = key.trim(); return Collector.collect(new Evaluator.Attribute(key), this); } public Elements getElementsByAttributeStarting(String keyPrefix) { Validate.notEmpty(keyPrefix); keyPrefix = keyPrefix.trim(); return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this); } public Elements getElementsByAttributeValue(String key, String value) {"
      },
      {
        "txt": "return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); } public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); } public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); } public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);"
      },
      {
        "txt": "} public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) { return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this); } public Elements getElementsByAttributeValueMatching(String key, String regex) { Pattern pattern; try {"
      },
      {
        "txt": "pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsByAttributeValueMatching(key, pattern); } public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this); } public Elements getElementsByIndexGreaterThan(int index) {"
      },
      {
        "txt": "return Collector.collect(new Evaluator.IndexGreaterThan(index), this); } public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); } public Elements getElementsContainingText(String searchText) { return Collector.collect(new Evaluator.ContainsText(searchText), this); } public Elements getElementsContainingOwnText(String searchText) { return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);"
      },
      {
        "txt": "} public Elements getElementsMatchingText(Pattern pattern) { return Collector.collect(new Evaluator.Matches(pattern), this); } public Elements getElementsMatchingText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex); } catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);"
      },
      {
        "txt": "} return getElementsMatchingText(pattern); } public Elements getElementsMatchingOwnText(Pattern pattern) { return Collector.collect(new Evaluator.MatchesOwn(pattern), this); } public Elements getElementsMatchingOwnText(String regex) { Pattern pattern; try { pattern = Pattern.compile(regex);"
      },
      {
        "txt": "} catch (PatternSyntaxException e) { throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e); } return getElementsMatchingOwnText(pattern); } public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); } public String text() { final StringBuilder accum = new StringBuilder();"
      },
      {
        "txt": "NodeTraversor.traverse(new NodeVisitor() { public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; appendNormalisedText(accum, textNode); } else if (node instanceof Element) { Element element = (Element) node; if (accum.length() > 0 && (element.isBlock() || element.tag.getName().equals(\"br\")) && !TextNode.lastCharIsWhitespace(accum))"
      },
      {
        "txt": "accum.append(' '); } } public void tail(Node node, int depth) { } }, this); return accum.toString().trim(); } public String ownText() { StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "ownText(sb); return sb.toString().trim(); } private void ownText(StringBuilder accum) { for (Node child : childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; appendNormalisedText(accum, textNode); } else if (child instanceof Element) { appendWhitespaceIfBr((Element) child, accum);"
      },
      {
        "txt": "} } } private static void appendNormalisedText(StringBuilder accum, TextNode textNode) { String text = textNode.getWholeText(); if (preserveWhitespace(textNode.parentNode)) accum.append(text); else StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum)); }"
      },
      {
        "txt": "private static void appendWhitespaceIfBr(Element element, StringBuilder accum) { if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum)) accum.append(\" \"); } static boolean preserveWhitespace(Node node) { if (node != null && node instanceof Element) { Element element = (Element) node; return element.tag.preserveWhitespace() || element.parent() != null && element.parent().tag.preserveWhitespace(); }"
      },
      {
        "txt": "return false; } public Element text(String text) { Validate.notNull(text); empty(); TextNode textNode = new TextNode(text); appendChild(textNode); return this; } Test if this element has any text content (that is not just whitespace)."
      },
      {
        "txt": "@return true if element has non-blank text content. public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; if (!textNode.isBlank()) return true; } else if (child instanceof Element) { Element el = (Element) child; if (el.hasText())"
      },
      {
        "txt": "return true; } } return false; } public String data() { StringBuilder sb = new StringBuilder(); for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode;"
      },
      {
        "txt": "sb.append(data.getWholeData()); } else if (childNode instanceof Comment) { Comment comment = (Comment) childNode; sb.append(comment.getData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } }"
      },
      {
        "txt": "return sb.toString(); } public String className() { return attr(\"class\").trim(); } public Set<String> classNames() { String[] names = classSplit.split(className()); Set<String> classNames = new LinkedHashSet<>(Arrays.asList(names)); classNames.remove(\"\"); // if classNames() was empty, would include an empty class return classNames;"
      },
      {
        "txt": "} Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) { Validate.notNull(classNames); attributes().put(\"class\", StringUtil.join(classNames, \" \")); return this; } public boolean hasClass(String className) {"
      },
      {
        "txt": "final String classAttr = attributes().getIgnoreCase(\"class\"); final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false;"
      },
      {
        "txt": "int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else {"
      },
      {
        "txt": "if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false;"
      },
      {
        "txt": "} Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.add(className); classNames(classes); return this;"
      },
      {
        "txt": "} Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.remove(className); classNames(classes); return this;"
      },
      {
        "txt": "} Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); if (classes.contains(className)) classes.remove(className); else"
      },
      {
        "txt": "classes.add(className); classNames(classes); return this; } public String val() { if (tagName().equals(\"textarea\")) return text(); else return attr(\"value\"); }"
      },
      {
        "txt": "public Element val(String value) { if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value); return this; } void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException { if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) { if (accum instanceof StringBuilder) {"
      },
      {
        "txt": "if (((StringBuilder) accum).length() > 0) indent(accum, depth, out); } else { indent(accum, depth, out); } } accum.append('<').append(tagName()); if (attributes != null) attributes.html(accum, out); if (childNodes.isEmpty() && tag.isSelfClosing()) { if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())"
      },
      {
        "txt": "accum.append('>'); else accum.append(\" />\"); // <img> in html, <img /> in xml } else accum.append('>'); } void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (!(childNodes.isEmpty() && tag.isSelfClosing())) { if (out.prettyPrint() && (!childNodes.isEmpty() && ("
      },
      {
        "txt": "tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode)))) ))) indent(accum, depth, out); accum.append(\"</\").append(tagName()).append('>'); } } public String html() { StringBuilder accum = StringUtil.stringBuilder(); html(accum); return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();"
      },
      {
        "txt": "} private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); } @Override public <T extends Appendable> T html(T appendable) { for (Node node : childNodes) node.outerHtml(appendable); return appendable;"
      },
      {
        "txt": "} public Element html(String html) { empty(); append(html); return this; } public String toString() { return outerHtml(); } @Override"
      },
      {
        "txt": "public Element clone() { return (Element) super.clone(); } @Override protected Element doClone(Node parent) { Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; clone.childNodes = new NodeList(childNodes.size()); clone.childNodes.addAll(childNodes);"
      },
      {
        "txt": "} private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { super(initialCapacity); } public void onContentsChanged() { <extra_id_0> } } }"
      }
    ]
  }
]