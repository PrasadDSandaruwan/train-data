[
  {
    "id": 1988,
    "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
    "start-bug-line": 15,
    "end-bug-line": 15,
    "bug": "",
    "fix": "private static final String PUB_SYS_KEY = \"pubSysKey\"; // PUBLIC or SYSTEM",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import org.jsoup.helper.StringUtil; import org.jsoup.nodes.Document.OutputSettings.*; public class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\"; private static final String NAME = \"name\"; <extra_id_0> private static final String SYSTEM_ID = \"systemId\"; public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId);"
      },
      {
        "txt": "attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); } @Override public String nodeName() { return \"#doctype\"; } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {"
      },
      {
        "txt": "accum.append(\"<!doctype\"); } else { accum.append(\"<!DOCTYPE\"); } if (has(NAME)) accum.append(\" \").append(attr(NAME)); if (has(PUBLIC_ID)) accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"'); if (has(SYSTEM_ID)) accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');"
      },
      {
        "txt": "accum.append('>'); } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) { } private boolean has(final String attribute) { return !StringUtil.isBlank(attr(attribute)); }"
      }
    ]
  },
  {
    "id": 1989,
    "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
    "start-bug-line": 31,
    "end-bug-line": 31,
    "bug": "",
    "fix": "if (has(PUBLIC_ID)) { attr(PUB_SYS_KEY, PUBLIC_KEY); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import java.io.IOException; import org.jsoup.helper.StringUtil; import org.jsoup.nodes.Document.OutputSettings.*; public class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\";"
      },
      {
        "txt": "private static final String PUBLIC_ID = \"publicId\"; private static final String SYSTEM_ID = \"systemId\"; public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); attr(PUBLIC_ID, publicId); <extra_id_0> } @Override public String nodeName() { return \"#doctype\"; } @Override"
      },
      {
        "txt": "} @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) { accum.append(\"<!doctype\"); } else { accum.append(\"<!DOCTYPE\"); } if (has(NAME)) accum.append(\" \").append(attr(NAME));"
      },
      {
        "txt": "if (has(PUBLIC_ID)) accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"'); if (has(SYSTEM_ID)) accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"'); accum.append('>'); } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) { } private boolean has(final String attribute) {"
      },
      {
        "txt": "return !StringUtil.isBlank(attr(attribute)); }"
      }
    ]
  },
  {
    "id": 1990,
    "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
    "start-bug-line": 41,
    "end-bug-line": 41,
    "bug": "",
    "fix": "public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) { super(baseUri);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import java.io.IOException; import org.jsoup.helper.StringUtil; import org.jsoup.nodes.Document.OutputSettings.*; public class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\"; private static final String NAME = \"name\"; private static final String PUBLIC_ID = \"publicId\";"
      },
      {
        "txt": "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); } <extra_id_0> @Override public String nodeName() { return \"#doctype\"; } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {"
      },
      {
        "txt": "@Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) { accum.append(\"<!doctype\"); } else { accum.append(\"<!DOCTYPE\"); } if (has(NAME)) accum.append(\" \").append(attr(NAME)); if (has(PUBLIC_ID))"
      },
      {
        "txt": "accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"'); if (has(SYSTEM_ID)) accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"'); accum.append('>'); } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) { } private boolean has(final String attribute) { return !StringUtil.isBlank(attr(attribute));"
      }
    ]
  },
  {
    "id": 1991,
    "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
    "start-bug-line": 42,
    "end-bug-line": 42,
    "bug": "",
    "fix": "attr(NAME, name); if (pubSysKey != null) { attr(PUB_SYS_KEY, pubSysKey); } attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import java.io.IOException; import org.jsoup.helper.StringUtil; import org.jsoup.nodes.Document.OutputSettings.*; public class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\"; private static final String NAME = \"name\"; private static final String PUBLIC_ID = \"publicId\";"
      },
      {
        "txt": "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); } <extra_id_0> @Override public String nodeName() { return \"#doctype\"; } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {"
      },
      {
        "txt": "@Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) { accum.append(\"<!doctype\"); } else { accum.append(\"<!DOCTYPE\"); } if (has(NAME)) accum.append(\" \").append(attr(NAME)); if (has(PUBLIC_ID))"
      },
      {
        "txt": "accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"'); if (has(SYSTEM_ID)) accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"'); accum.append('>'); } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) { } private boolean has(final String attribute) { return !StringUtil.isBlank(attr(attribute));"
      }
    ]
  },
  {
    "id": 1992,
    "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
    "start-bug-line": 58,
    "end-bug-line": 58,
    "bug": "",
    "fix": "if (has(PUB_SYS_KEY)) accum.append(\" \").append(attr(PUB_SYS_KEY));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import java.io.IOException;"
      },
      {
        "txt": "import org.jsoup.helper.StringUtil; import org.jsoup.nodes.Document.OutputSettings.*; public class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\"; private static final String NAME = \"name\"; private static final String PUBLIC_ID = \"publicId\"; private static final String SYSTEM_ID = \"systemId\"; public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri);"
      },
      {
        "txt": "attr(NAME, name); attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); } @Override public String nodeName() { return \"#doctype\"; } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {"
      },
      {
        "txt": "accum.append(\"<!doctype\"); } else { accum.append(\"<!DOCTYPE\"); } if (has(NAME)) accum.append(\" \").append(attr(NAME)); <extra_id_0> accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"'); if (has(SYSTEM_ID)) accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"'); accum.append('>'); } @Override"
      },
      {
        "txt": "} @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) { } private boolean has(final String attribute) { return !StringUtil.isBlank(attr(attribute)); }"
      }
    ]
  },
  {
    "id": 1993,
    "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
    "start-bug-line": 59,
    "end-bug-line": 59,
    "bug": "accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');",
    "fix": "accum.append(\" \\\"\").append(attr(PUBLIC_ID)).append('\"');",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import java.io.IOException; import org.jsoup.helper.StringUtil;"
      },
      {
        "txt": "import org.jsoup.nodes.Document.OutputSettings.*; public class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\"; private static final String NAME = \"name\"; private static final String PUBLIC_ID = \"publicId\"; private static final String SYSTEM_ID = \"systemId\"; public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name);"
      },
      {
        "txt": "attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); } @Override public String nodeName() { return \"#doctype\"; } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {"
      },
      {
        "txt": "} else { accum.append(\"<!DOCTYPE\"); } if (has(NAME)) accum.append(\" \").append(attr(NAME)); if (has(PUBLIC_ID)) <extra_id_0> if (has(SYSTEM_ID)) accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"'); accum.append('>'); } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {"
      },
      {
        "txt": "@Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) { } private boolean has(final String attribute) { return !StringUtil.isBlank(attr(attribute)); }"
      }
    ]
  },
  {
    "id": 1994,
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
    "start-bug-line": 23,
    "end-bug-line": 23,
    "bug": "tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());",
    "fix": "tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.jsoup.helper.StringUtil; import org.jsoup.nodes.*; import java.util.ArrayList; enum HtmlTreeBuilderState { Initial { boolean process(Token t, HtmlTreeBuilder tb) {"
      },
      {
        "txt": "return true; // ignore whitespace } else if (t.isComment()) { tb.insert(t.asComment()); } else if (t.isDoctype()) { Token.Doctype d = t.asDoctype(); DocumentType doctype = new DocumentType( <extra_id_0> tb.getDocument().appendChild(doctype); if (d.isForceQuirks()) tb.getDocument().quirksMode(Document.QuirksMode.quirks); tb.transition(BeforeHtml); } else { tb.transition(BeforeHtml);"
      },
      {
        "txt": "} else { tb.transition(BeforeHtml); return tb.process(t); // re-process token } return true; } }, BeforeHtml { boolean process(Token t, HtmlTreeBuilder tb) { if (t.isDoctype()) {"
      },
      {
        "txt": "tb.error(this); return false; } else if (t.isComment()) { tb.insert(t.asComment()); } else if (isWhitespace(t)) { return true; // ignore whitespace } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) { tb.insert(t.asStartTag()); tb.transition(BeforeHead); } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {"
      },
      {
        "txt": "return anythingElse(t, tb); } else if (t.isEndTag()) { tb.error(this); return false; } else { return anythingElse(t, tb); } return true; } private boolean anythingElse(Token t, HtmlTreeBuilder tb) {"
      },
      {
        "txt": "tb.insertStartTag(\"html\"); tb.transition(BeforeHead); return tb.process(t); } }, BeforeHead { boolean process(Token t, HtmlTreeBuilder tb) { if (isWhitespace(t)) { return true; } else if (t.isComment()) {"
      },
      {
        "txt": "tb.insert(t.asComment()); } else if (t.isDoctype()) { tb.error(this); return false; } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) { return InBody.process(t, tb); // does not transition } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) { Element head = tb.insert(t.asStartTag()); tb.setHeadElement(head); tb.transition(InHead);"
      },
      {
        "txt": "} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) { tb.processStartTag(\"head\"); return tb.process(t); } else if (t.isEndTag()) { tb.error(this); return false; } else { tb.processStartTag(\"head\"); return tb.process(t); }"
      },
      {
        "txt": "return true; } }, InHead { boolean process(Token t, HtmlTreeBuilder tb) { if (isWhitespace(t)) { tb.insert(t.asCharacter()); return true; } switch (t.type) {"
      },
      {
        "txt": "case Comment: tb.insert(t.asComment()); break; case Doctype: tb.error(this); return false; case StartTag: Token.StartTag start = t.asStartTag(); String name = start.normalName(); if (name.equals(\"html\")) {"
      },
      {
        "txt": "return InBody.process(t, tb); } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) { Element el = tb.insertEmpty(start); if (name.equals(\"base\") && el.hasAttr(\"href\")) tb.maybeSetBaseUri(el); } else if (name.equals(\"meta\")) { Element meta = tb.insertEmpty(start); } else if (name.equals(\"title\")) { handleRcData(start, tb); } else if (StringUtil.in(name, \"noframes\", \"style\")) {"
      },
      {
        "txt": "handleRawtext(start, tb); } else if (name.equals(\"noscript\")) { tb.insert(start); tb.transition(InHeadNoscript); } else if (name.equals(\"script\")) { tb.tokeniser.transition(TokeniserState.ScriptData); tb.markInsertionMode(); tb.transition(Text); tb.insert(start); } else if (name.equals(\"head\")) {"
      },
      {
        "txt": "tb.error(this); return false; } else { return anythingElse(t, tb); } break; case EndTag: Token.EndTag end = t.asEndTag(); name = end.normalName(); if (name.equals(\"head\")) {"
      },
      {
        "txt": "tb.pop(); tb.transition(AfterHead); } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) { return anythingElse(t, tb); } else { tb.error(this); return false; } break; default:"
      },
      {
        "txt": "return anythingElse(t, tb); } return true; } private boolean anythingElse(Token t, TreeBuilder tb) { tb.processEndTag(\"head\"); return tb.process(t); } }, InHeadNoscript {"
      },
      {
        "txt": "boolean process(Token t, HtmlTreeBuilder tb) { if (t.isDoctype()) { tb.error(this); } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) { return tb.process(t, InBody); } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) { tb.pop(); tb.transition(InHead); } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {"
      },
      {
        "txt": "return tb.process(t, InHead); } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) { return anythingElse(t, tb); } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) { tb.error(this); return false; } else { return anythingElse(t, tb); } return true;"
      },
      {
        "txt": "} private boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.error(this); tb.insert(new Token.Character().data(t.toString())); return true; } }, AfterHead { boolean process(Token t, HtmlTreeBuilder tb) { if (isWhitespace(t)) {"
      },
      {
        "txt": "tb.insert(t.asCharacter()); } else if (t.isComment()) { tb.insert(t.asComment()); } else if (t.isDoctype()) { tb.error(this); } else if (t.isStartTag()) { Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals(\"html\")) { return tb.process(t, InBody);"
      },
      {
        "txt": "} else if (name.equals(\"body\")) { tb.insert(startTag); tb.framesetOk(false); tb.transition(InBody); } else if (name.equals(\"frameset\")) { tb.insert(startTag); tb.transition(InFrameset); } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) { tb.error(this); Element head = tb.getHeadElement();"
      },
      {
        "txt": "tb.push(head); tb.process(t, InHead); tb.removeFromStack(head); } else if (name.equals(\"head\")) { tb.error(this); return false; } else { anythingElse(t, tb); } } else if (t.isEndTag()) {"
      },
      {
        "txt": "if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) { anythingElse(t, tb); } else { tb.error(this); return false; } } else { anythingElse(t, tb); } return true;"
      },
      {
        "txt": "} private boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.processStartTag(\"body\"); tb.framesetOk(true); return tb.process(t); } }, InBody { boolean process(Token t, HtmlTreeBuilder tb) { switch (t.type) {"
      },
      {
        "txt": "case Character: { Token.Character c = t.asCharacter(); if (c.getData().equals(nullString)) { tb.error(this); return false; } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed tb.reconstructFormattingElements(); tb.insert(c); } else { tb.reconstructFormattingElements();"
      },
      {
        "txt": "tb.insert(c); tb.framesetOk(false); } break; } case Comment: { tb.insert(t.asComment()); break; } case Doctype: {"
      },
      {
        "txt": "tb.error(this); return false; } case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals(\"a\")) { if (tb.getActiveFormattingElement(\"a\") != null) { tb.error(this); tb.processEndTag(\"a\");"
      },
      {
        "txt": "Element remainingA = tb.getFromStack(\"a\"); if (remainingA != null) { tb.removeFromActiveFormattingElements(remainingA); tb.removeFromStack(remainingA); } } tb.reconstructFormattingElements(); Element a = tb.insert(startTag); tb.pushActiveFormattingElements(a); } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {"
      },
      {
        "txt": "tb.reconstructFormattingElements(); tb.insertEmpty(startTag); tb.framesetOk(false); } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) { if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insert(startTag); } else if (name.equals(\"span\")) { tb.reconstructFormattingElements();"
      },
      {
        "txt": "tb.insert(startTag); } else if (name.equals(\"li\")) { tb.framesetOk(false); ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (el.nodeName().equals(\"li\")) { tb.processEndTag(\"li\"); break; }"
      },
      {
        "txt": "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insert(startTag); } else if (name.equals(\"html\")) { tb.error(this); Element html = tb.getStack().get(0);"
      },
      {
        "txt": "for (Attribute attribute : startTag.getAttributes()) { if (!html.hasAttr(attribute.getKey())) html.attributes().put(attribute); } } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) { return tb.process(t, InHead); } else if (name.equals(\"body\")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {"
      },
      {
        "txt": "return false; // ignore } else { tb.framesetOk(false); Element body = stack.get(1); for (Attribute attribute : startTag.getAttributes()) { if (!body.hasAttr(attribute.getKey())) body.attributes().put(attribute); } } } else if (name.equals(\"frameset\")) {"
      },
      {
        "txt": "tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) { return false; // ignore } else if (!tb.framesetOk()) { return false; // ignore frameset } else { Element second = stack.get(1); if (second.parent() != null) second.remove();"
      },
      {
        "txt": "while (stack.size() > 1) stack.remove(stack.size()-1); tb.insert(startTag); tb.transition(InFrameset); } } else if (StringUtil.inSorted(name, Constants.Headings)) { if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {"
      },
      {
        "txt": "tb.error(this); tb.pop(); } tb.insert(startTag); } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) { if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insert(startTag); tb.framesetOk(false);"
      },
      {
        "txt": "} else if (name.equals(\"form\")) { if (tb.getFormElement() != null) { tb.error(this); return false; } if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insertForm(startTag, true); } else if (StringUtil.inSorted(name, Constants.DdDt)) {"
      },
      {
        "txt": "tb.framesetOk(false); ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) { tb.processEndTag(el.nodeName()); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) break;"
      },
      {
        "txt": "} if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insert(startTag); } else if (name.equals(\"plaintext\")) { if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insert(startTag);"
      },
      {
        "txt": "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out } else if (name.equals(\"button\")) { if (tb.inButtonScope(\"button\")) { tb.error(this); tb.processEndTag(\"button\"); tb.process(startTag); } else { tb.reconstructFormattingElements(); tb.insert(startTag); tb.framesetOk(false);"
      },
      {
        "txt": "} } else if (StringUtil.inSorted(name, Constants.Formatters)) { tb.reconstructFormattingElements(); Element el = tb.insert(startTag); tb.pushActiveFormattingElements(el); } else if (name.equals(\"nobr\")) { tb.reconstructFormattingElements(); if (tb.inScope(\"nobr\")) { tb.error(this); tb.processEndTag(\"nobr\");"
      },
      {
        "txt": "tb.reconstructFormattingElements(); } Element el = tb.insert(startTag); tb.pushActiveFormattingElements(el); } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) { tb.reconstructFormattingElements(); tb.insert(startTag); tb.insertMarkerToFormattingElements(); tb.framesetOk(false); } else if (name.equals(\"table\")) {"
      },
      {
        "txt": "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insert(startTag); tb.framesetOk(false); tb.transition(InTable); } else if (name.equals(\"input\")) { tb.reconstructFormattingElements(); Element el = tb.insertEmpty(startTag); if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))"
      },
      {
        "txt": "tb.framesetOk(false); } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) { tb.insertEmpty(startTag); } else if (name.equals(\"hr\")) { if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals(\"image\")) {"
      },
      {
        "txt": "if (tb.getFromStack(\"svg\") == null) return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg else tb.insert(startTag); } else if (name.equals(\"isindex\")) { tb.error(this); if (tb.getFormElement() != null) return false; tb.tokeniser.acknowledgeSelfClosingFlag(); tb.processStartTag(\"form\");"
      },
      {
        "txt": "if (startTag.attributes.hasKey(\"action\")) { Element form = tb.getFormElement(); form.attr(\"action\", startTag.attributes.get(\"action\")); } tb.processStartTag(\"hr\"); tb.processStartTag(\"label\"); String prompt = startTag.attributes.hasKey(\"prompt\") ? startTag.attributes.get(\"prompt\") : \"This is a searchable index. Enter search keywords: \"; tb.process(new Token.Character().data(prompt));"
      },
      {
        "txt": "Attributes inputAttribs = new Attributes(); for (Attribute attr : startTag.attributes) { if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs)) inputAttribs.put(attr); } inputAttribs.put(\"name\", \"isindex\"); tb.processStartTag(\"input\", inputAttribs); tb.processEndTag(\"label\"); tb.processStartTag(\"hr\"); tb.processEndTag(\"form\");"
      },
      {
        "txt": "} else if (name.equals(\"textarea\")) { tb.insert(startTag); tb.tokeniser.transition(TokeniserState.Rcdata); tb.markInsertionMode(); tb.framesetOk(false); tb.transition(Text); } else if (name.equals(\"xmp\")) { if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); }"
      },
      {
        "txt": "tb.reconstructFormattingElements(); tb.framesetOk(false); handleRawtext(startTag, tb); } else if (name.equals(\"iframe\")) { tb.framesetOk(false); handleRawtext(startTag, tb); } else if (name.equals(\"noembed\")) { handleRawtext(startTag, tb); } else if (name.equals(\"select\")) { tb.reconstructFormattingElements();"
      },
      {
        "txt": "tb.insert(startTag); tb.framesetOk(false); HtmlTreeBuilderState state = tb.state(); if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell)) tb.transition(InSelectInTable); else tb.transition(InSelect); } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) { if (tb.currentElement().nodeName().equals(\"option\")) tb.processEndTag(\"option\");"
      },
      {
        "txt": "tb.reconstructFormattingElements(); tb.insert(startTag); } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) { if (tb.inScope(\"ruby\")) { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(\"ruby\")) { tb.error(this); tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name } tb.insert(startTag);"
      },
      {
        "txt": "} } else if (name.equals(\"math\")) { tb.reconstructFormattingElements(); tb.insert(startTag); tb.tokeniser.acknowledgeSelfClosingFlag(); } else if (name.equals(\"svg\")) { tb.reconstructFormattingElements(); tb.insert(startTag); tb.tokeniser.acknowledgeSelfClosingFlag(); } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {"
      },
      {
        "txt": "tb.error(this); return false; } else { tb.reconstructFormattingElements(); tb.insert(startTag); } break; case EndTag: Token.EndTag endTag = t.asEndTag(); name = endTag.normalName();"
      },
      {
        "txt": "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) { for (int i = 0; i < 8; i++) { Element formatEl = tb.getActiveFormattingElement(name); if (formatEl == null) return anyOtherEndTag(t, tb); else if (!tb.onStack(formatEl)) { tb.error(this); tb.removeFromActiveFormattingElements(formatEl); return true; } else if (!tb.inScope(formatEl.nodeName())) {"
      },
      {
        "txt": "tb.error(this); return false; } else if (tb.currentElement() != formatEl) tb.error(this); Element furthestBlock = null; Element commonAncestor = null; boolean seenFormattingElement = false; ArrayList<Element> stack = tb.getStack(); final int stackSize = stack.size(); for (int si = 0; si < stackSize && si < 64; si++) {"
      },
      {
        "txt": "Element el = stack.get(si); if (el == formatEl) { commonAncestor = stack.get(si - 1); seenFormattingElement = true; } else if (seenFormattingElement && tb.isSpecial(el)) { furthestBlock = el; break; } } if (furthestBlock == null) {"
      },
      {
        "txt": "tb.popStackToClose(formatEl.nodeName()); tb.removeFromActiveFormattingElements(formatEl); return true; } Element node = furthestBlock; Element lastNode = furthestBlock; for (int j = 0; j < 3; j++) { if (tb.onStack(node)) node = tb.aboveOnStack(node); if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check"
      },
      {
        "txt": "tb.removeFromStack(node); continue; } else if (node == formatEl) break; Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri()); tb.replaceActiveFormattingElement(node, replacement); tb.replaceOnStack(node, replacement); node = replacement; if (lastNode == furthestBlock) { }"
      },
      {
        "txt": "if (lastNode.parent() != null) lastNode.remove(); node.appendChild(lastNode); lastNode = node; } if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) { if (lastNode.parent() != null) lastNode.remove(); tb.insertInFosterParent(lastNode); } else {"
      },
      {
        "txt": "if (lastNode.parent() != null) lastNode.remove(); commonAncestor.appendChild(lastNode); } Element adopter = new Element(formatEl.tag(), tb.getBaseUri()); adopter.attributes().addAll(formatEl.attributes()); Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]); for (Node childNode : childNodes) { adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod. }"
      },
      {
        "txt": "furthestBlock.appendChild(adopter); tb.removeFromActiveFormattingElements(formatEl); tb.removeFromStack(formatEl); tb.insertOnStackAfter(furthestBlock, adopter); } } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) { if (!tb.inScope(name)) { tb.error(this); return false; } else {"
      },
      {
        "txt": "tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); } } else if (name.equals(\"span\")) { return anyOtherEndTag(t, tb); } else if (name.equals(\"li\")) { if (!tb.inListItemScope(name)) { tb.error(this);"
      },
      {
        "txt": "return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); } } else if (name.equals(\"body\")) { if (!tb.inScope(\"body\")) { tb.error(this);"
      },
      {
        "txt": "return false; } else { tb.transition(AfterBody); } } else if (name.equals(\"html\")) { boolean notIgnored = tb.processEndTag(\"body\"); if (notIgnored) return tb.process(endTag); } else if (name.equals(\"form\")) { Element currentForm = tb.getFormElement();"
      },
      {
        "txt": "tb.setFormElement(null); if (currentForm == null || !tb.inScope(name)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.removeFromStack(currentForm); }"
      },
      {
        "txt": "} else if (name.equals(\"p\")) { if (!tb.inButtonScope(name)) { tb.error(this); tb.processStartTag(name); // if no p to close, creates an empty <p></p> return tb.process(endTag); } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name);"
      },
      {
        "txt": "} } else if (StringUtil.inSorted(name, Constants.DdDt)) { if (!tb.inScope(name)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name);"
      },
      {
        "txt": "} } else if (StringUtil.inSorted(name, Constants.Headings)) { if (!tb.inScope(Constants.Headings)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(Constants.Headings);"
      },
      {
        "txt": "} } else if (name.equals(\"sarcasm\")) { return anyOtherEndTag(t, tb); } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) { if (!tb.inScope(\"name\")) { if (!tb.inScope(name)) { tb.error(this); return false; } tb.generateImpliedEndTags();"
      },
      {
        "txt": "if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker(); } } else if (name.equals(\"br\")) { tb.error(this); tb.processStartTag(\"br\"); return false; } else {"
      },
      {
        "txt": "return anyOtherEndTag(t, tb); } break; case EOF: break; } return true; } boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = t.asEndTag().normalName();"
      },
      {
        "txt": "ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (node.nodeName().equals(name)) { tb.generateImpliedEndTags(name); if (!name.equals(tb.currentElement().nodeName())) tb.error(this); tb.popStackToClose(name); break; } else {"
      },
      {
        "txt": "if (tb.isSpecial(node)) { tb.error(this); return false; } } } return true; } }, Text {"
      },
      {
        "txt": "boolean process(Token t, HtmlTreeBuilder tb) { if (t.isCharacter()) { tb.insert(t.asCharacter()); } else if (t.isEOF()) { tb.error(this); tb.pop(); tb.transition(tb.originalState()); return tb.process(t); } else if (t.isEndTag()) { tb.pop();"
      },
      {
        "txt": "tb.transition(tb.originalState()); } return true; } }, InTable { boolean process(Token t, HtmlTreeBuilder tb) { if (t.isCharacter()) { tb.newPendingTableCharacters(); tb.markInsertionMode();"
      },
      {
        "txt": "tb.transition(InTableText); return tb.process(t); } else if (t.isComment()) { tb.insert(t.asComment()); return true; } else if (t.isDoctype()) { tb.error(this); return false; } else if (t.isStartTag()) { Token.StartTag startTag = t.asStartTag();"
      },
      {
        "txt": "String name = startTag.normalName(); if (name.equals(\"caption\")) { tb.clearStackToTableContext(); tb.insertMarkerToFormattingElements(); tb.insert(startTag); tb.transition(InCaption); } else if (name.equals(\"colgroup\")) { tb.clearStackToTableContext(); tb.insert(startTag); tb.transition(InColumnGroup);"
      },
      {
        "txt": "} else if (name.equals(\"col\")) { tb.processStartTag(\"colgroup\"); return tb.process(t); } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) { tb.clearStackToTableContext(); tb.insert(startTag); tb.transition(InTableBody); } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) { tb.processStartTag(\"tbody\"); return tb.process(t);"
      },
      {
        "txt": "} else if (name.equals(\"table\")) { tb.error(this); boolean processed = tb.processEndTag(\"table\"); if (processed) // only ignored if in fragment return tb.process(t); } else if (StringUtil.in(name, \"style\", \"script\")) { return tb.process(t, InHead); } else if (name.equals(\"input\")) { if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) { return anythingElse(t, tb);"
      },
      {
        "txt": "} else { tb.insertEmpty(startTag); } } else if (name.equals(\"form\")) { tb.error(this); if (tb.getFormElement() != null) return false; else { tb.insertForm(startTag, false); }"
      },
      {
        "txt": "} else { return anythingElse(t, tb); } return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable } else if (t.isEndTag()) { Token.EndTag endTag = t.asEndTag(); String name = endTag.normalName(); if (name.equals(\"table\")) { if (!tb.inTableScope(name)) { tb.error(this);"
      },
      {
        "txt": "return false; } else { tb.popStackToClose(\"table\"); } tb.resetInsertionMode(); } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) { tb.error(this); return false; } else {"
      },
      {
        "txt": "return anythingElse(t, tb); } return true; // todo: as above todo } else if (t.isEOF()) { if (tb.currentElement().nodeName().equals(\"html\")) tb.error(this); return true; // stops parsing } return anythingElse(t, tb); }"
      },
      {
        "txt": "boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.error(this); boolean processed; if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) { tb.setFosterInserts(true); processed = tb.process(t, InBody); tb.setFosterInserts(false); } else { processed = tb.process(t, InBody); }"
      },
      {
        "txt": "return processed; } }, InTableText { boolean process(Token t, HtmlTreeBuilder tb) { switch (t.type) { case Character: Token.Character c = t.asCharacter(); if (c.getData().equals(nullString)) { tb.error(this);"
      },
      {
        "txt": "return false; } else { tb.getPendingTableCharacters().add(c.getData()); } break; default: if (tb.getPendingTableCharacters().size() > 0) { for (String character : tb.getPendingTableCharacters()) { if (!isWhitespace(character)) { tb.error(this);"
      },
      {
        "txt": "if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) { tb.setFosterInserts(true); tb.process(new Token.Character().data(character), InBody); tb.setFosterInserts(false); } else { tb.process(new Token.Character().data(character), InBody); } } else tb.insert(new Token.Character().data(character)); }"
      },
      {
        "txt": "tb.newPendingTableCharacters(); } tb.transition(tb.originalState()); return tb.process(t); } return true; } }, InCaption { boolean process(Token t, HtmlTreeBuilder tb) {"
      },
      {
        "txt": "if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) { Token.EndTag endTag = t.asEndTag(); String name = endTag.normalName(); if (!tb.inTableScope(name)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(\"caption\")) tb.error(this);"
      },
      {
        "txt": "tb.popStackToClose(\"caption\"); tb.clearFormattingElementsToLastMarker(); tb.transition(InTable); } } else if (( t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") || t.isEndTag() && t.asEndTag().normalName().equals(\"table\")) ) { tb.error(this);"
      },
      {
        "txt": "boolean processed = tb.processEndTag(\"caption\"); if (processed) return tb.process(t); } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) { tb.error(this); return false; } else { return tb.process(t, InBody); }"
      },
      {
        "txt": "return true; } }, InColumnGroup { boolean process(Token t, HtmlTreeBuilder tb) { if (isWhitespace(t)) { tb.insert(t.asCharacter()); return true; } switch (t.type) {"
      },
      {
        "txt": "case Comment: tb.insert(t.asComment()); break; case Doctype: tb.error(this); break; case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals(\"html\"))"
      },
      {
        "txt": "return tb.process(t, InBody); else if (name.equals(\"col\")) tb.insertEmpty(startTag); else return anythingElse(t, tb); break; case EndTag: Token.EndTag endTag = t.asEndTag(); name = endTag.normalName(); if (name.equals(\"colgroup\")) {"
      },
      {
        "txt": "if (tb.currentElement().nodeName().equals(\"html\")) { // frag case tb.error(this); return false; } else { tb.pop(); tb.transition(InTable); } } else return anythingElse(t, tb); break;"
      },
      {
        "txt": "case EOF: if (tb.currentElement().nodeName().equals(\"html\")) return true; // stop parsing; frag case else return anythingElse(t, tb); default: return anythingElse(t, tb); } return true; }"
      },
      {
        "txt": "private boolean anythingElse(Token t, TreeBuilder tb) { boolean processed = tb.processEndTag(\"colgroup\"); if (processed) // only ignored in frag case return tb.process(t); return true; } }, InTableBody { boolean process(Token t, HtmlTreeBuilder tb) { switch (t.type) {"
      },
      {
        "txt": "case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals(\"tr\")) { tb.clearStackToTableBodyContext(); tb.insert(startTag); tb.transition(InRow); } else if (StringUtil.in(name, \"th\", \"td\")) { tb.error(this); tb.processStartTag(\"tr\");"
      },
      {
        "txt": "return tb.process(startTag); } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) { return exitTableBody(t, tb); } else return anythingElse(t, tb); break; case EndTag: Token.EndTag endTag = t.asEndTag(); name = endTag.normalName(); if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {"
      },
      {
        "txt": "if (!tb.inTableScope(name)) { tb.error(this); return false; } else { tb.clearStackToTableBodyContext(); tb.pop(); tb.transition(InTable); } } else if (name.equals(\"table\")) { return exitTableBody(t, tb);"
      },
      {
        "txt": "} else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) { tb.error(this); return false; } else return anythingElse(t, tb); break; default: return anythingElse(t, tb); } return true;"
      },
      {
        "txt": "} private boolean exitTableBody(Token t, HtmlTreeBuilder tb) { if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) { tb.error(this); return false; } tb.clearStackToTableBodyContext(); tb.processEndTag(tb.currentElement().nodeName()); // tbody, tfoot, thead return tb.process(t); }"
      },
      {
        "txt": "private boolean anythingElse(Token t, HtmlTreeBuilder tb) { return tb.process(t, InTable); } }, InRow { boolean process(Token t, HtmlTreeBuilder tb) { if (t.isStartTag()) { Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (StringUtil.in(name, \"th\", \"td\")) {"
      },
      {
        "txt": "tb.clearStackToTableRowContext(); tb.insert(startTag); tb.transition(InCell); tb.insertMarkerToFormattingElements(); } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) { return handleMissingTr(t, tb); } else { return anythingElse(t, tb); } } else if (t.isEndTag()) {"
      },
      {
        "txt": "Token.EndTag endTag = t.asEndTag(); String name = endTag.normalName(); if (name.equals(\"tr\")) { if (!tb.inTableScope(name)) { tb.error(this); // frag return false; } tb.clearStackToTableRowContext(); tb.pop(); // tr tb.transition(InTableBody);"
      },
      {
        "txt": "} else if (name.equals(\"table\")) { return handleMissingTr(t, tb); } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) { if (!tb.inTableScope(name)) { tb.error(this); return false; } tb.processEndTag(\"tr\"); return tb.process(t); } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {"
      },
      {
        "txt": "tb.error(this); return false; } else { return anythingElse(t, tb); } } else { return anythingElse(t, tb); } return true; }"
      },
      {
        "txt": "private boolean anythingElse(Token t, HtmlTreeBuilder tb) { return tb.process(t, InTable); } private boolean handleMissingTr(Token t, TreeBuilder tb) { boolean processed = tb.processEndTag(\"tr\"); if (processed) return tb.process(t); else return false; }"
      },
      {
        "txt": "}, InCell { boolean process(Token t, HtmlTreeBuilder tb) { if (t.isEndTag()) { Token.EndTag endTag = t.asEndTag(); String name = endTag.normalName(); if (StringUtil.in(name, \"td\", \"th\")) { if (!tb.inTableScope(name)) { tb.error(this); tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag"
      },
      {
        "txt": "return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker(); tb.transition(InRow); } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\")) { tb.error(this);"
      },
      {
        "txt": "return false; } else if (StringUtil.in(name, \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) { if (!tb.inTableScope(name)) { tb.error(this); return false; } closeCell(tb); return tb.process(t); } else { return anythingElse(t, tb);"
      },
      {
        "txt": "} } else if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) { if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) { tb.error(this); return false; } closeCell(tb); return tb.process(t);"
      },
      {
        "txt": "} else { return anythingElse(t, tb); } return true; } private boolean anythingElse(Token t, HtmlTreeBuilder tb) { return tb.process(t, InBody); } private void closeCell(HtmlTreeBuilder tb) { if (tb.inTableScope(\"td\"))"
      },
      {
        "txt": "tb.processEndTag(\"td\"); else tb.processEndTag(\"th\"); // only here if th or td in scope } }, InSelect { boolean process(Token t, HtmlTreeBuilder tb) { switch (t.type) { case Character: Token.Character c = t.asCharacter();"
      },
      {
        "txt": "if (c.getData().equals(nullString)) { tb.error(this); return false; } else { tb.insert(c); } break; case Comment: tb.insert(t.asComment()); break;"
      },
      {
        "txt": "case Doctype: tb.error(this); return false; case StartTag: Token.StartTag start = t.asStartTag(); String name = start.normalName(); if (name.equals(\"html\")) return tb.process(start, InBody); else if (name.equals(\"option\")) { tb.processEndTag(\"option\");"
      },
      {
        "txt": "tb.insert(start); } else if (name.equals(\"optgroup\")) { if (tb.currentElement().nodeName().equals(\"option\")) tb.processEndTag(\"option\"); else if (tb.currentElement().nodeName().equals(\"optgroup\")) tb.processEndTag(\"optgroup\"); tb.insert(start); } else if (name.equals(\"select\")) { tb.error(this); return tb.processEndTag(\"select\");"
      },
      {
        "txt": "} else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) { tb.error(this); if (!tb.inSelectScope(\"select\")) return false; // frag tb.processEndTag(\"select\"); return tb.process(start); } else if (name.equals(\"script\")) { return tb.process(t, InHead); } else { return anythingElse(t, tb);"
      },
      {
        "txt": "} break; case EndTag: Token.EndTag end = t.asEndTag(); name = end.normalName(); if (name.equals(\"optgroup\")) { if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\")) tb.processEndTag(\"option\"); if (tb.currentElement().nodeName().equals(\"optgroup\")) tb.pop();"
      },
      {
        "txt": "else tb.error(this); } else if (name.equals(\"option\")) { if (tb.currentElement().nodeName().equals(\"option\")) tb.pop(); else tb.error(this); } else if (name.equals(\"select\")) { if (!tb.inSelectScope(name)) { tb.error(this);"
      },
      {
        "txt": "return false; } else { tb.popStackToClose(name); tb.resetInsertionMode(); } } else return anythingElse(t, tb); break; case EOF: if (!tb.currentElement().nodeName().equals(\"html\"))"
      },
      {
        "txt": "tb.error(this); break; default: return anythingElse(t, tb); } return true; } private boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.error(this); return false;"
      },
      {
        "txt": "} }, InSelectInTable { boolean process(Token t, HtmlTreeBuilder tb) { if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) { tb.error(this); tb.processEndTag(\"select\"); return tb.process(t); } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) { tb.error(this);"
      },
      {
        "txt": "if (tb.inTableScope(t.asEndTag().normalName())) { tb.processEndTag(\"select\"); return (tb.process(t)); } else return false; } else { return tb.process(t, InSelect); } } },"
      },
      {
        "txt": "AfterBody { boolean process(Token t, HtmlTreeBuilder tb) { if (isWhitespace(t)) { return tb.process(t, InBody); } else if (t.isComment()) { tb.insert(t.asComment()); // into html node } else if (t.isDoctype()) { tb.error(this); return false; } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {"
      },
      {
        "txt": "return tb.process(t, InBody); } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) { if (tb.isFragmentParsing()) { tb.error(this); return false; } else { tb.transition(AfterAfterBody); } } else if (t.isEOF()) { } else {"
      },
      {
        "txt": "tb.error(this); tb.transition(InBody); return tb.process(t); } return true; } }, InFrameset { boolean process(Token t, HtmlTreeBuilder tb) { if (isWhitespace(t)) {"
      },
      {
        "txt": "tb.insert(t.asCharacter()); } else if (t.isComment()) { tb.insert(t.asComment()); } else if (t.isDoctype()) { tb.error(this); return false; } else if (t.isStartTag()) { Token.StartTag start = t.asStartTag(); String name = start.normalName(); if (name.equals(\"html\")) {"
      },
      {
        "txt": "return tb.process(start, InBody); } else if (name.equals(\"frameset\")) { tb.insert(start); } else if (name.equals(\"frame\")) { tb.insertEmpty(start); } else if (name.equals(\"noframes\")) { return tb.process(start, InHead); } else { tb.error(this); return false;"
      },
      {
        "txt": "} } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) { if (tb.currentElement().nodeName().equals(\"html\")) { // frag tb.error(this); return false; } else { tb.pop(); if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) { tb.transition(AfterFrameset); }"
      },
      {
        "txt": "} } else if (t.isEOF()) { if (!tb.currentElement().nodeName().equals(\"html\")) { tb.error(this); return true; } } else { tb.error(this); return false; }"
      },
      {
        "txt": "return true; } }, AfterFrameset { boolean process(Token t, HtmlTreeBuilder tb) { if (isWhitespace(t)) { tb.insert(t.asCharacter()); } else if (t.isComment()) { tb.insert(t.asComment()); } else if (t.isDoctype()) {"
      },
      {
        "txt": "tb.error(this); return false; } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) { return tb.process(t, InBody); } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) { tb.transition(AfterAfterFrameset); } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) { return tb.process(t, InHead); } else if (t.isEOF()) { } else {"
      },
      {
        "txt": "tb.error(this); return false; } return true; } }, AfterAfterBody { boolean process(Token t, HtmlTreeBuilder tb) { if (t.isComment()) { tb.insert(t.asComment());"
      },
      {
        "txt": "} else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) { return tb.process(t, InBody); } else if (t.isEOF()) { } else { tb.error(this); tb.transition(InBody); return tb.process(t); } return true; }"
      },
      {
        "txt": "}, AfterAfterFrameset { boolean process(Token t, HtmlTreeBuilder tb) { if (t.isComment()) { tb.insert(t.asComment()); } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) { return tb.process(t, InBody); } else if (t.isEOF()) { } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) { return tb.process(t, InHead);"
      },
      {
        "txt": "} else { tb.error(this); return false; } return true; } }, ForeignContent { boolean process(Token t, HtmlTreeBuilder tb) { return true;"
      },
      {
        "txt": "} }; private static String nullString = String.valueOf('\\u0000'); abstract boolean process(Token t, HtmlTreeBuilder tb); private static boolean isWhitespace(Token t) { if (t.isCharacter()) { String data = t.asCharacter().getData(); return isWhitespace(data); } return false;"
      },
      {
        "txt": "} private static boolean isWhitespace(String data) { for (int i = 0; i < data.length(); i++) { char c = data.charAt(i); if (!StringUtil.isWhitespace(c)) return false; } return true; } private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {"
      },
      {
        "txt": "tb.insert(startTag); tb.tokeniser.transition(TokeniserState.Rcdata); tb.markInsertionMode(); tb.transition(Text); } private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) { tb.insert(startTag); tb.tokeniser.transition(TokeniserState.Rawtext); tb.markInsertionMode(); tb.transition(Text);"
      },
      {
        "txt": "} private static final class Constants { private static final String[] InBodyStartToHead = new String[]{\"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\"}; private static final String[] InBodyStartPClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\"}; private static final String[] Headings = new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"}; private static final String[] InBodyStartPreListing = new String[]{\"pre\", \"listing\"}; private static final String[] InBodyStartLiBreakers = new String[]{\"address\", \"div\", \"p\"}; private static final String[] DdDt = new String[]{\"dd\", \"dt\"};"
      },
      {
        "txt": "private static final String[] Formatters = new String[]{\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"}; private static final String[] InBodyStartApplets = new String[]{\"applet\", \"marquee\", \"object\"}; private static final String[] InBodyStartEmptyFormatters = new String[]{\"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\"}; private static final String[] InBodyStartMedia = new String[]{\"param\", \"source\", \"track\"}; private static final String[] InBodyStartInputAttribs = new String[]{\"name\", \"action\", \"prompt\"}; private static final String[] InBodyStartOptions = new String[]{\"optgroup\", \"option\"}; private static final String[] InBodyStartRuby = new String[]{\"rp\", \"rt\"}; private static final String[] InBodyStartDrop = new String[]{\"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"}; private static final String[] InBodyEndClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\","
      },
      {
        "txt": "\"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\"}; private static final String[] InBodyEndAdoptionFormatters = new String[]{\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"}; private static final String[] InBodyEndTableFosters = new String[]{\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"}; }"
      }
    ]
  },
  {
    "id": 1995,
    "file_path": "src/main/java/org/jsoup/parser/Token.java",
    "start-bug-line": 35,
    "end-bug-line": 35,
    "bug": "",
    "fix": "String pubSysKey = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.jsoup.helper.Validate; import org.jsoup.nodes.Attribute;"
      },
      {
        "txt": "import org.jsoup.nodes.Attributes; import org.jsoup.nodes.BooleanAttribute; abstract class Token { TokenType type; private Token() { } String tokenType() { return this.getClass().getSimpleName(); } abstract Token reset();"
      },
      {
        "txt": "if (sb != null) { sb.delete(0, sb.length()); } } static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); <extra_id_0> final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false; Doctype() { type = TokenType.Doctype; } @Override"
      },
      {
        "txt": "} @Override Token reset() { reset(name); reset(publicIdentifier); reset(systemIdentifier); forceQuirks = false; return this; } String getName() {"
      },
      {
        "txt": "return name.toString(); } String getPublicIdentifier() { return publicIdentifier.toString(); } public String getSystemIdentifier() { return systemIdentifier.toString(); } public boolean isForceQuirks() { return forceQuirks;"
      },
      {
        "txt": "} } static abstract class Tag extends Token { protected String tagName; protected String normalName; // lc version of tag name, for case insensitive tree build private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value private boolean hasPendingAttributeValue = false;"
      },
      {
        "txt": "boolean selfClosing = false; Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used). @Override Tag reset() { tagName = null; normalName = null; pendingAttributeName = null; reset(pendingAttributeValue); pendingAttributeValueS = null; hasEmptyAttributeValue = false;"
      },
      {
        "txt": "hasPendingAttributeValue = false; selfClosing = false; attributes = null; return this; } final void newAttribute() { if (attributes == null) attributes = new Attributes(); if (pendingAttributeName != null) { Attribute attribute;"
      },
      {
        "txt": "if (hasPendingAttributeValue) attribute = new Attribute(pendingAttributeName, pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS); else if (hasEmptyAttributeValue) attribute = new Attribute(pendingAttributeName, \"\"); else attribute = new BooleanAttribute(pendingAttributeName); attributes.put(attribute); } pendingAttributeName = null;"
      },
      {
        "txt": "hasEmptyAttributeValue = false; hasPendingAttributeValue = false; reset(pendingAttributeValue); pendingAttributeValueS = null; } final void finaliseTag() { if (pendingAttributeName != null) { newAttribute(); } }"
      },
      {
        "txt": "final String name() { // preserves case, for input into Tag.valueOf (which may drop case) Validate.isFalse(tagName == null || tagName.length() == 0); return tagName; } final String normalName() { // loses case, used in tree building for working out where in tree it should go return normalName; } final Tag name(String name) { tagName = name; normalName = name.toLowerCase();"
      },
      {
        "txt": "return this; } final boolean isSelfClosing() { return selfClosing; } @SuppressWarnings({\"TypeMayBeWeakened\"}) final Attributes getAttributes() { return attributes; } final void appendTagName(String append) {"
      },
      {
        "txt": "tagName = tagName == null ? append : tagName.concat(append); normalName = tagName.toLowerCase(); } final void appendTagName(char append) { appendTagName(String.valueOf(append)); } final void appendAttributeName(String append) { pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append); } final void appendAttributeName(char append) {"
      },
      {
        "txt": "appendAttributeName(String.valueOf(append)); } final void appendAttributeValue(String append) { ensureAttributeValue(); if (pendingAttributeValue.length() == 0) { pendingAttributeValueS = append; } else { pendingAttributeValue.append(append); } }"
      },
      {
        "txt": "final void appendAttributeValue(char append) { ensureAttributeValue(); pendingAttributeValue.append(append); } final void appendAttributeValue(char[] append) { ensureAttributeValue(); pendingAttributeValue.append(append); } final void appendAttributeValue(int[] appendCodepoints) { ensureAttributeValue();"
      },
      {
        "txt": "for (int codepoint : appendCodepoints) { pendingAttributeValue.appendCodePoint(codepoint); } } final void setEmptyAttributeValue() { hasEmptyAttributeValue = true; } private void ensureAttributeValue() { hasPendingAttributeValue = true; if (pendingAttributeValueS != null) {"
      },
      {
        "txt": "pendingAttributeValue.append(pendingAttributeValueS); pendingAttributeValueS = null; } } } final static class StartTag extends Tag { StartTag() { super(); attributes = new Attributes(); type = TokenType.StartTag;"
      },
      {
        "txt": "} @Override Tag reset() { super.reset(); attributes = new Attributes(); return this; } StartTag nameAttr(String name, Attributes attributes) { this.tagName = name; this.attributes = attributes;"
      },
      {
        "txt": "normalName = tagName.toLowerCase(); return this; } @Override public String toString() { if (attributes != null && attributes.size() > 0) return \"<\" + name() + \" \" + attributes.toString() + \">\"; else return \"<\" + name() + \">\"; }"
      },
      {
        "txt": "} final static class EndTag extends Tag{ EndTag() { super(); type = TokenType.EndTag; } @Override public String toString() { return \"</\" + name() + \">\"; }"
      },
      {
        "txt": "} final static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; @Override Token reset() { reset(data); bogus = false; return this; }"
      },
      {
        "txt": "Comment() { type = TokenType.Comment; } String getData() { return data.toString(); } @Override public String toString() { return \"<!--\" + getData() + \"-->\"; }"
      },
      {
        "txt": "} final static class Character extends Token { private String data; Character() { super(); type = TokenType.Character; } @Override Token reset() { data = null;"
      },
      {
        "txt": "return this; } Character data(String data) { this.data = data; return this; } String getData() { return data; } @Override"
      },
      {
        "txt": "public String toString() { return getData(); } } final static class EOF extends Token { EOF() { type = Token.TokenType.EOF; } @Override Token reset() {"
      },
      {
        "txt": "return this; } } final boolean isDoctype() { return type == TokenType.Doctype; } final Doctype asDoctype() { return (Doctype) this; } final boolean isStartTag() {"
      },
      {
        "txt": "return type == TokenType.StartTag; } final StartTag asStartTag() { return (StartTag) this; } final boolean isEndTag() { return type == TokenType.EndTag; } final EndTag asEndTag() { return (EndTag) this;"
      },
      {
        "txt": "} final boolean isComment() { return type == TokenType.Comment; } final Comment asComment() { return (Comment) this; } final boolean isCharacter() { return type == TokenType.Character; }"
      },
      {
        "txt": "final Character asCharacter() { return (Character) this; } final boolean isEOF() { return type == TokenType.EOF; } enum TokenType { Doctype, StartTag, EndTag,"
      },
      {
        "txt": "Comment, Character, EOF }"
      }
    ]
  },
  {
    "id": 1996,
    "file_path": "src/main/java/org/jsoup/parser/Token.java",
    "start-bug-line": 46,
    "end-bug-line": 46,
    "bug": "",
    "fix": "pubSysKey = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.jsoup.helper.Validate;"
      },
      {
        "txt": "import org.jsoup.nodes.Attribute; import org.jsoup.nodes.Attributes; import org.jsoup.nodes.BooleanAttribute; abstract class Token { TokenType type; private Token() { } String tokenType() { return this.getClass().getSimpleName(); }"
      },
      {
        "txt": "abstract Token reset(); static void reset(StringBuilder sb) { if (sb != null) { sb.delete(0, sb.length()); } } static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder();"
      },
      {
        "txt": "Doctype() { type = TokenType.Doctype; } @Override Token reset() { reset(name); <extra_id_0> reset(systemIdentifier); forceQuirks = false; return this; } String getName() { return name.toString();"
      },
      {
        "txt": "String getName() { return name.toString(); } String getPublicIdentifier() { return publicIdentifier.toString(); } public String getSystemIdentifier() { return systemIdentifier.toString(); } public boolean isForceQuirks() {"
      },
      {
        "txt": "return forceQuirks; } } static abstract class Tag extends Token { protected String tagName; protected String normalName; // lc version of tag name, for case insensitive tree build private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value"
      },
      {
        "txt": "private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used). @Override Tag reset() { tagName = null; normalName = null; pendingAttributeName = null; reset(pendingAttributeValue); pendingAttributeValueS = null;"
      },
      {
        "txt": "hasEmptyAttributeValue = false; hasPendingAttributeValue = false; selfClosing = false; attributes = null; return this; } final void newAttribute() { if (attributes == null) attributes = new Attributes(); if (pendingAttributeName != null) {"
      },
      {
        "txt": "Attribute attribute; if (hasPendingAttributeValue) attribute = new Attribute(pendingAttributeName, pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS); else if (hasEmptyAttributeValue) attribute = new Attribute(pendingAttributeName, \"\"); else attribute = new BooleanAttribute(pendingAttributeName); attributes.put(attribute); }"
      },
      {
        "txt": "pendingAttributeName = null; hasEmptyAttributeValue = false; hasPendingAttributeValue = false; reset(pendingAttributeValue); pendingAttributeValueS = null; } final void finaliseTag() { if (pendingAttributeName != null) { newAttribute(); }"
      },
      {
        "txt": "} final String name() { // preserves case, for input into Tag.valueOf (which may drop case) Validate.isFalse(tagName == null || tagName.length() == 0); return tagName; } final String normalName() { // loses case, used in tree building for working out where in tree it should go return normalName; } final Tag name(String name) { tagName = name;"
      },
      {
        "txt": "normalName = name.toLowerCase(); return this; } final boolean isSelfClosing() { return selfClosing; } @SuppressWarnings({\"TypeMayBeWeakened\"}) final Attributes getAttributes() { return attributes; }"
      },
      {
        "txt": "final void appendTagName(String append) { tagName = tagName == null ? append : tagName.concat(append); normalName = tagName.toLowerCase(); } final void appendTagName(char append) { appendTagName(String.valueOf(append)); } final void appendAttributeName(String append) { pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append); }"
      },
      {
        "txt": "final void appendAttributeName(char append) { appendAttributeName(String.valueOf(append)); } final void appendAttributeValue(String append) { ensureAttributeValue(); if (pendingAttributeValue.length() == 0) { pendingAttributeValueS = append; } else { pendingAttributeValue.append(append); }"
      },
      {
        "txt": "} final void appendAttributeValue(char append) { ensureAttributeValue(); pendingAttributeValue.append(append); } final void appendAttributeValue(char[] append) { ensureAttributeValue(); pendingAttributeValue.append(append); } final void appendAttributeValue(int[] appendCodepoints) {"
      },
      {
        "txt": "ensureAttributeValue(); for (int codepoint : appendCodepoints) { pendingAttributeValue.appendCodePoint(codepoint); } } final void setEmptyAttributeValue() { hasEmptyAttributeValue = true; } private void ensureAttributeValue() { hasPendingAttributeValue = true;"
      },
      {
        "txt": "if (pendingAttributeValueS != null) { pendingAttributeValue.append(pendingAttributeValueS); pendingAttributeValueS = null; } } } final static class StartTag extends Tag { StartTag() { super(); attributes = new Attributes();"
      },
      {
        "txt": "type = TokenType.StartTag; } @Override Tag reset() { super.reset(); attributes = new Attributes(); return this; } StartTag nameAttr(String name, Attributes attributes) { this.tagName = name;"
      },
      {
        "txt": "this.attributes = attributes; normalName = tagName.toLowerCase(); return this; } @Override public String toString() { if (attributes != null && attributes.size() > 0) return \"<\" + name() + \" \" + attributes.toString() + \">\"; else return \"<\" + name() + \">\";"
      },
      {
        "txt": "} } final static class EndTag extends Tag{ EndTag() { super(); type = TokenType.EndTag; } @Override public String toString() { return \"</\" + name() + \">\";"
      },
      {
        "txt": "} } final static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; @Override Token reset() { reset(data); bogus = false; return this;"
      },
      {
        "txt": "} Comment() { type = TokenType.Comment; } String getData() { return data.toString(); } @Override public String toString() { return \"<!--\" + getData() + \"-->\";"
      },
      {
        "txt": "} } final static class Character extends Token { private String data; Character() { super(); type = TokenType.Character; } @Override Token reset() {"
      },
      {
        "txt": "data = null; return this; } Character data(String data) { this.data = data; return this; } String getData() { return data; }"
      },
      {
        "txt": "@Override public String toString() { return getData(); } } final static class EOF extends Token { EOF() { type = Token.TokenType.EOF; } @Override"
      },
      {
        "txt": "Token reset() { return this; } } final boolean isDoctype() { return type == TokenType.Doctype; } final Doctype asDoctype() { return (Doctype) this; }"
      },
      {
        "txt": "final boolean isStartTag() { return type == TokenType.StartTag; } final StartTag asStartTag() { return (StartTag) this; } final boolean isEndTag() { return type == TokenType.EndTag; } final EndTag asEndTag() {"
      },
      {
        "txt": "return (EndTag) this; } final boolean isComment() { return type == TokenType.Comment; } final Comment asComment() { return (Comment) this; } final boolean isCharacter() { return type == TokenType.Character;"
      },
      {
        "txt": "} final Character asCharacter() { return (Character) this; } final boolean isEOF() { return type == TokenType.EOF; } enum TokenType { Doctype, StartTag,"
      },
      {
        "txt": "EndTag, Comment, Character, EOF }"
      }
    ]
  },
  {
    "id": 1997,
    "file_path": "src/main/java/org/jsoup/parser/Token.java",
    "start-bug-line": 56,
    "end-bug-line": 56,
    "bug": "",
    "fix": "String getPubSysKey() { return pubSysKey; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.jsoup.helper.Validate; import org.jsoup.nodes.Attribute; import org.jsoup.nodes.Attributes; import org.jsoup.nodes.BooleanAttribute; abstract class Token { TokenType type; private Token() { } String tokenType() {"
      },
      {
        "txt": "return this.getClass().getSimpleName(); } abstract Token reset(); static void reset(StringBuilder sb) { if (sb != null) { sb.delete(0, sb.length()); } } static final class Doctype extends Token { final StringBuilder name = new StringBuilder();"
      },
      {
        "txt": "final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false; Doctype() { type = TokenType.Doctype; } @Override Token reset() { reset(name); reset(publicIdentifier);"
      },
      {
        "txt": "forceQuirks = false; return this; } String getName() { return name.toString(); } <extra_id_0> String getPublicIdentifier() { return publicIdentifier.toString(); } public String getSystemIdentifier() { return systemIdentifier.toString(); }"
      },
      {
        "txt": "return systemIdentifier.toString(); } public boolean isForceQuirks() { return forceQuirks; } } static abstract class Tag extends Token { protected String tagName; protected String normalName; // lc version of tag name, for case insensitive tree build private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated"
      },
      {
        "txt": "private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used). @Override Tag reset() { tagName = null; normalName = null;"
      },
      {
        "txt": "pendingAttributeName = null; reset(pendingAttributeValue); pendingAttributeValueS = null; hasEmptyAttributeValue = false; hasPendingAttributeValue = false; selfClosing = false; attributes = null; return this; } final void newAttribute() {"
      },
      {
        "txt": "if (attributes == null) attributes = new Attributes(); if (pendingAttributeName != null) { Attribute attribute; if (hasPendingAttributeValue) attribute = new Attribute(pendingAttributeName, pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS); else if (hasEmptyAttributeValue) attribute = new Attribute(pendingAttributeName, \"\"); else"
      },
      {
        "txt": "attribute = new BooleanAttribute(pendingAttributeName); attributes.put(attribute); } pendingAttributeName = null; hasEmptyAttributeValue = false; hasPendingAttributeValue = false; reset(pendingAttributeValue); pendingAttributeValueS = null; } final void finaliseTag() {"
      },
      {
        "txt": "if (pendingAttributeName != null) { newAttribute(); } } final String name() { // preserves case, for input into Tag.valueOf (which may drop case) Validate.isFalse(tagName == null || tagName.length() == 0); return tagName; } final String normalName() { // loses case, used in tree building for working out where in tree it should go return normalName;"
      },
      {
        "txt": "} final Tag name(String name) { tagName = name; normalName = name.toLowerCase(); return this; } final boolean isSelfClosing() { return selfClosing; } @SuppressWarnings({\"TypeMayBeWeakened\"})"
      },
      {
        "txt": "final Attributes getAttributes() { return attributes; } final void appendTagName(String append) { tagName = tagName == null ? append : tagName.concat(append); normalName = tagName.toLowerCase(); } final void appendTagName(char append) { appendTagName(String.valueOf(append)); }"
      },
      {
        "txt": "final void appendAttributeName(String append) { pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append); } final void appendAttributeName(char append) { appendAttributeName(String.valueOf(append)); } final void appendAttributeValue(String append) { ensureAttributeValue(); if (pendingAttributeValue.length() == 0) { pendingAttributeValueS = append;"
      },
      {
        "txt": "} else { pendingAttributeValue.append(append); } } final void appendAttributeValue(char append) { ensureAttributeValue(); pendingAttributeValue.append(append); } final void appendAttributeValue(char[] append) { ensureAttributeValue();"
      },
      {
        "txt": "pendingAttributeValue.append(append); } final void appendAttributeValue(int[] appendCodepoints) { ensureAttributeValue(); for (int codepoint : appendCodepoints) { pendingAttributeValue.appendCodePoint(codepoint); } } final void setEmptyAttributeValue() { hasEmptyAttributeValue = true;"
      },
      {
        "txt": "} private void ensureAttributeValue() { hasPendingAttributeValue = true; if (pendingAttributeValueS != null) { pendingAttributeValue.append(pendingAttributeValueS); pendingAttributeValueS = null; } } } final static class StartTag extends Tag {"
      },
      {
        "txt": "StartTag() { super(); attributes = new Attributes(); type = TokenType.StartTag; } @Override Tag reset() { super.reset(); attributes = new Attributes(); return this;"
      },
      {
        "txt": "} StartTag nameAttr(String name, Attributes attributes) { this.tagName = name; this.attributes = attributes; normalName = tagName.toLowerCase(); return this; } @Override public String toString() { if (attributes != null && attributes.size() > 0)"
      },
      {
        "txt": "return \"<\" + name() + \" \" + attributes.toString() + \">\"; else return \"<\" + name() + \">\"; } } final static class EndTag extends Tag{ EndTag() { super(); type = TokenType.EndTag; }"
      },
      {
        "txt": "@Override public String toString() { return \"</\" + name() + \">\"; } } final static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; @Override Token reset() {"
      },
      {
        "txt": "reset(data); bogus = false; return this; } Comment() { type = TokenType.Comment; } String getData() { return data.toString(); }"
      },
      {
        "txt": "@Override public String toString() { return \"<!--\" + getData() + \"-->\"; } } final static class Character extends Token { private String data; Character() { super(); type = TokenType.Character;"
      },
      {
        "txt": "} @Override Token reset() { data = null; return this; } Character data(String data) { this.data = data; return this; }"
      },
      {
        "txt": "String getData() { return data; } @Override public String toString() { return getData(); } } final static class EOF extends Token { EOF() {"
      },
      {
        "txt": "type = Token.TokenType.EOF; } @Override Token reset() { return this; } } final boolean isDoctype() { return type == TokenType.Doctype; }"
      },
      {
        "txt": "final Doctype asDoctype() { return (Doctype) this; } final boolean isStartTag() { return type == TokenType.StartTag; } final StartTag asStartTag() { return (StartTag) this; } final boolean isEndTag() {"
      },
      {
        "txt": "return type == TokenType.EndTag; } final EndTag asEndTag() { return (EndTag) this; } final boolean isComment() { return type == TokenType.Comment; } final Comment asComment() { return (Comment) this;"
      },
      {
        "txt": "} final boolean isCharacter() { return type == TokenType.Character; } final Character asCharacter() { return (Character) this; } final boolean isEOF() { return type == TokenType.EOF; }"
      },
      {
        "txt": "enum TokenType { Doctype, StartTag, EndTag, Comment, Character, EOF }"
      }
    ]
  },
  {
    "id": 1998,
    "file_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
    "start-bug-line": 1195,
    "end-bug-line": 1195,
    "bug": "",
    "fix": "t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.jsoup.nodes.DocumentType;"
      },
      {
        "txt": "import java.util.Arrays; enum TokeniserState { Data { void read(Tokeniser t, CharacterReader r) { switch (r.current()) { case '&': t.advanceTransition(CharacterReferenceInData); break; case '<': t.advanceTransition(TagOpen);"
      },
      {
        "txt": "break; case nullChar: t.error(this); // NOT replacement character (oddly?) t.emit(r.consume()); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeData();"
      },
      {
        "txt": "t.emit(data); break; } } }, CharacterReferenceInData { void read(Tokeniser t, CharacterReader r) { readCharRef(t, Data); } },"
      },
      {
        "txt": "Rcdata { void read(Tokeniser t, CharacterReader r) { switch (r.current()) { case '&': t.advanceTransition(CharacterReferenceInRcdata); break; case '<': t.advanceTransition(RcdataLessthanSign); break; case nullChar:"
      },
      {
        "txt": "t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('&', '<', nullChar); t.emit(data);"
      },
      {
        "txt": "break; } } }, CharacterReferenceInRcdata { void read(Tokeniser t, CharacterReader r) { readCharRef(t, Rcdata); } }, Rawtext {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { readData(t, r, this, RawtextLessthanSign); } }, ScriptData { void read(Tokeniser t, CharacterReader r) { readData(t, r, this, ScriptDataLessthanSign); } }, PLAINTEXT {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { switch (r.current()) { case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break;"
      },
      {
        "txt": "default: String data = r.consumeTo(nullChar); t.emit(data); break; } } }, TagOpen { void read(Tokeniser t, CharacterReader r) { switch (r.current()) {"
      },
      {
        "txt": "case '!': t.advanceTransition(MarkupDeclarationOpen); break; case '/': t.advanceTransition(EndTagOpen); break; case '?': t.advanceTransition(BogusComment); break; default:"
      },
      {
        "txt": "if (r.matchesLetter()) { t.createTagPending(true); t.transition(TagName); } else { t.error(this); t.emit('<'); // char that got us here t.transition(Data); } break; }"
      },
      {
        "txt": "} }, EndTagOpen { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.emit(\"</\"); t.transition(Data); } else if (r.matchesLetter()) { t.createTagPending(false);"
      },
      {
        "txt": "t.transition(TagName); } else if (r.matches('>')) { t.error(this); t.advanceTransition(Data); } else { t.error(this); t.advanceTransition(BogusComment); } } },"
      },
      {
        "txt": "TagName { void read(Tokeniser t, CharacterReader r) { String tagName = r.consumeTagName(); t.tagPending.appendTagName(tagName); switch (r.consume()) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ':"
      },
      {
        "txt": "t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: // replacement"
      },
      {
        "txt": "t.tagPending.appendTagName(replacementStr); break; case eof: // should emit pending tag? t.eofError(this); t.transition(Data); } } }, RcdataLessthanSign { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) { t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); // undo \"<\" t.transition(Data); } else { t.emit(\"<\");"
      },
      {
        "txt": "t.transition(Rcdata); } } }, RCDATAEndTagOpen { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current());"
      },
      {
        "txt": "t.advanceTransition(RCDATAEndTagName); } else { t.emit(\"</\"); t.transition(Rcdata); } } }, RCDATAEndTagName { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) {"
      },
      {
        "txt": "String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name); t.dataBuffer.append(name); return; } char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r':"
      },
      {
        "txt": "case '\\f': case ' ': if (t.isAppropriateEndTagToken()) t.transition(BeforeAttributeName); else anythingElse(t, r); break; case '/': if (t.isAppropriateEndTagToken()) t.transition(SelfClosingStartTag);"
      },
      {
        "txt": "else anythingElse(t, r); break; case '>': if (t.isAppropriateEndTagToken()) { t.emitTagPending(); t.transition(Data); } else anythingElse(t, r);"
      },
      {
        "txt": "break; default: anythingElse(t, r); } } private void anythingElse(Tokeniser t, CharacterReader r) { t.emit(\"</\" + t.dataBuffer.toString()); r.unconsume(); t.transition(Rcdata); }"
      },
      {
        "txt": "}, RawtextLessthanSign { void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RawtextEndTagOpen); } else { t.emit('<'); t.transition(Rawtext); }"
      },
      {
        "txt": "} }, RawtextEndTagOpen { void read(Tokeniser t, CharacterReader r) { readEndTag(t, r, RawtextEndTagName, Rawtext); } }, RawtextEndTagName { void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, Rawtext);"
      },
      {
        "txt": "} }, ScriptDataLessthanSign { void read(Tokeniser t, CharacterReader r) { switch (r.consume()) { case '/': t.createTempBuffer(); t.transition(ScriptDataEndTagOpen); break; case '!':"
      },
      {
        "txt": "t.emit(\"<!\"); t.transition(ScriptDataEscapeStart); break; default: t.emit(\"<\"); r.unconsume(); t.transition(ScriptData); } } },"
      },
      {
        "txt": "ScriptDataEndTagOpen { void read(Tokeniser t, CharacterReader r) { readEndTag(t, r, ScriptDataEndTagName, ScriptData); } }, ScriptDataEndTagName { void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptData); } },"
      },
      {
        "txt": "ScriptDataEscapeStart { void read(Tokeniser t, CharacterReader r) { if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapeStartDash); } else { t.transition(ScriptData); } } },"
      },
      {
        "txt": "ScriptDataEscapeStartDash { void read(Tokeniser t, CharacterReader r) { if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapedDashDash); } else { t.transition(ScriptData); } } },"
      },
      {
        "txt": "ScriptDataEscaped { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } switch (r.current()) { case '-': t.emit('-');"
      },
      {
        "txt": "t.advanceTransition(ScriptDataEscapedDash); break; case '<': t.advanceTransition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break;"
      },
      {
        "txt": "default: String data = r.consumeToAny('-', '<', nullChar); t.emit(data); } } }, ScriptDataEscapedDash { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this);"
      },
      {
        "txt": "t.transition(Data); return; } char c = r.consume(); switch (c) { case '-': t.emit(c); t.transition(ScriptDataEscapedDashDash); break; case '<':"
      },
      {
        "txt": "t.transition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped);"
      },
      {
        "txt": "} } }, ScriptDataEscapedDashDash { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; }"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '-': t.emit(c); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case '>': t.emit(c);"
      },
      {
        "txt": "t.transition(ScriptData); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped);"
      },
      {
        "txt": "} } }, ScriptDataEscapedLessthanSign { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTempBuffer(); t.dataBuffer.append(r.current()); t.emit(\"<\" + r.current()); t.advanceTransition(ScriptDataDoubleEscapeStart);"
      },
      {
        "txt": "} else if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(ScriptDataEscapedEndTagOpen); } else { t.emit('<'); t.transition(ScriptDataEscaped); } } }, ScriptDataEscapedEndTagOpen {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current()); t.advanceTransition(ScriptDataEscapedEndTagName); } else { t.emit(\"</\"); t.transition(ScriptDataEscaped); }"
      },
      {
        "txt": "} }, ScriptDataEscapedEndTagName { void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptDataEscaped); } }, ScriptDataDoubleEscapeStart { void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);"
      },
      {
        "txt": "} }, ScriptDataDoubleEscaped { void read(Tokeniser t, CharacterReader r) { char c = r.current(); switch (c) { case '-': t.emit(c); t.advanceTransition(ScriptDataDoubleEscapedDash); break;"
      },
      {
        "txt": "case '<': t.emit(c); t.advanceTransition(ScriptDataDoubleEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof:"
      },
      {
        "txt": "t.eofError(this); t.transition(Data); break; default: String data = r.consumeToAny('-', '<', nullChar); t.emit(data); } } }, ScriptDataDoubleEscapedDash {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.emit(c); t.transition(ScriptDataDoubleEscapedDashDash); break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign);"
      },
      {
        "txt": "break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break;"
      },
      {
        "txt": "default: t.emit(c); t.transition(ScriptDataDoubleEscaped); } } }, ScriptDataDoubleEscapedDashDash { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '-': t.emit(c); break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign); break; case '>': t.emit(c); t.transition(ScriptData);"
      },
      {
        "txt": "break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break;"
      },
      {
        "txt": "default: t.emit(c); t.transition(ScriptDataDoubleEscaped); } } }, ScriptDataDoubleEscapedLessthanSign { void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.emit('/');"
      },
      {
        "txt": "t.createTempBuffer(); t.advanceTransition(ScriptDataDoubleEscapeEnd); } else { t.transition(ScriptDataDoubleEscaped); } } }, ScriptDataDoubleEscapeEnd { void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);"
      },
      {
        "txt": "} }, BeforeAttributeName { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f':"
      },
      {
        "txt": "case ' ': break; // ignore whitespace case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar:"
      },
      {
        "txt": "t.error(this); t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); break; case eof: t.eofError(this); t.transition(Data); break; case '\"':"
      },
      {
        "txt": "case '\\'': case '<': case '=': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName); break; default: // A-Z, anything else t.tagPending.newAttribute();"
      },
      {
        "txt": "r.unconsume(); t.transition(AttributeName); } } }, AttributeName { void read(Tokeniser t, CharacterReader r) { String name = r.consumeToAnySorted(attributeNameCharsSorted); t.tagPending.appendAttributeName(name); char c = r.consume();"
      },
      {
        "txt": "switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(AfterAttributeName); break; case '/': t.transition(SelfClosingStartTag);"
      },
      {
        "txt": "break; case '=': t.transition(BeforeAttributeValue); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this);"
      },
      {
        "txt": "t.tagPending.appendAttributeName(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; case '\"': case '\\'': case '<': t.error(this);"
      },
      {
        "txt": "t.tagPending.appendAttributeName(c); } } }, AfterAttributeName { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n':"
      },
      {
        "txt": "case '\\r': case '\\f': case ' ': break; case '/': t.transition(SelfClosingStartTag); break; case '=': t.transition(BeforeAttributeValue); break;"
      },
      {
        "txt": "case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeName(replacementChar); t.transition(AttributeName); break; case eof:"
      },
      {
        "txt": "t.eofError(this); t.transition(Data); break; case '\"': case '\\'': case '<': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName);"
      },
      {
        "txt": "break; default: // A-Z, anything else t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); } } }, BeforeAttributeValue { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\"': t.transition(AttributeValue_doubleQuoted);"
      },
      {
        "txt": "break; case '&': r.unconsume(); t.transition(AttributeValue_unquoted); break; case '\\'': t.transition(AttributeValue_singleQuoted); break; case nullChar: t.error(this);"
      },
      {
        "txt": "t.tagPending.appendAttributeValue(replacementChar); t.transition(AttributeValue_unquoted); break; case eof: t.eofError(this); t.emitTagPending(); t.transition(Data); break; case '>': t.error(this);"
      },
      {
        "txt": "t.emitTagPending(); t.transition(Data); break; case '<': case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); t.transition(AttributeValue_unquoted); break;"
      },
      {
        "txt": "default: r.unconsume(); t.transition(AttributeValue_unquoted); } } }, AttributeValue_doubleQuoted { void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeDoubleValueCharsSorted); if (value.length() > 0)"
      },
      {
        "txt": "t.tagPending.appendAttributeValue(value); else t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch (c) { case '\"': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\"', true);"
      },
      {
        "txt": "if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof:"
      },
      {
        "txt": "t.eofError(this); t.transition(Data); break; } } }, AttributeValue_singleQuoted { void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeSingleValueCharsSorted); if (value.length() > 0)"
      },
      {
        "txt": "t.tagPending.appendAttributeValue(value); else t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch (c) { case '\\'': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\\'', true);"
      },
      {
        "txt": "if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof:"
      },
      {
        "txt": "t.eofError(this); t.transition(Data); break; } } }, AttributeValue_unquoted { void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAnySorted(attributeValueUnquoted); if (value.length() > 0)"
      },
      {
        "txt": "t.tagPending.appendAttributeValue(value); char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break;"
      },
      {
        "txt": "case '&': int[] ref = t.consumeCharacterReference('>', true); if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case '>': t.emitTagPending(); t.transition(Data);"
      },
      {
        "txt": "break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; case '\"':"
      },
      {
        "txt": "case '\\'': case '<': case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); break; } } },"
      },
      {
        "txt": "AfterAttributeValue_quoted { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName);"
      },
      {
        "txt": "break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this);"
      },
      {
        "txt": "t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } } }, SelfClosingStartTag {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '>': t.tagPending.selfClosing = true; t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this);"
      },
      {
        "txt": "t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } } }, BogusComment {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { r.unconsume(); Token.Comment comment = new Token.Comment(); comment.bogus = true; comment.data.append(r.consumeTo('>')); t.emit(comment); t.advanceTransition(Data); } }, MarkupDeclarationOpen {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { if (r.matchConsume(\"--\")) { t.createCommentPending(); t.transition(CommentStart); } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) { t.transition(Doctype); } else if (r.matchConsume(\"[CDATA[\")) { t.transition(CdataSection); } else { t.error(this);"
      },
      {
        "txt": "t.advanceTransition(BogusComment); // advance so this character gets in bogus comment data's rewind } } }, CommentStart { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.transition(CommentStartDash);"
      },
      {
        "txt": "break; case nullChar: t.error(this); t.commentPending.data.append(replacementChar); t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data);"
      },
      {
        "txt": "break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); }"
      },
      {
        "txt": "} }, CommentStartDash { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.transition(CommentStartDash); break; case nullChar:"
      },
      {
        "txt": "t.error(this); t.commentPending.data.append(replacementChar); t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data); break; case eof:"
      },
      {
        "txt": "t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); } } },"
      },
      {
        "txt": "Comment { void read(Tokeniser t, CharacterReader r) { char c = r.current(); switch (c) { case '-': t.advanceTransition(CommentEndDash); break; case nullChar: t.error(this); r.advance();"
      },
      {
        "txt": "t.commentPending.data.append(replacementChar); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(r.consumeToAny('-', nullChar)); }"
      },
      {
        "txt": "} }, CommentEndDash { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.transition(CommentEnd); break; case nullChar:"
      },
      {
        "txt": "t.error(this); t.commentPending.data.append('-').append(replacementChar); t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.commentPending.data.append('-').append(c); t.transition(Comment); } } }, CommentEnd { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '>':"
      },
      {
        "txt": "t.emitCommentPending(); t.transition(Data); break; case nullChar: t.error(this); t.commentPending.data.append(\"--\").append(replacementChar); t.transition(Comment); break; case '!': t.error(this);"
      },
      {
        "txt": "t.transition(CommentEndBang); break; case '-': t.error(this); t.commentPending.data.append('-'); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data);"
      },
      {
        "txt": "break; default: t.error(this); t.commentPending.data.append(\"--\").append(c); t.transition(Comment); } } }, CommentEndBang { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '-': t.commentPending.data.append(\"--!\"); t.transition(CommentEndDash); break; case '>': t.emitCommentPending(); t.transition(Data); break;"
      },
      {
        "txt": "case nullChar: t.error(this); t.commentPending.data.append(\"--!\").append(replacementChar); t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break;"
      },
      {
        "txt": "default: t.commentPending.data.append(\"--!\").append(c); t.transition(Comment); } } }, Doctype { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypeName); break; case eof: t.eofError(this); case '>': // catch invalid <!DOCTYPE>"
      },
      {
        "txt": "t.error(this); t.createDoctypePending(); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BeforeDoctypeName); }"
      },
      {
        "txt": "} }, BeforeDoctypeName { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createDoctypePending(); t.transition(DoctypeName); return; } char c = r.consume();"
      },
      {
        "txt": "switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; // ignore whitespace case nullChar: t.error(this); t.createDoctypePending();"
      },
      {
        "txt": "t.doctypePending.name.append(replacementChar); t.transition(DoctypeName); break; case eof: t.eofError(this); t.createDoctypePending(); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break;"
      },
      {
        "txt": "default: t.createDoctypePending(); t.doctypePending.name.append(c); t.transition(DoctypeName); } } }, DoctypeName { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) {"
      },
      {
        "txt": "String name = r.consumeLetterSequence(); t.doctypePending.name.append(name); return; } char c = r.consume(); switch (c) { case '>': t.emitDoctypePending(); t.transition(Data); break;"
      },
      {
        "txt": "case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(AfterDoctypeName); break; case nullChar: t.error(this); t.doctypePending.name.append(replacementChar);"
      },
      {
        "txt": "break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.name.append(c); }"
      },
      {
        "txt": "} }, AfterDoctypeName { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); return;"
      },
      {
        "txt": "if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' ')) r.advance(); // ignore whitespace else if (r.matches('>')) { t.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { <extra_id_0> } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { t.transition(AfterDoctypeSystemKeyword); } else { t.error(this); t.doctypePending.forceQuirks = true; t.advanceTransition(BogusDoctype);"
      },
      {
        "txt": "t.doctypePending.forceQuirks = true; t.advanceTransition(BogusDoctype); } } }, AfterDoctypePublicKeyword { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t':"
      },
      {
        "txt": "case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypePublicIdentifier); break; case '\"': t.error(this); t.transition(DoctypePublicIdentifier_doubleQuoted); break;"
      },
      {
        "txt": "case '\\'': t.error(this); t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break;"
      },
      {
        "txt": "case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype);"
      },
      {
        "txt": "} } }, BeforeDoctypePublicIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r':"
      },
      {
        "txt": "case '\\f': case ' ': break; case '\"': t.transition(DoctypePublicIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>':"
      },
      {
        "txt": "t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data);"
      },
      {
        "txt": "break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } } }, DoctypePublicIdentifier_doubleQuoted { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '\"': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>':"
      },
      {
        "txt": "t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data);"
      },
      {
        "txt": "break; default: t.doctypePending.publicIdentifier.append(c); } } }, DoctypePublicIdentifier_singleQuoted { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '\\'': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true;"
      },
      {
        "txt": "t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.doctypePending.publicIdentifier.append(c); } } }, AfterDoctypePublicIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n':"
      },
      {
        "txt": "case '\\r': case '\\f': case ' ': t.transition(BetweenDoctypePublicAndSystemIdentifiers); break; case '>': t.emitDoctypePending(); t.transition(Data); break; case '\"':"
      },
      {
        "txt": "t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true;"
      },
      {
        "txt": "t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } } },"
      },
      {
        "txt": "BetweenDoctypePublicAndSystemIdentifiers { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break;"
      },
      {
        "txt": "case '>': t.emitDoctypePending(); t.transition(Data); break; case '\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this);"
      },
      {
        "txt": "t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this);"
      },
      {
        "txt": "t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } } }, AfterDoctypeSystemKeyword { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t':"
      },
      {
        "txt": "case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypeSystemIdentifier); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending();"
      },
      {
        "txt": "t.transition(Data); break; case '\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break;"
      },
      {
        "txt": "case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending();"
      },
      {
        "txt": "} } }, BeforeDoctypeSystemIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r':"
      },
      {
        "txt": "case '\\f': case ' ': break; case '\"': t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypeSystemIdentifier_singleQuoted); break; case '>':"
      },
      {
        "txt": "t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data);"
      },
      {
        "txt": "break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } } }, DoctypeSystemIdentifier_doubleQuoted { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '\"': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>':"
      },
      {
        "txt": "t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data);"
      },
      {
        "txt": "break; default: t.doctypePending.systemIdentifier.append(c); } } }, DoctypeSystemIdentifier_singleQuoted { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '\\'': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true;"
      },
      {
        "txt": "t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.doctypePending.systemIdentifier.append(c); } } }, AfterDoctypeSystemIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n':"
      },
      {
        "txt": "case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this);"
      },
      {
        "txt": "t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BogusDoctype); } } },"
      },
      {
        "txt": "BogusDoctype { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.emitDoctypePending();"
      },
      {
        "txt": "t.transition(Data); break; default: break; } } }, CdataSection { void read(Tokeniser t, CharacterReader r) { String data = r.consumeTo(\"]]>\");"
      },
      {
        "txt": "t.emit(data); r.matchConsume(\"]]>\"); t.transition(Data); } }; abstract void read(Tokeniser t, CharacterReader r); static final char nullChar = '\\u0000'; private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar}; private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar}; private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};"
      },
      {
        "txt": "private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'}; private static final char replacementChar = Tokeniser.replacementChar; private static final String replacementStr = String.valueOf(Tokeniser.replacementChar); private static final char eof = CharacterReader.EOF; static { Arrays.sort(attributeSingleValueCharsSorted); Arrays.sort(attributeDoubleValueCharsSorted); Arrays.sort(attributeNameCharsSorted); Arrays.sort(attributeValueUnquoted); }"
      },
      {
        "txt": "private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name); t.dataBuffer.append(name); return; } boolean needsExitTransition = false; if (t.isAppropriateEndTagToken() && !r.isEmpty()) { char c = r.consume();"
      },
      {
        "txt": "switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag);"
      },
      {
        "txt": "break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); needsExitTransition = true; } } else {"
      },
      {
        "txt": "needsExitTransition = true; } if (needsExitTransition) { t.emit(\"</\" + t.dataBuffer.toString()); t.transition(elseTransition); } } private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) { switch (r.current()) { case '<':"
      },
      {
        "txt": "t.advanceTransition(advance); break; case nullChar: t.error(current); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break;"
      },
      {
        "txt": "default: String data = r.consumeToAny('<', nullChar); t.emit(data); break; } } private static void readCharRef(Tokeniser t, TokeniserState advance) { int[] c = t.consumeCharacterReference(null, false); if (c == null) t.emit('&');"
      },
      {
        "txt": "else t.emit(c); t.transition(advance); } private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) { if (r.matchesLetter()) { t.createTagPending(false); t.transition(a); } else { t.emit(\"</\");"
      },
      {
        "txt": "t.transition(b); } } private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.dataBuffer.append(name); t.emit(name); return; }"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': case '/': case '>': if (t.dataBuffer.toString().equals(\"script\"))"
      },
      {
        "txt": "t.transition(primary); else t.transition(fallback); t.emit(c); break; default: r.unconsume(); t.transition(fallback); } }"
      }
    ]
  },
  {
    "id": 1999,
    "file_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
    "start-bug-line": 1197,
    "end-bug-line": 1197,
    "bug": "",
    "fix": "t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.jsoup.nodes.DocumentType; import java.util.Arrays; enum TokeniserState {"
      },
      {
        "txt": "Data { void read(Tokeniser t, CharacterReader r) { switch (r.current()) { case '&': t.advanceTransition(CharacterReferenceInData); break; case '<': t.advanceTransition(TagOpen); break; case nullChar:"
      },
      {
        "txt": "t.error(this); // NOT replacement character (oddly?) t.emit(r.consume()); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeData(); t.emit(data); break;"
      },
      {
        "txt": "} } }, CharacterReferenceInData { void read(Tokeniser t, CharacterReader r) { readCharRef(t, Data); } }, Rcdata { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "switch (r.current()) { case '&': t.advanceTransition(CharacterReferenceInRcdata); break; case '<': t.advanceTransition(RcdataLessthanSign); break; case nullChar: t.error(this); r.advance();"
      },
      {
        "txt": "t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('&', '<', nullChar); t.emit(data); break; }"
      },
      {
        "txt": "} }, CharacterReferenceInRcdata { void read(Tokeniser t, CharacterReader r) { readCharRef(t, Rcdata); } }, Rawtext { void read(Tokeniser t, CharacterReader r) { readData(t, r, this, RawtextLessthanSign);"
      },
      {
        "txt": "} }, ScriptData { void read(Tokeniser t, CharacterReader r) { readData(t, r, this, ScriptDataLessthanSign); } }, PLAINTEXT { void read(Tokeniser t, CharacterReader r) { switch (r.current()) {"
      },
      {
        "txt": "case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeTo(nullChar);"
      },
      {
        "txt": "t.emit(data); break; } } }, TagOpen { void read(Tokeniser t, CharacterReader r) { switch (r.current()) { case '!': t.advanceTransition(MarkupDeclarationOpen);"
      },
      {
        "txt": "break; case '/': t.advanceTransition(EndTagOpen); break; case '?': t.advanceTransition(BogusComment); break; default: if (r.matchesLetter()) { t.createTagPending(true);"
      },
      {
        "txt": "t.transition(TagName); } else { t.error(this); t.emit('<'); // char that got us here t.transition(Data); } break; } } },"
      },
      {
        "txt": "EndTagOpen { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.emit(\"</\"); t.transition(Data); } else if (r.matchesLetter()) { t.createTagPending(false); t.transition(TagName); } else if (r.matches('>')) {"
      },
      {
        "txt": "t.error(this); t.advanceTransition(Data); } else { t.error(this); t.advanceTransition(BogusComment); } } }, TagName { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "String tagName = r.consumeTagName(); t.tagPending.appendTagName(tagName); switch (r.consume()) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break;"
      },
      {
        "txt": "case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: // replacement t.tagPending.appendTagName(replacementStr); break;"
      },
      {
        "txt": "case eof: // should emit pending tag? t.eofError(this); t.transition(Data); } } }, RcdataLessthanSign { void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer();"
      },
      {
        "txt": "t.advanceTransition(RCDATAEndTagOpen); } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) { t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); // undo \"<\" t.transition(Data); } else { t.emit(\"<\"); t.transition(Rcdata); }"
      },
      {
        "txt": "} }, RCDATAEndTagOpen { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current()); t.advanceTransition(RCDATAEndTagName); } else {"
      },
      {
        "txt": "t.emit(\"</\"); t.transition(Rcdata); } } }, RCDATAEndTagName { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name);"
      },
      {
        "txt": "t.dataBuffer.append(name); return; } char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ':"
      },
      {
        "txt": "if (t.isAppropriateEndTagToken()) t.transition(BeforeAttributeName); else anythingElse(t, r); break; case '/': if (t.isAppropriateEndTagToken()) t.transition(SelfClosingStartTag); else anythingElse(t, r);"
      },
      {
        "txt": "break; case '>': if (t.isAppropriateEndTagToken()) { t.emitTagPending(); t.transition(Data); } else anythingElse(t, r); break; default:"
      },
      {
        "txt": "anythingElse(t, r); } } private void anythingElse(Tokeniser t, CharacterReader r) { t.emit(\"</\" + t.dataBuffer.toString()); r.unconsume(); t.transition(Rcdata); } }, RawtextLessthanSign {"
      },
      {
        "txt": "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RawtextEndTagOpen); } else { t.emit('<'); t.transition(Rawtext); } } },"
      },
      {
        "txt": "RawtextEndTagOpen { void read(Tokeniser t, CharacterReader r) { readEndTag(t, r, RawtextEndTagName, Rawtext); } }, RawtextEndTagName { void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, Rawtext); } },"
      },
      {
        "txt": "ScriptDataLessthanSign { void read(Tokeniser t, CharacterReader r) { switch (r.consume()) { case '/': t.createTempBuffer(); t.transition(ScriptDataEndTagOpen); break; case '!': t.emit(\"<!\"); t.transition(ScriptDataEscapeStart);"
      },
      {
        "txt": "break; default: t.emit(\"<\"); r.unconsume(); t.transition(ScriptData); } } }, ScriptDataEndTagOpen { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "readEndTag(t, r, ScriptDataEndTagName, ScriptData); } }, ScriptDataEndTagName { void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptData); } }, ScriptDataEscapeStart { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapeStartDash); } else { t.transition(ScriptData); } } }, ScriptDataEscapeStartDash { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapedDashDash); } else { t.transition(ScriptData); } } }, ScriptDataEscaped { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } switch (r.current()) { case '-': t.emit('-'); t.advanceTransition(ScriptDataEscapedDash); break;"
      },
      {
        "txt": "case '<': t.advanceTransition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; default: String data = r.consumeToAny('-', '<', nullChar);"
      },
      {
        "txt": "t.emit(data); } } }, ScriptDataEscapedDash { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return;"
      },
      {
        "txt": "} char c = r.consume(); switch (c) { case '-': t.emit(c); t.transition(ScriptDataEscapedDashDash); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break;"
      },
      {
        "txt": "case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }"
      },
      {
        "txt": "}, ScriptDataEscapedDashDash { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '-': t.emit(c); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case '>': t.emit(c); t.transition(ScriptData); break;"
      },
      {
        "txt": "case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }"
      },
      {
        "txt": "}, ScriptDataEscapedLessthanSign { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTempBuffer(); t.dataBuffer.append(r.current()); t.emit(\"<\" + r.current()); t.advanceTransition(ScriptDataDoubleEscapeStart); } else if (r.matches('/')) { t.createTempBuffer();"
      },
      {
        "txt": "t.advanceTransition(ScriptDataEscapedEndTagOpen); } else { t.emit('<'); t.transition(ScriptDataEscaped); } } }, ScriptDataEscapedEndTagOpen { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) {"
      },
      {
        "txt": "t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current()); t.advanceTransition(ScriptDataEscapedEndTagName); } else { t.emit(\"</\"); t.transition(ScriptDataEscaped); } } },"
      },
      {
        "txt": "ScriptDataEscapedEndTagName { void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptDataEscaped); } }, ScriptDataDoubleEscapeStart { void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped); } },"
      },
      {
        "txt": "ScriptDataDoubleEscaped { void read(Tokeniser t, CharacterReader r) { char c = r.current(); switch (c) { case '-': t.emit(c); t.advanceTransition(ScriptDataDoubleEscapedDash); break; case '<': t.emit(c);"
      },
      {
        "txt": "t.advanceTransition(ScriptDataDoubleEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.eofError(this); t.transition(Data);"
      },
      {
        "txt": "break; default: String data = r.consumeToAny('-', '<', nullChar); t.emit(data); } } }, ScriptDataDoubleEscapedDash { void read(Tokeniser t, CharacterReader r) { char c = r.consume();"
      },
      {
        "txt": "switch (c) { case '-': t.emit(c); t.transition(ScriptDataDoubleEscapedDashDash); break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign); break; case nullChar:"
      },
      {
        "txt": "t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break; default: t.emit(c);"
      },
      {
        "txt": "t.transition(ScriptDataDoubleEscaped); } } }, ScriptDataDoubleEscapedDashDash { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.emit(c);"
      },
      {
        "txt": "break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign); break; case '>': t.emit(c); t.transition(ScriptData); break; case nullChar:"
      },
      {
        "txt": "t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break; default: t.emit(c);"
      },
      {
        "txt": "t.transition(ScriptDataDoubleEscaped); } } }, ScriptDataDoubleEscapedLessthanSign { void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.emit('/'); t.createTempBuffer(); t.advanceTransition(ScriptDataDoubleEscapeEnd);"
      },
      {
        "txt": "} else { t.transition(ScriptDataDoubleEscaped); } } }, ScriptDataDoubleEscapeEnd { void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped); } },"
      },
      {
        "txt": "BeforeAttributeName { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; // ignore whitespace"
      },
      {
        "txt": "case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.newAttribute();"
      },
      {
        "txt": "r.unconsume(); t.transition(AttributeName); break; case eof: t.eofError(this); t.transition(Data); break; case '\"': case '\\'': case '<':"
      },
      {
        "txt": "case '=': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName); break; default: // A-Z, anything else t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName);"
      },
      {
        "txt": "} } }, AttributeName { void read(Tokeniser t, CharacterReader r) { String name = r.consumeToAnySorted(attributeNameCharsSorted); t.tagPending.appendAttributeName(name); char c = r.consume(); switch (c) { case '\\t':"
      },
      {
        "txt": "case '\\n': case '\\r': case '\\f': case ' ': t.transition(AfterAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '=':"
      },
      {
        "txt": "t.transition(BeforeAttributeValue); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeName(replacementChar); break;"
      },
      {
        "txt": "case eof: t.eofError(this); t.transition(Data); break; case '\"': case '\\'': case '<': t.error(this); t.tagPending.appendAttributeName(c); }"
      },
      {
        "txt": "} }, AfterAttributeName { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f':"
      },
      {
        "txt": "case ' ': break; case '/': t.transition(SelfClosingStartTag); break; case '=': t.transition(BeforeAttributeValue); break; case '>': t.emitTagPending();"
      },
      {
        "txt": "t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeName(replacementChar); t.transition(AttributeName); break; case eof: t.eofError(this); t.transition(Data);"
      },
      {
        "txt": "break; case '\"': case '\\'': case '<': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName); break; default: // A-Z, anything else"
      },
      {
        "txt": "t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); } } }, BeforeAttributeValue { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\"': t.transition(AttributeValue_doubleQuoted); break; case '&':"
      },
      {
        "txt": "r.unconsume(); t.transition(AttributeValue_unquoted); break; case '\\'': t.transition(AttributeValue_singleQuoted); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); t.transition(AttributeValue_unquoted);"
      },
      {
        "txt": "break; case eof: t.eofError(this); t.emitTagPending(); t.transition(Data); break; case '>': t.error(this); t.emitTagPending(); t.transition(Data);"
      },
      {
        "txt": "break; case '<': case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); t.transition(AttributeValue_unquoted); break; default: r.unconsume();"
      },
      {
        "txt": "t.transition(AttributeValue_unquoted); } } }, AttributeValue_doubleQuoted { void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeDoubleValueCharsSorted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); else"
      },
      {
        "txt": "t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch (c) { case '\"': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\"', true); if (ref != null) t.tagPending.appendAttributeValue(ref);"
      },
      {
        "txt": "else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data);"
      },
      {
        "txt": "break; } } }, AttributeValue_singleQuoted { void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeSingleValueCharsSorted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); else"
      },
      {
        "txt": "t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch (c) { case '\\'': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\\'', true); if (ref != null) t.tagPending.appendAttributeValue(ref);"
      },
      {
        "txt": "else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data);"
      },
      {
        "txt": "break; } } }, AttributeValue_unquoted { void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAnySorted(attributeValueUnquoted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); char c = r.consume();"
      },
      {
        "txt": "switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '&': int[] ref = t.consumeCharacterReference('>', true);"
      },
      {
        "txt": "if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar:"
      },
      {
        "txt": "t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; case '\"': case '\\'': case '<':"
      },
      {
        "txt": "case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); break; } } }, AfterAttributeValue_quoted { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/':"
      },
      {
        "txt": "t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break;"
      },
      {
        "txt": "default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } } }, SelfClosingStartTag { void read(Tokeniser t, CharacterReader r) { char c = r.consume();"
      },
      {
        "txt": "switch (c) { case '>': t.tagPending.selfClosing = true; t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break;"
      },
      {
        "txt": "default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } } }, BogusComment { void read(Tokeniser t, CharacterReader r) { r.unconsume();"
      },
      {
        "txt": "Token.Comment comment = new Token.Comment(); comment.bogus = true; comment.data.append(r.consumeTo('>')); t.emit(comment); t.advanceTransition(Data); } }, MarkupDeclarationOpen { void read(Tokeniser t, CharacterReader r) { if (r.matchConsume(\"--\")) {"
      },
      {
        "txt": "t.createCommentPending(); t.transition(CommentStart); } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) { t.transition(Doctype); } else if (r.matchConsume(\"[CDATA[\")) { t.transition(CdataSection); } else { t.error(this); t.advanceTransition(BogusComment); // advance so this character gets in bogus comment data's rewind }"
      },
      {
        "txt": "} }, CommentStart { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.transition(CommentStartDash); break; case nullChar:"
      },
      {
        "txt": "t.error(this); t.commentPending.data.append(replacementChar); t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data); break; case eof:"
      },
      {
        "txt": "t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); } } },"
      },
      {
        "txt": "CommentStartDash { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.transition(CommentStartDash); break; case nullChar: t.error(this); t.commentPending.data.append(replacementChar);"
      },
      {
        "txt": "t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data); break; case eof: t.eofError(this); t.emitCommentPending();"
      },
      {
        "txt": "t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); } } }, Comment { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.current(); switch (c) { case '-': t.advanceTransition(CommentEndDash); break; case nullChar: t.error(this); r.advance(); t.commentPending.data.append(replacementChar); break;"
      },
      {
        "txt": "case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(r.consumeToAny('-', nullChar)); } } },"
      },
      {
        "txt": "CommentEndDash { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '-': t.transition(CommentEnd); break; case nullChar: t.error(this); t.commentPending.data.append('-').append(replacementChar);"
      },
      {
        "txt": "t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append('-').append(c); t.transition(Comment);"
      },
      {
        "txt": "} } }, CommentEnd { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '>': t.emitCommentPending(); t.transition(Data);"
      },
      {
        "txt": "break; case nullChar: t.error(this); t.commentPending.data.append(\"--\").append(replacementChar); t.transition(Comment); break; case '!': t.error(this); t.transition(CommentEndBang); break;"
      },
      {
        "txt": "case '-': t.error(this); t.commentPending.data.append('-'); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.error(this); t.commentPending.data.append(\"--\").append(c); t.transition(Comment); } } }, CommentEndBang { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '-': t.commentPending.data.append(\"--!\"); t.transition(CommentEndDash); break; case '>': t.emitCommentPending(); t.transition(Data); break; case nullChar: t.error(this);"
      },
      {
        "txt": "t.commentPending.data.append(\"--!\").append(replacementChar); t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(\"--!\").append(c);"
      },
      {
        "txt": "t.transition(Comment); } } }, Doctype { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n':"
      },
      {
        "txt": "case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypeName); break; case eof: t.eofError(this); case '>': // catch invalid <!DOCTYPE> t.error(this); t.createDoctypePending();"
      },
      {
        "txt": "t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BeforeDoctypeName); } } },"
      },
      {
        "txt": "BeforeDoctypeName { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createDoctypePending(); t.transition(DoctypeName); return; } char c = r.consume(); switch (c) { case '\\t':"
      },
      {
        "txt": "case '\\n': case '\\r': case '\\f': case ' ': break; // ignore whitespace case nullChar: t.error(this); t.createDoctypePending(); t.doctypePending.name.append(replacementChar); t.transition(DoctypeName);"
      },
      {
        "txt": "break; case eof: t.eofError(this); t.createDoctypePending(); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.createDoctypePending();"
      },
      {
        "txt": "t.doctypePending.name.append(c); t.transition(DoctypeName); } } }, DoctypeName { void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.doctypePending.name.append(name);"
      },
      {
        "txt": "return; } char c = r.consume(); switch (c) { case '>': t.emitDoctypePending(); t.transition(Data); break; case '\\t': case '\\n':"
      },
      {
        "txt": "case '\\r': case '\\f': case ' ': t.transition(AfterDoctypeName); break; case nullChar: t.error(this); t.doctypePending.name.append(replacementChar); break; case eof:"
      },
      {
        "txt": "t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.name.append(c); } } },"
      },
      {
        "txt": "AfterDoctypeName { void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); return; } if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))"
      },
      {
        "txt": "else if (r.matches('>')) { t.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { t.transition(AfterDoctypePublicKeyword); } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { <extra_id_0> } else { t.error(this); t.doctypePending.forceQuirks = true; t.advanceTransition(BogusDoctype); } }"
      },
      {
        "txt": "} } }, AfterDoctypePublicKeyword { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r':"
      },
      {
        "txt": "case '\\f': case ' ': t.transition(BeforeDoctypePublicIdentifier); break; case '\"': t.error(this); t.transition(DoctypePublicIdentifier_doubleQuoted); break; case '\\'': t.error(this);"
      },
      {
        "txt": "t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this);"
      },
      {
        "txt": "t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }"
      },
      {
        "txt": "}, BeforeDoctypePublicIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ':"
      },
      {
        "txt": "break; case '\"': t.transition(DoctypePublicIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true;"
      },
      {
        "txt": "t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } } }, DoctypePublicIdentifier_doubleQuoted { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '\"': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true;"
      },
      {
        "txt": "t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.doctypePending.publicIdentifier.append(c); } } }, DoctypePublicIdentifier_singleQuoted { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\'': t.transition(AfterDoctypePublicIdentifier);"
      },
      {
        "txt": "break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data);"
      },
      {
        "txt": "break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.publicIdentifier.append(c); }"
      },
      {
        "txt": "} }, AfterDoctypePublicIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f':"
      },
      {
        "txt": "case ' ': t.transition(BetweenDoctypePublicAndSystemIdentifiers); break; case '>': t.emitDoctypePending(); t.transition(Data); break; case '\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted);"
      },
      {
        "txt": "break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data);"
      },
      {
        "txt": "break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } } }, BetweenDoctypePublicAndSystemIdentifiers { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending();"
      },
      {
        "txt": "t.transition(Data); break; case '\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break;"
      },
      {
        "txt": "case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype);"
      },
      {
        "txt": "} } }, AfterDoctypeSystemKeyword { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r':"
      },
      {
        "txt": "case '\\f': case ' ': t.transition(BeforeDoctypeSystemIdentifier); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break;"
      },
      {
        "txt": "case '\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this);"
      },
      {
        "txt": "t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); } }"
      },
      {
        "txt": "}, BeforeDoctypeSystemIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ':"
      },
      {
        "txt": "break; case '\"': t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypeSystemIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true;"
      },
      {
        "txt": "t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } } }, DoctypeSystemIdentifier_doubleQuoted { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '\"': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true;"
      },
      {
        "txt": "t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default:"
      },
      {
        "txt": "t.doctypePending.systemIdentifier.append(c); } } }, DoctypeSystemIdentifier_singleQuoted { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\'': t.transition(AfterDoctypeSystemIdentifier);"
      },
      {
        "txt": "break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data);"
      },
      {
        "txt": "break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.systemIdentifier.append(c); }"
      },
      {
        "txt": "} }, AfterDoctypeSystemIdentifier { void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\r': case '\\f':"
      },
      {
        "txt": "case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending();"
      },
      {
        "txt": "t.transition(Data); break; default: t.error(this); t.transition(BogusDoctype); } } }, BogusDoctype { void read(Tokeniser t, CharacterReader r) {"
      },
      {
        "txt": "char c = r.consume(); switch (c) { case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.emitDoctypePending(); t.transition(Data); break;"
      },
      {
        "txt": "default: break; } } }, CdataSection { void read(Tokeniser t, CharacterReader r) { String data = r.consumeTo(\"]]>\"); t.emit(data); r.matchConsume(\"]]>\");"
      },
      {
        "txt": "t.transition(Data); } }; abstract void read(Tokeniser t, CharacterReader r); static final char nullChar = '\\u0000'; private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar}; private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar}; private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'}; private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'}; private static final char replacementChar = Tokeniser.replacementChar;"
      },
      {
        "txt": "private static final String replacementStr = String.valueOf(Tokeniser.replacementChar); private static final char eof = CharacterReader.EOF; static { Arrays.sort(attributeSingleValueCharsSorted); Arrays.sort(attributeDoubleValueCharsSorted); Arrays.sort(attributeNameCharsSorted); Arrays.sort(attributeValueUnquoted); } private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) { if (r.matchesLetter()) {"
      },
      {
        "txt": "String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name); t.dataBuffer.append(name); return; } boolean needsExitTransition = false; if (t.isAppropriateEndTagToken() && !r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t':"
      },
      {
        "txt": "case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>':"
      },
      {
        "txt": "t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); needsExitTransition = true; } } else { needsExitTransition = true; }"
      },
      {
        "txt": "if (needsExitTransition) { t.emit(\"</\" + t.dataBuffer.toString()); t.transition(elseTransition); } } private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) { switch (r.current()) { case '<': t.advanceTransition(advance); break;"
      },
      {
        "txt": "case nullChar: t.error(current); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('<', nullChar);"
      },
      {
        "txt": "t.emit(data); break; } } private static void readCharRef(Tokeniser t, TokeniserState advance) { int[] c = t.consumeCharacterReference(null, false); if (c == null) t.emit('&'); else t.emit(c);"
      },
      {
        "txt": "t.transition(advance); } private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) { if (r.matchesLetter()) { t.createTagPending(false); t.transition(a); } else { t.emit(\"</\"); t.transition(b); }"
      },
      {
        "txt": "} private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.dataBuffer.append(name); t.emit(name); return; } char c = r.consume(); switch (c) {"
      },
      {
        "txt": "case '\\t': case '\\n': case '\\r': case '\\f': case ' ': case '/': case '>': if (t.dataBuffer.toString().equals(\"script\")) t.transition(primary); else"
      },
      {
        "txt": "t.transition(fallback); t.emit(c); break; default: r.unconsume(); t.transition(fallback); } }"
      }
    ]
  },
  {
    "id": 2000,
    "file_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
    "start-bug-line": 100,
    "end-bug-line": 100,
    "bug": "DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);",
    "fix": "DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import org.jsoup.Jsoup; import org.jsoup.helper.Validate; import org.jsoup.nodes.*; import java.util.List; public class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings() { return ParseSettings.preserveCase; } Document parse(String input, String baseUri) { return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);"
      },
      {
        "txt": "} @Override protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) { super.initialiseParse(input, baseUri, errors, settings); stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack) doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml); } @Override protected boolean process(Token token) { switch (token.type) {"
      },
      {
        "txt": "case StartTag: insert(token.asStartTag()); break; case EndTag: popStackToClose(token.asEndTag()); break; case Comment: insert(token.asComment()); break; case Character:"
      },
      {
        "txt": "insert(token.asCharacter()); break; case Doctype: insert(token.asDoctype()); break; case EOF: // could put some normalisation here if desired break; default: Validate.fail(\"Unexpected token type: \" + token.type); }"
      },
      {
        "txt": "return true; } private void insertNode(Node node) { currentElement().appendChild(node); } Element insert(Token.StartTag startTag) { Tag tag = Tag.valueOf(startTag.name(), settings); Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes)); insertNode(el); if (startTag.isSelfClosing()) {"
      },
      {
        "txt": "tokeniser.acknowledgeSelfClosingFlag(); if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above. tag.setSelfClosing(); } else { stack.add(el); } return el; } void insert(Token.Comment commentToken) { Comment comment = new Comment(commentToken.getData(), baseUri);"
      },
      {
        "txt": "Node insert = comment; if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml) String data = comment.getData(); if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) { Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser()); Element el = doc.child(0); insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), comment.baseUri(), data.startsWith(\"!\")); insert.attributes().addAll(el.attributes()); } }"
      },
      {
        "txt": "} void insert(Token.Character characterToken) { Node node = new TextNode(characterToken.getData(), baseUri); insertNode(node); } void insert(Token.Doctype d) { <extra_id_0> insertNode(doctypeNode); } private void popStackToClose(Token.EndTag endTag) { String elName = endTag.name(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) {"
      },
      {
        "txt": "Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; // not found, skip"
      },
      {
        "txt": "for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } } List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) { initialiseParse(inputFragment, baseUri, errors, settings); runParser();"
      },
      {
        "txt": "return doc.childNodes(); }"
      }
    ]
  }
]