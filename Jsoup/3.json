[
  {
    "id": 1850,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 270,
    "end-bug-line": 270,
    "bug": "Element fragment = Parser.parseBodyFragment(html, baseUri).body();",
    "fix": "Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.apache.commons.lang.Validate; import org.apache.commons.lang.StringUtils; import org.jsoup.parser.Parser; import org.jsoup.parser.Tag; import org.jsoup.select.Collector; import org.jsoup.select.Elements; import org.jsoup.select.Selector;"
      },
      {
        "txt": "import java.util.*; public class Element extends Node { private final Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes) { super(baseUri, attributes); Validate.notNull(tag); this.tag = tag; } public Element(Tag tag, String baseUri) {"
      },
      {
        "txt": "this(tag, baseUri, new Attributes()); } @Override public String nodeName() { return tag.getName(); } public String tagName() { return tag.getName(); } public Tag tag() {"
      },
      {
        "txt": "return tag; } public boolean isBlock() { return tag.isBlock(); } public String id() { String id = attr(\"id\"); return id == null ? \"\" : id; } public Element attr(String attributeKey, String attributeValue) {"
      },
      {
        "txt": "super.attr(attributeKey, attributeValue); return this; } @Override public Element parent() { return (Element) super.parent(); } public Elements parents() { Elements parents = new Elements(); accumulateParents(this, parents);"
      },
      {
        "txt": "return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent(); if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents); } } public Element child(int index) {"
      },
      {
        "txt": "return children().get(index); } public Elements children() { List<Element> elements = new ArrayList<Element>(); for (Node node : childNodes) { if (node instanceof Element) elements.add((Element) node); } return new Elements(elements); }"
      },
      {
        "txt": "public Elements select(String query) { return Selector.select(query, this); } public Element appendChild(Node child) { Validate.notNull(child); child.setParentNode(this); childNodes.add(child); return this; } public Element prependChild(Node child) {"
      },
      {
        "txt": "Validate.notNull(child); child.setParentNode(this); childNodes.add(0, child); return this; } public Element appendElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); appendChild(child); return child; }"
      },
      {
        "txt": "public Element prependElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child; } public Element appendText(String text) { TextNode node = new TextNode(text, baseUri()); appendChild(node); return this; }"
      },
      {
        "txt": "TextNode node = new TextNode(text, baseUri()); prependChild(node); return this; } public Element append(String html) { Validate.notNull(html); <extra_id_0> for (Node node : fragment.childNodes()) { node.parentNode = null; appendChild(node); } return this; }"
      },
      {
        "txt": "return this; } public Element prepend(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i); node.parentNode = null; prependChild(node);"
      },
      {
        "txt": "} return this; } public Element empty() { childNodes.clear(); return this; } Wrap the supplied HTML around this element. @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitralily deep. @return this element, for chaining."
      },
      {
        "txt": "public Element wrap(String html) { Validate.notEmpty(html); Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); Elements wrapChildren = wrapBody.children(); Element wrap = wrapChildren.first(); if (wrap == null) // nothing to wrap with; noop return null; Element deepest = getDeepChild(wrap); parentNode.replaceChild(this, wrap); deepest.addChild(this);"
      },
      {
        "txt": "if (wrapChildren.size() > 1) { for (int i = 1; i < wrapChildren.size(); i++) { // skip first Element remainder = wrapChildren.get(i); remainder.parentNode.removeChild(remainder); wrap.appendChild(remainder); } } return this; } private Element getDeepChild(Element el) {"
      },
      {
        "txt": "List<Element> children = el.children(); if (children.size() > 0) return getDeepChild(children.get(0)); else return el; } public Elements siblingElements() { return parent().children(); } public Element nextElementSibling() {"
      },
      {
        "txt": "List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); else return null; } public Element previousElementSibling() { List<Element> siblings = parent().children();"
      },
      {
        "txt": "Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1); else return null; } public Element firstElementSibling() { List<Element> siblings = parent().children(); return siblings.size() > 1 ? siblings.get(0) : null;"
      },
      {
        "txt": "} public Integer elementSiblingIndex() { if (parent() == null) return 0; return indexInList(this, parent().children()); } public Element lastElementSibling() { List<Element> siblings = parent().children(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; } public Elements getElementsByTag(String tagName) {"
      },
      {
        "txt": "Validate.notEmpty(tagName); tagName = tagName.toLowerCase().trim(); return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) { Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this); if (elements.size() > 0) return elements.get(0); else"
      },
      {
        "txt": "return null; } public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this); } public Elements getElementsByAttribute(String key) { Validate.notEmpty(key); key = key.trim().toLowerCase(); return Collector.collect(new Evaluator.Attribute(key), this);"
      },
      {
        "txt": "} public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); } public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); } public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); }"
      },
      {
        "txt": "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); } public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this); } public Elements getElementsByIndexGreaterThan(int index) {"
      },
      {
        "txt": "return Collector.collect(new Evaluator.IndexGreaterThan(index), this); } public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); } public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); } public String text() { StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "text(sb); return sb.toString().trim(); } private void text(StringBuilder accum) { for (Node child : childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; String text = textNode.getWholeText(); if (!preserveWhitespace()) { text = TextNode.normaliseWhitespace(text);"
      },
      {
        "txt": "if (TextNode.lastCharIsWhitespace(accum)) text = TextNode.stripLeadingWhitespace(text); } accum.append(text); } else if (child instanceof Element) { Element element = (Element) child; if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) accum.append(\" \"); element.text(accum); }"
      },
      {
        "txt": "} } boolean preserveWhitespace() { return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace(); } public Element text(String text) { Validate.notNull(text); empty(); TextNode textNode = new TextNode(text, baseUri); appendChild(textNode);"
      },
      {
        "txt": "return this; } Test if this element has any text content (that is not just whitespace). @return true if element has non-blank text content. public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; if (!textNode.isBlank()) return true;"
      },
      {
        "txt": "} else if (child instanceof Element) { Element el = (Element) child; if (el.hasText()) return true; } } return false; } public String data() { StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } }"
      },
      {
        "txt": "return sb.toString(); } public String className() { return attributes.hasKey(\"class\") ? attributes.get(\"class\") : \"\"; } public Set<String> classNames() { if (classNames == null) { String[] names = className().split(\"\\\\s+\"); classNames = new LinkedHashSet<String>(Arrays.asList(names)); }"
      },
      {
        "txt": "return classNames; } Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) { Validate.notNull(classNames); attributes.put(\"class\", StringUtils.join(classNames, \" \")); return this; }"
      },
      {
        "txt": "public boolean hasClass(String className) { return classNames().contains(className); } Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.add(className);"
      },
      {
        "txt": "classNames(classes); return this; } Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); classes.remove(className);"
      },
      {
        "txt": "classNames(classes); return this; } Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) { Validate.notNull(className); Set<String> classes = classNames(); if (classes.contains(className))"
      },
      {
        "txt": "classes.remove(className); else classes.add(className); classNames(classes); return this; } public String val() { if (tagName().equals(\"textarea\")) return text(); else"
      },
      {
        "txt": "return attr(\"value\"); } public Element val(String value) { if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value); return this; } void outerHtml(StringBuilder accum) {"
      },
      {
        "txt": "if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) indent(accum); accum .append(\"<\") .append(tagName()) .append(attributes.html()); if (childNodes.isEmpty() && tag.isEmpty()) { accum.append(\" />\"); } else { accum.append(\">\");"
      },
      {
        "txt": "html(accum); if (tag.canContainBlock()) indent(accum); accum.append(\"</\").append(tagName()).append(\">\"); } } public String html() { StringBuilder accum = new StringBuilder(); html(accum); return accum.toString().trim(); }"
      },
      {
        "txt": "private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); } public Element html(String html) { empty(); append(html); return this; } public String toString() {"
      },
      {
        "txt": "return outerHtml(); } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Element)) return false; if (!super.equals(o)) return false; Element element = (Element) o; if (tag != null ? !tag.equals(element.tag) : element.tag != null) return false; return true;"
      },
      {
        "txt": "} @Override public int hashCode() { int result = super.hashCode(); result = 31 * result + (tag != null ? tag.hashCode() : 0); return result; }"
      }
    ]
  },
  {
    "id": 1851,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 287,
    "end-bug-line": 287,
    "bug": "Element fragment = Parser.parseBodyFragment(html, baseUri).body();",
    "fix": "Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.apache.commons.lang.Validate; import org.apache.commons.lang.StringUtils; import org.jsoup.parser.Parser; import org.jsoup.parser.Tag; import org.jsoup.select.Collector; import org.jsoup.select.Elements;"
      },
      {
        "txt": "import org.jsoup.select.Selector; import java.util.*; public class Element extends Node { private final Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes) { super(baseUri, attributes); Validate.notNull(tag); this.tag = tag; }"
      },
      {
        "txt": "public Element(Tag tag, String baseUri) { this(tag, baseUri, new Attributes()); } @Override public String nodeName() { return tag.getName(); } public String tagName() { return tag.getName(); }"
      },
      {
        "txt": "public Tag tag() { return tag; } public boolean isBlock() { return tag.isBlock(); } public String id() { String id = attr(\"id\"); return id == null ? \"\" : id; }"
      },
      {
        "txt": "public Element attr(String attributeKey, String attributeValue) { super.attr(attributeKey, attributeValue); return this; } @Override public Element parent() { return (Element) super.parent(); } public Elements parents() { Elements parents = new Elements();"
      },
      {
        "txt": "accumulateParents(this, parents); return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent(); if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents); } }"
      },
      {
        "txt": "public Element child(int index) { return children().get(index); } public Elements children() { List<Element> elements = new ArrayList<Element>(); for (Node node : childNodes) { if (node instanceof Element) elements.add((Element) node); } return new Elements(elements);"
      },
      {
        "txt": "} public Elements select(String query) { return Selector.select(query, this); } public Element appendChild(Node child) { Validate.notNull(child); child.setParentNode(this); childNodes.add(child); return this; }"
      },
      {
        "txt": "public Element prependChild(Node child) { Validate.notNull(child); child.setParentNode(this); childNodes.add(0, child); return this; } public Element appendElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); appendChild(child); return child;"
      },
      {
        "txt": "} public Element prependElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child; } public Element appendText(String text) { TextNode node = new TextNode(text, baseUri()); appendChild(node); return this;"
      },
      {
        "txt": "} public Element prependText(String text) { TextNode node = new TextNode(text, baseUri()); prependChild(node); return this; } public Element append(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); for (Node node : fragment.childNodes()) {"
      },
      {
        "txt": "appendChild(node); } return this; } public Element prepend(String html) { Validate.notNull(html); <extra_id_0> List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i); node.parentNode = null; prependChild(node); }"
      },
      {
        "txt": "prependChild(node); } return this; } public Element empty() { childNodes.clear(); return this; } Wrap the supplied HTML around this element. @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitralily deep."
      },
      {
        "txt": "@return this element, for chaining. public Element wrap(String html) { Validate.notEmpty(html); Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); Elements wrapChildren = wrapBody.children(); Element wrap = wrapChildren.first(); if (wrap == null) // nothing to wrap with; noop return null; Element deepest = getDeepChild(wrap); parentNode.replaceChild(this, wrap);"
      },
      {
        "txt": "deepest.addChild(this); if (wrapChildren.size() > 1) { for (int i = 1; i < wrapChildren.size(); i++) { // skip first Element remainder = wrapChildren.get(i); remainder.parentNode.removeChild(remainder); wrap.appendChild(remainder); } } return this; }"
      },
      {
        "txt": "private Element getDeepChild(Element el) { List<Element> children = el.children(); if (children.size() > 0) return getDeepChild(children.get(0)); else return el; } public Elements siblingElements() { return parent().children(); }"
      },
      {
        "txt": "public Element nextElementSibling() { List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); else return null; } public Element previousElementSibling() {"
      },
      {
        "txt": "List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1); else return null; } public Element firstElementSibling() { List<Element> siblings = parent().children();"
      },
      {
        "txt": "return siblings.size() > 1 ? siblings.get(0) : null; } public Integer elementSiblingIndex() { if (parent() == null) return 0; return indexInList(this, parent().children()); } public Element lastElementSibling() { List<Element> siblings = parent().children(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; }"
      },
      {
        "txt": "public Elements getElementsByTag(String tagName) { Validate.notEmpty(tagName); tagName = tagName.toLowerCase().trim(); return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) { Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this); if (elements.size() > 0) return elements.get(0);"
      },
      {
        "txt": "else return null; } public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this); } public Elements getElementsByAttribute(String key) { Validate.notEmpty(key); key = key.trim().toLowerCase();"
      },
      {
        "txt": "return Collector.collect(new Evaluator.Attribute(key), this); } public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); } public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); } public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);"
      },
      {
        "txt": "} public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); } public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this); }"
      },
      {
        "txt": "public Elements getElementsByIndexGreaterThan(int index) { return Collector.collect(new Evaluator.IndexGreaterThan(index), this); } public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); } public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); } public String text() {"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); text(sb); return sb.toString().trim(); } private void text(StringBuilder accum) { for (Node child : childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; String text = textNode.getWholeText(); if (!preserveWhitespace()) {"
      },
      {
        "txt": "text = TextNode.normaliseWhitespace(text); if (TextNode.lastCharIsWhitespace(accum)) text = TextNode.stripLeadingWhitespace(text); } accum.append(text); } else if (child instanceof Element) { Element element = (Element) child; if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) accum.append(\" \"); element.text(accum);"
      },
      {
        "txt": "} } } boolean preserveWhitespace() { return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace(); } public Element text(String text) { Validate.notNull(text); empty(); TextNode textNode = new TextNode(text, baseUri);"
      },
      {
        "txt": "appendChild(textNode); return this; } Test if this element has any text content (that is not just whitespace). @return true if element has non-blank text content. public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child; if (!textNode.isBlank())"
      },
      {
        "txt": "return true; } else if (child instanceof Element) { Element el = (Element) child; if (el.hasText()) return true; } } return false; } public String data() {"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); }"
      },
      {
        "txt": "} return sb.toString(); } public String className() { return attributes.hasKey(\"class\") ? attributes.get(\"class\") : \"\"; } public Set<String> classNames() { if (classNames == null) { String[] names = className().split(\"\\\\s+\"); classNames = new LinkedHashSet<String>(Arrays.asList(names));"
      },
      {
        "txt": "} return classNames; } Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) { Validate.notNull(classNames); attributes.put(\"class\", StringUtils.join(classNames, \" \")); return this;"
      },
      {
        "txt": "} public boolean hasClass(String className) { return classNames().contains(className); } Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) { Validate.notNull(className); Set<String> classes = classNames();"
      },
      {
        "txt": "classes.add(className); classNames(classes); return this; } Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) { Validate.notNull(className); Set<String> classes = classNames();"
      },
      {
        "txt": "classes.remove(className); classNames(classes); return this; } Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) { Validate.notNull(className); Set<String> classes = classNames();"
      },
      {
        "txt": "if (classes.contains(className)) classes.remove(className); else classes.add(className); classNames(classes); return this; } public String val() { if (tagName().equals(\"textarea\")) return text();"
      },
      {
        "txt": "else return attr(\"value\"); } public Element val(String value) { if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value); return this; }"
      },
      {
        "txt": "void outerHtml(StringBuilder accum) { if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) indent(accum); accum .append(\"<\") .append(tagName()) .append(attributes.html()); if (childNodes.isEmpty() && tag.isEmpty()) { accum.append(\" />\"); } else {"
      },
      {
        "txt": "accum.append(\">\"); html(accum); if (tag.canContainBlock()) indent(accum); accum.append(\"</\").append(tagName()).append(\">\"); } } public String html() { StringBuilder accum = new StringBuilder(); html(accum); return accum.toString().trim();"
      },
      {
        "txt": "} private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); } public Element html(String html) { empty(); append(html); return this; }"
      },
      {
        "txt": "public String toString() { return outerHtml(); } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Element)) return false; if (!super.equals(o)) return false; Element element = (Element) o; if (tag != null ? !tag.equals(element.tag) : element.tag != null) return false;"
      },
      {
        "txt": "return true; } @Override public int hashCode() { int result = super.hashCode(); result = 31 * result + (tag != null ? tag.hashCode() : 0); return result; }"
      }
    ]
  },
  {
    "id": 1852,
    "file_path": "src/main/java/org/jsoup/nodes/Element.java",
    "start-bug-line": 314,
    "end-bug-line": 314,
    "bug": "Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();",
    "fix": "Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.nodes; import org.apache.commons.lang.Validate; import org.apache.commons.lang.StringUtils; import org.jsoup.parser.Parser; import org.jsoup.parser.Tag;"
      },
      {
        "txt": "import org.jsoup.select.Collector; import org.jsoup.select.Elements; import org.jsoup.select.Selector; import java.util.*; public class Element extends Node { private final Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes) { super(baseUri, attributes); Validate.notNull(tag);"
      },
      {
        "txt": "this.tag = tag; } public Element(Tag tag, String baseUri) { this(tag, baseUri, new Attributes()); } @Override public String nodeName() { return tag.getName(); } public String tagName() {"
      },
      {
        "txt": "return tag.getName(); } public Tag tag() { return tag; } public boolean isBlock() { return tag.isBlock(); } public String id() { String id = attr(\"id\");"
      },
      {
        "txt": "return id == null ? \"\" : id; } public Element attr(String attributeKey, String attributeValue) { super.attr(attributeKey, attributeValue); return this; } @Override public Element parent() { return (Element) super.parent(); }"
      },
      {
        "txt": "public Elements parents() { Elements parents = new Elements(); accumulateParents(this, parents); return parents; } private static void accumulateParents(Element el, Elements parents) { Element parent = el.parent(); if (parent != null && !parent.tagName().equals(\"#root\")) { parents.add(parent); accumulateParents(parent, parents);"
      },
      {
        "txt": "} } public Element child(int index) { return children().get(index); } public Elements children() { List<Element> elements = new ArrayList<Element>(); for (Node node : childNodes) { if (node instanceof Element) elements.add((Element) node);"
      },
      {
        "txt": "} return new Elements(elements); } public Elements select(String query) { return Selector.select(query, this); } public Element appendChild(Node child) { Validate.notNull(child); child.setParentNode(this); childNodes.add(child);"
      },
      {
        "txt": "return this; } public Element prependChild(Node child) { Validate.notNull(child); child.setParentNode(this); childNodes.add(0, child); return this; } public Element appendElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri());"
      },
      {
        "txt": "appendChild(child); return child; } public Element prependElement(String tagName) { Element child = new Element(Tag.valueOf(tagName), baseUri()); prependChild(child); return child; } public Element appendText(String text) { TextNode node = new TextNode(text, baseUri());"
      },
      {
        "txt": "appendChild(node); return this; } public Element prependText(String text) { TextNode node = new TextNode(text, baseUri()); prependChild(node); return this; } public Element append(String html) { Validate.notNull(html);"
      },
      {
        "txt": "Element fragment = Parser.parseBodyFragment(html, baseUri).body(); for (Node node : fragment.childNodes()) { node.parentNode = null; appendChild(node); } return this; } public Element prepend(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body();"
      },
      {
        "txt": "List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i); node.parentNode = null; prependChild(node); } return this; } public Element empty() { childNodes.clear();"
      },
      {
        "txt": "} Wrap the supplied HTML around this element. @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitralily deep. @return this element, for chaining. public Element wrap(String html) { Validate.notEmpty(html); <extra_id_0> Elements wrapChildren = wrapBody.children(); Element wrap = wrapChildren.first(); if (wrap == null) // nothing to wrap with; noop return null; Element deepest = getDeepChild(wrap); parentNode.replaceChild(this, wrap);"
      },
      {
        "txt": "Element deepest = getDeepChild(wrap); parentNode.replaceChild(this, wrap); deepest.addChild(this); if (wrapChildren.size() > 1) { for (int i = 1; i < wrapChildren.size(); i++) { // skip first Element remainder = wrapChildren.get(i); remainder.parentNode.removeChild(remainder); wrap.appendChild(remainder); } }"
      },
      {
        "txt": "return this; } private Element getDeepChild(Element el) { List<Element> children = el.children(); if (children.size() > 0) return getDeepChild(children.get(0)); else return el; } public Elements siblingElements() {"
      },
      {
        "txt": "return parent().children(); } public Element nextElementSibling() { List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); else return null;"
      },
      {
        "txt": "} public Element previousElementSibling() { List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1); else return null; }"
      },
      {
        "txt": "public Element firstElementSibling() { List<Element> siblings = parent().children(); return siblings.size() > 1 ? siblings.get(0) : null; } public Integer elementSiblingIndex() { if (parent() == null) return 0; return indexInList(this, parent().children()); } public Element lastElementSibling() { List<Element> siblings = parent().children();"
      },
      {
        "txt": "return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; } public Elements getElementsByTag(String tagName) { Validate.notEmpty(tagName); tagName = tagName.toLowerCase().trim(); return Collector.collect(new Evaluator.Tag(tagName), this); } public Element getElementById(String id) { Validate.notEmpty(id); Elements elements = Collector.collect(new Evaluator.Id(id), this);"
      },
      {
        "txt": "if (elements.size() > 0) return elements.get(0); else return null; } public Elements getElementsByClass(String className) { Validate.notEmpty(className); return Collector.collect(new Evaluator.Class(className), this); } public Elements getElementsByAttribute(String key) {"
      },
      {
        "txt": "Validate.notEmpty(key); key = key.trim().toLowerCase(); return Collector.collect(new Evaluator.Attribute(key), this); } public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); } public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); }"
      },
      {
        "txt": "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); } public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); } public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); } public Elements getElementsByIndexLessThan(int index) {"
      },
      {
        "txt": "return Collector.collect(new Evaluator.IndexLessThan(index), this); } public Elements getElementsByIndexGreaterThan(int index) { return Collector.collect(new Evaluator.IndexGreaterThan(index), this); } public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); } public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this);"
      },
      {
        "txt": "} public String text() { StringBuilder sb = new StringBuilder(); text(sb); return sb.toString().trim(); } private void text(StringBuilder accum) { for (Node child : childNodes) { if (child instanceof TextNode) { TextNode textNode = (TextNode) child;"
      },
      {
        "txt": "String text = textNode.getWholeText(); if (!preserveWhitespace()) { text = TextNode.normaliseWhitespace(text); if (TextNode.lastCharIsWhitespace(accum)) text = TextNode.stripLeadingWhitespace(text); } accum.append(text); } else if (child instanceof Element) { Element element = (Element) child; if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))"
      },
      {
        "txt": "accum.append(\" \"); element.text(accum); } } } boolean preserveWhitespace() { return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace(); } public Element text(String text) { Validate.notNull(text);"
      },
      {
        "txt": "empty(); TextNode textNode = new TextNode(text, baseUri); appendChild(textNode); return this; } Test if this element has any text content (that is not just whitespace). @return true if element has non-blank text content. public boolean hasText() { for (Node child: childNodes) { if (child instanceof TextNode) {"
      },
      {
        "txt": "TextNode textNode = (TextNode) child; if (!textNode.isBlank()) return true; } else if (child instanceof Element) { Element el = (Element) child; if (el.hasText()) return true; } } return false;"
      },
      {
        "txt": "} public String data() { StringBuilder sb = new StringBuilder(); for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data();"
      },
      {
        "txt": "sb.append(elementData); } } return sb.toString(); } public String className() { return attributes.hasKey(\"class\") ? attributes.get(\"class\") : \"\"; } public Set<String> classNames() { if (classNames == null) {"
      },
      {
        "txt": "String[] names = className().split(\"\\\\s+\"); classNames = new LinkedHashSet<String>(Arrays.asList(names)); } return classNames; } Set the element's {@code class} attribute to the supplied class names. @param classNames set of classes @return this element, for chaining public Element classNames(Set<String> classNames) { Validate.notNull(classNames);"
      },
      {
        "txt": "attributes.put(\"class\", StringUtils.join(classNames, \" \")); return this; } public boolean hasClass(String className) { return classNames().contains(className); } Add a class name to this element's {@code class} attribute. @param className class name to add @return this element public Element addClass(String className) {"
      },
      {
        "txt": "Validate.notNull(className); Set<String> classes = classNames(); classes.add(className); classNames(classes); return this; } Remove a class name from this element's {@code class} attribute. @param className class name to remove @return this element public Element removeClass(String className) {"
      },
      {
        "txt": "Validate.notNull(className); Set<String> classes = classNames(); classes.remove(className); classNames(classes); return this; } Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it. @param className class name to toggle @return this element public Element toggleClass(String className) {"
      },
      {
        "txt": "Validate.notNull(className); Set<String> classes = classNames(); if (classes.contains(className)) classes.remove(className); else classes.add(className); classNames(classes); return this; } public String val() {"
      },
      {
        "txt": "if (tagName().equals(\"textarea\")) return text(); else return attr(\"value\"); } public Element val(String value) { if (tagName().equals(\"textarea\")) text(value); else attr(\"value\", value);"
      },
      {
        "txt": "return this; } void outerHtml(StringBuilder accum) { if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) indent(accum); accum .append(\"<\") .append(tagName()) .append(attributes.html()); if (childNodes.isEmpty() && tag.isEmpty()) {"
      },
      {
        "txt": "accum.append(\" />\"); } else { accum.append(\">\"); html(accum); if (tag.canContainBlock()) indent(accum); accum.append(\"</\").append(tagName()).append(\">\"); } } public String html() { StringBuilder accum = new StringBuilder();"
      },
      {
        "txt": "html(accum); return accum.toString().trim(); } private void html(StringBuilder accum) { for (Node node : childNodes) node.outerHtml(accum); } public Element html(String html) { empty(); append(html);"
      },
      {
        "txt": "return this; } public String toString() { return outerHtml(); } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Element)) return false; if (!super.equals(o)) return false;"
      },
      {
        "txt": "Element element = (Element) o; if (tag != null ? !tag.equals(element.tag) : element.tag != null) return false; return true; } @Override public int hashCode() { int result = super.hashCode(); result = 31 * result + (tag != null ? tag.hashCode() : 0); return result; }"
      }
    ]
  },
  {
    "id": 1853,
    "file_path": "src/main/java/org/jsoup/parser/Parser.java",
    "start-bug-line": 26,
    "end-bug-line": 26,
    "bug": "",
    "fix": "private boolean relaxed = false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import org.apache.commons.lang.Validate; import org.jsoup.nodes.*; import java.util.*; Parses HTML into a {@link Document}. Generally best to use one of the more convenient parse methods in {@link org.jsoup.Jsoup}. @author Jonathan Hedley, jonathan@hedley.net */ public class Parser { private static final String SQ = \"'\"; private static final String DQ = \"\\\"\"; private static final Tag htmlTag = Tag.valueOf(\"html\"); private static final Tag headTag = Tag.valueOf(\"head\");"
      },
      {
        "txt": "private static final Tag titleTag = Tag.valueOf(\"title\"); private static final Tag textareaTag = Tag.valueOf(\"textarea\"); private final LinkedList<Element> stack; private final TokenQueue tq; private final Document doc; private String baseUri; <extra_id_0> private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html); Validate.notNull(baseUri); stack = new LinkedList<Element>(); tq = new TokenQueue(html); this.baseUri = baseUri;"
      },
      {
        "txt": "tq = new TokenQueue(html); this.baseUri = baseUri; if (isBodyFragment) { doc = Document.createShell(baseUri); stack.add(doc.body()); } else { doc = new Document(baseUri); stack.add(doc); } }"
      },
      {
        "txt": "Parse HTML into a Document. @param html HTML to parse @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return parsed Document public static Document parse(String html, String baseUri) { Parser parser = new Parser(html, baseUri, false); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document. @param bodyHtml fragment of HTML"
      },
      {
        "txt": "@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body public static Document parseBodyFragment(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this context, means that implicit tags are not automatically created when missing. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs."
      },
      {
        "txt": "@return Document, with empty head, and HTML parsed into body private Document parse() { while (!tq.isEmpty()) { if (tq.matches(\"<!--\")) { parseComment(); } else if (tq.matches(\"<![CDATA[\")) { parseCdata(); } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) { parseXmlDecl(); } else if (tq.matches(\"</\")) {"
      },
      {
        "txt": "parseEndTag(); } else if (tq.matches(\"<\")) { parseStartTag(); } else { parseTextNode(); } } return doc.normalise(); } private void parseComment() {"
      },
      {
        "txt": "tq.consume(\"<!--\"); String data = tq.chompTo(\"->\"); if (data.endsWith(\"-\")) // i.e. was --> data = data.substring(0, data.length()-1); Comment comment = new Comment(data, baseUri); last().appendChild(comment); } private void parseXmlDecl() { tq.consume(\"<\"); Character firstChar = tq.consume(); // <? or <!, from initial match."
      },
      {
        "txt": "boolean procInstr = firstChar.toString().equals(\"!\"); String data = tq.chompTo(\">\"); XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr); last().appendChild(decl); } private void parseEndTag() { tq.consume(\"</\"); String tagName = tq.consumeWord(); tq.chompTo(\">\"); if (tagName.length() != 0) {"
      },
      {
        "txt": "Tag tag = Tag.valueOf(tagName); popStackToClose(tag); } } private void parseStartTag() { tq.consume(\"<\"); String tagName = tq.consumeWord(); if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text tq.addFirst(\"&lt;\"); parseTextNode();"
      },
      {
        "txt": "return; } Attributes attributes = new Attributes(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) { Attribute attribute = parseAttribute(); if (attribute != null) attributes.put(attribute); } Tag tag = Tag.valueOf(tagName); Element child = new Element(tag, baseUri, attributes);"
      },
      {
        "txt": "boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/> if (tq.matchChomp(\"/>\")) { // close empty element or tag isEmptyElement = true; } else { tq.matchChomp(\">\"); } addChildToParent(child, isEmptyElement); if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); tq.chompTo(\">\");"
      },
      {
        "txt": "popStackToClose(tag); Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.createFromEncoded(data, baseUri); else dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script) child.appendChild(dataNode); } if (child.tagName().equals(\"base\")) { String href = child.absUrl(\"href\");"
      },
      {
        "txt": "if (href.length() != 0) { // ignore <base target> etc baseUri = href; doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base } } } private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = \"\";"
      },
      {
        "txt": "tq.consumeWhitespace(); if (tq.matchChomp(\"=\")) { tq.consumeWhitespace(); if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {"
      },
      {
        "txt": "valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume(); // unknown char, keep popping so not get stuck"
      },
      {
        "txt": "return null; } } private void parseTextNode() { String text = tq.consumeTo(\"<\"); TextNode textNode = TextNode.createFromEncoded(text, baseUri); last().appendChild(textNode); } private void parseCdata() { tq.consume(\"<![CDATA[\");"
      },
      {
        "txt": "String rawText = tq.chompTo(\"]]>\"); TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape last().appendChild(textNode); } private Element addChildToParent(Element child, boolean isEmptyElement) { Element parent = popStackToSuitableContainer(child.tag()); Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor) { Tag parentTag = childTag.getImplicitParent();"
      },
      {
        "txt": "Element implicit = new Element(parentTag, baseUri); if (child.tag().equals(bodyTag)) { Element head = new Element(headTag, baseUri); implicit.appendChild(head); } implicit.appendChild(child); Element root = addChildToParent(implicit, false); if (!isEmptyElement) stack.addLast(child); return root;"
      },
      {
        "txt": "} parent.appendChild(child); if (!isEmptyElement) stack.addLast(child); return parent; } private boolean stackHasValidParent(Tag childTag) { if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node for (int i = stack.size() -1; i >= 0; i--) {"
      },
      {
        "txt": "Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidParent(childTag)) { return true; } } return false; } private Element popStackToSuitableContainer(Tag tag) { while (!stack.isEmpty()) {"
      },
      {
        "txt": "if (last().tag().canContain(tag)) return last(); else stack.removeLast(); } return null; } private Element popStackToClose(Tag tag) { int counter = 0; Element elToClose = null;"
      },
      {
        "txt": "for (int i = stack.size() -1; i > 0; i--) { counter++; Element el = stack.get(i); Tag elTag = el.tag(); if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body break; } else if (elTag.equals(tag)) { elToClose = el; break; }"
      },
      {
        "txt": "} if (elToClose != null) { for (int i = 0; i < counter; i++) { stack.removeLast(); } } return elToClose; } private Element last() { return stack.getLast();"
      }
    ]
  },
  {
    "id": 1854,
    "file_path": "src/main/java/org/jsoup/parser/Parser.java",
    "start-bug-line": 73,
    "end-bug-line": 73,
    "bug": "",
    "fix": "public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); parser.relaxed = true; return parser.parse(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import org.jsoup.nodes.*; import java.util.*; Parses HTML into a {@link Document}. Generally best to use one of the more convenient parse methods in {@link org.jsoup.Jsoup}. @author Jonathan Hedley, jonathan@hedley.net */"
      },
      {
        "txt": "public class Parser { private static final String SQ = \"'\"; private static final String DQ = \"\\\"\"; private static final Tag htmlTag = Tag.valueOf(\"html\"); private static final Tag headTag = Tag.valueOf(\"head\"); private static final Tag bodyTag = Tag.valueOf(\"body\"); private static final Tag titleTag = Tag.valueOf(\"title\"); private static final Tag textareaTag = Tag.valueOf(\"textarea\"); private final LinkedList<Element> stack; private final TokenQueue tq;"
      },
      {
        "txt": "private final Document doc; private String baseUri; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html); Validate.notNull(baseUri); stack = new LinkedList<Element>(); tq = new TokenQueue(html); this.baseUri = baseUri; if (isBodyFragment) { doc = Document.createShell(baseUri);"
      },
      {
        "txt": "stack.add(doc.body()); } else { doc = new Document(baseUri); stack.add(doc); } } Parse HTML into a Document. @param html HTML to parse @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return parsed Document"
      },
      {
        "txt": "public static Document parse(String html, String baseUri) { Parser parser = new Parser(html, baseUri, false); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body public static Document parseBodyFragment(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true);"
      },
      {
        "txt": "} Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this context, means that implicit tags are not automatically created when missing. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body <extra_id_0> private Document parse() { while (!tq.isEmpty()) { if (tq.matches(\"<!--\")) { parseComment(); } else if (tq.matches(\"<![CDATA[\")) { parseCdata();"
      },
      {
        "txt": "} else if (tq.matches(\"<![CDATA[\")) { parseCdata(); } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) { parseXmlDecl(); } else if (tq.matches(\"</\")) { parseEndTag(); } else if (tq.matches(\"<\")) { parseStartTag(); } else { parseTextNode();"
      },
      {
        "txt": "} } return doc.normalise(); } private void parseComment() { tq.consume(\"<!--\"); String data = tq.chompTo(\"->\"); if (data.endsWith(\"-\")) // i.e. was --> data = data.substring(0, data.length()-1); Comment comment = new Comment(data, baseUri);"
      },
      {
        "txt": "last().appendChild(comment); } private void parseXmlDecl() { tq.consume(\"<\"); Character firstChar = tq.consume(); // <? or <!, from initial match. boolean procInstr = firstChar.toString().equals(\"!\"); String data = tq.chompTo(\">\"); XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr); last().appendChild(decl); }"
      },
      {
        "txt": "private void parseEndTag() { tq.consume(\"</\"); String tagName = tq.consumeWord(); tq.chompTo(\">\"); if (tagName.length() != 0) { Tag tag = Tag.valueOf(tagName); popStackToClose(tag); } } private void parseStartTag() {"
      },
      {
        "txt": "tq.consume(\"<\"); String tagName = tq.consumeWord(); if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text tq.addFirst(\"&lt;\"); parseTextNode(); return; } Attributes attributes = new Attributes(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) { Attribute attribute = parseAttribute();"
      },
      {
        "txt": "if (attribute != null) attributes.put(attribute); } Tag tag = Tag.valueOf(tagName); Element child = new Element(tag, baseUri, attributes); boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/> if (tq.matchChomp(\"/>\")) { // close empty element or tag isEmptyElement = true; } else { tq.matchChomp(\">\");"
      },
      {
        "txt": "} addChildToParent(child, isEmptyElement); if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); tq.chompTo(\">\"); popStackToClose(tag); Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.createFromEncoded(data, baseUri); else"
      },
      {
        "txt": "dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script) child.appendChild(dataNode); } if (child.tagName().equals(\"base\")) { String href = child.absUrl(\"href\"); if (href.length() != 0) { // ignore <base target> etc baseUri = href; doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base } }"
      },
      {
        "txt": "} private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = \"\"; tq.consumeWhitespace(); if (tq.matchChomp(\"=\")) { tq.consumeWhitespace(); if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ);"
      },
      {
        "txt": "} else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace();"
      },
      {
        "txt": "} if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume(); // unknown char, keep popping so not get stuck return null; } } private void parseTextNode() { String text = tq.consumeTo(\"<\");"
      },
      {
        "txt": "TextNode textNode = TextNode.createFromEncoded(text, baseUri); last().appendChild(textNode); } private void parseCdata() { tq.consume(\"<![CDATA[\"); String rawText = tq.chompTo(\"]]>\"); TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape last().appendChild(textNode); } private Element addChildToParent(Element child, boolean isEmptyElement) {"
      },
      {
        "txt": "Element parent = popStackToSuitableContainer(child.tag()); Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor) { Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri); if (child.tag().equals(bodyTag)) { Element head = new Element(headTag, baseUri); implicit.appendChild(head); }"
      },
      {
        "txt": "implicit.appendChild(child); Element root = addChildToParent(implicit, false); if (!isEmptyElement) stack.addLast(child); return root; } parent.appendChild(child); if (!isEmptyElement) stack.addLast(child); return parent;"
      },
      {
        "txt": "} private boolean stackHasValidParent(Tag childTag) { if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidParent(childTag)) { return true; }"
      },
      {
        "txt": "} return false; } private Element popStackToSuitableContainer(Tag tag) { while (!stack.isEmpty()) { if (last().tag().canContain(tag)) return last(); else stack.removeLast(); }"
      },
      {
        "txt": "return null; } private Element popStackToClose(Tag tag) { int counter = 0; Element elToClose = null; for (int i = stack.size() -1; i > 0; i--) { counter++; Element el = stack.get(i); Tag elTag = el.tag(); if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body"
      },
      {
        "txt": "break; } else if (elTag.equals(tag)) { elToClose = el; break; } } if (elToClose != null) { for (int i = 0; i < counter; i++) { stack.removeLast(); }"
      },
      {
        "txt": "} return elToClose; } private Element last() { return stack.getLast(); }"
      }
    ]
  },
  {
    "id": 1855,
    "file_path": "src/main/java/org/jsoup/parser/Parser.java",
    "start-bug-line": 224,
    "end-bug-line": 224,
    "bug": "if (!validAncestor) {",
    "fix": "if (!validAncestor && !relaxed) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import org.jsoup.nodes.*;"
      },
      {
        "txt": "import java.util.*; Parses HTML into a {@link Document}. Generally best to use one of the more convenient parse methods in {@link org.jsoup.Jsoup}. @author Jonathan Hedley, jonathan@hedley.net */ public class Parser { private static final String SQ = \"'\"; private static final String DQ = \"\\\"\"; private static final Tag htmlTag = Tag.valueOf(\"html\"); private static final Tag headTag = Tag.valueOf(\"head\"); private static final Tag bodyTag = Tag.valueOf(\"body\"); private static final Tag titleTag = Tag.valueOf(\"title\");"
      },
      {
        "txt": "private static final Tag textareaTag = Tag.valueOf(\"textarea\"); private final LinkedList<Element> stack; private final TokenQueue tq; private final Document doc; private String baseUri; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html); Validate.notNull(baseUri); stack = new LinkedList<Element>(); tq = new TokenQueue(html);"
      },
      {
        "txt": "this.baseUri = baseUri; if (isBodyFragment) { doc = Document.createShell(baseUri); stack.add(doc.body()); } else { doc = new Document(baseUri); stack.add(doc); } } Parse HTML into a Document."
      },
      {
        "txt": "@param html HTML to parse @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return parsed Document public static Document parse(String html, String baseUri) { Parser parser = new Parser(html, baseUri, false); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs."
      },
      {
        "txt": "@return Document, with empty head, and HTML parsed into body public static Document parseBodyFragment(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this context, means that implicit tags are not automatically created when missing. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body"
      },
      {
        "txt": "private Document parse() { while (!tq.isEmpty()) { if (tq.matches(\"<!--\")) { parseComment(); } else if (tq.matches(\"<![CDATA[\")) { parseCdata(); } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) { parseXmlDecl(); } else if (tq.matches(\"</\")) { parseEndTag();"
      },
      {
        "txt": "} else if (tq.matches(\"<\")) { parseStartTag(); } else { parseTextNode(); } } return doc.normalise(); } private void parseComment() { tq.consume(\"<!--\");"
      },
      {
        "txt": "String data = tq.chompTo(\"->\"); if (data.endsWith(\"-\")) // i.e. was --> data = data.substring(0, data.length()-1); Comment comment = new Comment(data, baseUri); last().appendChild(comment); } private void parseXmlDecl() { tq.consume(\"<\"); Character firstChar = tq.consume(); // <? or <!, from initial match. boolean procInstr = firstChar.toString().equals(\"!\");"
      },
      {
        "txt": "String data = tq.chompTo(\">\"); XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr); last().appendChild(decl); } private void parseEndTag() { tq.consume(\"</\"); String tagName = tq.consumeWord(); tq.chompTo(\">\"); if (tagName.length() != 0) { Tag tag = Tag.valueOf(tagName);"
      },
      {
        "txt": "popStackToClose(tag); } } private void parseStartTag() { tq.consume(\"<\"); String tagName = tq.consumeWord(); if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text tq.addFirst(\"&lt;\"); parseTextNode(); return;"
      },
      {
        "txt": "} Attributes attributes = new Attributes(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) { Attribute attribute = parseAttribute(); if (attribute != null) attributes.put(attribute); } Tag tag = Tag.valueOf(tagName); Element child = new Element(tag, baseUri, attributes); boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>"
      },
      {
        "txt": "if (tq.matchChomp(\"/>\")) { // close empty element or tag isEmptyElement = true; } else { tq.matchChomp(\">\"); } addChildToParent(child, isEmptyElement); if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); tq.chompTo(\">\"); popStackToClose(tag);"
      },
      {
        "txt": "Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.createFromEncoded(data, baseUri); else dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script) child.appendChild(dataNode); } if (child.tagName().equals(\"base\")) { String href = child.absUrl(\"href\"); if (href.length() != 0) { // ignore <base target> etc"
      },
      {
        "txt": "baseUri = href; doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base } } } private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = \"\"; tq.consumeWhitespace();"
      },
      {
        "txt": "if (tq.matchChomp(\"=\")) { tq.consumeWhitespace(); if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume());"
      },
      {
        "txt": "} value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume(); // unknown char, keep popping so not get stuck return null;"
      },
      {
        "txt": "} } private void parseTextNode() { String text = tq.consumeTo(\"<\"); TextNode textNode = TextNode.createFromEncoded(text, baseUri); last().appendChild(textNode); } private void parseCdata() { tq.consume(\"<![CDATA[\"); String rawText = tq.chompTo(\"]]>\");"
      },
      {
        "txt": "last().appendChild(textNode); } private Element addChildToParent(Element child, boolean isEmptyElement) { Element parent = popStackToSuitableContainer(child.tag()); Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); <extra_id_0> Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri); if (child.tag().equals(bodyTag)) { Element head = new Element(headTag, baseUri); implicit.appendChild(head); }"
      },
      {
        "txt": "implicit.appendChild(head); } implicit.appendChild(child); Element root = addChildToParent(implicit, false); if (!isEmptyElement) stack.addLast(child); return root; } parent.appendChild(child); if (!isEmptyElement)"
      },
      {
        "txt": "stack.addLast(child); return parent; } private boolean stackHasValidParent(Tag childTag) { if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidParent(childTag)) {"
      },
      {
        "txt": "return true; } } return false; } private Element popStackToSuitableContainer(Tag tag) { while (!stack.isEmpty()) { if (last().tag().canContain(tag)) return last(); else"
      },
      {
        "txt": "stack.removeLast(); } return null; } private Element popStackToClose(Tag tag) { int counter = 0; Element elToClose = null; for (int i = stack.size() -1; i > 0; i--) { counter++; Element el = stack.get(i);"
      },
      {
        "txt": "Tag elTag = el.tag(); if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body break; } else if (elTag.equals(tag)) { elToClose = el; break; } } if (elToClose != null) { for (int i = 0; i < counter; i++) {"
      },
      {
        "txt": "stack.removeLast(); } } return elToClose; } private Element last() { return stack.getLast(); }"
      }
    ]
  },
  {
    "id": 1856,
    "file_path": "src/main/java/org/jsoup/parser/Parser.java",
    "start-bug-line": 253,
    "end-bug-line": 253,
    "bug": "",
    "fix": "if (childTag.requiresSpecificParent()) return stack.getLast().tag().isValidParent(childTag);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import org.jsoup.nodes.*; import java.util.*;"
      },
      {
        "txt": "Parses HTML into a {@link Document}. Generally best to use one of the more convenient parse methods in {@link org.jsoup.Jsoup}. @author Jonathan Hedley, jonathan@hedley.net */ public class Parser { private static final String SQ = \"'\"; private static final String DQ = \"\\\"\"; private static final Tag htmlTag = Tag.valueOf(\"html\"); private static final Tag headTag = Tag.valueOf(\"head\"); private static final Tag bodyTag = Tag.valueOf(\"body\"); private static final Tag titleTag = Tag.valueOf(\"title\"); private static final Tag textareaTag = Tag.valueOf(\"textarea\");"
      },
      {
        "txt": "private final LinkedList<Element> stack; private final TokenQueue tq; private final Document doc; private String baseUri; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html); Validate.notNull(baseUri); stack = new LinkedList<Element>(); tq = new TokenQueue(html); this.baseUri = baseUri;"
      },
      {
        "txt": "if (isBodyFragment) { doc = Document.createShell(baseUri); stack.add(doc.body()); } else { doc = new Document(baseUri); stack.add(doc); } } Parse HTML into a Document. @param html HTML to parse"
      },
      {
        "txt": "@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return parsed Document public static Document parse(String html, String baseUri) { Parser parser = new Parser(html, baseUri, false); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body"
      },
      {
        "txt": "public static Document parseBodyFragment(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this context, means that implicit tags are not automatically created when missing. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body private Document parse() {"
      },
      {
        "txt": "while (!tq.isEmpty()) { if (tq.matches(\"<!--\")) { parseComment(); } else if (tq.matches(\"<![CDATA[\")) { parseCdata(); } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) { parseXmlDecl(); } else if (tq.matches(\"</\")) { parseEndTag(); } else if (tq.matches(\"<\")) {"
      },
      {
        "txt": "parseStartTag(); } else { parseTextNode(); } } return doc.normalise(); } private void parseComment() { tq.consume(\"<!--\"); String data = tq.chompTo(\"->\");"
      },
      {
        "txt": "if (data.endsWith(\"-\")) // i.e. was --> data = data.substring(0, data.length()-1); Comment comment = new Comment(data, baseUri); last().appendChild(comment); } private void parseXmlDecl() { tq.consume(\"<\"); Character firstChar = tq.consume(); // <? or <!, from initial match. boolean procInstr = firstChar.toString().equals(\"!\"); String data = tq.chompTo(\">\");"
      },
      {
        "txt": "XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr); last().appendChild(decl); } private void parseEndTag() { tq.consume(\"</\"); String tagName = tq.consumeWord(); tq.chompTo(\">\"); if (tagName.length() != 0) { Tag tag = Tag.valueOf(tagName); popStackToClose(tag);"
      },
      {
        "txt": "} } private void parseStartTag() { tq.consume(\"<\"); String tagName = tq.consumeWord(); if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text tq.addFirst(\"&lt;\"); parseTextNode(); return; }"
      },
      {
        "txt": "Attributes attributes = new Attributes(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) { Attribute attribute = parseAttribute(); if (attribute != null) attributes.put(attribute); } Tag tag = Tag.valueOf(tagName); Element child = new Element(tag, baseUri, attributes); boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/> if (tq.matchChomp(\"/>\")) { // close empty element or tag"
      },
      {
        "txt": "isEmptyElement = true; } else { tq.matchChomp(\">\"); } addChildToParent(child, isEmptyElement); if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); tq.chompTo(\">\"); popStackToClose(tag); Node dataNode;"
      },
      {
        "txt": "if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.createFromEncoded(data, baseUri); else dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script) child.appendChild(dataNode); } if (child.tagName().equals(\"base\")) { String href = child.absUrl(\"href\"); if (href.length() != 0) { // ignore <base target> etc baseUri = href;"
      },
      {
        "txt": "doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base } } } private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = \"\"; tq.consumeWhitespace(); if (tq.matchChomp(\"=\")) {"
      },
      {
        "txt": "tq.consumeWhitespace(); if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); }"
      },
      {
        "txt": "value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume(); // unknown char, keep popping so not get stuck return null; }"
      },
      {
        "txt": "} private void parseTextNode() { String text = tq.consumeTo(\"<\"); TextNode textNode = TextNode.createFromEncoded(text, baseUri); last().appendChild(textNode); } private void parseCdata() { tq.consume(\"<![CDATA[\"); String rawText = tq.chompTo(\"]]>\"); TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape"
      },
      {
        "txt": "last().appendChild(textNode); } private Element addChildToParent(Element child, boolean isEmptyElement) { Element parent = popStackToSuitableContainer(child.tag()); Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor) { Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri); if (child.tag().equals(bodyTag)) {"
      },
      {
        "txt": "Element head = new Element(headTag, baseUri); implicit.appendChild(head); } implicit.appendChild(child); Element root = addChildToParent(implicit, false); if (!isEmptyElement) stack.addLast(child); return root; } parent.appendChild(child);"
      },
      {
        "txt": "stack.addLast(child); return parent; } private boolean stackHasValidParent(Tag childTag) { if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node <extra_id_0> for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidParent(childTag)) { return true; }"
      },
      {
        "txt": "return true; } } return false; } private Element popStackToSuitableContainer(Tag tag) { while (!stack.isEmpty()) { if (last().tag().canContain(tag)) return last(); else"
      },
      {
        "txt": "stack.removeLast(); } return null; } private Element popStackToClose(Tag tag) { int counter = 0; Element elToClose = null; for (int i = stack.size() -1; i > 0; i--) { counter++; Element el = stack.get(i);"
      },
      {
        "txt": "Tag elTag = el.tag(); if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body break; } else if (elTag.equals(tag)) { elToClose = el; break; } } if (elToClose != null) { for (int i = 0; i < counter; i++) {"
      },
      {
        "txt": "stack.removeLast(); } } return elToClose; } private Element last() { return stack.getLast(); }"
      }
    ]
  },
  {
    "id": 1857,
    "file_path": "src/main/java/org/jsoup/parser/Parser.java",
    "start-bug-line": 258,
    "end-bug-line": 258,
    "bug": "if (parent2.isValidParent(childTag)) {",
    "fix": "if (parent2.isValidAncestor(childTag)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import org.jsoup.nodes.*; import java.util.*; Parses HTML into a {@link Document}. Generally best to use one of the more convenient parse methods in {@link org.jsoup.Jsoup}. @author Jonathan Hedley, jonathan@hedley.net */ public class Parser {"
      },
      {
        "txt": "private static final String SQ = \"'\"; private static final String DQ = \"\\\"\"; private static final Tag htmlTag = Tag.valueOf(\"html\"); private static final Tag headTag = Tag.valueOf(\"head\"); private static final Tag bodyTag = Tag.valueOf(\"body\"); private static final Tag titleTag = Tag.valueOf(\"title\"); private static final Tag textareaTag = Tag.valueOf(\"textarea\"); private final LinkedList<Element> stack; private final TokenQueue tq; private final Document doc;"
      },
      {
        "txt": "private String baseUri; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html); Validate.notNull(baseUri); stack = new LinkedList<Element>(); tq = new TokenQueue(html); this.baseUri = baseUri; if (isBodyFragment) { doc = Document.createShell(baseUri); stack.add(doc.body());"
      },
      {
        "txt": "} else { doc = new Document(baseUri); stack.add(doc); } } Parse HTML into a Document. @param html HTML to parse @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return parsed Document public static Document parse(String html, String baseUri) {"
      },
      {
        "txt": "Parser parser = new Parser(html, baseUri, false); return parser.parse(); } Parse a fragment of HTML into the {@code body} of a Document. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body public static Document parseBodyFragment(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); return parser.parse();"
      },
      {
        "txt": "} Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this context, means that implicit tags are not automatically created when missing. @param bodyHtml fragment of HTML @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body private Document parse() { while (!tq.isEmpty()) { if (tq.matches(\"<!--\")) { parseComment();"
      },
      {
        "txt": "} else if (tq.matches(\"<![CDATA[\")) { parseCdata(); } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) { parseXmlDecl(); } else if (tq.matches(\"</\")) { parseEndTag(); } else if (tq.matches(\"<\")) { parseStartTag(); } else { parseTextNode();"
      },
      {
        "txt": "} } return doc.normalise(); } private void parseComment() { tq.consume(\"<!--\"); String data = tq.chompTo(\"->\"); if (data.endsWith(\"-\")) // i.e. was --> data = data.substring(0, data.length()-1); Comment comment = new Comment(data, baseUri);"
      },
      {
        "txt": "last().appendChild(comment); } private void parseXmlDecl() { tq.consume(\"<\"); Character firstChar = tq.consume(); // <? or <!, from initial match. boolean procInstr = firstChar.toString().equals(\"!\"); String data = tq.chompTo(\">\"); XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr); last().appendChild(decl); }"
      },
      {
        "txt": "private void parseEndTag() { tq.consume(\"</\"); String tagName = tq.consumeWord(); tq.chompTo(\">\"); if (tagName.length() != 0) { Tag tag = Tag.valueOf(tagName); popStackToClose(tag); } } private void parseStartTag() {"
      },
      {
        "txt": "tq.consume(\"<\"); String tagName = tq.consumeWord(); if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text tq.addFirst(\"&lt;\"); parseTextNode(); return; } Attributes attributes = new Attributes(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) { Attribute attribute = parseAttribute();"
      },
      {
        "txt": "if (attribute != null) attributes.put(attribute); } Tag tag = Tag.valueOf(tagName); Element child = new Element(tag, baseUri, attributes); boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/> if (tq.matchChomp(\"/>\")) { // close empty element or tag isEmptyElement = true; } else { tq.matchChomp(\">\");"
      },
      {
        "txt": "} addChildToParent(child, isEmptyElement); if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); tq.chompTo(\">\"); popStackToClose(tag); Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.createFromEncoded(data, baseUri); else"
      },
      {
        "txt": "dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script) child.appendChild(dataNode); } if (child.tagName().equals(\"base\")) { String href = child.absUrl(\"href\"); if (href.length() != 0) { // ignore <base target> etc baseUri = href; doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base } }"
      },
      {
        "txt": "} private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = \"\"; tq.consumeWhitespace(); if (tq.matchChomp(\"=\")) { tq.consumeWhitespace(); if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ);"
      },
      {
        "txt": "} else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace();"
      },
      {
        "txt": "} if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume(); // unknown char, keep popping so not get stuck return null; } } private void parseTextNode() { String text = tq.consumeTo(\"<\");"
      },
      {
        "txt": "TextNode textNode = TextNode.createFromEncoded(text, baseUri); last().appendChild(textNode); } private void parseCdata() { tq.consume(\"<![CDATA[\"); String rawText = tq.chompTo(\"]]>\"); TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape last().appendChild(textNode); } private Element addChildToParent(Element child, boolean isEmptyElement) {"
      },
      {
        "txt": "Element parent = popStackToSuitableContainer(child.tag()); Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor) { Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri); if (child.tag().equals(bodyTag)) { Element head = new Element(headTag, baseUri); implicit.appendChild(head); }"
      },
      {
        "txt": "implicit.appendChild(child); Element root = addChildToParent(implicit, false); if (!isEmptyElement) stack.addLast(child); return root; } parent.appendChild(child); if (!isEmptyElement) stack.addLast(child); return parent;"
      },
      {
        "txt": "private boolean stackHasValidParent(Tag childTag) { if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); <extra_id_0> return true; } } return false; } private Element popStackToSuitableContainer(Tag tag) {"
      },
      {
        "txt": "} private Element popStackToSuitableContainer(Tag tag) { while (!stack.isEmpty()) { if (last().tag().canContain(tag)) return last(); else stack.removeLast(); } return null; }"
      },
      {
        "txt": "private Element popStackToClose(Tag tag) { int counter = 0; Element elToClose = null; for (int i = stack.size() -1; i > 0; i--) { counter++; Element el = stack.get(i); Tag elTag = el.tag(); if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body break; } else if (elTag.equals(tag)) {"
      },
      {
        "txt": "elToClose = el; break; } } if (elToClose != null) { for (int i = 0; i < counter; i++) { stack.removeLast(); } } return elToClose;"
      },
      {
        "txt": "} private Element last() { return stack.getLast(); }"
      }
    ]
  },
  {
    "id": 1858,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 28,
    "end-bug-line": 28,
    "bug": "",
    "fix": "private Tag parent; // if not null, elements must be a direct child of parent",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD,"
      },
      {
        "txt": "but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName;"
      },
      {
        "txt": "private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors <extra_id_0> private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; }"
      },
      {
        "txt": "return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase();"
      },
      {
        "txt": "Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag;"
      },
      {
        "txt": "} } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline"
      },
      {
        "txt": "return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData()) return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; }"
      },
      {
        "txt": "return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; } Gets if this is a block tag. @return if block tag"
      },
      {
        "txt": "public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags. @return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag."
      },
      {
        "txt": "public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag. @return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag"
      },
      {
        "txt": "public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null;"
      },
      {
        "txt": "} boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false; }"
      },
      {
        "txt": "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false;"
      },
      {
        "txt": "if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0);"
      },
      {
        "txt": "result = 31 * result + (empty ? 1 : 0); return result; } public String toString() { return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl"
      },
      {
        "txt": "createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty();"
      },
      {
        "txt": "createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\");"
      },
      {
        "txt": "createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty();"
      },
      {
        "txt": "createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly();"
      },
      {
        "txt": "createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly();"
      },
      {
        "txt": "createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\");"
      },
      {
        "txt": "createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\");"
      },
      {
        "txt": "createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) {"
      },
      {
        "txt": "return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName);"
      },
      {
        "txt": "synchronized (tags) { tags.put(tag.tagName, tag); } return tag; } private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; }"
      },
      {
        "txt": "private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this; } private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true;"
      },
      {
        "txt": "return this; } private Tag setOptionalClosing() { optionalClosing = true; return this; } private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; }"
      },
      {
        "txt": "private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this;"
      }
    ]
  },
  {
    "id": 1859,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 99,
    "end-bug-line": 99,
    "bug": "",
    "fix": "if (this.requiresSpecificParent() && this.getImplicitParent().equals(child)) return false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD,"
      },
      {
        "txt": "but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName;"
      },
      {
        "txt": "private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); }"
      },
      {
        "txt": "public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName);"
      },
      {
        "txt": "tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; }"
      },
      {
        "txt": "return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false;"
      },
      {
        "txt": "if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData()) return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true;"
      },
      {
        "txt": "return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; <extra_id_0> return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock;"
      },
      {
        "txt": "public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags. @return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag."
      },
      {
        "txt": "public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag. @return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag"
      },
      {
        "txt": "public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null;"
      },
      {
        "txt": "} boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false; }"
      },
      {
        "txt": "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false;"
      },
      {
        "txt": "if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0);"
      },
      {
        "txt": "result = 31 * result + (empty ? 1 : 0); return result; } public String toString() { return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl"
      },
      {
        "txt": "createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty();"
      },
      {
        "txt": "createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\");"
      },
      {
        "txt": "createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty();"
      },
      {
        "txt": "createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly();"
      },
      {
        "txt": "createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly();"
      },
      {
        "txt": "createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\");"
      },
      {
        "txt": "createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\");"
      },
      {
        "txt": "createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) {"
      },
      {
        "txt": "return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName);"
      },
      {
        "txt": "synchronized (tags) { tags.put(tag.tagName, tag); } return tag; } private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; }"
      },
      {
        "txt": "private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this; } private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true;"
      },
      {
        "txt": "return this; } private Tag setOptionalClosing() { optionalClosing = true; return this; } private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; }"
      },
      {
        "txt": "private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this;"
      }
    ]
  },
  {
    "id": 1860,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 155,
    "end-bug-line": 155,
    "bug": "",
    "fix": "boolean requiresSpecificParent() { return this.parent != null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor;"
      },
      {
        "txt": "static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img"
      },
      {
        "txt": "private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p>"
      },
      {
        "txt": "Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) {"
      },
      {
        "txt": "tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag."
      },
      {
        "txt": "@return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData())"
      },
      {
        "txt": "return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; } return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false;"
      },
      {
        "txt": "if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags."
      },
      {
        "txt": "@return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag."
      },
      {
        "txt": "@return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes."
      },
      {
        "txt": "public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } <extra_id_0> boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true;"
      },
      {
        "txt": "if (this.equals(tag)) return true; } return false; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o;"
      },
      {
        "txt": "if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override public int hashCode() {"
      },
      {
        "txt": "int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result; } public String toString() { return tagName;"
      },
      {
        "txt": "} static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty();"
      },
      {
        "txt": "createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\");"
      },
      {
        "txt": "createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\");"
      },
      {
        "txt": "createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\");"
      },
      {
        "txt": "createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\");"
      },
      {
        "txt": "createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self"
      },
      {
        "txt": "createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\");"
      },
      {
        "txt": "createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty();"
      },
      {
        "txt": "createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false;"
      },
      {
        "txt": "inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag); } return tag; }"
      },
      {
        "txt": "private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this;"
      },
      {
        "txt": "} private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this; } private Tag setOptionalClosing() { optionalClosing = true; return this;"
      },
      {
        "txt": "} private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length);"
      },
      {
        "txt": "for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this; }"
      }
    ]
  },
  {
    "id": 1861,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 157,
    "end-bug-line": 157,
    "bug": "",
    "fix": "return this.equals(child.parent); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static {"
      },
      {
        "txt": "defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc"
      },
      {
        "txt": "private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals()."
      },
      {
        "txt": "@param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName);"
      },
      {
        "txt": "tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child."
      },
      {
        "txt": "boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData()) return false;"
      },
      {
        "txt": "if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; } return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\"))"
      },
      {
        "txt": "return false; return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags. @return if tag can contain block tags"
      },
      {
        "txt": "public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag. @return if this tag is a data only tag"
      },
      {
        "txt": "public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace"
      },
      {
        "txt": "return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { <extra_id_0> if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; }"
      },
      {
        "txt": "return true; } return false; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false;"
      },
      {
        "txt": "if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0;"
      },
      {
        "txt": "result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result; } public String toString() { return tagName; }"
      },
      {
        "txt": "static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head"
      },
      {
        "txt": "createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\");"
      },
      {
        "txt": "createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\"); createInline(\"ABBR\");"
      },
      {
        "txt": "createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\"); createInline(\"BDO\");"
      },
      {
        "txt": "createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace();"
      },
      {
        "txt": "createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined"
      },
      {
        "txt": "createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing();"
      },
      {
        "txt": "createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing();"
      },
      {
        "txt": "createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false;"
      },
      {
        "txt": "return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag); } return tag; } private Tag setContainInlineOnly() {"
      },
      {
        "txt": "canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this; }"
      },
      {
        "txt": "private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this; } private Tag setOptionalClosing() { optionalClosing = true; return this; }"
      },
      {
        "txt": "private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) {"
      },
      {
        "txt": "ancestors.add(Tag.valueOf(name)); } } return this; }"
      }
    ]
  },
  {
    "id": 1862,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 158,
    "end-bug-line": 158,
    "bug": "",
    "fix": "boolean isValidAncestor(Tag child) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static {"
      },
      {
        "txt": "defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc"
      },
      {
        "txt": "private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals()."
      },
      {
        "txt": "@param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName);"
      },
      {
        "txt": "tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child."
      },
      {
        "txt": "boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData()) return false;"
      },
      {
        "txt": "if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; } return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\"))"
      },
      {
        "txt": "return false; return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags. @return if tag can contain block tags"
      },
      {
        "txt": "public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag. @return if this tag is a data only tag"
      },
      {
        "txt": "public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace"
      },
      {
        "txt": "return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { <extra_id_0> return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false;"
      },
      {
        "txt": "} return false; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false;"
      },
      {
        "txt": "if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0);"
      },
      {
        "txt": "result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result; } public String toString() { return tagName; } static {"
      },
      {
        "txt": "createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param"
      },
      {
        "txt": "createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\");"
      },
      {
        "txt": "createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\");"
      },
      {
        "txt": "createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block?"
      },
      {
        "txt": "createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\");"
      },
      {
        "txt": "createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\");"
      },
      {
        "txt": "createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing();"
      },
      {
        "txt": "createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing();"
      },
      {
        "txt": "createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false; return register(inline);"
      },
      {
        "txt": "} private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag); } return tag; } private Tag setContainInlineOnly() { canContainBlock = false;"
      },
      {
        "txt": "canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this; } private Tag setEmpty() {"
      },
      {
        "txt": "canContainBlock = false; canContainInline = false; empty = true; return this; } private Tag setOptionalClosing() { optionalClosing = true; return this; } private Tag setPreserveWhitespace() {"
      },
      {
        "txt": "preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) { ancestors.add(Tag.valueOf(name));"
      },
      {
        "txt": "} } return this; }"
      }
    ]
  },
  {
    "id": 1863,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 224,
    "end-bug-line": 225,
    "bug": "createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly();",
    "fix": "createBlock(\"FRAME\").setParent(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setParent(\"FRAMESET\").setContainDataOnly();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag {"
      },
      {
        "txt": "private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not"
      },
      {
        "txt": "private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; }"
      },
      {
        "txt": "Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) {"
      },
      {
        "txt": "Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag; } }"
      },
      {
        "txt": "Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child))"
      },
      {
        "txt": "return false; if (this.empty || this.isData()) return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; } return false; }"
      },
      {
        "txt": "if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock;"
      },
      {
        "txt": "} Gets if this tag can contain block tags. @return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock;"
      },
      {
        "txt": "} Gets if this tag is a data only tag. @return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty;"
      },
      {
        "txt": "} Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) {"
      },
      {
        "txt": "if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false; } @Override public boolean equals(Object o) {"
      },
      {
        "txt": "if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true;"
      },
      {
        "txt": "} @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result;"
      },
      {
        "txt": "} public String toString() { return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();"
      },
      {
        "txt": "createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); <extra_id_0> createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\");"
      },
      {
        "txt": "createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\");"
      },
      {
        "txt": "createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\");"
      },
      {
        "txt": "createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\");"
      },
      {
        "txt": "createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self"
      },
      {
        "txt": "createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\");"
      },
      {
        "txt": "createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty();"
      },
      {
        "txt": "createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false;"
      },
      {
        "txt": "inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag); } return tag; }"
      },
      {
        "txt": "private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this;"
      },
      {
        "txt": "} private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this; } private Tag setOptionalClosing() { optionalClosing = true; return this;"
      },
      {
        "txt": "} private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length);"
      },
      {
        "txt": "for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this; }"
      }
    ]
  },
  {
    "id": 1864,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 288,
    "end-bug-line": 289,
    "bug": "createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly();",
    "fix": "createInline(\"OPTGROUP\").setParent(\"SELECT\"); //  only contain option createInline(\"OPTION\").setParent(\"SELECT\").setContainDataOnly();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD,"
      },
      {
        "txt": "but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName;"
      },
      {
        "txt": "private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); }"
      },
      {
        "txt": "public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName);"
      },
      {
        "txt": "tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; }"
      },
      {
        "txt": "return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false;"
      },
      {
        "txt": "if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData()) return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true;"
      },
      {
        "txt": "} return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; } Gets if this is a block tag."
      },
      {
        "txt": "@return if block tag public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags. @return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag."
      },
      {
        "txt": "@return if this tag is an inline tag. public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag. @return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag"
      },
      {
        "txt": "@return if this is an emtpy tag public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() {"
      },
      {
        "txt": "return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false;"
      },
      {
        "txt": "} @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false;"
      },
      {
        "txt": "if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0);"
      },
      {
        "txt": "result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result; } public String toString() { return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT"
      },
      {
        "txt": "createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty();"
      },
      {
        "txt": "createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\");"
      },
      {
        "txt": "createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty();"
      },
      {
        "txt": "createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly();"
      },
      {
        "txt": "createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty();"
      },
      {
        "txt": "createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined <extra_id_0> createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body"
      },
      {
        "txt": "createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing();"
      },
      {
        "txt": "createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); }"
      },
      {
        "txt": "private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag);"
      },
      {
        "txt": "} return tag; } private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false;"
      },
      {
        "txt": "canContainInline = false; preserveWhitespace = true; return this; } private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this; }"
      },
      {
        "txt": "private Tag setOptionalClosing() { optionalClosing = true; return this; } private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) {"
      },
      {
        "txt": "ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this; }"
      }
    ]
  },
  {
    "id": 1865,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 295,
    "end-bug-line": 295,
    "bug": "createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty();",
    "fix": "createInline(\"PARAM\").setParent(\"OBJECT\").setEmpty();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor;"
      },
      {
        "txt": "static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img"
      },
      {
        "txt": "private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p>"
      },
      {
        "txt": "Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) {"
      },
      {
        "txt": "tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag."
      },
      {
        "txt": "@return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData())"
      },
      {
        "txt": "return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; } return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false;"
      },
      {
        "txt": "if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags."
      },
      {
        "txt": "@return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag."
      },
      {
        "txt": "@return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes."
      },
      {
        "txt": "@return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag"
      },
      {
        "txt": "for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;"
      },
      {
        "txt": "Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override"
      },
      {
        "txt": "public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result; } public String toString() {"
      },
      {
        "txt": "return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();"
      },
      {
        "txt": "createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\");"
      },
      {
        "txt": "createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\");"
      },
      {
        "txt": "createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\");"
      },
      {
        "txt": "createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\");"
      },
      {
        "txt": "createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly();"
      },
      {
        "txt": "createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se <extra_id_0> createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL."
      },
      {
        "txt": "createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing();"
      },
      {
        "txt": "createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false;"
      },
      {
        "txt": "return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag); } return tag; } private Tag setContainInlineOnly() {"
      },
      {
        "txt": "canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this; }"
      },
      {
        "txt": "private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this; } private Tag setOptionalClosing() { optionalClosing = true; return this; }"
      },
      {
        "txt": "private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) {"
      },
      {
        "txt": "ancestors.add(Tag.valueOf(name)); } } return this; }"
      }
    ]
  },
  {
    "id": 1866,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 300,
    "end-bug-line": 301,
    "bug": "createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing();",
    "fix": "createInline(\"DT\").setParent(\"DL\").setOptionalClosing(); // only within DL. createInline(\"DD\").setParent(\"DL\").setOptionalClosing(); // only within DL.",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*;"
      },
      {
        "txt": "HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); }"
      },
      {
        "txt": "private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase();"
      },
      {
        "txt": "} public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) {"
      },
      {
        "txt": "Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true;"
      },
      {
        "txt": "} return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock)"
      },
      {
        "txt": "return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData()) return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) {"
      },
      {
        "txt": "return true; } return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; }"
      },
      {
        "txt": "Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags. @return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; }"
      },
      {
        "txt": "Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag. @return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); }"
      },
      {
        "txt": "Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; }"
      },
      {
        "txt": "Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; }"
      },
      {
        "txt": "return false; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false;"
      },
      {
        "txt": "if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0);"
      },
      {
        "txt": "result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result; } public String toString() { return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl"
      },
      {
        "txt": "createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();"
      },
      {
        "txt": "createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\");"
      },
      {
        "txt": "createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self"
      },
      {
        "txt": "createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly();"
      },
      {
        "txt": "createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\");"
      },
      {
        "txt": "createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly();"
      },
      {
        "txt": "createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body createBlock(\"DL\"); <extra_id_0> createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing();"
      },
      {
        "txt": "createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName));"
      },
      {
        "txt": "} private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) {"
      },
      {
        "txt": "tags.put(tag.tagName, tag); } return tag; } private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() {"
      },
      {
        "txt": "canContainBlock = false; canContainInline = false; preserveWhitespace = true; return this; } private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this;"
      },
      {
        "txt": "} private Tag setOptionalClosing() { optionalClosing = true; return this; } private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) {"
      },
      {
        "txt": "if (tagNames == null) { ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this; }"
      }
    ]
  },
  {
    "id": 1867,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 307,
    "end-bug-line": 315,
    "bug": "createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing();",
    "fix": "createBlock(\"CAPTION\").setParent(\"TABLE\"); createBlock(\"THEAD\").setParent(\"TABLE\").setOptionalClosing(); // just TR createBlock(\"TFOOT\").setParent(\"TABLE\").setOptionalClosing(); // just TR createBlock(\"TBODY\").setParent(\"TABLE\").setOptionalClosing(); // optional / implicit open too. just TR createBlock(\"COLGROUP\").setParent(\"TABLE\").setOptionalClosing(); // just COL createBlock(\"COL\").setParent(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setParent(\"TABLE\").setOptionalClosing(); // just TH, TD createBlock(\"TH\").setParent(\"TR\").setOptionalClosing(); createBlock(\"TD\").setParent(\"TR\").setOptionalClosing();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag {"
      },
      {
        "txt": "private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor; static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not"
      },
      {
        "txt": "private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; }"
      },
      {
        "txt": "Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p> Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) {"
      },
      {
        "txt": "Tag tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag; } }"
      },
      {
        "txt": "Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag. @return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child))"
      },
      {
        "txt": "return false; if (this.empty || this.isData()) return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; } return false; }"
      },
      {
        "txt": "if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false; if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock;"
      },
      {
        "txt": "} Gets if this tag can contain block tags. @return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock;"
      },
      {
        "txt": "} Gets if this tag is a data only tag. @return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty;"
      },
      {
        "txt": "} Get if this tag should preserve whitespace within child text nodes. @return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) {"
      },
      {
        "txt": "if (child.ancestors.isEmpty()) return true; // HTML tag for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false; } @Override public boolean equals(Object o) {"
      },
      {
        "txt": "if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true;"
      },
      {
        "txt": "} @Override public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result;"
      },
      {
        "txt": "} public String toString() { return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();"
      },
      {
        "txt": "createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\");"
      },
      {
        "txt": "createInline(\"TT\"); createInline(\"I\"); createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\");"
      },
      {
        "txt": "createInline(\"KBD\"); createInline(\"VAR\"); createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\");"
      },
      {
        "txt": "createInline(\"SUB\"); createInline(\"SUP\"); createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly();"
      },
      {
        "txt": "createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\"); createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty();"
      },
      {
        "txt": "createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly(); createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty();"
      },
      {
        "txt": "createBlock(\"DEL\"); // only within body createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented <extra_id_0> } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName);"
      },
      {
        "txt": "private static Tag createInline(String tagName) { Tag inline = new Tag(tagName); inline.isBlock = false; inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag);"
      },
      {
        "txt": "} return tag; } private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false;"
      },
      {
        "txt": "canContainInline = false; preserveWhitespace = true; return this; } private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this; }"
      },
      {
        "txt": "private Tag setOptionalClosing() { optionalClosing = true; return this; } private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) {"
      },
      {
        "txt": "ancestors = Collections.emptyList(); } else { ancestors = new ArrayList<Tag>(tagNames.length); for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this; }"
      }
    ]
  },
  {
    "id": 1868,
    "file_path": "src/main/java/org/jsoup/parser/Tag.java",
    "start-bug-line": 379,
    "end-bug-line": 379,
    "bug": "",
    "fix": "private Tag setParent(String tagName) { parent = Tag.valueOf(tagName); setAncestor(tagName); return this; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.jsoup.parser; import org.apache.commons.lang.Validate; import java.util.*; HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD, but it should capture most of what we need to know to intelligently parse a doc. @author Jonathan Hedley, jonathan@hedley.net */ public class Tag { private static final Map<String, Tag> tags = new HashMap<String, Tag>(); private static final Tag defaultAncestor;"
      },
      {
        "txt": "static { defaultAncestor = new Tag(\"BODY\"); tags.put(defaultAncestor.tagName, defaultAncestor); } private String tagName; private boolean isBlock = true; // block or inline private boolean canContainBlock = true; // Can this tag hold block level tags? private boolean canContainInline = true; // only pcdata if not private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag private boolean empty = false; // can hold nothing; e.g. img"
      },
      {
        "txt": "private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase(); } public String getName() { return tagName; } Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything. <p>"
      },
      {
        "txt": "Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals(). @param tagName Name of tag, e.g. \"p\". Case insensitive. @return The tag, either defined or new generic. public static Tag valueOf(String tagName) { Validate.notNull(tagName); tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); synchronized (tags) { Tag tag = tags.get(tagName); if (tag == null) {"
      },
      {
        "txt": "tag = new Tag(tagName); tag.setAncestor(defaultAncestor.tagName); tag.isBlock = false; tag.canContainBlock = true; } return tag; } } Test if this tag, the prospective parent, can accept the proposed child. @param child potential child tag."
      },
      {
        "txt": "@return true if this can contain child. boolean canContain(Tag child) { Validate.notNull(child); if (child.isBlock && !this.canContainBlock) return false; if (!child.isBlock && !this.canContainInline) // not block == inline return false; if (this.optionalClosing && this.equals(child)) return false; if (this.empty || this.isData())"
      },
      {
        "txt": "return false; if (this.tagName.equals(\"head\")) { if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) { return true; } return false; } if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\")) return false;"
      },
      {
        "txt": "if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\")) return false; return true; } Gets if this is a block tag. @return if block tag public boolean isBlock() { return isBlock; } Gets if this tag can contain block tags."
      },
      {
        "txt": "@return if tag can contain block tags public boolean canContainBlock() { return canContainBlock; } Gets if this tag is an inline tag. @return if this tag is an inline tag. public boolean isInline() { return !isBlock; } Gets if this tag is a data only tag."
      },
      {
        "txt": "@return if this tag is a data only tag public boolean isData() { return !canContainInline && !isEmpty(); } Get if this is an empty tag @return if this is an emtpy tag public boolean isEmpty() { return empty; } Get if this tag should preserve whitespace within child text nodes."
      },
      {
        "txt": "@return if preserve whitepace public boolean preserveWhitespace() { return preserveWhitespace; } Tag getImplicitParent() { return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag"
      },
      {
        "txt": "for (Tag tag : child.ancestors) { if (this.equals(tag)) return true; } return false; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;"
      },
      {
        "txt": "Tag tag = (Tag) o; if (canContainBlock != tag.canContainBlock) return false; if (canContainInline != tag.canContainInline) return false; if (empty != tag.empty) return false; if (isBlock != tag.isBlock) return false; if (optionalClosing != tag.optionalClosing) return false; if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; return true; } @Override"
      },
      {
        "txt": "public int hashCode() { int result = tagName != null ? tagName.hashCode() : 0; result = 31 * result + (isBlock ? 1 : 0); result = 31 * result + (canContainBlock ? 1 : 0); result = 31 * result + (canContainInline ? 1 : 0); result = 31 * result + (optionalClosing ? 1 : 0); result = 31 * result + (empty ? 1 : 0); return result; } public String toString() {"
      },
      {
        "txt": "return tagName; } static { createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl createBlock(\"FRAMESET\").setAncestor(\"HTML\"); createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\"); createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();"
      },
      {
        "txt": "createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly(); createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty(); createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly(); createInline(\"FONT\"); createInline(\"TT\"); createInline(\"I\");"
      },
      {
        "txt": "createInline(\"B\"); createInline(\"BIG\"); createInline(\"SMALL\"); createInline(\"EM\"); createInline(\"STRONG\"); createInline(\"DFN\"); createInline(\"CODE\"); createInline(\"SAMP\"); createInline(\"KBD\"); createInline(\"VAR\");"
      },
      {
        "txt": "createInline(\"CITE\"); createInline(\"ABBR\"); createInline(\"ACRONYM\"); createInline(\"A\").setOptionalClosing(); // cannot contain self createInline(\"IMG\").setEmpty(); createInline(\"BR\").setEmpty(); createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD. createInline(\"Q\"); createInline(\"SUB\"); createInline(\"SUP\");"
      },
      {
        "txt": "createInline(\"SPAN\"); createInline(\"BDO\"); createBlock(\"P\").setContainInlineOnly(); // emasculated block? createBlock(\"H1\").setContainInlineOnly(); createBlock(\"H2\").setContainInlineOnly(); createBlock(\"H3\").setContainInlineOnly(); createBlock(\"H4\").setContainInlineOnly(); createBlock(\"H5\").setContainInlineOnly(); createBlock(\"H6\").setContainInlineOnly(); createBlock(\"UL\");"
      },
      {
        "txt": "createBlock(\"OL\"); createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace(); createBlock(\"DIV\"); createBlock(\"BLOCKQUOTE\"); createBlock(\"HR\").setEmpty(); createBlock(\"ADDRESS\").setContainInlineOnly(); createBlock(\"FORM\").setOptionalClosing(); // can't contian self createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty(); createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly();"
      },
      {
        "txt": "createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly(); createBlock(\"FIELDSET\").setAncestor(\"FORM\"); createInline(\"LEGEND\").setAncestor(\"FIELDSET\"); createInline(\"AREA\").setEmpty(); // not an inline per-se createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty(); createBlock(\"INS\"); // only within body createBlock(\"DEL\"); // only within body"
      },
      {
        "txt": "createBlock(\"DL\"); createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL. createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented createBlock(\"CAPTION\").setAncestor(\"TABLE\"); createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing();"
      },
      {
        "txt": "createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty(); createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing(); createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing(); } private static Tag createBlock(String tagName) { return register(new Tag(tagName)); } private static Tag createInline(String tagName) { Tag inline = new Tag(tagName);"
      },
      {
        "txt": "inline.isBlock = false; inline.canContainBlock = false; return register(inline); } private static Tag register(Tag tag) { tag.setAncestor(defaultAncestor.tagName); synchronized (tags) { tags.put(tag.tagName, tag); } return tag;"
      },
      {
        "txt": "} private Tag setContainInlineOnly() { canContainBlock = false; canContainInline = true; return this; } private Tag setContainDataOnly() { canContainBlock = false; canContainInline = false; preserveWhitespace = true;"
      },
      {
        "txt": "return this; } private Tag setEmpty() { canContainBlock = false; canContainInline = false; empty = true; return this; } private Tag setOptionalClosing() { optionalClosing = true;"
      },
      {
        "txt": "return this; } private Tag setPreserveWhitespace() { preserveWhitespace = true; return this; } private Tag setAncestor(String... tagNames) { if (tagNames == null) { ancestors = Collections.emptyList(); } else {"
      },
      {
        "txt": "for (String name : tagNames) { ancestors.add(Tag.valueOf(name)); } } return this; } <extra_id_0>"
      }
    ]
  }
]