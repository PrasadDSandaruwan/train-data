[
  {
    "id": 2729,
    "file_path": "src/java/org/apache/commons/math/linear/BigMatrixImpl.java",
    "start-bug-line": 991,
    "end-bug-line": 991,
    "bug": "final BigDecimal[] out = new BigDecimal[v.length];",
    "fix": "final BigDecimal[] out = new BigDecimal[nRows];",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math.linear; import java.io.Serializable; import java.math.BigDecimal; public class BigMatrixImpl implements BigMatrix, Serializable { private static final long serialVersionUID = -1011428905656140431L; protected BigDecimal data[][] = null; protected BigDecimal lu[][] = null; protected int[] permutation = null; protected int parity = 1; private int roundingMode = BigDecimal.ROUND_HALF_UP;"
      },
      {
        "txt": "private int scale = 64; private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12); static final BigDecimal ZERO = new BigDecimal(0); static final BigDecimal ONE = new BigDecimal(1); public BigMatrixImpl() { } public BigMatrixImpl(int rowDimension, int columnDimension) { if (rowDimension <=0 || columnDimension <=0) { throw new IllegalArgumentException (\"row and column dimensions must be positive\");"
      },
      {
        "txt": "} data = new BigDecimal[rowDimension][columnDimension]; lu = null; } public BigMatrixImpl(BigDecimal[][] d) { this.copyIn(d); lu = null; } public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) { if (copyArray) {"
      },
      {
        "txt": "copyIn(d); } else { if (d == null) { throw new NullPointerException(); } final int nRows = d.length; if (nRows == 0) { throw new IllegalArgumentException(\"Matrix must have at least one row.\"); } final int nCols = d[0].length;"
      },
      {
        "txt": "if (nCols == 0) { throw new IllegalArgumentException(\"Matrix must have at least one column.\"); } for (int r = 1; r < nRows; r++) { if (d[r].length != nCols) { throw new IllegalArgumentException(\"All input rows must have the same length.\"); } } data = d; }"
      },
      {
        "txt": "lu = null; } public BigMatrixImpl(double[][] d) { final int nRows = d.length; if (nRows == 0) { throw new IllegalArgumentException( \"Matrix must have at least one row.\"); } final int nCols = d[0].length; if (nCols == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException( \"Matrix must have at least one column.\"); } for (int row = 1; row < nRows; row++) { if (d[row].length != nCols) { throw new IllegalArgumentException( \"All input rows must have the same length.\"); } } this.copyIn(d);"
      },
      {
        "txt": "lu = null; } public BigMatrixImpl(String[][] d) { final int nRows = d.length; if (nRows == 0) { throw new IllegalArgumentException( \"Matrix must have at least one row.\"); } final int nCols = d[0].length; if (nCols == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException( \"Matrix must have at least one column.\"); } for (int row = 1; row < nRows; row++) { if (d[row].length != nCols) { throw new IllegalArgumentException( \"All input rows must have the same length.\"); } } this.copyIn(d);"
      },
      {
        "txt": "lu = null; } public BigMatrixImpl(BigDecimal[] v) { final int nRows = v.length; data = new BigDecimal[nRows][1]; for (int row = 0; row < nRows; row++) { data[row][0] = v[row]; } } public BigMatrix copy() {"
      },
      {
        "txt": "return new BigMatrixImpl(this.copyOut(), false); } public BigMatrix add(BigMatrix m) throws IllegalArgumentException { try { return add((BigMatrixImpl) m); } catch (ClassCastException cce) { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\");"
      },
      {
        "txt": "} final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final BigDecimal[] dataRow = data[row]; final BigDecimal[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col].add(m.getEntry(row, col)); } } return new BigMatrixImpl(outData, false);"
      },
      {
        "txt": "} } public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\"); } final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) {"
      },
      {
        "txt": "final BigDecimal[] dataRow = data[row]; final BigDecimal[] mRow = m.data[row]; final BigDecimal[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col].add(mRow[col]); } } return new BigMatrixImpl(outData, false); } public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {"
      },
      {
        "txt": "try { return subtract((BigMatrixImpl) m); } catch (ClassCastException cce) { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\"); } final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) {"
      },
      {
        "txt": "final BigDecimal[] dataRow = data[row]; final BigDecimal[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col].subtract(getEntry(row, col)); } } return new BigMatrixImpl(outData, false); } } public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {"
      },
      {
        "txt": "final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\"); } final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final BigDecimal[] dataRow = data[row]; final BigDecimal[] mRow = m.data[row]; final BigDecimal[] outDataRow = outData[row];"
      },
      {
        "txt": "for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col].subtract(mRow[col]); } } return new BigMatrixImpl(outData, false); } public BigMatrix scalarAdd(BigDecimal d) { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];"
      },
      {
        "txt": "for (int row = 0; row < rowCount; row++) { final BigDecimal[] dataRow = data[row]; final BigDecimal[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col].add(d); } } return new BigMatrixImpl(outData, false); } public BigMatrix scalarMultiply(BigDecimal d) {"
      },
      {
        "txt": "final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final BigDecimal[] dataRow = data[row]; final BigDecimal[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col].multiply(d); } }"
      },
      {
        "txt": "return new BigMatrixImpl(outData, false); } public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException { try { return multiply((BigMatrixImpl) m); } catch (ClassCastException cce) { if (this.getColumnDimension() != m.getRowDimension()) { throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\"); } final int nRows = this.getRowDimension();"
      },
      {
        "txt": "final int nCols = m.getColumnDimension(); final int nSum = this.getColumnDimension(); final BigDecimal[][] outData = new BigDecimal[nRows][nCols]; for (int row = 0; row < nRows; row++) { final BigDecimal[] dataRow = data[row]; final BigDecimal[] outDataRow = outData[row]; for (int col = 0; col < nCols; col++) { BigDecimal sum = ZERO; for (int i = 0; i < nSum; i++) { sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));"
      },
      {
        "txt": "} outDataRow[col] = sum; } } return new BigMatrixImpl(outData, false); } } public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException { if (this.getColumnDimension() != m.getRowDimension()) { throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");"
      },
      {
        "txt": "} final int nRows = this.getRowDimension(); final int nCols = m.getColumnDimension(); final int nSum = this.getColumnDimension(); final BigDecimal[][] outData = new BigDecimal[nRows][nCols]; for (int row = 0; row < nRows; row++) { final BigDecimal[] dataRow = data[row]; final BigDecimal[] outDataRow = outData[row]; for (int col = 0; col < nCols; col++) { BigDecimal sum = ZERO;"
      },
      {
        "txt": "for (int i = 0; i < nSum; i++) { sum = sum.add(dataRow[i].multiply(m.data[i][col])); } outDataRow[col] = sum; } } return new BigMatrixImpl(outData, false); } public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException { return m.multiply(this);"
      },
      {
        "txt": "} public BigDecimal[][] getData() { return copyOut(); } public double[][] getDataAsDoubleArray() { final int nRows = getRowDimension(); final int nCols = getColumnDimension(); final double d[][] = new double[nRows][nCols]; for (int i = 0; i < nRows; i++) { for (int j = 0; j < nCols; j++) {"
      },
      {
        "txt": "d[i][j] = data[i][j].doubleValue(); } } return d; } public BigDecimal[][] getDataRef() { return data; } public int getRoundingMode() { return roundingMode;"
      },
      {
        "txt": "} public void setRoundingMode(int roundingMode) { this.roundingMode = roundingMode; } public int getScale() { return scale; } public void setScale(int scale) { this.scale = scale; }"
      },
      {
        "txt": "public BigDecimal getNorm() { BigDecimal maxColSum = ZERO; for (int col = 0; col < this.getColumnDimension(); col++) { BigDecimal sum = ZERO; for (int row = 0; row < this.getRowDimension(); row++) { sum = sum.add(data[row][col].abs()); } maxColSum = maxColSum.max(sum); } return maxColSum;"
      },
      {
        "txt": "} public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException { if (startRow < 0 || startRow > endRow || endRow > data.length || startColumn < 0 || startColumn > endColumn || endColumn > data[0].length ) { throw new MatrixIndexException( \"invalid row or column index selection\"); }"
      },
      {
        "txt": "final BigDecimal[][] subMatrixData = new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1]; for (int i = startRow; i <= endRow; i++) { System.arraycopy(data[i], startColumn, subMatrixData[i - startRow], 0, endColumn - startColumn + 1); } return new BigMatrixImpl(subMatrixData, false); } public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)"
      },
      {
        "txt": "throws MatrixIndexException { if (selectedRows.length * selectedColumns.length == 0) { throw new MatrixIndexException( \"selected row and column index arrays must be non-empty\"); } final BigDecimal[][] subMatrixData = new BigDecimal[selectedRows.length][selectedColumns.length]; try { for (int i = 0; i < selectedRows.length; i++) { final BigDecimal[] subI = subMatrixData[i];"
      },
      {
        "txt": "final BigDecimal[] dataSelectedI = data[selectedRows[i]]; for (int j = 0; j < selectedColumns.length; j++) { subI[j] = dataSelectedI[selectedColumns[j]]; } } } catch (ArrayIndexOutOfBoundsException e) { throw new MatrixIndexException(\"matrix dimension mismatch\"); } return new BigMatrixImpl(subMatrixData, false);"
      },
      {
        "txt": "} public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException { if ((row < 0) || (column < 0)){ throw new MatrixIndexException (\"invalid row or column index selection\"); } final int nRows = subMatrix.length; if (nRows == 0) { throw new IllegalArgumentException("
      },
      {
        "txt": "\"Matrix must have at least one row.\"); } final int nCols = subMatrix[0].length; if (nCols == 0) { throw new IllegalArgumentException( \"Matrix must have at least one column.\"); } for (int r = 1; r < nRows; r++) { if (subMatrix[r].length != nCols) { throw new IllegalArgumentException("
      },
      {
        "txt": "\"All input rows must have the same length.\"); } } if (data == null) { if ((row > 0)||(column > 0)) throw new MatrixIndexException (\"matrix must be initialized to perfom this method\"); data = new BigDecimal[nRows][nCols]; System.arraycopy(subMatrix, 0, data, 0, subMatrix.length); } if (((nRows + row) > this.getRowDimension()) ||"
      },
      {
        "txt": "(nCols + column > this.getColumnDimension())) throw new MatrixIndexException( \"invalid row or column index selection\"); for (int i = 0; i < nRows; i++) { System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols); } lu = null; } public BigMatrix getRowMatrix(int row) throws MatrixIndexException { if ( !isValidCoordinate( row, 0)) {"
      },
      {
        "txt": "throw new MatrixIndexException(\"illegal row argument\"); } final int ncols = this.getColumnDimension(); final BigDecimal[][] out = new BigDecimal[1][ncols]; System.arraycopy(data[row], 0, out[0], 0, ncols); return new BigMatrixImpl(out, false); } public BigMatrix getColumnMatrix(int column) throws MatrixIndexException { if ( !isValidCoordinate( 0, column)) { throw new MatrixIndexException(\"illegal column argument\");"
      },
      {
        "txt": "} final int nRows = this.getRowDimension(); final BigDecimal[][] out = new BigDecimal[nRows][1]; for (int row = 0; row < nRows; row++) { out[row][0] = data[row][column]; } return new BigMatrixImpl(out, false); } public BigDecimal[] getRow(int row) throws MatrixIndexException { if ( !isValidCoordinate( row, 0 ) ) {"
      },
      {
        "txt": "throw new MatrixIndexException(\"illegal row argument\"); } final int ncols = this.getColumnDimension(); final BigDecimal[] out = new BigDecimal[ncols]; System.arraycopy(data[row], 0, out, 0, ncols); return out; } public double[] getRowAsDoubleArray(int row) throws MatrixIndexException { if ( !isValidCoordinate( row, 0 ) ) { throw new MatrixIndexException(\"illegal row argument\");"
      },
      {
        "txt": "} final int ncols = this.getColumnDimension(); final double[] out = new double[ncols]; for (int i=0;i<ncols;i++) { out[i] = data[row][i].doubleValue(); } return out; } public BigDecimal[] getColumn(int col) throws MatrixIndexException { if ( !isValidCoordinate(0, col) ) {"
      },
      {
        "txt": "throw new MatrixIndexException(\"illegal column argument\"); } final int nRows = this.getRowDimension(); final BigDecimal[] out = new BigDecimal[nRows]; for (int i = 0; i < nRows; i++) { out[i] = data[i][col]; } return out; } public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {"
      },
      {
        "txt": "if ( !isValidCoordinate( 0, col ) ) { throw new MatrixIndexException(\"illegal column argument\"); } final int nrows = this.getRowDimension(); final double[] out = new double[nrows]; for (int i=0;i<nrows;i++) { out[i] = data[i][col].doubleValue(); } return out; }"
      },
      {
        "txt": "public BigDecimal getEntry(int row, int column) throws MatrixIndexException { try { return data[row][column]; } catch (ArrayIndexOutOfBoundsException e) { throw new MatrixIndexException(\"matrix entry does not exist\"); } } public double getEntryAsDouble(int row, int column) throws MatrixIndexException { return getEntry(row,column).doubleValue();"
      },
      {
        "txt": "} public BigMatrix transpose() { final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); final BigDecimal[][] outData = new BigDecimal[nCols][nRows]; for (int row = 0; row < nRows; row++) { final BigDecimal[] dataRow = data[row]; for (int col = 0; col < nCols; col++) { outData[col][row] = dataRow[col]; }"
      },
      {
        "txt": "} return new BigMatrixImpl(outData, false); } public BigMatrix inverse() throws InvalidMatrixException { return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension())); } public BigDecimal getDeterminant() throws InvalidMatrixException { if (!isSquare()) { throw new InvalidMatrixException(\"matrix is not square\"); }"
      },
      {
        "txt": "if (isSingular()) { // note: this has side effect of attempting LU decomp if lu == null return ZERO; } else { BigDecimal det = (parity == 1) ? ONE : ONE.negate(); for (int i = 0; i < this.getRowDimension(); i++) { det = det.multiply(lu[i][i]); } return det; } }"
      },
      {
        "txt": "public boolean isSquare() { return (this.getColumnDimension() == this.getRowDimension()); } public boolean isSingular() { if (lu == null) { try { luDecompose(); return false; } catch (InvalidMatrixException ex) { return true;"
      },
      {
        "txt": "} } else { // LU decomp must have been successfully performed return false; // so the matrix is not singular } } public int getRowDimension() { return data.length; } public int getColumnDimension() { return data[0].length;"
      },
      {
        "txt": "} public BigDecimal getTrace() throws IllegalArgumentException { if (!isSquare()) { throw new IllegalArgumentException(\"matrix is not square\"); } BigDecimal trace = data[0][0]; for (int i = 1; i < this.getRowDimension(); i++) { trace = trace.add(data[i][i]); } return trace;"
      },
      {
        "txt": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length != this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); <extra_id_0> for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum;"
      },
      {
        "txt": "} out[row] = sum; } return out; } public BigDecimal[] operate(double[] v) throws IllegalArgumentException { final BigDecimal bd[] = new BigDecimal[v.length]; for (int i = 0; i < bd.length; i++) { bd[i] = new BigDecimal(v[i]); }"
      },
      {
        "txt": "return operate(bd); } public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException { final int nRows = this.getRowDimension(); if (v.length != nRows) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nCols = this.getColumnDimension(); final BigDecimal[] out = new BigDecimal[nCols]; for (int col = 0; col < nCols; col++) {"
      },
      {
        "txt": "BigDecimal sum = ZERO; for (int i = 0; i < nRows; i++) { sum = sum.add(data[i][col].multiply(v[i])); } out[col] = sum; } return out; } public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException { final int nRows = this.getRowDimension();"
      },
      {
        "txt": "if (b.length != nRows) { throw new IllegalArgumentException(\"constant vector has wrong length\"); } final BigMatrix bMatrix = new BigMatrixImpl(b); final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef(); final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { out[row] = solution[row][0]; } return out;"
      },
      {
        "txt": "} public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException { final BigDecimal bd[] = new BigDecimal[b.length]; for (int i = 0; i < bd.length; i++) { bd[i] = new BigDecimal(b[i]); } return solve(bd); } public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException { if (b.getRowDimension() != this.getRowDimension()) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Incorrect row dimension\"); } if (!this.isSquare()) { throw new InvalidMatrixException(\"coefficient matrix is not square\"); } if (this.isSingular()) { // side effect: compute LU decomp throw new InvalidMatrixException(\"Matrix is singular.\"); } final int nCol = this.getColumnDimension(); final int nColB = b.getColumnDimension();"
      },
      {
        "txt": "final int nRowB = b.getRowDimension(); final BigDecimal[][] bp = new BigDecimal[nRowB][nColB]; for (int row = 0; row < nRowB; row++) { final BigDecimal[] bpRow = bp[row]; for (int col = 0; col < nColB; col++) { bpRow[col] = b.getEntry(permutation[row], col); } } for (int col = 0; col < nCol; col++) { for (int i = col + 1; i < nCol; i++) {"
      },
      {
        "txt": "final BigDecimal[] bpI = bp[i]; final BigDecimal[] luI = lu[i]; for (int j = 0; j < nColB; j++) { bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col])); } } } for (int col = nCol - 1; col >= 0; col--) { final BigDecimal[] bpCol = bp[col]; final BigDecimal luDiag = lu[col][col];"
      },
      {
        "txt": "for (int j = 0; j < nColB; j++) { bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode); } for (int i = 0; i < col; i++) { final BigDecimal[] bpI = bp[i]; final BigDecimal[] luI = lu[i]; for (int j = 0; j < nColB; j++) { bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col])); } }"
      },
      {
        "txt": "} return new BigMatrixImpl(bp, false); } public void luDecompose() throws InvalidMatrixException { final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); if (nRows != nCols) { throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\"); } lu = this.getData();"
      },
      {
        "txt": "permutation = new int[nRows]; for (int row = 0; row < nRows; row++) { permutation[row] = row; } parity = 1; for (int col = 0; col < nCols; col++) { BigDecimal sum = ZERO; for (int row = 0; row < col; row++) { final BigDecimal[] luRow = lu[row]; sum = luRow[col];"
      },
      {
        "txt": "for (int i = 0; i < row; i++) { sum = sum.subtract(luRow[i].multiply(lu[i][col])); } luRow[col] = sum; } int max = col; // permutation row BigDecimal largest = ZERO; for (int row = col; row < nRows; row++) { final BigDecimal[] luRow = lu[row]; sum = luRow[col];"
      },
      {
        "txt": "for (int i = 0; i < col; i++) { sum = sum.subtract(luRow[i].multiply(lu[i][col])); } luRow[col] = sum; if (sum.abs().compareTo(largest) == 1) { largest = sum.abs(); max = row; } } if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {"
      },
      {
        "txt": "lu = null; throw new InvalidMatrixException(\"matrix is singular\"); } if (max != col) { BigDecimal tmp = ZERO; for (int i = 0; i < nCols; i++) { tmp = lu[max][i]; lu[max][i] = lu[col][i]; lu[col][i] = tmp; }"
      },
      {
        "txt": "int temp = permutation[max]; permutation[max] = permutation[col]; permutation[col] = temp; parity = -parity; } final BigDecimal luDiag = lu[col][col]; for (int row = col + 1; row < nRows; row++) { final BigDecimal[] luRow = lu[row]; luRow[col] = luRow[col].divide(luDiag, scale, roundingMode); }"
      },
      {
        "txt": "} } public String toString() { StringBuffer res = new StringBuffer(); res.append(\"BigMatrixImpl{\"); if (data != null) { for (int i = 0; i < data.length; i++) { if (i > 0) { res.append(\",\"); }"
      },
      {
        "txt": "res.append(\"{\"); for (int j = 0; j < data[0].length; j++) { if (j > 0) { res.append(\",\"); } res.append(data[i][j]); } res.append(\"}\"); } }"
      },
      {
        "txt": "res.append(\"}\"); return res.toString(); } public boolean equals(Object object) { if (object == this ) { return true; } if (object instanceof BigMatrixImpl == false) { return false; }"
      },
      {
        "txt": "final BigMatrix m = (BigMatrix) object; final int nRows = getRowDimension(); final int nCols = getColumnDimension(); if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) { return false; } for (int row = 0; row < nRows; row++) { final BigDecimal[] dataRow = data[row]; for (int col = 0; col < nCols; col++) { if (!dataRow[col].equals(m.getEntry(row, col))) {"
      },
      {
        "txt": "return false; } } } return true; } public int hashCode() { int ret = 7; final int nRows = getRowDimension(); final int nCols = getColumnDimension();"
      },
      {
        "txt": "ret = ret * 31 + nRows; ret = ret * 31 + nCols; for (int row = 0; row < nRows; row++) { final BigDecimal[] dataRow = data[row]; for (int col = 0; col < nCols; col++) { ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * dataRow[col].hashCode(); } } return ret;"
      },
      {
        "txt": "} protected BigMatrix getLUMatrix() throws InvalidMatrixException { if (lu == null) { luDecompose(); } return new BigMatrixImpl(lu); } protected int[] getPermutation() { final int[] out = new int[permutation.length]; System.arraycopy(permutation, 0, out, 0, permutation.length);"
      },
      {
        "txt": "return out; } private BigDecimal[][] copyOut() { final int nRows = this.getRowDimension(); final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()]; for (int i = 0; i < nRows; i++) { System.arraycopy(data[i], 0, out[i], 0, data[i].length); } return out; }"
      },
      {
        "txt": "private void copyIn(BigDecimal[][] in) { setSubMatrix(in,0,0); } private void copyIn(double[][] in) { final int nRows = in.length; final int nCols = in[0].length; data = new BigDecimal[nRows][nCols]; for (int i = 0; i < nRows; i++) { final BigDecimal[] dataI = data[i]; final double[] inI = in[i];"
      },
      {
        "txt": "for (int j = 0; j < nCols; j++) { dataI[j] = new BigDecimal(inI[j]); } } lu = null; } private void copyIn(String[][] in) { final int nRows = in.length; final int nCols = in[0].length; data = new BigDecimal[nRows][nCols];"
      },
      {
        "txt": "for (int i = 0; i < nRows; i++) { final BigDecimal[] dataI = data[i]; final String[] inI = in[i]; for (int j = 0; j < nCols; j++) { dataI[j] = new BigDecimal(inI[j]); } } lu = null; } private boolean isValidCoordinate(int row, int col) {"
      },
      {
        "txt": "final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); return !(row < 0 || row >= nRows || col < 0 || col >= nCols); }"
      }
    ]
  },
  {
    "id": 2730,
    "file_path": "src/java/org/apache/commons/math/linear/RealMatrixImpl.java",
    "start-bug-line": 779,
    "end-bug-line": 779,
    "bug": "final double[] out = new double[v.length];",
    "fix": "final double[] out = new double[nRows];",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math.linear; import java.io.Serializable; import org.apache.commons.math.util.MathUtils; public class RealMatrixImpl implements RealMatrix, Serializable { private static final long serialVersionUID = -4828886979278117018L; protected double data[][] = null; protected double lu[][] = null;"
      },
      {
        "txt": "protected int[] permutation = null; protected int parity = 1; private static final double TOO_SMALL = 10E-12; public RealMatrixImpl() { } public RealMatrixImpl(int rowDimension, int columnDimension) { if (rowDimension <= 0 || columnDimension <= 0) { throw new IllegalArgumentException( \"row and column dimensions must be postive\"); }"
      },
      {
        "txt": "data = new double[rowDimension][columnDimension]; lu = null; } public RealMatrixImpl(double[][] d) { copyIn(d); lu = null; } public RealMatrixImpl(double[][] d, boolean copyArray) { if (copyArray) { copyIn(d);"
      },
      {
        "txt": "} else { if (d == null) { throw new NullPointerException(); } final int nRows = d.length; if (nRows == 0) { throw new IllegalArgumentException(\"Matrix must have at least one row.\"); } final int nCols = d[0].length; if (nCols == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Matrix must have at least one column.\"); } for (int r = 1; r < nRows; r++) { if (d[r].length != nCols) { throw new IllegalArgumentException(\"All input rows must have the same length.\"); } } data = d; } lu = null;"
      },
      {
        "txt": "} public RealMatrixImpl(double[] v) { final int nRows = v.length; data = new double[nRows][1]; for (int row = 0; row < nRows; row++) { data[row][0] = v[row]; } } public RealMatrix copy() { return new RealMatrixImpl(copyOut(), false);"
      },
      {
        "txt": "} public RealMatrix add(RealMatrix m) throws IllegalArgumentException { try { return add((RealMatrixImpl) m); } catch (ClassCastException cce) { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\"); }"
      },
      {
        "txt": "final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow = data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] + m.getEntry(row, col); } } return new RealMatrixImpl(outData, false); }"
      },
      {
        "txt": "} public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\"); } final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow = data[row];"
      },
      {
        "txt": "final double[] mRow = m.data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] + mRow[col]; } } return new RealMatrixImpl(outData, false); } public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException { try {"
      },
      {
        "txt": "return subtract((RealMatrixImpl) m); } catch (ClassCastException cce) { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\"); } final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow = data[row];"
      },
      {
        "txt": "final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] - m.getEntry(row, col); } } return new RealMatrixImpl(outData, false); } } public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException { final int rowCount = getRowDimension();"
      },
      {
        "txt": "final int columnCount = getColumnDimension(); if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) { throw new IllegalArgumentException(\"matrix dimension mismatch\"); } final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow = data[row]; final double[] mRow = m.data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) {"
      },
      {
        "txt": "outDataRow[col] = dataRow[col] - mRow[col]; } } return new RealMatrixImpl(outData, false); } public RealMatrix scalarAdd(double d) { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) {"
      },
      {
        "txt": "final double[] dataRow = data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] + d; } } return new RealMatrixImpl(outData, false); } public RealMatrix scalarMultiply(double d) { final int rowCount = getRowDimension();"
      },
      {
        "txt": "final int columnCount = getColumnDimension(); final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow = data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] * d; } } return new RealMatrixImpl(outData, false);"
      },
      {
        "txt": "} public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException { try { return multiply((RealMatrixImpl) m); } catch (ClassCastException cce) { if (this.getColumnDimension() != m.getRowDimension()) { throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\"); } final int nRows = this.getRowDimension(); final int nCols = m.getColumnDimension();"
      },
      {
        "txt": "final int nSum = this.getColumnDimension(); final double[][] outData = new double[nRows][nCols]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < nCols; col++) { double sum = 0; for (int i = 0; i < nSum; i++) { sum += dataRow[i] * m.getEntry(i, col); }"
      },
      {
        "txt": "outDataRow[col] = sum; } } return new RealMatrixImpl(outData, false); } } public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException { if (this.getColumnDimension() != m.getRowDimension()) { throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\"); }"
      },
      {
        "txt": "final int nRows = this.getRowDimension(); final int nCols = m.getColumnDimension(); final int nSum = this.getColumnDimension(); final double[][] outData = new double[nRows][nCols]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < nCols; col++) { double sum = 0; for (int i = 0; i < nSum; i++) {"
      },
      {
        "txt": "sum += dataRow[i] * m.data[i][col]; } outDataRow[col] = sum; } } return new RealMatrixImpl(outData, false); } public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException { return m.multiply(this); }"
      },
      {
        "txt": "public double[][] getData() { return copyOut(); } public double[][] getDataRef() { return data; } public double getNorm() { double maxColSum = 0; for (int col = 0; col < this.getColumnDimension(); col++) { double sum = 0;"
      },
      {
        "txt": "for (int row = 0; row < this.getRowDimension(); row++) { sum += Math.abs(data[row][col]); } maxColSum = Math.max(maxColSum, sum); } return maxColSum; } public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {"
      },
      {
        "txt": "if (startRow < 0 || startRow > endRow || endRow > data.length || startColumn < 0 || startColumn > endColumn || endColumn > data[0].length) { throw new MatrixIndexException( \"invalid row or column index selection\"); } final double[][] subMatrixData = new double[endRow - startRow + 1][endColumn - startColumn + 1]; for (int i = startRow; i <= endRow; i++) { System.arraycopy(data[i], startColumn,"
      },
      {
        "txt": "subMatrixData[i - startRow], 0, endColumn - startColumn + 1); } return new RealMatrixImpl(subMatrixData, false); } public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException { if (selectedRows.length * selectedColumns.length == 0) { throw new MatrixIndexException( \"selected row and column index arrays must be non-empty\");"
      },
      {
        "txt": "} final double[][] subMatrixData = new double[selectedRows.length][selectedColumns.length]; try { for (int i = 0; i < selectedRows.length; i++) { final double[] subI = subMatrixData[i]; final double[] dataSelectedI = data[selectedRows[i]]; for (int j = 0; j < selectedColumns.length; j++) { subI[j] = dataSelectedI[selectedColumns[j]]; }"
      },
      {
        "txt": "} } catch (ArrayIndexOutOfBoundsException e) { throw new MatrixIndexException(\"matrix dimension mismatch\"); } return new RealMatrixImpl(subMatrixData, false); } public void setSubMatrix(double[][] subMatrix, int row, int column) throws MatrixIndexException { if ((row < 0) || (column < 0)){ throw new MatrixIndexException"
      },
      {
        "txt": "(\"invalid row or column index selection\"); } final int nRows = subMatrix.length; if (nRows == 0) { throw new IllegalArgumentException( \"Matrix must have at least one row.\"); } final int nCols = subMatrix[0].length; if (nCols == 0) { throw new IllegalArgumentException("
      },
      {
        "txt": "\"Matrix must have at least one column.\"); } for (int r = 1; r < nRows; r++) { if (subMatrix[r].length != nCols) { throw new IllegalArgumentException( \"All input rows must have the same length.\"); } } if (data == null) { if ((row > 0)||(column > 0)) throw new MatrixIndexException"
      },
      {
        "txt": "(\"matrix must be initialized to perfom this method\"); data = new double[nRows][nCols]; System.arraycopy(subMatrix, 0, data, 0, subMatrix.length); } if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension())) throw new MatrixIndexException( \"invalid row or column index selection\"); for (int i = 0; i < nRows; i++) { System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);"
      },
      {
        "txt": "} lu = null; } public RealMatrix getRowMatrix(int row) throws MatrixIndexException { if ( !isValidCoordinate( row, 0)) { throw new MatrixIndexException(\"illegal row argument\"); } final int ncols = this.getColumnDimension(); final double[][] out = new double[1][ncols]; System.arraycopy(data[row], 0, out[0], 0, ncols);"
      },
      {
        "txt": "return new RealMatrixImpl(out, false); } public RealMatrix getColumnMatrix(int column) throws MatrixIndexException { if ( !isValidCoordinate( 0, column)) { throw new MatrixIndexException(\"illegal column argument\"); } final int nRows = this.getRowDimension(); final double[][] out = new double[nRows][1]; for (int row = 0; row < nRows; row++) { out[row][0] = data[row][column];"
      },
      {
        "txt": "} return new RealMatrixImpl(out, false); } public double[] getRow(int row) throws MatrixIndexException { if ( !isValidCoordinate( row, 0 ) ) { throw new MatrixIndexException(\"illegal row argument\"); } final int ncols = this.getColumnDimension(); final double[] out = new double[ncols]; System.arraycopy(data[row], 0, out, 0, ncols);"
      },
      {
        "txt": "return out; } public double[] getColumn(int col) throws MatrixIndexException { if ( !isValidCoordinate(0, col) ) { throw new MatrixIndexException(\"illegal column argument\"); } final int nRows = this.getRowDimension(); final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { out[row] = data[row][col];"
      },
      {
        "txt": "} return out; } public double getEntry(int row, int column) throws MatrixIndexException { try { return data[row][column]; } catch (ArrayIndexOutOfBoundsException e) { throw new MatrixIndexException(\"matrix entry does not exist\"); }"
      },
      {
        "txt": "} public RealMatrix transpose() { final int nRows = getRowDimension(); final int nCols = getColumnDimension(); final double[][] outData = new double[nCols][nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; for (int col = 0; col < nCols; col++) { outData[col][row] = dataRow[col]; }"
      },
      {
        "txt": "} return new RealMatrixImpl(outData, false); } public RealMatrix inverse() throws InvalidMatrixException { return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension())); } public double getDeterminant() throws InvalidMatrixException { if (!isSquare()) { throw new InvalidMatrixException(\"matrix is not square\"); }"
      },
      {
        "txt": "if (isSingular()) { // note: this has side effect of attempting LU decomp if lu == null return 0d; } else { double det = parity; for (int i = 0; i < this.getRowDimension(); i++) { det *= lu[i][i]; } return det; } }"
      },
      {
        "txt": "public boolean isSquare() { return (this.getColumnDimension() == this.getRowDimension()); } public boolean isSingular() { if (lu == null) { try { luDecompose(); return false; } catch (InvalidMatrixException ex) { return true;"
      },
      {
        "txt": "} } else { // LU decomp must have been successfully performed return false; // so the matrix is not singular } } public int getRowDimension() { return data.length; } public int getColumnDimension() { return data[0].length;"
      },
      {
        "txt": "} public double getTrace() throws IllegalArgumentException { if (!isSquare()) { throw new IllegalArgumentException(\"matrix is not square\"); } double trace = data[0][0]; for (int i = 1; i < this.getRowDimension(); i++) { trace += data[i][i]; } return trace;"
      },
      {
        "txt": "public double[] operate(double[] v) throws IllegalArgumentException { final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); if (v.length != nCols) { throw new IllegalArgumentException(\"vector has wrong length\"); } <extra_id_0> for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0; for (int i = 0; i < nCols; i++) { sum += dataRow[i] * v[i]; }"
      },
      {
        "txt": "sum += dataRow[i] * v[i]; } out[row] = sum; } return out; } public double[] preMultiply(double[] v) throws IllegalArgumentException { final int nRows = this.getRowDimension(); if (v.length != nRows) { throw new IllegalArgumentException(\"vector has wrong length\");"
      },
      {
        "txt": "} final int nCols = this.getColumnDimension(); final double[] out = new double[nCols]; for (int col = 0; col < nCols; col++) { double sum = 0; for (int i = 0; i < nRows; i++) { sum += data[i][col] * v[i]; } out[col] = sum; }"
      },
      {
        "txt": "return out; } public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException { final int nRows = this.getRowDimension(); if (b.length != nRows) { throw new IllegalArgumentException(\"constant vector has wrong length\"); } final RealMatrix bMatrix = new RealMatrixImpl(b); final double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef(); final double[] out = new double[nRows];"
      },
      {
        "txt": "for (int row = 0; row < nRows; row++) { out[row] = solution[row][0]; } return out; } public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException { if (b.getRowDimension() != this.getRowDimension()) { throw new IllegalArgumentException(\"Incorrect row dimension\"); } if (!this.isSquare()) {"
      },
      {
        "txt": "throw new InvalidMatrixException(\"coefficient matrix is not square\"); } if (this.isSingular()) { // side effect: compute LU decomp throw new InvalidMatrixException(\"Matrix is singular.\"); } final int nCol = this.getColumnDimension(); final int nColB = b.getColumnDimension(); final int nRowB = b.getRowDimension(); final double[][] bp = new double[nRowB][nColB]; for (int row = 0; row < nRowB; row++) {"
      },
      {
        "txt": "final double[] bpRow = bp[row]; for (int col = 0; col < nColB; col++) { bpRow[col] = b.getEntry(permutation[row], col); } } for (int col = 0; col < nCol; col++) { for (int i = col + 1; i < nCol; i++) { final double[] bpI = bp[i]; final double[] luI = lu[i]; for (int j = 0; j < nColB; j++) {"
      },
      {
        "txt": "bpI[j] -= bp[col][j] * luI[col]; } } } for (int col = nCol - 1; col >= 0; col--) { final double[] bpCol = bp[col]; final double luDiag = lu[col][col]; for (int j = 0; j < nColB; j++) { bpCol[j] /= luDiag; }"
      },
      {
        "txt": "for (int i = 0; i < col; i++) { final double[] bpI = bp[i]; final double[] luI = lu[i]; for (int j = 0; j < nColB; j++) { bpI[j] -= bp[col][j] * luI[col]; } } } return new RealMatrixImpl(bp, false); }"
      },
      {
        "txt": "public void luDecompose() throws InvalidMatrixException { final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); if (nRows != nCols) { throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\"); } lu = getData(); permutation = new int[nRows]; for (int row = 0; row < nRows; row++) { permutation[row] = row;"
      },
      {
        "txt": "} parity = 1; for (int col = 0; col < nCols; col++) { double sum = 0; for (int row = 0; row < col; row++) { final double[] luRow = lu[row]; sum = luRow[col]; for (int i = 0; i < row; i++) { sum -= luRow[i] * lu[i][col]; }"
      },
      {
        "txt": "luRow[col] = sum; } int max = col; // permutation row double largest = 0d; for (int row = col; row < nRows; row++) { final double[] luRow = lu[row]; sum = luRow[col]; for (int i = 0; i < col; i++) { sum -= luRow[i] * lu[i][col]; }"
      },
      {
        "txt": "luRow[col] = sum; if (Math.abs(sum) > largest) { largest = Math.abs(sum); max = row; } } if (Math.abs(lu[max][col]) < TOO_SMALL) { lu = null; throw new InvalidMatrixException(\"matrix is singular\"); }"
      },
      {
        "txt": "if (max != col) { double tmp = 0; for (int i = 0; i < nCols; i++) { tmp = lu[max][i]; lu[max][i] = lu[col][i]; lu[col][i] = tmp; } int temp = permutation[max]; permutation[max] = permutation[col]; permutation[col] = temp;"
      },
      {
        "txt": "parity = -parity; } final double luDiag = lu[col][col]; for (int row = col + 1; row < nRows; row++) { lu[row][col] /= luDiag; } } } public String toString() { StringBuffer res = new StringBuffer();"
      },
      {
        "txt": "res.append(\"RealMatrixImpl{\"); if (data != null) { for (int i = 0; i < data.length; i++) { if (i > 0) { res.append(\",\"); } res.append(\"{\"); for (int j = 0; j < data[0].length; j++) { if (j > 0) { res.append(\",\");"
      },
      {
        "txt": "} res.append(data[i][j]); } res.append(\"}\"); } } res.append(\"}\"); return res.toString(); } public boolean equals(Object object) {"
      },
      {
        "txt": "if (object == this ) { return true; } if (object instanceof RealMatrixImpl == false) { return false; } RealMatrix m = (RealMatrix) object; final int nRows = getRowDimension(); final int nCols = getColumnDimension(); if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {"
      },
      {
        "txt": "return false; } for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; for (int col = 0; col < nCols; col++) { if (Double.doubleToLongBits(dataRow[col]) != Double.doubleToLongBits(m.getEntry(row, col))) { return false; } }"
      },
      {
        "txt": "} return true; } public int hashCode() { int ret = 7; final int nRows = getRowDimension(); final int nCols = getColumnDimension(); ret = ret * 31 + nRows; ret = ret * 31 + nCols; for (int row = 0; row < nRows; row++) {"
      },
      {
        "txt": "final double[] dataRow = data[row]; for (int col = 0; col < nCols; col++) { ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * MathUtils.hash(dataRow[col]); } } return ret; } protected RealMatrix getLUMatrix() throws InvalidMatrixException { if (lu == null) {"
      },
      {
        "txt": "luDecompose(); } return new RealMatrixImpl(lu); } protected int[] getPermutation() { final int[] out = new int[permutation.length]; System.arraycopy(permutation, 0, out, 0, permutation.length); return out; } private double[][] copyOut() {"
      },
      {
        "txt": "final int nRows = this.getRowDimension(); final double[][] out = new double[nRows][this.getColumnDimension()]; for (int i = 0; i < nRows; i++) { System.arraycopy(data[i], 0, out[i], 0, data[i].length); } return out; } private void copyIn(double[][] in) { setSubMatrix(in,0,0); }"
      },
      {
        "txt": "private boolean isValidCoordinate(int row, int col) { final int nRows = getRowDimension(); final int nCols = getColumnDimension(); return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1); }"
      }
    ]
  }
]