[
  {
    "id": 2493,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 82,
    "end-bug-line": 82,
    "bug": "",
    "fix": "private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream; public class FastMath { <extra_id_0> public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024"
      },
      {
        "txt": "static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14},"
      },
      {
        "txt": "{0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8},"
      },
      {
        "txt": "{-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d,"
      },
      {
        "txt": "+0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d,"
      },
      {
        "txt": "+0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d,"
      },
      {
        "txt": "+4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] ="
      },
      {
        "txt": "{ +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d,"
      },
      {
        "txt": "+0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d,"
      },
      {
        "txt": "+5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d,"
      },
      {
        "txt": "+3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d,"
      },
      {
        "txt": "+0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, };"
      },
      {
        "txt": "private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d,"
      },
      {
        "txt": "+1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L,"
      },
      {
        "txt": "(0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L,"
      },
      {
        "txt": "(0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};"
      },
      {
        "txt": "private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d;"
      },
      {
        "txt": "private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d;"
      },
      {
        "txt": "private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert }"
      },
      {
        "txt": "long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) { return Math.sqrt(a); } public static double cosh(double x) { if (x != x) { return x;"
      },
      {
        "txt": "} if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x;"
      },
      {
        "txt": "} exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp;"
      },
      {
        "txt": "double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb;"
      },
      {
        "txt": "result *= 0.5; return result; } public static double sinh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x);"
      },
      {
        "txt": "} if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true;"
      },
      {
        "txt": "} double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa;"
      },
      {
        "txt": "double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa);"
      },
      {
        "txt": "ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2]; expm1(x, hiPrec);"
      },
      {
        "txt": "double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000;"
      },
      {
        "txt": "double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb);"
      },
      {
        "txt": "ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; } return result; } public static double tanh(double x) {"
      },
      {
        "txt": "boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0; } if (x < -20) { return -1.0; }"
      },
      {
        "txt": "if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x >= 0.5) { double hiPrec[] = new double[2];"
      },
      {
        "txt": "exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb); na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya);"
      },
      {
        "txt": "temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa;"
      },
      {
        "txt": "ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else { double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);"
      },
      {
        "txt": "double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa;"
      },
      {
        "txt": "double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } if (negate) {"
      },
      {
        "txt": "result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); } public static double asinh(double a) { boolean negative = false; if (a < 0) {"
      },
      {
        "txt": "negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else { final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);"
      },
      {
        "txt": "} else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); } } return negative ? -absAsinh : absAsinh; }"
      },
      {
        "txt": "public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else {"
      },
      {
        "txt": "final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); }"
      },
      {
        "txt": "} return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) {"
      },
      {
        "txt": "return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random(); } public static double exp(double x) { return exp(x, 0.0, null);"
      },
      {
        "txt": "} private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0;"
      },
      {
        "txt": "hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; }"
      },
      {
        "txt": "return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; } return result; }"
      },
      {
        "txt": "intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0;"
      },
      {
        "txt": "} return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0);"
      },
      {
        "txt": "full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion."
      },
      {
        "txt": "tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) {"
      },
      {
        "txt": "result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result; }"
      },
      {
        "txt": "public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; } if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec);"
      },
      {
        "txt": "if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb; } } double baseA;"
      },
      {
        "txt": "double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true; } { int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;"
      },
      {
        "txt": "double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571;"
      },
      {
        "txt": "zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb; zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000;"
      },
      {
        "txt": "temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp;"
      },
      {
        "txt": "temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za; yb += -(temp - ya - za); ya = temp; temp = ya + baseB;"
      },
      {
        "txt": "yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr;"
      },
      {
        "txt": "temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra;"
      },
      {
        "txt": "yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb; } public static double log(final double x) { return log(x, null);"
      },
      {
        "txt": "} private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN;"
      },
      {
        "txt": "} return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY; } bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) {"
      },
      {
        "txt": "--exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000;"
      },
      {
        "txt": "double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb;"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; }"
      },
      {
        "txt": "aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; } } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);"
      },
      {
        "txt": "epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab;"
      },
      {
        "txt": "final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb;"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; }"
      },
      {
        "txt": "aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab); } else { using standard double precision */ lnza = -0.16624882440418567;"
      },
      {
        "txt": "lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; } double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0];"
      },
      {
        "txt": "double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c; b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c;"
      },
      {
        "txt": "b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d; if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores;"
      },
      {
        "txt": "} final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x; } } public static double log10(final double x) {"
      },
      {
        "txt": "final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8;"
      },
      {
        "txt": "return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0; }"
      },
      {
        "txt": "if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0; }"
      },
      {
        "txt": "return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0;"
      },
      {
        "txt": "} } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0;"
      },
      {
        "txt": "} return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "} if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; }"
      },
      {
        "txt": "} if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; }"
      },
      {
        "txt": "} double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10;"
      },
      {
        "txt": "ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000;"
      },
      {
        "txt": "double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0);"
      },
      {
        "txt": "z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) { if (e == 0) { return 1.0; } else if (e < 0) {"
      },
      {
        "txt": "e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0; double d2p = d;"
      },
      {
        "txt": "double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh;"
      },
      {
        "txt": "resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);"
      },
      {
        "txt": "d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x) { double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4;"
      },
      {
        "txt": "p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) { double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166;"
      },
      {
        "txt": "p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx];"
      },
      {
        "txt": "final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result;"
      },
      {
        "txt": "double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA * sinEpsA; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsB; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsB;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa);"
      },
      {
        "txt": "b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx];"
      },
      {
        "txt": "double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0; double b = 0;"
      },
      {
        "txt": "double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) {"
      },
      {
        "txt": "double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000;"
      },
      {
        "txt": "double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb;"
      },
      {
        "txt": "if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err; } private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0; long shpiA; long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6);"
      },
      {
        "txt": "if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; }"
      },
      {
        "txt": "long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32);"
      },
      {
        "txt": "boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32);"
      },
      {
        "txt": "prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c; bc = b * c;"
      },
      {
        "txt": "ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; }"
      },
      {
        "txt": "c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2;"
      },
      {
        "txt": "a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c; ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32);"
      },
      {
        "txt": "bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32);"
      },
      {
        "txt": "prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c;"
      },
      {
        "txt": "ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0;"
      },
      {
        "txt": "prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB);"
      },
      {
        "txt": "result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false; int quadrant = 0; double xa; double xb = 0.0; xa = x;"
      },
      {
        "txt": "if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0;"
      },
      {
        "txt": "} if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2];"
      },
      {
        "txt": "} else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) { quadrant ^= 2; // Flip bit 1 } switch (quadrant) {"
      },
      {
        "txt": "case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3: return -cosQ(xa, xb); default: return Double.NaN;"
      },
      {
        "txt": "} } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) { xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN;"
      },
      {
        "txt": "} double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb);"
      },
      {
        "txt": "quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0: return cosQ(xa, xb); case 1: return -sinQ(xa, xb); case 2:"
      },
      {
        "txt": "return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; } } public static double tan(double x) { boolean negative = false; int quadrant = 0;"
      },
      {
        "txt": "double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; }"
      },
      {
        "txt": "return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3;"
      },
      {
        "txt": "xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (xa > 1.5) { final double pi2a = 1.5707963267948966;"
      },
      {
        "txt": "final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1; negative ^= true; } double result;"
      },
      {
        "txt": "if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) { result = -result; } return result; }"
      },
      {
        "txt": "public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) {"
      },
      {
        "txt": "xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); } if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else {"
      },
      {
        "txt": "final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000;"
      },
      {
        "txt": "double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx];"
      },
      {
        "txt": "double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp;"
      },
      {
        "txt": "final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za; } epsA = ya; epsB = yb;"
      },
      {
        "txt": "final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305;"
      },
      {
        "txt": "yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya;"
      },
      {
        "txt": "double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result;"
      },
      {
        "txt": "zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result; } return result; }"
      },
      {
        "txt": "public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y; final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) {"
      },
      {
        "txt": "return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) { return -Math.PI; } else { return Math.PI;"
      },
      {
        "txt": "} } else { return result; } } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) {"
      },
      {
        "txt": "return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4;"
      },
      {
        "txt": "} return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; } if (y < 0 || 1 / y < 0) { return -0d; }"
      },
      {
        "txt": "} if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) { return -Math.PI; } }"
      },
      {
        "txt": "if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; } } final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN"
      },
      {
        "txt": "return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp;"
      },
      {
        "txt": "if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) { if (x != x) { return Double.NaN; }"
      },
      {
        "txt": "if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) { return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign"
      },
      {
        "txt": "return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya;"
      },
      {
        "txt": "double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);"
      },
      {
        "txt": "double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp;"
      },
      {
        "txt": "return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == -1.0) {"
      },
      {
        "txt": "return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) { return Math.PI/2.0; } double temp = x * HEX_40000000; final double xa = x + temp - temp;"
      },
      {
        "txt": "final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp;"
      },
      {
        "txt": "double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb; yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero"
      },
      {
        "txt": "return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0);"
      },
      {
        "txt": "} public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) { return x; } subnormal = true;"
      },
      {
        "txt": "x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x; } int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52);"
      },
      {
        "txt": "final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est);"
      },
      {
        "txt": "double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp; zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb;"
      },
      {
        "txt": "za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) { est *= 3.814697265625E-6; // 2^-18 } return est;"
      },
      {
        "txt": "} public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa;"
      },
      {
        "txt": "double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; } public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x;"
      },
      {
        "txt": "} final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; } public static int abs(final int x) { return (x < 0) ? -x : x; }"
      },
      {
        "txt": "public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) {"
      },
      {
        "txt": "if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));"
      },
      {
        "txt": "} public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d; } if (n < -2098) { return (d > 0) ? 0.0 : -0.0;"
      },
      {
        "txt": "} if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) {"
      },
      {
        "txt": "if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Double.longBitsToDouble(sign | mantissa);"
      },
      {
        "txt": "} else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent;"
      },
      {
        "txt": "mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); } if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; }"
      },
      {
        "txt": "if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff;"
      },
      {
        "txt": "int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++;"
      },
      {
        "txt": "} return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent;"
      },
      {
        "txt": "} ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);"
      },
      {
        "txt": "} else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction;"
      },
      {
        "txt": "} else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else {"
      },
      {
        "txt": "return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;"
      },
      {
        "txt": "} else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); }"
      },
      {
        "txt": "} public static double floor(double x) { long y; if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; } y = (long) x;"
      },
      {
        "txt": "if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; } return y; } public static double ceil(double x) { double y;"
      },
      {
        "txt": "if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y; } y += 1.0; if (y == 0) { return x*y;"
      },
      {
        "txt": "} return y; } public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand }"
      },
      {
        "txt": "return y+1.0; } if (d < 0.5) { return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) { return (long) floor(x + 0.5);"
      },
      {
        "txt": "} public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b; } public static long min(final long a, final long b) { return (a <= b) ? a : b; }"
      },
      {
        "txt": "public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Float.NaN; }"
      },
      {
        "txt": "int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; } public static double min(final double a, final double b) { if (a > b) { return b; }"
      },
      {
        "txt": "if (a < b) { return a; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a; }"
      },
      {
        "txt": "return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a; } public static float max(final float a, final float b) { if (a > b) {"
      },
      {
        "txt": "return a; } if (a < b) { return b; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) {"
      },
      {
        "txt": "return b; } return a; } public static double max(final double a, final double b) { if (a > b) { return a; } if (a < b) { return b;"
      },
      {
        "txt": "} if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; }"
      },
      {
        "txt": "public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) { return abs(x);"
      },
      {
        "txt": "} else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); } }"
      },
      {
        "txt": "} public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; }"
      },
      {
        "txt": "return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign }"
      },
      {
        "txt": "public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); }"
      },
      {
        "txt": "private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {"
      },
      {
        "txt": "FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } } } else {"
      },
      {
        "txt": "EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {"
      },
      {
        "txt": "EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; } } else {"
      },
      {
        "txt": "EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][];"
      },
      {
        "txt": "for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); } } } private static class CodyWaite {"
      },
      {
        "txt": "private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA; double remB; while (true) { double a = -k * 1.570796251296997;"
      },
      {
        "txt": "remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17; b = remA; remA = a + b; remB += -(remA - b - a);"
      },
      {
        "txt": "if (remA > 0) { break; } --k; } this.finalK = k; this.finalRemA = remA; this.finalRemB = remB; } int getK() {"
      },
      {
        "txt": "return finalK; } double getRemA() { return finalRemA; } double getRemB() { return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2494,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 394,
    "end-bug-line": 394,
    "bug": "",
    "fix": "if (x >= LOG_MAX_VALUE) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream;"
      },
      {
        "txt": "public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7;"
      },
      {
        "txt": "private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9},"
      },
      {
        "txt": "}; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14;"
      },
      {
        "txt": "private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d,"
      },
      {
        "txt": "+0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d,"
      },
      {
        "txt": "-4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d,"
      },
      {
        "txt": "+4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d,"
      },
      {
        "txt": "+0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d,"
      },
      {
        "txt": "}; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d,"
      },
      {
        "txt": "+4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = {"
      },
      {
        "txt": "+0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d,"
      },
      {
        "txt": "+3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d,"
      },
      {
        "txt": "+5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d,"
      },
      {
        "txt": "-3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL,"
      },
      {
        "txt": "(0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL,"
      },
      {
        "txt": "0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 };"
      },
      {
        "txt": "private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d;"
      },
      {
        "txt": "private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d;"
      },
      {
        "txt": "private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) {"
      },
      {
        "txt": "} public static double cosh(double x) { if (x != x) { return x; } if (x > 20) { <extra_id_0> return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2];"
      },
      {
        "txt": "} final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp;"
      },
      {
        "txt": "double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp;"
      },
      {
        "txt": "temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result; } public static double sinh(double x) { boolean negate = false; if (x != x) {"
      },
      {
        "txt": "return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x;"
      },
      {
        "txt": "} if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1];"
      },
      {
        "txt": "double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip;"
      },
      {
        "txt": "recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5;"
      },
      {
        "txt": "} else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr;"
      },
      {
        "txt": "double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra;"
      },
      {
        "txt": "yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result;"
      },
      {
        "txt": "} return result; } public static double tanh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0;"
      },
      {
        "txt": "} if (x < -20) { return -1.0; } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true;"
      },
      {
        "txt": "} double result; if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb;"
      },
      {
        "txt": "nb += -(temp - na - yb); na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa;"
      },
      {
        "txt": "double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else {"
      },
      {
        "txt": "double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb);"
      },
      {
        "txt": "da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da;"
      },
      {
        "txt": "ratiob += -db * na / da / da; result = ratioa + ratiob; } if (negate) { result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1));"
      },
      {
        "txt": "} public static double asinh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);"
      },
      {
        "txt": "} else { final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);"
      },
      {
        "txt": "} } return negative ? -absAsinh : absAsinh; } public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; }"
      },
      {
        "txt": "double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) {"
      },
      {
        "txt": "absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } } return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a }"
      },
      {
        "txt": "public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() {"
      },
      {
        "txt": "return Math.random(); } public static double exp(double x) { return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) {"
      },
      {
        "txt": "intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620;"
      },
      {
        "txt": "hiPrec[1] /= 4.455505956692756620; } return result; } intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x;"
      },
      {
        "txt": "if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; }"
      },
      {
        "txt": "final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083;"
      },
      {
        "txt": "z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the"
      },
      {
        "txt": "pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA;"
      },
      {
        "txt": "hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result; } public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x;"
      },
      {
        "txt": "} if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1];"
      },
      {
        "txt": "return ra + rb; } } double baseA; double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true;"
      },
      {
        "txt": "} { int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp;"
      },
      {
        "txt": "baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon;"
      },
      {
        "txt": "double temp = za + zb; zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB);"
      },
      {
        "txt": "ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp;"
      },
      {
        "txt": "temp = ya + za; yb += -(temp - ya - za); ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) {"
      },
      {
        "txt": "double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za;"
      },
      {
        "txt": "rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; }"
      },
      {
        "txt": "return ya + yb; } public static double log(final double x) { return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; } return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) {"
      },
      {
        "txt": "polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0];"
      },
      {
        "txt": "double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1];"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb;"
      },
      {
        "txt": "} } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000;"
      },
      {
        "txt": "double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0];"
      },
      {
        "txt": "double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1];"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab;"
      },
      {
        "txt": "lnzb = -(lnza - aa - ab); } else { using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon;"
      },
      {
        "txt": "} double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c;"
      },
      {
        "txt": "b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb;"
      },
      {
        "txt": "d = -(c - a - lnzb); a = c; b = b + d; if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) {"
      },
      {
        "txt": "if (x == -1) { return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x);"
      },
      {
        "txt": "final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1;"
      },
      {
        "txt": "return y * x; } } public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000;"
      },
      {
        "txt": "final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) {"
      },
      {
        "txt": "final double lns[] = new double[2]; if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) {"
      },
      {
        "txt": "long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; }"
      },
      {
        "txt": "if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; }"
      },
      {
        "txt": "if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; }"
      },
      {
        "txt": "if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) {"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) {"
      },
      {
        "txt": "return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } } double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1;"
      },
      {
        "txt": "yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores;"
      },
      {
        "txt": "} double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab;"
      },
      {
        "txt": "lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; }"
      },
      {
        "txt": "public static double pow(double d, int e) { if (e == 0) { return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d);"
      },
      {
        "txt": "final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0; double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh;"
      },
      {
        "txt": "final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH;"
      },
      {
        "txt": "final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x)"
      },
      {
        "txt": "{ double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) {"
      },
      {
        "txt": "double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5);"
      },
      {
        "txt": "final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000;"
      },
      {
        "txt": "double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = costA * sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = costA*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) -"
      },
      {
        "txt": "(sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t); a = c; b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) {"
      },
      {
        "txt": "final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;"
      },
      {
        "txt": "final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp;"
      },
      {
        "txt": "sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;"
      },
      {
        "txt": "b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est);"
      },
      {
        "txt": "est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding"
      },
      {
        "txt": "err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err;"
      },
      {
        "txt": "} private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0;"
      },
      {
        "txt": "long shpiA; long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else {"
      },
      {
        "txt": "shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d;"
      },
      {
        "txt": "long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++;"
      },
      {
        "txt": "} bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; }"
      },
      {
        "txt": "c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32);"
      },
      {
        "txt": "int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d;"
      },
      {
        "txt": "bc = b * c; ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++;"
      },
      {
        "txt": "} bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c;"
      },
      {
        "txt": "ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false;"
      },
      {
        "txt": "int quadrant = 0; double xa; double xb = 0.0; xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3];"
      },
      {
        "txt": "reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); }"
      },
      {
        "txt": "if (negative) { quadrant ^= 2; // Flip bit 1 } switch (quadrant) { case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb);"
      },
      {
        "txt": "case 3: return -cosQ(xa, xb); default: return Double.NaN; } } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) {"
      },
      {
        "txt": "xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3;"
      },
      {
        "txt": "xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0:"
      },
      {
        "txt": "return cosQ(xa, xb); case 1: return -sinQ(xa, xb); case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; }"
      },
      {
        "txt": "} public static double tan(double x) { boolean negative = false; int quadrant = 0; double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) {"
      },
      {
        "txt": "long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0;"
      },
      {
        "txt": "if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA();"
      },
      {
        "txt": "xb = cw.getRemB(); } if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b);"
      },
      {
        "txt": "quadrant ^= 1; negative ^= true; } double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) {"
      },
      {
        "txt": "result = -result; } return result; } public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;"
      },
      {
        "txt": "if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) { xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);"
      },
      {
        "txt": "} if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];"
      },
      {
        "txt": "double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));"
      },
      {
        "txt": "ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp;"
      },
      {
        "txt": "zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za;"
      },
      {
        "txt": "yb += epsB / za; } epsA = ya; epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093;"
      },
      {
        "txt": "yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb;"
      },
      {
        "txt": "yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb);"
      },
      {
        "txt": "if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) {"
      },
      {
        "txt": "result = -result; } return result; } public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y;"
      },
      {
        "txt": "final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) {"
      },
      {
        "txt": "if (y < 0 || invy < 0) { return -Math.PI; } else { return Math.PI; } } else { return result; } } if (y == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; } return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d;"
      },
      {
        "txt": "} if (y < 0 || 1 / y < 0) { return -0d; } } if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; }"
      },
      {
        "txt": "if (y < 0 || 1 / y < 0) { return -Math.PI; } } if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2;"
      },
      {
        "txt": "} } final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa;"
      },
      {
        "txt": "rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; }"
      },
      {
        "txt": "public static double asin(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; }"
      },
      {
        "txt": "if (x == -1.0) { return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa;"
      },
      {
        "txt": "double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za);"
      },
      {
        "txt": "temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division"
      },
      {
        "txt": "rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; }"
      },
      {
        "txt": "if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == -1.0) { return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) {"
      },
      {
        "txt": "return Math.PI/2.0; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya;"
      },
      {
        "txt": "double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y);"
      },
      {
        "txt": "y = ya+yb; yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt."
      },
      {
        "txt": "temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) {"
      },
      {
        "txt": "if (x == 0) { return x; } subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x;"
      },
      {
        "txt": "} int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233;"
      },
      {
        "txt": "est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000;"
      },
      {
        "txt": "double temp2 = za + temp - temp; zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2;"
      },
      {
        "txt": "if (subnormal) { est *= 3.814697265625E-6; // 2^-18 } return est; } public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; }"
      },
      {
        "txt": "final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; }"
      },
      {
        "txt": "public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta;"
      },
      {
        "txt": "} public static int abs(final int x) { return (x < 0) ? -x : x; } public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 }"
      },
      {
        "txt": "public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) {"
      },
      {
        "txt": "if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {"
      },
      {
        "txt": "return d; } if (n < -2098) { return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L;"
      },
      {
        "txt": "int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent);"
      },
      {
        "txt": "if (mostSignificantLostBit != 0) { mantissa++; } return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) {"
      },
      {
        "txt": "mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "} else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23);"
      },
      {
        "txt": "} if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; } if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23);"
      },
      {
        "txt": "final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else {"
      },
      {
        "txt": "if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else {"
      },
      {
        "txt": "return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) {"
      },
      {
        "txt": "if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d);"
      },
      {
        "txt": "final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN;"
      },
      {
        "txt": "} else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) {"
      },
      {
        "txt": "return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } } public static double floor(double x) { long y; if (x != x) { // NaN return x; }"
      },
      {
        "txt": "if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; } y = (long) x; if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; }"
      },
      {
        "txt": "return y; } public static double ceil(double x) { double y; if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y;"
      },
      {
        "txt": "} y += 1.0; if (y == 0) { return x*y; } return y; } public static double rint(double x) { double y = floor(x); double d = x - y;"
      },
      {
        "txt": "if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand } return y+1.0; } if (d < 0.5) { return y; } long z = (long) y;"
      },
      {
        "txt": "return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) { return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b;"
      },
      {
        "txt": "} public static long min(final long a, final long b) { return (a <= b) ? a : b; } public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a;"
      },
      {
        "txt": "} if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; }"
      },
      {
        "txt": "public static double min(final double a, final double b) { if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Double.NaN; }"
      },
      {
        "txt": "long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a; } return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) {"
      },
      {
        "txt": "return (a <= b) ? b : a; } public static float max(final float a, final float b) { if (a > b) { return a; } if (a < b) { return b; } if (a != b) {"
      },
      {
        "txt": "return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b; } return a; } public static double max(final double a, final double b) { if (a > b) {"
      },
      {
        "txt": "return a; } if (a < b) { return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) {"
      },
      {
        "txt": "return b; } return a; } public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else {"
      },
      {
        "txt": "final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp);"
      },
      {
        "txt": "final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); } } } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude);"
      },
      {
        "txt": "long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK"
      },
      {
        "txt": "return magnitude; } return -magnitude; // flip sign } public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; }"
      },
      {
        "txt": "public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];"
      },
      {
        "txt": "EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];"
      },
      {
        "txt": "EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } } } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable {"
      },
      {
        "txt": "private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp);"
      },
      {
        "txt": "EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; } } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant {"
      },
      {
        "txt": "private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant();"
      },
      {
        "txt": "} } } private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814);"
      },
      {
        "txt": "double remA; double remB; while (true) { double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a);"
      },
      {
        "txt": "a = -k * 6.123233995736766E-17; b = remA; remA = a + b; remB += -(remA - b - a); if (remA > 0) { break; } --k; } this.finalK = k;"
      },
      {
        "txt": "this.finalRemA = remA; this.finalRemB = remB; } int getK() { return finalK; } double getRemA() { return finalRemA; } double getRemB() {"
      },
      {
        "txt": "return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2495,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 395,
    "end-bug-line": 395,
    "bug": "",
    "fix": "final double t = exp(0.5 * x); return (0.5 * t) * t; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream;"
      },
      {
        "txt": "public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7;"
      },
      {
        "txt": "private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9},"
      },
      {
        "txt": "}; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14;"
      },
      {
        "txt": "private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d,"
      },
      {
        "txt": "+0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d,"
      },
      {
        "txt": "-4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d,"
      },
      {
        "txt": "+4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d,"
      },
      {
        "txt": "+0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d,"
      },
      {
        "txt": "}; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d,"
      },
      {
        "txt": "+4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = {"
      },
      {
        "txt": "+0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d,"
      },
      {
        "txt": "+3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d,"
      },
      {
        "txt": "+5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d,"
      },
      {
        "txt": "-3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL,"
      },
      {
        "txt": "(0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL,"
      },
      {
        "txt": "0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 };"
      },
      {
        "txt": "private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d;"
      },
      {
        "txt": "private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d;"
      },
      {
        "txt": "private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) {"
      },
      {
        "txt": "} public static double cosh(double x) { if (x != x) { return x; } if (x > 20) { <extra_id_0> } if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) {"
      },
      {
        "txt": "final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa;"
      },
      {
        "txt": "double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb;"
      },
      {
        "txt": "yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result; } public static double sinh(double x) { boolean negate = false; if (x != x) { return x;"
      },
      {
        "txt": "} if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x; }"
      },
      {
        "txt": "if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);"
      },
      {
        "txt": "double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa;"
      },
      {
        "txt": "recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; }"
      },
      {
        "txt": "else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000;"
      },
      {
        "txt": "double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra);"
      },
      {
        "txt": "ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; }"
      },
      {
        "txt": "return result; } public static double tanh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0; }"
      },
      {
        "txt": "if (x < -20) { return -1.0; } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; }"
      },
      {
        "txt": "double result; if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb);"
      },
      {
        "txt": "na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da;"
      },
      {
        "txt": "temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else { double hiPrec[] = new double[2];"
      },
      {
        "txt": "expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp;"
      },
      {
        "txt": "temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da;"
      },
      {
        "txt": "result = ratioa + ratiob; } if (negate) { result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); }"
      },
      {
        "txt": "public static double asinh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else {"
      },
      {
        "txt": "final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); }"
      },
      {
        "txt": "} return negative ? -absAsinh : absAsinh; } public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAtanh;"
      },
      {
        "txt": "if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));"
      },
      {
        "txt": "} else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } } return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) {"
      },
      {
        "txt": "return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random();"
      },
      {
        "txt": "} public static double exp(double x) { return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x;"
      },
      {
        "txt": "if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620;"
      },
      {
        "txt": "} return result; } intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) {"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0);"
      },
      {
        "txt": "final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687;"
      },
      {
        "txt": "z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */"
      },
      {
        "txt": "final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;"
      },
      {
        "txt": "} return result; } public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; }"
      },
      {
        "txt": "if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb;"
      },
      {
        "txt": "} } double baseA; double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true; }"
      },
      {
        "txt": "{ int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA);"
      },
      {
        "txt": "epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb;"
      },
      {
        "txt": "zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp;"
      },
      {
        "txt": "temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za;"
      },
      {
        "txt": "yb += -(temp - ya - za); ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya;"
      },
      {
        "txt": "double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;"
      },
      {
        "txt": "rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb;"
      },
      {
        "txt": "} public static double log(final double x) { return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) {"
      },
      {
        "txt": "if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; } return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */"
      },
      {
        "txt": "double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1];"
      },
      {
        "txt": "for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000;"
      },
      {
        "txt": "ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; }"
      },
      {
        "txt": "} final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp;"
      },
      {
        "txt": "double ab = epsilon - aa; double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1];"
      },
      {
        "txt": "for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000;"
      },
      {
        "txt": "ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab);"
      },
      {
        "txt": "} else { using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; }"
      },
      {
        "txt": "double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c; b = b + d;"
      },
      {
        "txt": "c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb);"
      },
      {
        "txt": "a = c; b = b + d; if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) { if (x == -1) {"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2];"
      },
      {
        "txt": "final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x;"
      },
      {
        "txt": "} } public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp;"
      },
      {
        "txt": "final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2];"
      },
      {
        "txt": "if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y;"
      },
      {
        "txt": "if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) {"
      },
      {
        "txt": "return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) {"
      },
      {
        "txt": "long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} else { return 0.0; } } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);"
      },
      {
        "txt": "} else { return Double.NaN; } } double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya;"
      },
      {
        "txt": "} else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; }"
      },
      {
        "txt": "double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab);"
      },
      {
        "txt": "double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) {"
      },
      {
        "txt": "if (e == 0) { return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High;"
      },
      {
        "txt": "double resultHigh = 1; double resultLow = 0; double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh);"
      },
      {
        "txt": "final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);"
      },
      {
        "txt": "final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x) {"
      },
      {
        "txt": "double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) { double x2 = x*x;"
      },
      {
        "txt": "double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;"
      },
      {
        "txt": "final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp;"
      },
      {
        "txt": "sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = costA * sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = costA*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966;"
      },
      {
        "txt": "final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx];"
      },
      {
        "txt": "final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2;"
      },
      {
        "txt": "sinEpsA = temp2; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);"
      },
      {
        "txt": "double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb);"
      },
      {
        "txt": "err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb"
      },
      {
        "txt": "err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err; }"
      },
      {
        "txt": "private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0; long shpiA;"
      },
      {
        "txt": "long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];"
      },
      {
        "txt": "shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c;"
      },
      {
        "txt": "long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; }"
      },
      {
        "txt": "bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32;"
      },
      {
        "txt": "d = shpiB & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prodA++; } c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62);"
      },
      {
        "txt": "prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c;"
      },
      {
        "txt": "ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32;"
      },
      {
        "txt": "d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prod2A++; } a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d;"
      },
      {
        "txt": "ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits"
      },
      {
        "txt": "double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false; int quadrant = 0;"
      },
      {
        "txt": "double xa; double xb = 0.0; xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) {"
      },
      {
        "txt": "return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults);"
      },
      {
        "txt": "quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) {"
      },
      {
        "txt": "quadrant ^= 2; // Flip bit 1 } switch (quadrant) { case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3:"
      },
      {
        "txt": "return -cosQ(xa, xb); default: return Double.NaN; } } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) { xa = -xa;"
      },
      {
        "txt": "} if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1];"
      },
      {
        "txt": "xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0: return cosQ(xa, xb);"
      },
      {
        "txt": "case 1: return -sinQ(xa, xb); case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; } }"
      },
      {
        "txt": "public static double tan(double x) { boolean negative = false; int quadrant = 0; double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) {"
      },
      {
        "txt": "double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB();"
      },
      {
        "txt": "} if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1;"
      },
      {
        "txt": "negative ^= true; } double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) { result = -result;"
      },
      {
        "txt": "} return result; } public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign"
      },
      {
        "txt": "return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) { xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }"
      },
      {
        "txt": "if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB;"
      },
      {
        "txt": "epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom;"
      },
      {
        "txt": "yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx];"
      },
      {
        "txt": "ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za;"
      },
      {
        "txt": "} epsA = ya; epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA;"
      },
      {
        "txt": "yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb);"
      },
      {
        "txt": "ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) {"
      },
      {
        "txt": "final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result;"
      },
      {
        "txt": "} return result; } public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y; final double invx = 1d / x;"
      },
      {
        "txt": "final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) {"
      },
      {
        "txt": "return -Math.PI; } else { return Math.PI; } } else { return result; } } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4;"
      },
      {
        "txt": "} if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; } return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; }"
      },
      {
        "txt": "if (y < 0 || 1 / y < 0) { return -0d; } } if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) {"
      },
      {
        "txt": "return -Math.PI; } } if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; }"
      },
      {
        "txt": "} final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;"
      },
      {
        "txt": "final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) {"
      },
      {
        "txt": "if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) {"
      },
      {
        "txt": "return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb;"
      },
      {
        "txt": "ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za); temp = y * HEX_40000000;"
      },
      {
        "txt": "ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt."
      },
      {
        "txt": "temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) {"
      },
      {
        "txt": "return Double.NaN; } if (x == -1.0) { return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) { return Math.PI/2.0;"
      },
      {
        "txt": "} double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya);"
      },
      {
        "txt": "temp = za + yb; zb += -(temp - za - yb); za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb;"
      },
      {
        "txt": "yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb;"
      },
      {
        "txt": "rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) {"
      },
      {
        "txt": "return x; } subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x; }"
      },
      {
        "txt": "int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2];"
      },
      {
        "txt": "final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp;"
      },
      {
        "txt": "zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) {"
      },
      {
        "txt": "est *= 3.814697265625E-6; // 2^-18 } return est; } public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854;"
      },
      {
        "txt": "final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; } public static double toDegrees(double x)"
      },
      {
        "txt": "{ if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; }"
      },
      {
        "txt": "public static int abs(final int x) { return (x < 0) ? -x : x; } public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) {"
      },
      {
        "txt": "return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) {"
      },
      {
        "txt": "return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d;"
      },
      {
        "txt": "} if (n < -2098) { return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff;"
      },
      {
        "txt": "long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) {"
      },
      {
        "txt": "mantissa++; } return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1;"
      },
      {
        "txt": "--scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) {"
      },
      {
        "txt": "return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); }"
      },
      {
        "txt": "if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; } if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f);"
      },
      {
        "txt": "final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));"
      },
      {
        "txt": "mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) {"
      },
      {
        "txt": "while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) {"
      },
      {
        "txt": "return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L;"
      },
      {
        "txt": "if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) {"
      },
      {
        "txt": "return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));"
      },
      {
        "txt": "} else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } } public static double floor(double x) { long y; if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {"
      },
      {
        "txt": "return x; } y = (long) x; if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; } return y;"
      },
      {
        "txt": "} public static double ceil(double x) { double y; if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y; }"
      },
      {
        "txt": "y += 1.0; if (y == 0) { return x*y; } return y; } public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) {"
      },
      {
        "txt": "if (y == -1.0) { return -0.0; // Preserve sign of operand } return y+1.0; } if (d < 0.5) { return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0;"
      },
      {
        "txt": "} public static long round(double x) { return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b; }"
      },
      {
        "txt": "public static long min(final long a, final long b) { return (a <= b) ? a : b; } public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a; }"
      },
      {
        "txt": "if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; } public static double min(final double a, final double b) {"
      },
      {
        "txt": "if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a);"
      },
      {
        "txt": "if (bits == 0x8000000000000000L) { return a; } return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a;"
      },
      {
        "txt": "} public static float max(final float a, final float b) { if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Float.NaN;"
      },
      {
        "txt": "} int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b; } return a; } public static double max(final double a, final double b) { if (a > b) { return a;"
      },
      {
        "txt": "} if (a < b) { return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b;"
      },
      {
        "txt": "} return a; } public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x);"
      },
      {
        "txt": "final int expY = getExponent(y); if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);"
      },
      {
        "txt": "return scalb(scaledH, middleExp); } } } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign);"
      },
      {
        "txt": "if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude;"
      },
      {
        "txt": "} return -magnitude; // flip sign } public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) {"
      },
      {
        "txt": "PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];"
      },
      {
        "txt": "final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];"
      },
      {
        "txt": "} } } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A;"
      },
      {
        "txt": "private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0];"
      },
      {
        "txt": "EXP_FRAC_TABLE_B[i] = tmp[1]; } } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant { private static final double[][] LN_MANT;"
      },
      {
        "txt": "static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); }"
      },
      {
        "txt": "} } private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA;"
      },
      {
        "txt": "double remB; while (true) { double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17;"
      },
      {
        "txt": "b = remA; remA = a + b; remB += -(remA - b - a); if (remA > 0) { break; } --k; } this.finalK = k; this.finalRemA = remA;"
      },
      {
        "txt": "this.finalRemB = remB; } int getK() { return finalK; } double getRemA() { return finalRemA; } double getRemB() { return finalRemB;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2496,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 397,
    "end-bug-line": 397,
    "bug": "if (x < -20) {",
    "fix": "} else if (x < -20) { if (x <= -LOG_MAX_VALUE) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream; public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
      },
      {
        "txt": "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24},"
      },
      {
        "txt": "{-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = {"
      },
      {
        "txt": "{1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = {"
      },
      {
        "txt": "+0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d,"
      },
      {
        "txt": "+0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d,"
      },
      {
        "txt": "+1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d,"
      },
      {
        "txt": "-1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d,"
      },
      {
        "txt": "+0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] ="
      },
      {
        "txt": "{ +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d,"
      },
      {
        "txt": "-2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d,"
      },
      {
        "txt": "+0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d,"
      },
      {
        "txt": "+14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d,"
      },
      {
        "txt": "+1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, };"
      },
      {
        "txt": "private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L,"
      },
      {
        "txt": "(0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] {"
      },
      {
        "txt": "(0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;"
      },
      {
        "txt": "private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d;"
      },
      {
        "txt": "private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {} private static double doubleHighPart(double d) {"
      },
      {
        "txt": "if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) { return Math.sqrt(a); }"
      },
      {
        "txt": "if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } <extra_id_0> return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; }"
      },
      {
        "txt": "x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000;"
      },
      {
        "txt": "double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp;"
      },
      {
        "txt": "double result = ya + yb; result *= 0.5; return result; } public static double sinh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20) {"
      },
      {
        "txt": "return 0.5 * exp(x); } if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x; } if (x < 0.0) { x = -x;"
      },
      {
        "txt": "negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp;"
      },
      {
        "txt": "double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa;"
      },
      {
        "txt": "yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2];"
      },
      {
        "txt": "expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra;"
      },
      {
        "txt": "temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb;"
      },
      {
        "txt": "yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; } return result; }"
      },
      {
        "txt": "public static double tanh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0; } if (x < -20) { return -1.0;"
      },
      {
        "txt": "} if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x >= 0.5) {"
      },
      {
        "txt": "double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb); na = temp; double da = 1.0 + ya;"
      },
      {
        "txt": "double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp;"
      },
      {
        "txt": "double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else { double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1];"
      },
      {
        "txt": "double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp;"
      },
      {
        "txt": "double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; }"
      },
      {
        "txt": "if (negate) { result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); } public static double asinh(double a) { boolean negative = false;"
      },
      {
        "txt": "if (a < 0) { negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else { final double a2 = a * a; if (a > 0.097) {"
      },
      {
        "txt": "absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); } } return negative ? -absAsinh : absAsinh;"
      },
      {
        "txt": "} public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));"
      },
      {
        "txt": "} else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));"
      },
      {
        "txt": "} } return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a }"
      },
      {
        "txt": "public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random(); } public static double exp(double x) {"
      },
      {
        "txt": "return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0;"
      },
      {
        "txt": "} return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; } return result;"
      },
      {
        "txt": "} intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];"
      },
      {
        "txt": "final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20;"
      },
      {
        "txt": "expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA; final double result;"
      },
      {
        "txt": "if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result;"
      },
      {
        "txt": "} public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; } if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2];"
      },
      {
        "txt": "exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb; } }"
      },
      {
        "txt": "double baseA; double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true; } { int intFrac = (int) (x * 1024.0);"
      },
      {
        "txt": "double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; }"
      },
      {
        "txt": "double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb; zb = -(temp - za - zb); za = temp;"
      },
      {
        "txt": "temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA);"
      },
      {
        "txt": "ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za; yb += -(temp - ya - za); ya = temp;"
      },
      {
        "txt": "temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb;"
      },
      {
        "txt": "double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator"
      },
      {
        "txt": "ya = -ra; yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb; } public static double log(final double x) {"
      },
      {
        "txt": "return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = Double.NaN; } return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY; } bits <<= 1;"
      },
      {
        "txt": "while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0;"
      },
      {
        "txt": "double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa;"
      },
      {
        "txt": "ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab;"
      },
      {
        "txt": "} aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; } } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];"
      },
      {
        "txt": "double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa;"
      },
      {
        "txt": "double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa;"
      },
      {
        "txt": "ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab;"
      },
      {
        "txt": "} aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab); } else { using standard double precision */"
      },
      {
        "txt": "lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; } double a = LN_2_A*exp; double b = 0.0;"
      },
      {
        "txt": "double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c; b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp);"
      },
      {
        "txt": "a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d;"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN"
      },
      {
        "txt": "return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x; } }"
      },
      {
        "txt": "public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795;"
      },
      {
        "txt": "final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0;"
      },
      {
        "txt": "} if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0;"
      },
      {
        "txt": "} return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0; } else {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else {"
      },
      {
        "txt": "return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) {"
      },
      {
        "txt": "return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0;"
      },
      {
        "txt": "} } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN;"
      },
      {
        "txt": "} } double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10;"
      },
      {
        "txt": "double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1];"
      },
      {
        "txt": "double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0);"
      },
      {
        "txt": "z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) { if (e == 0) { return 1.0;"
      },
      {
        "txt": "} else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0;"
      },
      {
        "txt": "double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);"
      },
      {
        "txt": "resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh);"
      },
      {
        "txt": "d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x) { double x2 = x*x; double p = 2.7553817452272217E-6;"
      },
      {
        "txt": "p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) { double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883;"
      },
      {
        "txt": "p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx];"
      },
      {
        "txt": "final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2;"
      },
      {
        "txt": "double result; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA * sinEpsA; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsB;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa;"
      },
      {
        "txt": "double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx];"
      },
      {
        "txt": "final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0;"
      },
      {
        "txt": "double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b);"
      },
      {
        "txt": "if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa;"
      },
      {
        "txt": "temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) {"
      },
      {
        "txt": "double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err; } private static void reducePayneHanek(double x, double result[]) {"
      },
      {
        "txt": "long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0; long shpiA; long shpiB; int idx = exponent >> 6;"
      },
      {
        "txt": "int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1];"
      },
      {
        "txt": "} long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32);"
      },
      {
        "txt": "long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0;"
      },
      {
        "txt": "prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c;"
      },
      {
        "txt": "bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++;"
      },
      {
        "txt": "} c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62;"
      },
      {
        "txt": "prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c; ad = a * d; long prod2B = bd + (ad << 32);"
      },
      {
        "txt": "long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0;"
      },
      {
        "txt": "prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c;"
      },
      {
        "txt": "bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++;"
      },
      {
        "txt": "} a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB;"
      },
      {
        "txt": "double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false; int quadrant = 0; double xa; double xb = 0.0;"
      },
      {
        "txt": "xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; }"
      },
      {
        "txt": "return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1];"
      },
      {
        "txt": "xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) { quadrant ^= 2; // Flip bit 1 }"
      },
      {
        "txt": "switch (quadrant) { case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3: return -cosQ(xa, xb); default:"
      },
      {
        "txt": "return Double.NaN; } } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) { xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) {"
      },
      {
        "txt": "final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0: return cosQ(xa, xb); case 1: return -sinQ(xa, xb);"
      },
      {
        "txt": "case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; } } public static double tan(double x) { boolean negative = false;"
      },
      {
        "txt": "int quadrant = 0; double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0;"
      },
      {
        "txt": "} return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults);"
      },
      {
        "txt": "quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (xa > 1.5) {"
      },
      {
        "txt": "final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1; negative ^= true; }"
      },
      {
        "txt": "double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) { result = -result; } return result;"
      },
      {
        "txt": "} public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; }"
      },
      {
        "txt": "if (xa < 0) { xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); } if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);"
      },
      {
        "txt": "} else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp;"
      },
      {
        "txt": "temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom; yb = epsB * denom; } else {"
      },
      {
        "txt": "double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000;"
      },
      {
        "txt": "final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za; } epsA = ya;"
      },
      {
        "txt": "epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192;"
      },
      {
        "txt": "yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA);"
      },
      {
        "txt": "double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2;"
      },
      {
        "txt": "za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result; } return result;"
      },
      {
        "txt": "} public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y; final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite"
      },
      {
        "txt": "if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) { return -Math.PI; } else {"
      },
      {
        "txt": "return Math.PI; } } else { return result; } } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; }"
      },
      {
        "txt": "if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) {"
      },
      {
        "txt": "return -Math.PI * F_3_4; } return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; } if (y < 0 || 1 / y < 0) { return -0d;"
      },
      {
        "txt": "} } if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) { return -Math.PI; }"
      },
      {
        "txt": "} if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; } } final double r = y / x;"
      },
      {
        "txt": "if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb);"
      },
      {
        "txt": "ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) { if (x != x) { return Double.NaN;"
      },
      {
        "txt": "} if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) { return -Math.PI/2.0; }"
      },
      {
        "txt": "if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb;"
      },
      {
        "txt": "double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya;"
      },
      {
        "txt": "yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb);"
      },
      {
        "txt": "ra = temp; return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; }"
      },
      {
        "txt": "if (x == -1.0) { return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) { return Math.PI/2.0; } double temp = x * HEX_40000000;"
      },
      {
        "txt": "final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb);"
      },
      {
        "txt": "za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb; yb = -(y - ya - yb); double r = y/x;"
      },
      {
        "txt": "if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp;"
      },
      {
        "txt": "return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) { return x; }"
      },
      {
        "txt": "subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x; } int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |"
      },
      {
        "txt": "(long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est);"
      },
      {
        "txt": "est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp; zb += za - temp2; za = temp2;"
      },
      {
        "txt": "zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) { est *= 3.814697265625E-6; // 2^-18 }"
      },
      {
        "txt": "return est; } public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x);"
      },
      {
        "txt": "double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; } public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign"
      },
      {
        "txt": "return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; } public static int abs(final int x) { return (x < 0) ? -x : x;"
      },
      {
        "txt": "} public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 }"
      },
      {
        "txt": "public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; }"
      },
      {
        "txt": "return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d; } if (n < -2098) {"
      },
      {
        "txt": "return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n;"
      },
      {
        "txt": "if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; }"
      },
      {
        "txt": "return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1; --scaledExponent; }"
      },
      {
        "txt": "++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else {"
      },
      {
        "txt": "return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); } if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f;"
      },
      {
        "txt": "} if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff;"
      },
      {
        "txt": "int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) {"
      },
      {
        "txt": "mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1;"
      },
      {
        "txt": "--scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) {"
      },
      {
        "txt": "return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) {"
      },
      {
        "txt": "return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));"
      },
      {
        "txt": "} else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) {"
      },
      {
        "txt": "return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));"
      },
      {
        "txt": "} } public static double floor(double x) { long y; if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; }"
      },
      {
        "txt": "y = (long) x; if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; } return y; } public static double ceil(double x) {"
      },
      {
        "txt": "double y; if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y; } y += 1.0; if (y == 0) {"
      },
      {
        "txt": "return x*y; } return y; } public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand"
      },
      {
        "txt": "} return y+1.0; } if (d < 0.5) { return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) {"
      },
      {
        "txt": "return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b; } public static long min(final long a, final long b) { return (a <= b) ? a : b;"
      },
      {
        "txt": "} public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Float.NaN;"
      },
      {
        "txt": "} int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; } public static double min(final double a, final double b) { if (a > b) { return b;"
      },
      {
        "txt": "} if (a < b) { return a; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a;"
      },
      {
        "txt": "} return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a; } public static float max(final float a, final float b) {"
      },
      {
        "txt": "if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a);"
      },
      {
        "txt": "if (bits == 0x80000000) { return b; } return a; } public static double max(final double a, final double b) { if (a > b) { return a; } if (a < b) {"
      },
      {
        "txt": "return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a;"
      },
      {
        "txt": "} public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) {"
      },
      {
        "txt": "return abs(x); } else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); }"
      },
      {
        "txt": "} } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude;"
      },
      {
        "txt": "} return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign"
      },
      {
        "txt": "} public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);"
      },
      {
        "txt": "} private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2];"
      },
      {
        "txt": "for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } }"
      },
      {
        "txt": "} else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static {"
      },
      {
        "txt": "if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; }"
      },
      {
        "txt": "} else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {"
      },
      {
        "txt": "LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); } } }"
      },
      {
        "txt": "private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA; double remB; while (true) {"
      },
      {
        "txt": "double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17; b = remA; remA = a + b;"
      },
      {
        "txt": "remB += -(remA - b - a); if (remA > 0) { break; } --k; } this.finalK = k; this.finalRemA = remA; this.finalRemB = remB; }"
      },
      {
        "txt": "int getK() { return finalK; } double getRemA() { return finalRemA; } double getRemB() { return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2497,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 399,
    "end-bug-line": 399,
    "bug": "",
    "fix": "final double t = exp(-0.5 * x); return (0.5 * t) * t; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream; public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
      },
      {
        "txt": "static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25},"
      },
      {
        "txt": "{0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23},"
      },
      {
        "txt": "{-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d,"
      },
      {
        "txt": "+0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d,"
      },
      {
        "txt": "+0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d,"
      },
      {
        "txt": "-1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d,"
      },
      {
        "txt": "}; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d,"
      },
      {
        "txt": "+0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = {"
      },
      {
        "txt": "+0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d,"
      },
      {
        "txt": "+2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d, +0.25534194707870483d,"
      },
      {
        "txt": "+0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d,"
      },
      {
        "txt": "-18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d,"
      },
      {
        "txt": "-5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] {"
      },
      {
        "txt": "(0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL,"
      },
      {
        "txt": "(0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L,"
      },
      {
        "txt": "(0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0;"
      },
      {
        "txt": "private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d;"
      },
      {
        "txt": "private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){"
      },
      {
        "txt": "return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) { return Math.sqrt(a); } public static double cosh(double x) {"
      },
      {
        "txt": "return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { <extra_id_0> } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);"
      },
      {
        "txt": "} exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp;"
      },
      {
        "txt": "double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb;"
      },
      {
        "txt": "result *= 0.5; return result; } public static double sinh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x);"
      },
      {
        "txt": "} if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true;"
      },
      {
        "txt": "} double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa;"
      },
      {
        "txt": "double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa);"
      },
      {
        "txt": "ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2]; expm1(x, hiPrec);"
      },
      {
        "txt": "double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000;"
      },
      {
        "txt": "double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb);"
      },
      {
        "txt": "ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; } return result; } public static double tanh(double x) {"
      },
      {
        "txt": "boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0; } if (x < -20) { return -1.0; }"
      },
      {
        "txt": "if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x >= 0.5) { double hiPrec[] = new double[2];"
      },
      {
        "txt": "exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb); na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya);"
      },
      {
        "txt": "temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa;"
      },
      {
        "txt": "ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else { double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);"
      },
      {
        "txt": "double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa;"
      },
      {
        "txt": "double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } if (negate) {"
      },
      {
        "txt": "result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); } public static double asinh(double a) { boolean negative = false; if (a < 0) {"
      },
      {
        "txt": "negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else { final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);"
      },
      {
        "txt": "} else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); } } return negative ? -absAsinh : absAsinh; }"
      },
      {
        "txt": "public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else {"
      },
      {
        "txt": "final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); }"
      },
      {
        "txt": "} return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) {"
      },
      {
        "txt": "return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random(); } public static double exp(double x) { return exp(x, 0.0, null);"
      },
      {
        "txt": "} private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0;"
      },
      {
        "txt": "hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; }"
      },
      {
        "txt": "return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; } return result; }"
      },
      {
        "txt": "intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0;"
      },
      {
        "txt": "} return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0);"
      },
      {
        "txt": "full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion."
      },
      {
        "txt": "tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) {"
      },
      {
        "txt": "result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result; }"
      },
      {
        "txt": "public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; } if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec);"
      },
      {
        "txt": "if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb; } } double baseA;"
      },
      {
        "txt": "double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true; } { int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;"
      },
      {
        "txt": "double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571;"
      },
      {
        "txt": "zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb; zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000;"
      },
      {
        "txt": "temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp;"
      },
      {
        "txt": "temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za; yb += -(temp - ya - za); ya = temp; temp = ya + baseB;"
      },
      {
        "txt": "yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr;"
      },
      {
        "txt": "temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra;"
      },
      {
        "txt": "yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb; } public static double log(final double x) { return log(x, null);"
      },
      {
        "txt": "} private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN;"
      },
      {
        "txt": "} return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY; } bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) {"
      },
      {
        "txt": "--exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000;"
      },
      {
        "txt": "double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb;"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; }"
      },
      {
        "txt": "aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; } } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);"
      },
      {
        "txt": "epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab;"
      },
      {
        "txt": "final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb;"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; }"
      },
      {
        "txt": "aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab); } else { using standard double precision */ lnza = -0.16624882440418567;"
      },
      {
        "txt": "lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; } double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0];"
      },
      {
        "txt": "double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c; b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c;"
      },
      {
        "txt": "b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d; if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores;"
      },
      {
        "txt": "} final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x; } } public static double log10(final double x) {"
      },
      {
        "txt": "final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8;"
      },
      {
        "txt": "return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0; }"
      },
      {
        "txt": "if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0; }"
      },
      {
        "txt": "return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0;"
      },
      {
        "txt": "} } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0;"
      },
      {
        "txt": "} return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "} if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; }"
      },
      {
        "txt": "} if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; }"
      },
      {
        "txt": "} double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10;"
      },
      {
        "txt": "ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000;"
      },
      {
        "txt": "double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0);"
      },
      {
        "txt": "z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) { if (e == 0) { return 1.0; } else if (e < 0) {"
      },
      {
        "txt": "e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0; double d2p = d;"
      },
      {
        "txt": "double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh;"
      },
      {
        "txt": "resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);"
      },
      {
        "txt": "d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x) { double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4;"
      },
      {
        "txt": "p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) { double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166;"
      },
      {
        "txt": "p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx];"
      },
      {
        "txt": "final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result;"
      },
      {
        "txt": "double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA * sinEpsA; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsB; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsB;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa);"
      },
      {
        "txt": "b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx];"
      },
      {
        "txt": "double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0; double b = 0;"
      },
      {
        "txt": "double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) {"
      },
      {
        "txt": "double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000;"
      },
      {
        "txt": "double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb;"
      },
      {
        "txt": "if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err; } private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0; long shpiA; long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6);"
      },
      {
        "txt": "if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; }"
      },
      {
        "txt": "long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32);"
      },
      {
        "txt": "boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32);"
      },
      {
        "txt": "prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c; bc = b * c;"
      },
      {
        "txt": "ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; }"
      },
      {
        "txt": "c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2;"
      },
      {
        "txt": "a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c; ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32);"
      },
      {
        "txt": "bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32);"
      },
      {
        "txt": "prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c;"
      },
      {
        "txt": "ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0;"
      },
      {
        "txt": "prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB);"
      },
      {
        "txt": "result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false; int quadrant = 0; double xa; double xb = 0.0; xa = x;"
      },
      {
        "txt": "if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0;"
      },
      {
        "txt": "} if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2];"
      },
      {
        "txt": "} else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) { quadrant ^= 2; // Flip bit 1 } switch (quadrant) {"
      },
      {
        "txt": "case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3: return -cosQ(xa, xb); default: return Double.NaN;"
      },
      {
        "txt": "} } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) { xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN;"
      },
      {
        "txt": "} double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb);"
      },
      {
        "txt": "quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0: return cosQ(xa, xb); case 1: return -sinQ(xa, xb); case 2:"
      },
      {
        "txt": "return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; } } public static double tan(double x) { boolean negative = false; int quadrant = 0;"
      },
      {
        "txt": "double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; }"
      },
      {
        "txt": "return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3;"
      },
      {
        "txt": "xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (xa > 1.5) { final double pi2a = 1.5707963267948966;"
      },
      {
        "txt": "final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1; negative ^= true; } double result;"
      },
      {
        "txt": "if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) { result = -result; } return result; }"
      },
      {
        "txt": "public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) {"
      },
      {
        "txt": "xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); } if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else {"
      },
      {
        "txt": "final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000;"
      },
      {
        "txt": "double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx];"
      },
      {
        "txt": "double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp;"
      },
      {
        "txt": "final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za; } epsA = ya; epsB = yb;"
      },
      {
        "txt": "final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305;"
      },
      {
        "txt": "yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya;"
      },
      {
        "txt": "double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result;"
      },
      {
        "txt": "zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result; } return result; }"
      },
      {
        "txt": "public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y; final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) {"
      },
      {
        "txt": "return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) { return -Math.PI; } else { return Math.PI;"
      },
      {
        "txt": "} } else { return result; } } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) {"
      },
      {
        "txt": "return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4;"
      },
      {
        "txt": "} return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; } if (y < 0 || 1 / y < 0) { return -0d; }"
      },
      {
        "txt": "} if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) { return -Math.PI; } }"
      },
      {
        "txt": "if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; } } final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN"
      },
      {
        "txt": "return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp;"
      },
      {
        "txt": "if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) { if (x != x) { return Double.NaN; }"
      },
      {
        "txt": "if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) { return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign"
      },
      {
        "txt": "return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya;"
      },
      {
        "txt": "double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);"
      },
      {
        "txt": "double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp;"
      },
      {
        "txt": "return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == -1.0) {"
      },
      {
        "txt": "return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) { return Math.PI/2.0; } double temp = x * HEX_40000000; final double xa = x + temp - temp;"
      },
      {
        "txt": "final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp;"
      },
      {
        "txt": "double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb; yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero"
      },
      {
        "txt": "return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0);"
      },
      {
        "txt": "} public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) { return x; } subnormal = true;"
      },
      {
        "txt": "x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x; } int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52);"
      },
      {
        "txt": "final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est);"
      },
      {
        "txt": "double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp; zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb;"
      },
      {
        "txt": "za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) { est *= 3.814697265625E-6; // 2^-18 } return est;"
      },
      {
        "txt": "} public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa;"
      },
      {
        "txt": "double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; } public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x;"
      },
      {
        "txt": "} final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; } public static int abs(final int x) { return (x < 0) ? -x : x; }"
      },
      {
        "txt": "public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) {"
      },
      {
        "txt": "if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));"
      },
      {
        "txt": "} public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d; } if (n < -2098) { return (d > 0) ? 0.0 : -0.0;"
      },
      {
        "txt": "} if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) {"
      },
      {
        "txt": "if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Double.longBitsToDouble(sign | mantissa);"
      },
      {
        "txt": "} else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent;"
      },
      {
        "txt": "mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); } if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; }"
      },
      {
        "txt": "if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff;"
      },
      {
        "txt": "int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++;"
      },
      {
        "txt": "} return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent;"
      },
      {
        "txt": "} ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);"
      },
      {
        "txt": "} else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction;"
      },
      {
        "txt": "} else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else {"
      },
      {
        "txt": "return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;"
      },
      {
        "txt": "} else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); }"
      },
      {
        "txt": "} public static double floor(double x) { long y; if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; } y = (long) x;"
      },
      {
        "txt": "if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; } return y; } public static double ceil(double x) { double y;"
      },
      {
        "txt": "if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y; } y += 1.0; if (y == 0) { return x*y;"
      },
      {
        "txt": "} return y; } public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand }"
      },
      {
        "txt": "return y+1.0; } if (d < 0.5) { return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) { return (long) floor(x + 0.5);"
      },
      {
        "txt": "} public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b; } public static long min(final long a, final long b) { return (a <= b) ? a : b; }"
      },
      {
        "txt": "public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Float.NaN; }"
      },
      {
        "txt": "int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; } public static double min(final double a, final double b) { if (a > b) { return b; }"
      },
      {
        "txt": "if (a < b) { return a; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a; }"
      },
      {
        "txt": "return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a; } public static float max(final float a, final float b) { if (a > b) {"
      },
      {
        "txt": "return a; } if (a < b) { return b; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) {"
      },
      {
        "txt": "return b; } return a; } public static double max(final double a, final double b) { if (a > b) { return a; } if (a < b) { return b;"
      },
      {
        "txt": "} if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; }"
      },
      {
        "txt": "public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) { return abs(x);"
      },
      {
        "txt": "} else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); } }"
      },
      {
        "txt": "} public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; }"
      },
      {
        "txt": "return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign }"
      },
      {
        "txt": "public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); }"
      },
      {
        "txt": "private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {"
      },
      {
        "txt": "FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } } } else {"
      },
      {
        "txt": "EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {"
      },
      {
        "txt": "EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; } } else {"
      },
      {
        "txt": "EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][];"
      },
      {
        "txt": "for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); } } } private static class CodyWaite {"
      },
      {
        "txt": "private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA; double remB; while (true) { double a = -k * 1.570796251296997;"
      },
      {
        "txt": "remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17; b = remA; remA = a + b; remB += -(remA - b - a);"
      },
      {
        "txt": "if (remA > 0) { break; } --k; } this.finalK = k; this.finalRemA = remA; this.finalRemB = remB; } int getK() {"
      },
      {
        "txt": "return finalK; } double getRemA() { return finalRemA; } double getRemB() { return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2498,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 400,
    "end-bug-line": 400,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream; public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750;"
      },
      {
        "txt": "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8},"
      },
      {
        "txt": "{-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25},"
      },
      {
        "txt": "{0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d,"
      },
      {
        "txt": "+0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d,"
      },
      {
        "txt": "+0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d,"
      },
      {
        "txt": "-3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, };"
      },
      {
        "txt": "private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d,"
      },
      {
        "txt": "+0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = { +0.0d,"
      },
      {
        "txt": "+3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d,"
      },
      {
        "txt": "-4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d,"
      },
      {
        "txt": "+0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d,"
      },
      {
        "txt": "}; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d,"
      },
      {
        "txt": "+7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL,"
      },
      {
        "txt": "(0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL,"
      },
      {
        "txt": "(0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L };"
      },
      {
        "txt": "private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d;"
      },
      {
        "txt": "private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d;"
      },
      {
        "txt": "private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert"
      },
      {
        "txt": "} long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) { return Math.sqrt(a); } public static double cosh(double x) { if (x != x) {"
      },
      {
        "txt": "} if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x); <extra_id_0> final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1];"
      },
      {
        "txt": "exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa;"
      },
      {
        "txt": "recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5;"
      },
      {
        "txt": "return result; } public static double sinh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); }"
      },
      {
        "txt": "if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; }"
      },
      {
        "txt": "double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya;"
      },
      {
        "txt": "temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp;"
      },
      {
        "txt": "temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1];"
      },
      {
        "txt": "double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp;"
      },
      {
        "txt": "double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp;"
      },
      {
        "txt": "result = ya + yb; result *= 0.5; } if (negate) { result = -result; } return result; } public static double tanh(double x) { boolean negate = false;"
      },
      {
        "txt": "if (x != x) { return x; } if (x > 20.0) { return 1.0; } if (x < -20) { return -1.0; } if (x == 0) {"
      },
      {
        "txt": "return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec);"
      },
      {
        "txt": "double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb); na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb;"
      },
      {
        "txt": "db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;"
      },
      {
        "txt": "ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else { double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya;"
      },
      {
        "txt": "double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da;"
      },
      {
        "txt": "temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } if (negate) { result = -result;"
      },
      {
        "txt": "} return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); } public static double asinh(double a) { boolean negative = false; if (a < 0) { negative = true;"
      },
      {
        "txt": "a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else { final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) {"
      },
      {
        "txt": "absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); } } return negative ? -absAsinh : absAsinh; } public static double atanh(double a) {"
      },
      {
        "txt": "boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a;"
      },
      {
        "txt": "if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } }"
      },
      {
        "txt": "return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY);"
      },
      {
        "txt": "} public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random(); } public static double exp(double x) { return exp(x, 0.0, null); }"
      },
      {
        "txt": "private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0;"
      },
      {
        "txt": "} return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result;"
      },
      {
        "txt": "} if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; } return result; } intVal++;"
      },
      {
        "txt": "intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; }"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have"
      },
      {
        "txt": "62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each."
      },
      {
        "txt": "tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;"
      },
      {
        "txt": "} else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result; } public static double expm1(double x) {"
      },
      {
        "txt": "return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; } if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) {"
      },
      {
        "txt": "return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb; } } double baseA; double baseB;"
      },
      {
        "txt": "double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true; } { int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];"
      },
      {
        "txt": "double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654;"
      },
      {
        "txt": "zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb; zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000; temp = za + temp - temp;"
      },
      {
        "txt": "zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB;"
      },
      {
        "txt": "yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za; yb += -(temp - ya - za); ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB);"
      },
      {
        "txt": "ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000;"
      },
      {
        "txt": "final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb;"
      },
      {
        "txt": "} if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb; } public static double log(final double x) { return log(x, null); }"
      },
      {
        "txt": "private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; }"
      },
      {
        "txt": "return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023;"
      },
      {
        "txt": "if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY; } bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp;"
      },
      {
        "txt": "bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp;"
      },
      {
        "txt": "double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000;"
      },
      {
        "txt": "ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa;"
      },
      {
        "txt": "ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; } } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0;"
      },
      {
        "txt": "final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL;"
      },
      {
        "txt": "final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000;"
      },
      {
        "txt": "ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa;"
      },
      {
        "txt": "ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab); } else { using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515;"
      },
      {
        "txt": "lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; } double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]);"
      },
      {
        "txt": "a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c; b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d;"
      },
      {
        "txt": "c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d; if (hiPrec != null) { hiPrec[0] = a;"
      },
      {
        "txt": "hiPrec[1] = b; } return a + b; } public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; }"
      },
      {
        "txt": "final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x; } } public static double log10(final double x) { final double hiPrec[] = new double[2];"
      },
      {
        "txt": "final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;"
      },
      {
        "txt": "} public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN"
      },
      {
        "txt": "return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) {"
      },
      {
        "txt": "return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0; } return Double.NaN;"
      },
      {
        "txt": "} if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "} if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; }"
      },
      {
        "txt": "} if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; }"
      },
      {
        "txt": "return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; } }"
      },
      {
        "txt": "if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } }"
      },
      {
        "txt": "if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } }"
      },
      {
        "txt": "double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;"
      },
      {
        "txt": "yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1;"
      },
      {
        "txt": "lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5;"
      },
      {
        "txt": "z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) { if (e == 0) { return 1.0; } else if (e < 0) { e = -e;"
      },
      {
        "txt": "d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0; double d2p = d; double d2pHigh = d1High;"
      },
      {
        "txt": "double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow;"
      },
      {
        "txt": "} final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow;"
      },
      {
        "txt": "e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x) { double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196;"
      },
      {
        "txt": "p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) { double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994;"
      },
      {
        "txt": "p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx];"
      },
      {
        "txt": "double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result; double a = 0;"
      },
      {
        "txt": "double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA * sinEpsA; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsB; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsA; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsB; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "} result = a + b; return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb;"
      },
      {
        "txt": "return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon;"
      },
      {
        "txt": "double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0; double b = 0; double t = sintA;"
      },
      {
        "txt": "double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB;"
      },
      {
        "txt": "b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = -sintA*sinEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) { double tmp;"
      },
      {
        "txt": "tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp;"
      },
      {
        "txt": "double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) {"
      },
      {
        "txt": "xbadj = -xbadj; } err += xbadj; } return est+err; } private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;"
      },
      {
        "txt": "inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0; long shpiA; long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) {"
      },
      {
        "txt": "shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32;"
      },
      {
        "txt": "long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32);"
      },
      {
        "txt": "bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d;"
      },
      {
        "txt": "ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpi0 >>> 32;"
      },
      {
        "txt": "d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32;"
      },
      {
        "txt": "b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c; ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32);"
      },
      {
        "txt": "bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d;"
      },
      {
        "txt": "ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } a = prodB >>> 32;"
      },
      {
        "txt": "b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac;"
      },
      {
        "txt": "bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart;"
      },
      {
        "txt": "result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false; int quadrant = 0; double xa; double xb = 0.0; xa = x; if (x < 0) {"
      },
      {
        "txt": "negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0; }"
      },
      {
        "txt": "if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) {"
      },
      {
        "txt": "final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) { quadrant ^= 2; // Flip bit 1 } switch (quadrant) { case 0:"
      },
      {
        "txt": "return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3: return -cosQ(xa, xb); default: return Double.NaN; }"
      },
      {
        "txt": "} public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) { xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; }"
      },
      {
        "txt": "double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3;"
      },
      {
        "txt": "xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0: return cosQ(xa, xb); case 1: return -sinQ(xa, xb); case 2: return -cosQ(xa, xb);"
      },
      {
        "txt": "case 3: return sinQ(xa, xb); default: return Double.NaN; } } public static double tan(double x) { boolean negative = false; int quadrant = 0; double xa = x;"
      },
      {
        "txt": "if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0;"
      },
      {
        "txt": "} if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1];"
      },
      {
        "txt": "xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17;"
      },
      {
        "txt": "final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1; negative ^= true; } double result; if ((quadrant & 1) == 0) {"
      },
      {
        "txt": "result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) { result = -result; } return result; } public static double atan(double x) {"
      },
      {
        "txt": "return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) { xa = -xa;"
      },
      {
        "txt": "xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); } if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa;"
      },
      {
        "txt": "idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp;"
      },
      {
        "txt": "double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2;"
      },
      {
        "txt": "double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa;"
      },
      {
        "txt": "temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za; } epsA = ya; epsB = yb; final double epsA2 = epsA * epsA;"
      },
      {
        "txt": "yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182;"
      },
      {
        "txt": "yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya);"
      },
      {
        "txt": "temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result);"
      },
      {
        "txt": "zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result; } return result; } public static double atan2(double y, double x) {"
      },
      {
        "txt": "if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y; final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0"
      },
      {
        "txt": "} else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) { return -Math.PI; } else { return Math.PI; }"
      },
      {
        "txt": "} else { return result; } } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4;"
      },
      {
        "txt": "} return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; }"
      },
      {
        "txt": "return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; } if (y < 0 || 1 / y < 0) { return -0d; } }"
      },
      {
        "txt": "if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) { return -Math.PI; } } if (x == 0) {"
      },
      {
        "txt": "if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; } } final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0);"
      },
      {
        "txt": "} double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly"
      },
      {
        "txt": "ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) {"
      },
      {
        "txt": "return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) { return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign return x;"
      },
      {
        "txt": "} double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya);"
      },
      {
        "txt": "temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y);"
      },
      {
        "txt": "double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false);"
      },
      {
        "txt": "} public static double acos(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == -1.0) { return Math.PI;"
      },
      {
        "txt": "} if (x == 1.0) { return 0.0; } if (x == 0) { return Math.PI/2.0; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa;"
      },
      {
        "txt": "double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y = sqrt(za);"
      },
      {
        "txt": "temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb; yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value"
      },
      {
        "txt": "} double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0); }"
      },
      {
        "txt": "public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) { return x; } subnormal = true; x *= 1.8014398509481984E16; // 2^54"
      },
      {
        "txt": "inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x; } int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);"
      },
      {
        "txt": "double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000;"
      },
      {
        "txt": "double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp; zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya;"
      },
      {
        "txt": "double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) { est *= 3.814697265625E-6; // 2^-18 } return est; }"
      },
      {
        "txt": "public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta;"
      },
      {
        "txt": "if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; } public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; }"
      },
      {
        "txt": "final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; } public static int abs(final int x) { return (x < 0) ? -x : x; } public static long abs(final long x) {"
      },
      {
        "txt": "return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) { if (Double.isInfinite(x)) {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); }"
      },
      {
        "txt": "public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d; } if (n < -2098) { return (d > 0) ? 0.0 : -0.0; }"
      },
      {
        "txt": "if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) {"
      },
      {
        "txt": "return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Double.longBitsToDouble(sign | mantissa); } else {"
      },
      {
        "txt": "return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL;"
      },
      {
        "txt": "if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "} } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); } if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; } if (n < -277) {"
      },
      {
        "txt": "return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n;"
      },
      {
        "txt": "if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; }"
      },
      {
        "txt": "return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent; }"
      },
      {
        "txt": "++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else {"
      },
      {
        "txt": "return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) {"
      },
      {
        "txt": "return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));"
      },
      {
        "txt": "} } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) {"
      },
      {
        "txt": "return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } }"
      },
      {
        "txt": "public static double floor(double x) { long y; if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; } y = (long) x; if (x < 0 && y != x) {"
      },
      {
        "txt": "y--; } if (y == 0) { return x*y; } return y; } public static double ceil(double x) { double y; if (x != x) { // NaN"
      },
      {
        "txt": "return x; } y = floor(x); if (y == x) { return y; } y += 1.0; if (y == 0) { return x*y; }"
      },
      {
        "txt": "return y; } public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand } return y+1.0;"
      },
      {
        "txt": "} if (d < 0.5) { return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) { return (long) floor(x + 0.5); }"
      },
      {
        "txt": "public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b; } public static long min(final long a, final long b) { return (a <= b) ? a : b; } public static float min(final float a, final float b) {"
      },
      {
        "txt": "if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a);"
      },
      {
        "txt": "if (bits == 0x80000000) { return a; } return b; } public static double min(final double a, final double b) { if (a > b) { return b; } if (a < b) {"
      },
      {
        "txt": "return a; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a; } return b;"
      },
      {
        "txt": "} public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a; } public static float max(final float a, final float b) { if (a > b) { return a;"
      },
      {
        "txt": "} if (a < b) { return b; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b;"
      },
      {
        "txt": "} return a; } public static double max(final double a, final double b) { if (a > b) { return a; } if (a < b) { return b; }"
      },
      {
        "txt": "if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; } public static double hypot(final double x, final double y) {"
      },
      {
        "txt": "if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) {"
      },
      {
        "txt": "return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); } } }"
      },
      {
        "txt": "public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign"
      },
      {
        "txt": "} public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static int getExponent(final double d) {"
      },
      {
        "txt": "return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable {"
      },
      {
        "txt": "private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp);"
      },
      {
        "txt": "EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } } } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();"
      },
      {
        "txt": "EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];"
      },
      {
        "txt": "EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; } } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();"
      },
      {
        "txt": "EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) {"
      },
      {
        "txt": "final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); } } } private static class CodyWaite { private final int finalK;"
      },
      {
        "txt": "private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA; double remB; while (true) { double a = -k * 1.570796251296997; remA = xa + a;"
      },
      {
        "txt": "remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17; b = remA; remA = a + b; remB += -(remA - b - a); if (remA > 0) {"
      },
      {
        "txt": "break; } --k; } this.finalK = k; this.finalRemA = remA; this.finalRemB = remB; } int getK() { return finalK;"
      },
      {
        "txt": "} double getRemA() { return finalRemA; } double getRemB() { return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2499,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 455,
    "end-bug-line": 455,
    "bug": "",
    "fix": "if (x >= LOG_MAX_VALUE) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream; public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024"
      },
      {
        "txt": "private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9},"
      },
      {
        "txt": "{0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10},"
      },
      {
        "txt": "{-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d,"
      },
      {
        "txt": "+0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, };"
      },
      {
        "txt": "private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d,"
      },
      {
        "txt": "+2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d,"
      },
      {
        "txt": "+0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d,"
      },
      {
        "txt": "+0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d,"
      },
      {
        "txt": "+1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d,"
      },
      {
        "txt": "}; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d,"
      },
      {
        "txt": "+1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = {"
      },
      {
        "txt": "+0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d,"
      },
      {
        "txt": "+2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L,"
      },
      {
        "txt": "(0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL,"
      },
      {
        "txt": "(0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998,"
      },
      {
        "txt": "1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d;"
      },
      {
        "txt": "private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d;"
      },
      {
        "txt": "private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits"
      },
      {
        "txt": "return Double.longBitsToDouble(xl); } public static double sqrt(final double a) { return Math.sqrt(a); } public static double cosh(double x) { if (x != x) { return x; } if (x > 20) {"
      },
      {
        "txt": "return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);"
      },
      {
        "txt": "double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;"
      },
      {
        "txt": "recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result;"
      },
      {
        "txt": "public static double sinh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20) { <extra_id_0> return 0.5 * exp(x); } if (x < -20) { return -0.5 * exp(-x); } if (x == 0) {"
      },
      {
        "txt": "} if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) {"
      },
      {
        "txt": "double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp;"
      },
      {
        "txt": "double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb);"
      },
      {
        "txt": "ya = temp; result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya;"
      },
      {
        "txt": "double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;"
      },
      {
        "txt": "rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5;"
      },
      {
        "txt": "} if (negate) { result = -result; } return result; } public static double tanh(double x) { boolean negate = false; if (x != x) { return x;"
      },
      {
        "txt": "} if (x > 20.0) { return 1.0; } if (x < -20) { return -1.0; } if (x == 0) { return x; }"
      },
      {
        "txt": "if (x < 0.0) { x = -x; negate = true; } double result; if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);"
      },
      {
        "txt": "double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb); na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp;"
      },
      {
        "txt": "temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da;"
      },
      {
        "txt": "result = ratioa + ratiob; } else { double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya;"
      },
      {
        "txt": "double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp;"
      },
      {
        "txt": "double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } if (negate) { result = -result; } return result;"
      },
      {
        "txt": "} public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); } public static double asinh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; }"
      },
      {
        "txt": "double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else { final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) {"
      },
      {
        "txt": "absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); } } return negative ? -absAsinh : absAsinh; } public static double atanh(double a) { boolean negative = false; if (a < 0) {"
      },
      {
        "txt": "negative = true; a = -a; } double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));"
      },
      {
        "txt": "} else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } } return negative ? -absAtanh : absAtanh; }"
      },
      {
        "txt": "public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) {"
      },
      {
        "txt": "return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random(); } public static double exp(double x) { return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA;"
      },
      {
        "txt": "double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0;"
      },
      {
        "txt": "} if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; } if (intVal == 709) {"
      },
      {
        "txt": "final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; } return result; } intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];"
      },
      {
        "txt": "intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */"
      },
      {
        "txt": "is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA;"
      },
      {
        "txt": "double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA;"
      },
      {
        "txt": "} if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result; } public static double expm1(double x) { return expm1(x, null); }"
      },
      {
        "txt": "private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; } if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else {"
      },
      {
        "txt": "final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb; } } double baseA; double baseB; double epsilon; boolean negative = false;"
      },
      {
        "txt": "if (x < 0.0) { x = -x; negative = true; } { int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB);"
      },
      {
        "txt": "tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994;"
      },
      {
        "txt": "zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb; zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp;"
      },
      {
        "txt": "double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp;"
      },
      {
        "txt": "temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za; yb += -(temp - ya - za); ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb;"
      },
      {
        "txt": "yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra;"
      },
      {
        "txt": "temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb; } if (hiPrecOut != null) {"
      },
      {
        "txt": "hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb; } public static double log(final double x) { return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; } return Double.NaN; }"
      },
      {
        "txt": "} if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) {"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY; } bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; }"
      },
      {
        "txt": "} if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa;"
      },
      {
        "txt": "xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab;"
      },
      {
        "txt": "final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000;"
      },
      {
        "txt": "ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; } } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0;"
      },
      {
        "txt": "double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom;"
      },
      {
        "txt": "xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab;"
      },
      {
        "txt": "final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0;"
      },
      {
        "txt": "lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab); } else { using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802;"
      },
      {
        "txt": "lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; } double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d;"
      },
      {
        "txt": "c = a + lnza; d = -(c - a - lnza); a = c; b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]);"
      },
      {
        "txt": "a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d; if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; }"
      },
      {
        "txt": "return a + b; } public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 ||"
      },
      {
        "txt": "x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1;"
      },
      {
        "txt": "return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x; } } public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN"
      },
      {
        "txt": "return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) {"
      },
      {
        "txt": "return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; }"
      },
      {
        "txt": "if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; }"
      },
      {
        "txt": "} if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) {"
      },
      {
        "txt": "if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; }"
      },
      {
        "txt": "if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) {"
      },
      {
        "txt": "return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {"
      },
      {
        "txt": "return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } } double ya; double yb;"
      },
      {
        "txt": "if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; }"
      },
      {
        "txt": "final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2;"
      },
      {
        "txt": "final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb;"
      },
      {
        "txt": "final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) { if (e == 0) { return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; }"
      },
      {
        "txt": "final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0; double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) {"
      },
      {
        "txt": "if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p;"
      },
      {
        "txt": "final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; }"
      },
      {
        "txt": "return resultHigh + resultLow; } private static double polySine(final double x) { double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x;"
      },
      {
        "txt": "return p; } private static double polyCosine(double x) { double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p;"
      },
      {
        "txt": "} private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon);"
      },
      {
        "txt": "final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result; double a = 0; double b = 0; double t = sintA;"
      },
      {
        "txt": "double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA * sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB;"
      },
      {
        "txt": "t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t); a = c; b = b + d; } result = a + b;"
      },
      {
        "txt": "return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); }"
      },
      {
        "txt": "private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0;"
      },
      {
        "txt": "final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = costA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b;"
      },
      {
        "txt": "double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp;"
      },
      {
        "txt": "} double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000;"
      },
      {
        "txt": "double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; }"
      },
      {
        "txt": "err += xbadj; } return est+err; } private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L;"
      },
      {
        "txt": "exponent++; inbits <<= 11; long shpi0; long shpiA; long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift);"
      },
      {
        "txt": "shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32;"
      },
      {
        "txt": "long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d;"
      },
      {
        "txt": "bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32;"
      },
      {
        "txt": "d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c; ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32;"
      },
      {
        "txt": "d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0;"
      },
      {
        "txt": "} public static double sin(double x) { boolean negative = false; int quadrant = 0; double xa; double xb = 0.0; xa = x; if (x < 0) { negative = true; xa = -xa;"
      },
      {
        "txt": "} if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN;"
      },
      {
        "txt": "} if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3;"
      },
      {
        "txt": "xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) { quadrant ^= 2; // Flip bit 1 } switch (quadrant) { case 0: return sinQ(xa, xb); case 1:"
      },
      {
        "txt": "return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3: return -cosQ(xa, xb); default: return Double.NaN; } } public static double cos(double x) {"
      },
      {
        "txt": "int quadrant = 0; double xa = x; if (x < 0) { xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) {"
      },
      {
        "txt": "double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB();"
      },
      {
        "txt": "} switch (quadrant) { case 0: return cosQ(xa, xb); case 1: return -sinQ(xa, xb); case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb);"
      },
      {
        "txt": "default: return Double.NaN; } } public static double tan(double x) { boolean negative = false; int quadrant = 0; double xa = x; if (x < 0) { negative = true;"
      },
      {
        "txt": "xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) {"
      },
      {
        "txt": "final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa);"
      },
      {
        "txt": "b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1; negative ^= true; } double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else {"
      },
      {
        "txt": "result = -tanQ(xa, xb, true); } if (negative) { result = -result; } return result; } public static double atan(double x) { return atan(x, 0.0, false); }"
      },
      {
        "txt": "private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) { xa = -xa; xb = -xb; negate = true;"
      },
      {
        "txt": "} if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); } if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); }"
      },
      {
        "txt": "double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya;"
      },
      {
        "txt": "xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];"
      },
      {
        "txt": "temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp;"
      },
      {
        "txt": "final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za; } epsA = ya; epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211;"
      },
      {
        "txt": "yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287;"
      },
      {
        "txt": "yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb);"
      },
      {
        "txt": "za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb;"
      },
      {
        "txt": "resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result; } return result; } public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN;"
      },
      {
        "txt": "} if (y == 0) { final double result = x * y; final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y);"
      },
      {
        "txt": "} } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) { return -Math.PI; } else { return Math.PI; } } else { return result;"
      },
      {
        "txt": "} } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2;"
      },
      {
        "txt": "} if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; } return -Math.PI * F_1_2; }"
      },
      {
        "txt": "if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; } if (y < 0 || 1 / y < 0) { return -0d; } } if (x == Double.NEGATIVE_INFINITY) {"
      },
      {
        "txt": "if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) { return -Math.PI; } } if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2;"
      },
      {
        "txt": "} if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; } } final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r);"
      },
      {
        "txt": "double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); }"
      },
      {
        "txt": "final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; }"
      },
      {
        "txt": "if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) { return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000;"
      },
      {
        "txt": "final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb);"
      },
      {
        "txt": "za = temp; double y; y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000;"
      },
      {
        "txt": "double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false); } public static double acos(double x) {"
      },
      {
        "txt": "if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == -1.0) { return Math.PI; } if (x == 1.0) {"
      },
      {
        "txt": "return 0.0; } if (x == 0) { return Math.PI/2.0; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb;"
      },
      {
        "txt": "ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp;"
      },
      {
        "txt": "yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb; yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r);"
      },
      {
        "txt": "double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) { return x; } subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;"
      },
      {
        "txt": "} if (exponent == 1024) { return x; } int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075;"
      },
      {
        "txt": "est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya;"
      },
      {
        "txt": "double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp; zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za);"
      },
      {
        "txt": "nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) { est *= 3.814697265625E-6; // 2^-18 } return est; } public static double toRadians(double x) {"
      },
      {
        "txt": "if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows"
      },
      {
        "txt": "} return result; } public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6;"
      },
      {
        "txt": "double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; } public static int abs(final int x) { return (x < 0) ? -x : x; } public static long abs(final long x) { return (x < 0l) ? -x : x; }"
      },
      {
        "txt": "public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) {"
      },
      {
        "txt": "return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d; } if (n < -2098) { return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) {"
      },
      {
        "txt": "mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; }"
      },
      {
        "txt": "} else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);"
      },
      {
        "txt": "} else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } }"
      },
      {
        "txt": "public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); } if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; } if (n < -277) { return (f > 0) ? 0.0f : -0.0f; }"
      },
      {
        "txt": "if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) {"
      },
      {
        "txt": "return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else {"
      },
      {
        "txt": "return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff;"
      },
      {
        "txt": "if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "} } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) {"
      },
      {
        "txt": "return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } }"
      },
      {
        "txt": "public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; }"
      },
      {
        "txt": "final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } } public static double floor(double x) { long y;"
      },
      {
        "txt": "if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; } y = (long) x; if (x < 0 && y != x) { y--; }"
      },
      {
        "txt": "if (y == 0) { return x*y; } return y; } public static double ceil(double x) { double y; if (x != x) { // NaN return x; }"
      },
      {
        "txt": "y = floor(x); if (y == x) { return y; } y += 1.0; if (y == 0) { return x*y; } return y; }"
      },
      {
        "txt": "public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand } return y+1.0; } if (d < 0.5) {"
      },
      {
        "txt": "return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) { return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f);"
      },
      {
        "txt": "} public static int min(final int a, final int b) { return (a <= b) ? a : b; } public static long min(final long a, final long b) { return (a <= b) ? a : b; } public static float min(final float a, final float b) { if (a > b) { return b;"
      },
      {
        "txt": "} if (a < b) { return a; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a;"
      },
      {
        "txt": "} return b; } public static double min(final double a, final double b) { if (a > b) { return b; } if (a < b) { return a; }"
      },
      {
        "txt": "if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a; } return b; } public static int max(final int a, final int b) {"
      },
      {
        "txt": "return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a; } public static float max(final float a, final float b) { if (a > b) { return a; } if (a < b) {"
      },
      {
        "txt": "return b; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b; } return a;"
      },
      {
        "txt": "} public static double max(final double a, final double b) { if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Double.NaN;"
      },
      {
        "txt": "} long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; } public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) { return abs(y); } else {"
      },
      {
        "txt": "final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); } } } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation"
      },
      {
        "txt": "} public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){"
      },
      {
        "txt": "int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; }"
      },
      {
        "txt": "public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B;"
      },
      {
        "txt": "static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];"
      },
      {
        "txt": "if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } } } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); }"
      },
      {
        "txt": "} } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2];"
      },
      {
        "txt": "final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; } } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); }"
      },
      {
        "txt": "} } private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d);"
      },
      {
        "txt": "} } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); } } } private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB;"
      },
      {
        "txt": "CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA; double remB; while (true) { double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8;"
      },
      {
        "txt": "double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17; b = remA; remA = a + b; remB += -(remA - b - a); if (remA > 0) { break; }"
      },
      {
        "txt": "--k; } this.finalK = k; this.finalRemA = remA; this.finalRemB = remB; } int getK() { return finalK; } double getRemA() {"
      },
      {
        "txt": "return finalRemA; } double getRemB() { return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2500,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 456,
    "end-bug-line": 456,
    "bug": "",
    "fix": "final double t = exp(0.5 * x); return (0.5 * t) * t; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream; public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024"
      },
      {
        "txt": "private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9},"
      },
      {
        "txt": "{0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10},"
      },
      {
        "txt": "{-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d,"
      },
      {
        "txt": "+0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, };"
      },
      {
        "txt": "private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d,"
      },
      {
        "txt": "+2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d,"
      },
      {
        "txt": "+0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d,"
      },
      {
        "txt": "+0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d,"
      },
      {
        "txt": "+1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d,"
      },
      {
        "txt": "}; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d,"
      },
      {
        "txt": "+1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = {"
      },
      {
        "txt": "+0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d,"
      },
      {
        "txt": "+2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L,"
      },
      {
        "txt": "(0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL,"
      },
      {
        "txt": "(0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998,"
      },
      {
        "txt": "1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d;"
      },
      {
        "txt": "private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d;"
      },
      {
        "txt": "private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits"
      },
      {
        "txt": "return Double.longBitsToDouble(xl); } public static double sqrt(final double a) { return Math.sqrt(a); } public static double cosh(double x) { if (x != x) { return x; } if (x > 20) {"
      },
      {
        "txt": "return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);"
      },
      {
        "txt": "double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;"
      },
      {
        "txt": "recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result;"
      },
      {
        "txt": "public static double sinh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20) { <extra_id_0> } if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x;"
      },
      {
        "txt": "if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2];"
      },
      {
        "txt": "exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa;"
      },
      {
        "txt": "recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp;"
      },
      {
        "txt": "result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom;"
      },
      {
        "txt": "double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator"
      },
      {
        "txt": "rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; }"
      },
      {
        "txt": "if (negate) { result = -result; } return result; } public static double tanh(double x) { boolean negate = false; if (x != x) { return x; }"
      },
      {
        "txt": "if (x > 20.0) { return 1.0; } if (x < -20) { return -1.0; } if (x == 0) { return x; } if (x < 0.0) {"
      },
      {
        "txt": "x = -x; negate = true; } double result; if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya;"
      },
      {
        "txt": "double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb); na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000;"
      },
      {
        "txt": "double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob;"
      },
      {
        "txt": "} else { double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya);"
      },
      {
        "txt": "double temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa;"
      },
      {
        "txt": "ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } if (negate) { result = -result; } return result; }"
      },
      {
        "txt": "public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); } public static double asinh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAsinh;"
      },
      {
        "txt": "if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else { final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);"
      },
      {
        "txt": "} else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); } } return negative ? -absAsinh : absAsinh; } public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true;"
      },
      {
        "txt": "a = -a; } double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) {"
      },
      {
        "txt": "absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } } return negative ? -absAtanh : absAtanh; } public static double signum(final double a) {"
      },
      {
        "txt": "return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY);"
      },
      {
        "txt": "} public static double random() { return Math.random(); } public static double exp(double x) { return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB;"
      },
      {
        "txt": "int intVal; if (x < 0.0) { intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; }"
      },
      {
        "txt": "if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; } return result; } intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal;"
      },
      {
        "txt": "} else { intVal = (int) x; if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];"
      },
      {
        "txt": "intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */"
      },
      {
        "txt": "double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;"
      },
      {
        "txt": "important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; }"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result; } public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) {"
      },
      {
        "txt": "if (x != x || x == 0.0) { // NaN or zero return x; } if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0];"
      },
      {
        "txt": "double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb; } } double baseA; double baseB; double epsilon; boolean negative = false; if (x < 0.0) {"
      },
      {
        "txt": "x = -x; negative = true; } { int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp;"
      },
      {
        "txt": "temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon;"
      },
      {
        "txt": "zb = zb * epsilon; double za = epsilon; double temp = za + zb; zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA;"
      },
      {
        "txt": "temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA;"
      },
      {
        "txt": "yb += -(temp - baseA - ya); ya = temp; temp = ya + za; yb += -(temp - ya - za); ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb);"
      },
      {
        "txt": "ya = temp; if (negative) { double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000;"
      },
      {
        "txt": "za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya;"
      },
      {
        "txt": "hiPrecOut[1] = yb; } return ya + yb; } public static double log(final double x) { return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; } return Double.NaN; } }"
      },
      {
        "txt": "if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY; } bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; } }"
      },
      {
        "txt": "if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab;"
      },
      {
        "txt": "final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i];"
      },
      {
        "txt": "aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp;"
      },
      {
        "txt": "yb = aa - ya + ab; return ya + yb; } } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0;"
      },
      {
        "txt": "if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom;"
      },
      {
        "txt": "final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i];"
      },
      {
        "txt": "aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp;"
      },
      {
        "txt": "lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab); } else { using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5;"
      },
      {
        "txt": "lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; } double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza;"
      },
      {
        "txt": "d = -(c - a - lnza); a = c; b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c;"
      },
      {
        "txt": "b = b + d; c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d; if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; } return a + b;"
      },
      {
        "txt": "} public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) {"
      },
      {
        "txt": "final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0];"
      },
      {
        "txt": "} else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x; } } public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores;"
      },
      {
        "txt": "} final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base);"
      },
      {
        "txt": "} public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) {"
      },
      {
        "txt": "long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }"
      },
      {
        "txt": "if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN"
      },
      {
        "txt": "return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) {"
      },
      {
        "txt": "return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN"
      },
      {
        "txt": "return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) {"
      },
      {
        "txt": "long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN;"
      },
      {
        "txt": "} if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y);"
      },
      {
        "txt": "} if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } } double ya; double yb; if (y < 8e298 && y > -8e298) {"
      },
      {
        "txt": "double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns);"
      },
      {
        "txt": "if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya;"
      },
      {
        "txt": "final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null);"
      },
      {
        "txt": "return result; } public static double pow(double d, int e) { if (e == 0) { return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001;"
      },
      {
        "txt": "final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0; double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) {"
      },
      {
        "txt": "final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh;"
      },
      {
        "txt": "final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow;"
      },
      {
        "txt": "} private static double polySine(final double x) { double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p;"
      },
      {
        "txt": "} private static double polyCosine(double x) { double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p; }"
      },
      {
        "txt": "private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0;"
      },
      {
        "txt": "final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result; double a = 0; double b = 0; double t = sintA; double c = a + t;"
      },
      {
        "txt": "double d = -(c - a - t); a = c; b = b + d; t = costA * sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;"
      },
      {
        "txt": "t = sintB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = sintB*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t); a = c; b = b + d; } result = a + b; return result;"
      },
      {
        "txt": "} private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) {"
      },
      {
        "txt": "int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon);"
      },
      {
        "txt": "double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = costA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b);"
      },
      {
        "txt": "a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; }"
      },
      {
        "txt": "double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp;"
      },
      {
        "txt": "double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; } err += xbadj;"
      },
      {
        "txt": "} return est+err; } private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++;"
      },
      {
        "txt": "inbits <<= 11; long shpi0; long shpiA; long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));"
      },
      {
        "txt": "shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL;"
      },
      {
        "txt": "long ac = a * c; long bd = b * d; long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prodA++; } bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) {"
      },
      {
        "txt": "prodA++; } c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0;"
      },
      {
        "txt": "prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c;"
      },
      {
        "txt": "ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL;"
      },
      {
        "txt": "ac = a * c; bd = b * d; bc = b * c; ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prod2A++; } bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) {"
      },
      {
        "txt": "prod2A++; } c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0;"
      },
      {
        "txt": "prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL;"
      },
      {
        "txt": "ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) {"
      },
      {
        "txt": "prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; }"
      },
      {
        "txt": "public static double sin(double x) { boolean negative = false; int quadrant = 0; double xa; double xb = 0.0; xa = x; if (x < 0) { negative = true; xa = -xa; }"
      },
      {
        "txt": "if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; }"
      },
      {
        "txt": "if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA();"
      },
      {
        "txt": "xb = cw.getRemB(); } if (negative) { quadrant ^= 2; // Flip bit 1 } switch (quadrant) { case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb);"
      },
      {
        "txt": "case 2: return -sinQ(xa, xb); case 3: return -cosQ(xa, xb); default: return Double.NaN; } } public static double cos(double x) { int quadrant = 0;"
      },
      {
        "txt": "double xa = x; if (x < 0) { xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3];"
      },
      {
        "txt": "reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); }"
      },
      {
        "txt": "switch (quadrant) { case 0: return cosQ(xa, xb); case 1: return -sinQ(xa, xb); case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default:"
      },
      {
        "txt": "return Double.NaN; } } public static double tan(double x) { boolean negative = false; int quadrant = 0; double xa = x; if (x < 0) { negative = true; xa = -xa;"
      },
      {
        "txt": "} if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN;"
      },
      {
        "txt": "} double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb);"
      },
      {
        "txt": "quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb;"
      },
      {
        "txt": "xa = a + b; xb = -(xa - a - b); quadrant ^= 1; negative ^= true; } double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true);"
      },
      {
        "txt": "} if (negative) { result = -result; } return result; } public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) {"
      },
      {
        "txt": "boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) { xa = -xa; xb = -xb; negate = true; }"
      },
      {
        "txt": "if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); } if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx];"
      },
      {
        "txt": "double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb;"
      },
      {
        "txt": "if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2;"
      },
      {
        "txt": "zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa;"
      },
      {
        "txt": "yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za; } epsA = ya; epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913;"
      },
      {
        "txt": "yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA;"
      },
      {
        "txt": "ya = epsA; temp = ya + yb; yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp;"
      },
      {
        "txt": "double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb);"
      },
      {
        "txt": "} if (negate ^ leftPlane) { result = -result; } return result; } public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; }"
      },
      {
        "txt": "if (y == 0) { final double result = x * y; final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y); }"
      },
      {
        "txt": "} if (x < 0 || invx < 0) { if (y < 0 || invy < 0) { return -Math.PI; } else { return Math.PI; } } else { return result; }"
      },
      {
        "txt": "} if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2; }"
      },
      {
        "txt": "if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; } return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "if (y > 0 || 1 / y > 0) { return 0d; } if (y < 0 || 1 / y < 0) { return -0d; } } if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) {"
      },
      {
        "txt": "return Math.PI; } if (y < 0 || 1 / y < 0) { return -Math.PI; } } if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; }"
      },
      {
        "txt": "if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; } } final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra;"
      },
      {
        "txt": "final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0);"
      },
      {
        "txt": "return result; } public static double asin(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) {"
      },
      {
        "txt": "return Math.PI/2.0; } if (x == -1.0) { return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp;"
      },
      {
        "txt": "final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp;"
      },
      {
        "txt": "double y; y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp;"
      },
      {
        "txt": "double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false); } public static double acos(double x) { if (x != x) {"
      },
      {
        "txt": "return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == -1.0) { return Math.PI; } if (x == 1.0) { return 0.0;"
      },
      {
        "txt": "} if (x == 0) { return Math.PI/2.0; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya;"
      },
      {
        "txt": "yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya;"
      },
      {
        "txt": "yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb; yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra;"
      },
      {
        "txt": "rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;"
      },
      {
        "txt": "boolean subnormal = false; if (exponent == -1023) { if (x == 0) { return x; } subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; }"
      },
      {
        "txt": "if (exponent == 1024) { return x; } int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271;"
      },
      {
        "txt": "est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya;"
      },
      {
        "txt": "double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp; zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb;"
      },
      {
        "txt": "est += (na+nb)/(3*est*est); est *= p2; if (subnormal) { est *= 3.814697265625E-6; // 2^-18 } return est; } public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign"
      },
      {
        "txt": "return x; } final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows }"
      },
      {
        "txt": "return result; } public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x);"
      },
      {
        "txt": "double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; } public static int abs(final int x) { return (x < 0) ? -x : x; } public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) {"
      },
      {
        "txt": "return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));"
      },
      {
        "txt": "} public static float ulp(float x) { if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);"
      },
      {
        "txt": "} if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d; } if (n < -2098) { return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52);"
      },
      {
        "txt": "final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; } } else {"
      },
      {
        "txt": "if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else {"
      },
      {
        "txt": "return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } } public static float scalb(final float f, final int n) {"
      },
      {
        "txt": "if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); } if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; } if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) {"
      },
      {
        "txt": "return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);"
      },
      {
        "txt": "} else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f;"
      },
      {
        "txt": "} } else { if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) {"
      },
      {
        "txt": "return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } }"
      },
      {
        "txt": "} public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;"
      },
      {
        "txt": "} final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) {"
      },
      {
        "txt": "if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f);"
      },
      {
        "txt": "final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } } public static double floor(double x) { long y; if (x != x) { // NaN"
      },
      {
        "txt": "return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; } y = (long) x; if (x < 0 && y != x) { y--; } if (y == 0) {"
      },
      {
        "txt": "return x*y; } return y; } public static double ceil(double x) { double y; if (x != x) { // NaN return x; } y = floor(x);"
      },
      {
        "txt": "if (y == x) { return y; } y += 1.0; if (y == 0) { return x*y; } return y; } public static double rint(double x) {"
      },
      {
        "txt": "double y = floor(x); double d = x - y; if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand } return y+1.0; } if (d < 0.5) { return y;"
      },
      {
        "txt": "} long z = (long) y; return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) { return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f); }"
      },
      {
        "txt": "public static int min(final int a, final int b) { return (a <= b) ? a : b; } public static long min(final long a, final long b) { return (a <= b) ? a : b; } public static float min(final float a, final float b) { if (a > b) { return b; }"
      },
      {
        "txt": "if (a < b) { return a; } if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; }"
      },
      {
        "txt": "return b; } public static double min(final double a, final double b) { if (a > b) { return b; } if (a < b) { return a; } if (a != b) {"
      },
      {
        "txt": "return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a; } return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a;"
      },
      {
        "txt": "} public static long max(final long a, final long b) { return (a <= b) ? b : a; } public static float max(final float a, final float b) { if (a > b) { return a; } if (a < b) { return b;"
      },
      {
        "txt": "} if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b; } return a; }"
      },
      {
        "txt": "public static double max(final double a, final double b) { if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Double.NaN; }"
      },
      {
        "txt": "long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; } public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) {"
      },
      {
        "txt": "return Double.NaN; } else { final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2;"
      },
      {
        "txt": "final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); } } } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation }"
      },
      {
        "txt": "public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude);"
      },
      {
        "txt": "int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) {"
      },
      {
        "txt": "return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static {"
      },
      {
        "txt": "if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) {"
      },
      {
        "txt": "FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } } } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } }"
      },
      {
        "txt": "} private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);"
      },
      {
        "txt": "for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; } } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } }"
      },
      {
        "txt": "} private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); }"
      },
      {
        "txt": "} else { LN_MANT = FastMathLiteralArrays.loadLnMant(); } } } private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa,"
      },
      {
        "txt": "double xb) { int k = (int)(xa * 0.6366197723675814); double remA; double remB; while (true) { double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA;"
      },
      {
        "txt": "remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17; b = remA; remA = a + b; remB += -(remA - b - a); if (remA > 0) { break; } --k;"
      },
      {
        "txt": "} this.finalK = k; this.finalRemA = remA; this.finalRemB = remB; } int getK() { return finalK; } double getRemA() { return finalRemA;"
      },
      {
        "txt": "} double getRemB() { return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2501,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 458,
    "end-bug-line": 458,
    "bug": "if (x < -20) {",
    "fix": "} else if (x < -20) { if (x <= -LOG_MAX_VALUE) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.PrintStream; public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059;"
      },
      {
        "txt": "private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11},"
      },
      {
        "txt": "{0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} };"
      },
      {
        "txt": "private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d,"
      },
      {
        "txt": "+0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = {"
      },
      {
        "txt": "+0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d,"
      },
      {
        "txt": "-3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d,"
      },
      {
        "txt": "+0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d,"
      },
      {
        "txt": "-0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d,"
      },
      {
        "txt": "+1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] ="
      },
      {
        "txt": "{ +0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d,"
      },
      {
        "txt": "+2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d,"
      },
      {
        "txt": "-2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d,"
      },
      {
        "txt": "+4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L,"
      },
      {
        "txt": "(0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL,"
      },
      {
        "txt": "(0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732,"
      },
      {
        "txt": "1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d;"
      },
      {
        "txt": "private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d;"
      },
      {
        "txt": "private static final double F_1_4 = 1d / 4d; private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); }"
      },
      {
        "txt": "public static double sqrt(final double a) { return Math.sqrt(a); } public static double cosh(double x) { if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); }"
      },
      {
        "txt": "if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);"
      },
      {
        "txt": "double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa;"
      },
      {
        "txt": "yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result; } public static double sinh(double x) {"
      },
      {
        "txt": "if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } <extra_id_0> return -0.5 * exp(-x); } if (x == 0) { return x; } if (x < 0.0) {"
      },
      {
        "txt": "} if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1];"
      },
      {
        "txt": "double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip;"
      },
      {
        "txt": "recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5;"
      },
      {
        "txt": "} else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr;"
      },
      {
        "txt": "double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra;"
      },
      {
        "txt": "yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result;"
      },
      {
        "txt": "} return result; } public static double tanh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0;"
      },
      {
        "txt": "} if (x < -20) { return -1.0; } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true;"
      },
      {
        "txt": "} double result; if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb;"
      },
      {
        "txt": "nb += -(temp - na - yb); na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa;"
      },
      {
        "txt": "double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else {"
      },
      {
        "txt": "double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb);"
      },
      {
        "txt": "da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da;"
      },
      {
        "txt": "ratiob += -db * na / da / da; result = ratioa + ratiob; } if (negate) { result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1));"
      },
      {
        "txt": "} public static double asinh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);"
      },
      {
        "txt": "} else { final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);"
      },
      {
        "txt": "} } return negative ? -absAsinh : absAsinh; } public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; }"
      },
      {
        "txt": "double absAtanh; if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) {"
      },
      {
        "txt": "absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } } return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a }"
      },
      {
        "txt": "public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() {"
      },
      {
        "txt": "return Math.random(); } public static double exp(double x) { return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) {"
      },
      {
        "txt": "intVal = (int) -x; if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620;"
      },
      {
        "txt": "hiPrec[1] /= 4.455505956692756620; } return result; } intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x;"
      },
      {
        "txt": "if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; }"
      },
      {
        "txt": "final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083;"
      },
      {
        "txt": "z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the"
      },
      {
        "txt": "pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA;"
      },
      {
        "txt": "hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; } return result; } public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x;"
      },
      {
        "txt": "} if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1];"
      },
      {
        "txt": "return ra + rb; } } double baseA; double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true;"
      },
      {
        "txt": "} { int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp;"
      },
      {
        "txt": "baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon;"
      },
      {
        "txt": "double temp = za + zb; zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB);"
      },
      {
        "txt": "ya = temp; temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp;"
      },
      {
        "txt": "temp = ya + za; yb += -(temp - ya - za); ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) {"
      },
      {
        "txt": "double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za;"
      },
      {
        "txt": "rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; }"
      },
      {
        "txt": "return ya + yb; } public static double log(final double x) { return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; } return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = Double.POSITIVE_INFINITY; } return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) {"
      },
      {
        "txt": "polynomial expansion in higer precision. */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0];"
      },
      {
        "txt": "double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1];"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb;"
      },
      {
        "txt": "} } final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000;"
      },
      {
        "txt": "double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0];"
      },
      {
        "txt": "double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1];"
      },
      {
        "txt": "tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab;"
      },
      {
        "txt": "lnzb = -(lnza - aa - ab); } else { using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon;"
      },
      {
        "txt": "} double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c;"
      },
      {
        "txt": "b = b + d; c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb;"
      },
      {
        "txt": "d = -(c - a - lnzb); a = c; b = b + d; if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) {"
      },
      {
        "txt": "if (x == -1) { return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x);"
      },
      {
        "txt": "final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1;"
      },
      {
        "txt": "return y * x; } } public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000;"
      },
      {
        "txt": "final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) {"
      },
      {
        "txt": "final double lns[] = new double[2]; if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) {"
      },
      {
        "txt": "long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; }"
      },
      {
        "txt": "if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; }"
      },
      {
        "txt": "if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; }"
      },
      {
        "txt": "if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) {"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) {"
      },
      {
        "txt": "return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } } double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1;"
      },
      {
        "txt": "yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores;"
      },
      {
        "txt": "} double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab;"
      },
      {
        "txt": "lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; }"
      },
      {
        "txt": "public static double pow(double d, int e) { if (e == 0) { return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d);"
      },
      {
        "txt": "final double d1Low = d - d1High; double resultHigh = 1; double resultLow = 0; double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh;"
      },
      {
        "txt": "final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH;"
      },
      {
        "txt": "final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x)"
      },
      {
        "txt": "{ double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) {"
      },
      {
        "txt": "double x2 = x*x; double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5);"
      },
      {
        "txt": "final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000;"
      },
      {
        "txt": "double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = costA * sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = costA*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) -"
      },
      {
        "txt": "(sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t; d = -(c - a - t); a = c; b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) {"
      },
      {
        "txt": "final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;"
      },
      {
        "txt": "final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp;"
      },
      {
        "txt": "sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;"
      },
      {
        "txt": "b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est);"
      },
      {
        "txt": "est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding"
      },
      {
        "txt": "err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err;"
      },
      {
        "txt": "} private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0;"
      },
      {
        "txt": "long shpiA; long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else {"
      },
      {
        "txt": "shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d;"
      },
      {
        "txt": "long bc = b * c; long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++;"
      },
      {
        "txt": "} bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; }"
      },
      {
        "txt": "c = shpiB >>> 32; d = shpiB & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32);"
      },
      {
        "txt": "int intPart = (int)(prodA >>> 62); prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d;"
      },
      {
        "txt": "bc = b * c; ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++;"
      },
      {
        "txt": "} bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c;"
      },
      {
        "txt": "ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false;"
      },
      {
        "txt": "int quadrant = 0; double xa; double xb = 0.0; xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3];"
      },
      {
        "txt": "reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); }"
      },
      {
        "txt": "if (negative) { quadrant ^= 2; // Flip bit 1 } switch (quadrant) { case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb);"
      },
      {
        "txt": "case 3: return -cosQ(xa, xb); default: return Double.NaN; } } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) {"
      },
      {
        "txt": "xa = -xa; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3;"
      },
      {
        "txt": "xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0:"
      },
      {
        "txt": "return cosQ(xa, xb); case 1: return -sinQ(xa, xb); case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; }"
      },
      {
        "txt": "} public static double tan(double x) { boolean negative = false; int quadrant = 0; double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) {"
      },
      {
        "txt": "long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0;"
      },
      {
        "txt": "if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA();"
      },
      {
        "txt": "xb = cw.getRemB(); } if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b);"
      },
      {
        "txt": "quadrant ^= 1; negative ^= true; } double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) {"
      },
      {
        "txt": "result = -result; } return result; } public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;"
      },
      {
        "txt": "if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) { xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);"
      },
      {
        "txt": "} if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];"
      },
      {
        "txt": "double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));"
      },
      {
        "txt": "ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp;"
      },
      {
        "txt": "zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za;"
      },
      {
        "txt": "yb += epsB / za; } epsA = ya; epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093;"
      },
      {
        "txt": "yb = yb * epsA2 * epsA; yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb;"
      },
      {
        "txt": "yb = -(temp - ya - yb); ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb);"
      },
      {
        "txt": "if (leftPlane) { final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) {"
      },
      {
        "txt": "result = -result; } return result; } public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y;"
      },
      {
        "txt": "final double invx = 1d / x; final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) {"
      },
      {
        "txt": "if (y < 0 || invy < 0) { return -Math.PI; } else { return Math.PI; } } else { return result; } } if (y == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return -Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; } return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d;"
      },
      {
        "txt": "} if (y < 0 || 1 / y < 0) { return -0d; } } if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; }"
      },
      {
        "txt": "if (y < 0 || 1 / y < 0) { return -Math.PI; } } if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2;"
      },
      {
        "txt": "} } final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa;"
      },
      {
        "txt": "rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; }"
      },
      {
        "txt": "public static double asin(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; }"
      },
      {
        "txt": "if (x == -1.0) { return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa;"
      },
      {
        "txt": "double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za);"
      },
      {
        "txt": "temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division"
      },
      {
        "txt": "rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; }"
      },
      {
        "txt": "if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == -1.0) { return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) {"
      },
      {
        "txt": "return Math.PI/2.0; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya;"
      },
      {
        "txt": "double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y);"
      },
      {
        "txt": "y = ya+yb; yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt."
      },
      {
        "txt": "temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) {"
      },
      {
        "txt": "if (x == 0) { return x; } subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x;"
      },
      {
        "txt": "} int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233;"
      },
      {
        "txt": "est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000;"
      },
      {
        "txt": "double temp2 = za + temp - temp; zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2;"
      },
      {
        "txt": "if (subnormal) { est *= 3.814697265625E-6; // 2^-18 } return est; } public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; }"
      },
      {
        "txt": "final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; }"
      },
      {
        "txt": "public static double toDegrees(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta;"
      },
      {
        "txt": "} public static int abs(final int x) { return (x < 0) ? -x : x; } public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 }"
      },
      {
        "txt": "public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) {"
      },
      {
        "txt": "if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {"
      },
      {
        "txt": "return d; } if (n < -2098) { return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L;"
      },
      {
        "txt": "int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent);"
      },
      {
        "txt": "if (mostSignificantLostBit != 0) { mantissa++; } return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) {"
      },
      {
        "txt": "mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "} else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23);"
      },
      {
        "txt": "} if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; } if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23);"
      },
      {
        "txt": "final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else {"
      },
      {
        "txt": "if (exponent == 0) { while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else {"
      },
      {
        "txt": "return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) {"
      },
      {
        "txt": "if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d);"
      },
      {
        "txt": "final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN;"
      },
      {
        "txt": "} else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) {"
      },
      {
        "txt": "return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } } public static double floor(double x) { long y; if (x != x) { // NaN return x; }"
      },
      {
        "txt": "if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; } y = (long) x; if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; }"
      },
      {
        "txt": "return y; } public static double ceil(double x) { double y; if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y;"
      },
      {
        "txt": "} y += 1.0; if (y == 0) { return x*y; } return y; } public static double rint(double x) { double y = floor(x); double d = x - y;"
      },
      {
        "txt": "if (d > 0.5) { if (y == -1.0) { return -0.0; // Preserve sign of operand } return y+1.0; } if (d < 0.5) { return y; } long z = (long) y;"
      },
      {
        "txt": "return (z & 1) == 0 ? y : y + 1.0; } public static long round(double x) { return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b;"
      },
      {
        "txt": "} public static long min(final long a, final long b) { return (a <= b) ? a : b; } public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a;"
      },
      {
        "txt": "} if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; }"
      },
      {
        "txt": "public static double min(final double a, final double b) { if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Double.NaN; }"
      },
      {
        "txt": "long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return a; } return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) {"
      },
      {
        "txt": "return (a <= b) ? b : a; } public static float max(final float a, final float b) { if (a > b) { return a; } if (a < b) { return b; } if (a != b) {"
      },
      {
        "txt": "return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b; } return a; } public static double max(final double a, final double b) { if (a > b) {"
      },
      {
        "txt": "return a; } if (a < b) { return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) {"
      },
      {
        "txt": "return b; } return a; } public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else {"
      },
      {
        "txt": "final int expX = getExponent(x); final int expY = getExponent(y); if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp);"
      },
      {
        "txt": "final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp); } } } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude);"
      },
      {
        "txt": "long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK"
      },
      {
        "txt": "return magnitude; } return -magnitude; // flip sign } public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; }"
      },
      {
        "txt": "public static void main(String[] a) { PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];"
      },
      {
        "txt": "EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];"
      },
      {
        "txt": "EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; } } } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable {"
      },
      {
        "txt": "private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp);"
      },
      {
        "txt": "EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1]; } } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant {"
      },
      {
        "txt": "private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant();"
      },
      {
        "txt": "} } } private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814);"
      },
      {
        "txt": "double remA; double remB; while (true) { double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a);"
      },
      {
        "txt": "a = -k * 6.123233995736766E-17; b = remA; remA = a + b; remB += -(remA - b - a); if (remA > 0) { break; } --k; } this.finalK = k;"
      },
      {
        "txt": "this.finalRemA = remA; this.finalRemB = remB; } int getK() { return finalK; } double getRemA() { return finalRemA; } double getRemB() {"
      },
      {
        "txt": "return finalRemB; } }"
      }
    ]
  },
  {
    "id": 2502,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 460,
    "end-bug-line": 460,
    "bug": "",
    "fix": "final double t = exp(-0.5 * x); return (-0.5 * t) * t; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream;"
      },
      {
        "txt": "public class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7;"
      },
      {
        "txt": "private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9},"
      },
      {
        "txt": "}; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14;"
      },
      {
        "txt": "private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d,"
      },
      {
        "txt": "+0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d,"
      },
      {
        "txt": "-4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d,"
      },
      {
        "txt": "+4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d,"
      },
      {
        "txt": "+0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d,"
      },
      {
        "txt": "}; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d,"
      },
      {
        "txt": "+4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = {"
      },
      {
        "txt": "+0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d,"
      },
      {
        "txt": "+3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d,"
      },
      {
        "txt": "+5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d,"
      },
      {
        "txt": "-3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL,"
      },
      {
        "txt": "(0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL,"
      },
      {
        "txt": "0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 };"
      },
      {
        "txt": "private static final long HEX_40000000 = 0x40000000L; // 1073741824L private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d;"
      },
      {
        "txt": "private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d;"
      },
      {
        "txt": "private FastMath() {} private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) {"
      },
      {
        "txt": "return Math.sqrt(a); } public static double cosh(double x) { if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) {"
      },
      {
        "txt": "return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000;"
      },
      {
        "txt": "double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa);"
      },
      {
        "txt": "ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result; } public static double sinh(double x) { boolean negate = false;"
      },
      {
        "txt": "return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { <extra_id_0> } if (x == 0) { return x; } if (x < 0.0) { x = -x;"
      },
      {
        "txt": "if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);"
      },
      {
        "txt": "double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa;"
      },
      {
        "txt": "recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; }"
      },
      {
        "txt": "else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000;"
      },
      {
        "txt": "double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra);"
      },
      {
        "txt": "ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; }"
      },
      {
        "txt": "return result; } public static double tanh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0; }"
      },
      {
        "txt": "if (x < -20) { return -1.0; } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; }"
      },
      {
        "txt": "double result; if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb);"
      },
      {
        "txt": "na = temp; double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da;"
      },
      {
        "txt": "temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else { double hiPrec[] = new double[2];"
      },
      {
        "txt": "expm1(x*2.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp;"
      },
      {
        "txt": "temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da;"
      },
      {
        "txt": "result = ratioa + ratiob; } if (negate) { result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); }"
      },
      {
        "txt": "public static double asinh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else {"
      },
      {
        "txt": "final double a2 = a * a; if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); }"
      },
      {
        "txt": "} return negative ? -absAsinh : absAsinh; } public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAtanh;"
      },
      {
        "txt": "if (a > 0.15) { absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));"
      },
      {
        "txt": "} else { absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } } return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) {"
      },
      {
        "txt": "return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a } public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random();"
      },
      {
        "txt": "} public static double exp(double x) { return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x;"
      },
      {
        "txt": "if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620;"
      },
      {
        "txt": "} return result; } intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) {"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0);"
      },
      {
        "txt": "final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687;"
      },
      {
        "txt": "z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */"
      },
      {
        "txt": "final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;"
      },
      {
        "txt": "} return result; } public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; }"
      },
      {
        "txt": "if (x <= -1.0 || x >= 1.0) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb;"
      },
      {
        "txt": "} } double baseA; double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true; }"
      },
      {
        "txt": "{ int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA);"
      },
      {
        "txt": "epsilon = x - intFrac/1024.0; } double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb;"
      },
      {
        "txt": "zb = -(temp - za - zb); za = temp; temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp;"
      },
      {
        "txt": "temp = ya + zb * baseA; yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za;"
      },
      {
        "txt": "yb += -(temp - ya - za); ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya;"
      },
      {
        "txt": "double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;"
      },
      {
        "txt": "rb += yb * denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb;"
      },
      {
        "txt": "} public static double log(final double x) { return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) {"
      },
      {
        "txt": "if (x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; } return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */"
      },
      {
        "txt": "double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1];"
      },
      {
        "txt": "for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000;"
      },
      {
        "txt": "ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; }"
      },
      {
        "txt": "} final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp;"
      },
      {
        "txt": "double ab = epsilon - aa; double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1];"
      },
      {
        "txt": "for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000;"
      },
      {
        "txt": "ya = aa + tmp - tmp; yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab);"
      },
      {
        "txt": "} else { using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; }"
      },
      {
        "txt": "double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c; b = b + d;"
      },
      {
        "txt": "c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb);"
      },
      {
        "txt": "a = c; b = b + d; if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) { if (x == -1) {"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2];"
      },
      {
        "txt": "final double lores = log(xpa, hiPrec); if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x;"
      },
      {
        "txt": "} } public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp;"
      },
      {
        "txt": "final double lnb = hiPrec[0] - lna + hiPrec[1]; final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2];"
      },
      {
        "txt": "if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y;"
      },
      {
        "txt": "if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) {"
      },
      {
        "txt": "return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) {"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) {"
      },
      {
        "txt": "long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} else { return 0.0; } } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);"
      },
      {
        "txt": "} else { return Double.NaN; } } double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya;"
      },
      {
        "txt": "} else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; }"
      },
      {
        "txt": "double lna = lns[0]; double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab);"
      },
      {
        "txt": "double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) {"
      },
      {
        "txt": "if (e == 0) { return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High;"
      },
      {
        "txt": "double resultHigh = 1; double resultLow = 0; double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh);"
      },
      {
        "txt": "final double rHL = resultHigh - rHH; final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);"
      },
      {
        "txt": "final double cTmpH = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x) {"
      },
      {
        "txt": "double x2 = x*x; double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) { double x2 = x*x;"
      },
      {
        "txt": "double p = 2.479773539153719E-5; p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;"
      },
      {
        "txt": "final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp;"
      },
      {
        "txt": "sinEpsB += sinEpsA - temp2; sinEpsA = temp2; double result; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = costA * sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = costA*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966;"
      },
      {
        "txt": "final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx];"
      },
      {
        "txt": "final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2;"
      },
      {
        "txt": "sinEpsA = temp2; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);"
      },
      {
        "txt": "double cosa = a + b; double cosb = -(cosa - a - b); if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb);"
      },
      {
        "txt": "err = (sina - cosa*est) + (sinb - cosb*est); double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb"
      },
      {
        "txt": "err += -sina * cosb / cosa / cosa; // Change in est due to cosb if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err; }"
      },
      {
        "txt": "private static void reducePayneHanek(double x, double result[]) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0; long shpiA;"
      },
      {
        "txt": "long shpiB; int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];"
      },
      {
        "txt": "shpiA = RECIP_2PI[idx]; shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c;"
      },
      {
        "txt": "long ad = a * d; long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; }"
      },
      {
        "txt": "bita = (prodB & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32;"
      },
      {
        "txt": "d = shpiB & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prodA++; } c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62);"
      },
      {
        "txt": "prodA <<= 2; prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c;"
      },
      {
        "txt": "ad = a * d; long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; }"
      },
      {
        "txt": "bita = (prod2B & 0x8000000000000000L) != 0; bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32;"
      },
      {
        "txt": "d = PI_O_4_BITS[1] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) ||"
      },
      {
        "txt": "((bita || bitb) && !bitsum) ) { prod2A++; } a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d;"
      },
      {
        "txt": "ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits"
      },
      {
        "txt": "double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false; int quadrant = 0;"
      },
      {
        "txt": "double xa; double xb = 0.0; xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) {"
      },
      {
        "txt": "return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults);"
      },
      {
        "txt": "quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) {"
      },
      {
        "txt": "quadrant ^= 2; // Flip bit 1 } switch (quadrant) { case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3:"
      },
      {
        "txt": "return -cosQ(xa, xb); default: return Double.NaN; } } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) { xa = -xa;"
      },
      {
        "txt": "} if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1];"
      },
      {
        "txt": "xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0: return cosQ(xa, xb);"
      },
      {
        "txt": "case 1: return -sinQ(xa, xb); case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; } }"
      },
      {
        "txt": "public static double tan(double x) { boolean negative = false; int quadrant = 0; double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x);"
      },
      {
        "txt": "if (bits < 0) { return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) {"
      },
      {
        "txt": "double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB();"
      },
      {
        "txt": "} if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1;"
      },
      {
        "txt": "negative ^= true; } double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) { result = -result;"
      },
      {
        "txt": "} return result; } public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign"
      },
      {
        "txt": "return leftPlane ? copySign(Math.PI, xa) : xa; } if (xa < 0) { xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }"
      },
      {
        "txt": "if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB;"
      },
      {
        "txt": "epsB = -(temp - epsA - epsB); epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom;"
      },
      {
        "txt": "yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx];"
      },
      {
        "txt": "ya = epsA / za; temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za;"
      },
      {
        "txt": "} epsA = ya; epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA;"
      },
      {
        "txt": "yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb);"
      },
      {
        "txt": "ya = temp; yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) {"
      },
      {
        "txt": "final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result;"
      },
      {
        "txt": "} return result; } public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y; final double invx = 1d / x;"
      },
      {
        "txt": "final double invy = 1d / y; if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) {"
      },
      {
        "txt": "return -Math.PI; } else { return Math.PI; } } else { return result; } } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "return Math.PI * F_1_4; } if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4;"
      },
      {
        "txt": "} if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; } return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; }"
      },
      {
        "txt": "if (y < 0 || 1 / y < 0) { return -0d; } } if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) {"
      },
      {
        "txt": "return -Math.PI; } } if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; }"
      },
      {
        "txt": "} final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;"
      },
      {
        "txt": "final double temp = ra + rb; rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) {"
      },
      {
        "txt": "if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) {"
      },
      {
        "txt": "return -Math.PI/2.0; } if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb;"
      },
      {
        "txt": "ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za); temp = y * HEX_40000000;"
      },
      {
        "txt": "ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt."
      },
      {
        "txt": "temp = ra + rb; rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) {"
      },
      {
        "txt": "return Double.NaN; } if (x == -1.0) { return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) { return Math.PI/2.0;"
      },
      {
        "txt": "} double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya);"
      },
      {
        "txt": "temp = za + yb; zb += -(temp - za - yb); za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb;"
      },
      {
        "txt": "yb = -(y - ya - yb); double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb;"
      },
      {
        "txt": "rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) {"
      },
      {
        "txt": "return x; } subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x; }"
      },
      {
        "txt": "int exp3 = exponent / 3; double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2];"
      },
      {
        "txt": "final double xs = x / (p2*p2*p2); est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp;"
      },
      {
        "txt": "zb += za - temp2; za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) {"
      },
      {
        "txt": "est *= 3.814697265625E-6; // 2^-18 } return est; } public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854;"
      },
      {
        "txt": "final double factb = 1.997844754509471E-9; double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; } public static double toDegrees(double x)"
      },
      {
        "txt": "{ if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; }"
      },
      {
        "txt": "public static int abs(final int x) { return (x < 0) ? -x : x; } public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) {"
      },
      {
        "txt": "return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0 } public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) {"
      },
      {
        "txt": "return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d;"
      },
      {
        "txt": "} if (n < -2098) { return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff;"
      },
      {
        "txt": "long mantissa = bits & 0x000fffffffffffffL; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) {"
      },
      {
        "txt": "mantissa++; } return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1;"
      },
      {
        "txt": "--scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) {"
      },
      {
        "txt": "return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); }"
      },
      {
        "txt": "if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { return f; } if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f);"
      },
      {
        "txt": "final int sign = bits & 0x80000000; int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));"
      },
      {
        "txt": "mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) {"
      },
      {
        "txt": "while ((mantissa >>> 23) != 1) { mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} } else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) {"
      },
      {
        "txt": "return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L;"
      },
      {
        "txt": "if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) {"
      },
      {
        "txt": "return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));"
      },
      {
        "txt": "} else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } } public static double floor(double x) { long y; if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {"
      },
      {
        "txt": "return x; } y = (long) x; if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; } return y;"
      },
      {
        "txt": "} public static double ceil(double x) { double y; if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y; }"
      },
      {
        "txt": "y += 1.0; if (y == 0) { return x*y; } return y; } public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) {"
      },
      {
        "txt": "if (y == -1.0) { return -0.0; // Preserve sign of operand } return y+1.0; } if (d < 0.5) { return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0;"
      },
      {
        "txt": "} public static long round(double x) { return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b; }"
      },
      {
        "txt": "public static long min(final long a, final long b) { return (a <= b) ? a : b; } public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a; }"
      },
      {
        "txt": "if (a != b) { return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; } public static double min(final double a, final double b) {"
      },
      {
        "txt": "if (a > b) { return b; } if (a < b) { return a; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a);"
      },
      {
        "txt": "if (bits == 0x8000000000000000L) { return a; } return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a;"
      },
      {
        "txt": "} public static float max(final float a, final float b) { if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Float.NaN;"
      },
      {
        "txt": "} int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b; } return a; } public static double max(final double a, final double b) { if (a > b) { return a;"
      },
      {
        "txt": "} if (a < b) { return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b;"
      },
      {
        "txt": "} return a; } public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x);"
      },
      {
        "txt": "final int expY = getExponent(y); if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);"
      },
      {
        "txt": "return scalb(scaledH, middleExp); } } } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign);"
      },
      {
        "txt": "if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; } return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude;"
      },
      {
        "txt": "} return -magnitude; // flip sign } public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) {"
      },
      {
        "txt": "PrintStream out = System.out; FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A); FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];"
      },
      {
        "txt": "final double tmp[] = new double[2]; final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];"
      },
      {
        "txt": "} } } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A;"
      },
      {
        "txt": "private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0];"
      },
      {
        "txt": "EXP_FRAC_TABLE_B[i] = tmp[1]; } } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant { private static final double[][] LN_MANT;"
      },
      {
        "txt": "static { if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); }"
      },
      {
        "txt": "} } private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA;"
      },
      {
        "txt": "double remB; while (true) { double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17;"
      },
      {
        "txt": "b = remA; remA = a + b; remB += -(remA - b - a); if (remA > 0) { break; } --k; } this.finalK = k; this.finalRemA = remA;"
      },
      {
        "txt": "this.finalRemB = remB; } int getK() { return finalK; } double getRemA() { return finalRemA; } double getRemB() { return finalRemB;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2503,
    "file_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
    "start-bug-line": 461,
    "end-bug-line": 461,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.util; import java.io.PrintStream; public class FastMath {"
      },
      {
        "txt": "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024 private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = {"
      },
      {
        "txt": "{1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, };"
      },
      {
        "txt": "private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] ="
      },
      {
        "txt": "{ +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d,"
      },
      {
        "txt": "+0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d,"
      },
      {
        "txt": "+9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d,"
      },
      {
        "txt": "+5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d,"
      },
      {
        "txt": "+0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, };"
      },
      {
        "txt": "private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d,"
      },
      {
        "txt": "+2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = { +0.0d,"
      },
      {
        "txt": "+0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d,"
      },
      {
        "txt": "+5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d,"
      },
      {
        "txt": "+5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d,"
      },
      {
        "txt": "}; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L,"
      },
      {
        "txt": "(0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 };"
      },
      {
        "txt": "private static final long PI_O_4_BITS[] = new long[] { (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L }; private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; // 1073741824L"
      },
      {
        "txt": "private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L; private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d;"
      },
      {
        "txt": "private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {}"
      },
      {
        "txt": "private static double doubleHighPart(double d) { if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){ return d; // These are un-normalised - don't try to convert } long xl = Double.doubleToLongBits(d); xl = xl & MASK_30BITS; // Drop low order bits return Double.longBitsToDouble(xl); } public static double sqrt(final double a) { return Math.sqrt(a);"
      },
      {
        "txt": "} public static double cosh(double x) { if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x);"
      },
      {
        "txt": "} final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp;"
      },
      {
        "txt": "double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp;"
      },
      {
        "txt": "temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result; } public static double sinh(double x) { boolean negate = false; if (x != x) {"
      },
      {
        "txt": "} if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return -0.5 * exp(-x); <extra_id_0> if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true;"
      },
      {
        "txt": "x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000;"
      },
      {
        "txt": "double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb;"
      },
      {
        "txt": "temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; } else {"
      },
      {
        "txt": "double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp;"
      },
      {
        "txt": "double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; // numerator rb += -ya * denomb * denomr * denomr; // denominator temp = ya + ra; yb += -(temp - ya - ra); ya = temp;"
      },
      {
        "txt": "temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; } return result;"
      },
      {
        "txt": "} public static double tanh(double x) { boolean negate = false; if (x != x) { return x; } if (x > 20.0) { return 1.0; } if (x < -20) {"
      },
      {
        "txt": "return -1.0; } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result;"
      },
      {
        "txt": "if (x >= 0.5) { double hiPrec[] = new double[2]; exp(x*2.0, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = -1.0 + ya; double nb = -(na + 1.0 - ya); double temp = na + yb; nb += -(temp - na - yb); na = temp;"
      },
      {
        "txt": "double da = 1.0 + ya; double db = -(da - 1.0 - ya); temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000; double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000;"
      },
      {
        "txt": "double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob; } else { double hiPrec[] = new double[2]; expm1(x*2.0, hiPrec);"
      },
      {
        "txt": "double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double na = ya; double nb = yb; double da = 2.0 + ya; double db = -(da - 2.0 - ya); double temp = da + yb; db += -(temp - da - yb); da = temp; temp = da * HEX_40000000;"
      },
      {
        "txt": "double daa = da + temp - temp; double dab = da - daa; double ratio = na/da; temp = ratio * HEX_40000000; double ratioa = ratio + temp - temp; double ratiob = ratio - ratioa; ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da; ratiob += nb / da; ratiob += -db * na / da / da; result = ratioa + ratiob;"
      },
      {
        "txt": "} if (negate) { result = -result; } return result; } public static double acosh(final double a) { return FastMath.log(a + FastMath.sqrt(a * a - 1)); } public static double asinh(double a) {"
      },
      {
        "txt": "boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAsinh; if (a > 0.167) { absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); } else { final double a2 = a * a;"
      },
      {
        "txt": "if (a > 0.097) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else if (a > 0.0036) { absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); } else { absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); } }"
      },
      {
        "txt": "return negative ? -absAsinh : absAsinh; } public static double atanh(double a) { boolean negative = false; if (a < 0) { negative = true; a = -a; } double absAtanh; if (a > 0.15) {"
      },
      {
        "txt": "absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); } else { final double a2 = a * a; if (a > 0.087) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); } else if (a > 0.031) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); } else if (a > 0.003) { absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); } else {"
      },
      {
        "txt": "absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); } } return negative ? -absAtanh : absAtanh; } public static double signum(final double a) { return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a } public static float signum(final float a) { return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a"
      },
      {
        "txt": "} public static double nextUp(final double a) { return nextAfter(a, Double.POSITIVE_INFINITY); } public static float nextUp(final float a) { return nextAfter(a, Float.POSITIVE_INFINITY); } public static double random() { return Math.random(); }"
      },
      {
        "txt": "public static double exp(double x) { return exp(x, 0.0, null); } private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal; if (x < 0.0) { intVal = (int) -x; if (intVal > 746) {"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; } if (intVal > 709) { final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0;"
      },
      {
        "txt": "hiPrec[1] /= 285040095144011776.0; } return result; } if (intVal == 709) { final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; }"
      },
      {
        "txt": "return result; } intVal++; intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal]; intVal = -intVal; } else { intVal = (int) x; if (intVal > 709) { if (hiPrec != null) {"
      },
      {
        "txt": "hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; } intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal]; intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal]; } final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];"
      },
      {
        "txt": "final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; final double epsilon = x - (intVal + intFrac / 1024.0); full double precision (52 bits). Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1. This will be used in the last addition below to get proper rounding. */ is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0;"
      },
      {
        "txt": "z = z * epsilon + -3.940510424527919E-20; expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; important. For accuracy add by increasing size. tempA is exact and much larger than the others. If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA;"
      },
      {
        "txt": "final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) { hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; }"
      },
      {
        "txt": "return result; } public static double expm1(double x) { return expm1(x, null); } private static double expm1(double x, double hiPrecOut[]) { if (x != x || x == 0.0) { // NaN or zero return x; } if (x <= -1.0 || x >= 1.0) {"
      },
      {
        "txt": "double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); if (x > 0.0) { return -1.0 + hiPrec[0] + hiPrec[1]; } else { final double ra = -1.0 + hiPrec[0]; double rb = -(ra + 1.0 - hiPrec[0]); rb += hiPrec[1]; return ra + rb; }"
      },
      {
        "txt": "} double baseA; double baseB; double epsilon; boolean negative = false; if (x < 0.0) { x = -x; negative = true; } {"
      },
      {
        "txt": "int intFrac = (int) (x * 1024.0); double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; double temp = tempA + tempB; tempB = -(temp - tempA - tempB); tempA = temp; temp = tempA * HEX_40000000; baseA = tempA + temp - temp; baseB = tempB + (tempA - baseA); epsilon = x - intFrac/1024.0;"
      },
      {
        "txt": "} double zb = 0.008336750013465571; zb = zb * epsilon + 0.041666663879186654; zb = zb * epsilon + 0.16666666666745392; zb = zb * epsilon + 0.49999999999999994; zb = zb * epsilon; zb = zb * epsilon; double za = epsilon; double temp = za + zb; zb = -(temp - za - zb);"
      },
      {
        "txt": "za = temp; temp = za * HEX_40000000; temp = za + temp - temp; zb += za - temp; za = temp; double ya = za * baseA; temp = ya + za * baseB; double yb = -(temp - ya - za * baseB); ya = temp; temp = ya + zb * baseA;"
      },
      {
        "txt": "yb += -(temp - ya - zb * baseA); ya = temp; temp = ya + zb * baseB; yb += -(temp - ya - zb*baseB); ya = temp; temp = ya + baseA; yb += -(temp - baseA - ya); ya = temp; temp = ya + za; yb += -(temp - ya - za);"
      },
      {
        "txt": "ya = temp; temp = ya + baseB; yb += -(temp - ya - baseB); ya = temp; temp = ya + zb; yb += -(temp - ya - zb); ya = temp; if (negative) { double denom = 1.0 + ya; double denomr = 1.0 / denom;"
      },
      {
        "txt": "double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; temp = ratio * HEX_40000000; final double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; za = denom + temp - temp; zb = denom - za; rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; rb += yb * denomr; // numerator"
      },
      {
        "txt": "rb += -ya * denomb * denomr * denomr; // denominator ya = -ra; yb = -rb; } if (hiPrecOut != null) { hiPrecOut[0] = ya; hiPrecOut[1] = yb; } return ya + yb; }"
      },
      {
        "txt": "public static double log(final double x) { return log(x, null); } private static double log(final double x, final double[] hiPrec) { if (x==0) { // Handle special case of +0/-0 return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0 || x != x) { if (x != 0.0) {"
      },
      {
        "txt": "if (hiPrec != null) { hiPrec[0] = Double.NaN; } return Double.NaN; } } if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } int exp = (int)(bits >> 52)-1023; if ((bits & 0x7ff0000000000000L) == 0) { if (x == 0) { if (hiPrec != null) { hiPrec[0] = Double.NEGATIVE_INFINITY; } return Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "bits <<= 1; while ( (bits & 0x0010000000000000L) == 0) { --exp; bits <<= 1; } } if (exp == -1 || exp == 0) { if (x < 1.01 && x > 0.99 && hiPrec == null) { polynomial expansion in higer precision. */ double xa = x - 1.0;"
      },
      {
        "txt": "double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab; final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {"
      },
      {
        "txt": "aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_QUICK_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp;"
      },
      {
        "txt": "yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; return ya + yb; } }"
      },
      {
        "txt": "final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L); epsilon -= 1.0; final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); double lnza = 0.0; double lnzb = 0.0; if (hiPrec != null) { double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa;"
      },
      {
        "txt": "double xa = aa; double xb = ab; final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom; final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1]; double ya = lnCoef_last[0]; double yb = lnCoef_last[1]; for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {"
      },
      {
        "txt": "aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * HEX_40000000; ya = aa + tmp - tmp; yb = aa - ya + ab; final double[] lnCoef_i = LN_HI_PREC_COEF[i]; aa = ya + lnCoef_i[0]; ab = yb + lnCoef_i[1]; tmp = aa * HEX_40000000; ya = aa + tmp - tmp;"
      },
      {
        "txt": "yb = aa - ya + ab; } aa = ya * xa; ab = ya * xb + yb * xa + yb * xb; tmp = aa * 1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab; lnza = aa + ab; lnzb = -(lnza - aa - ab); } else {"
      },
      {
        "txt": "using standard double precision */ lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; } double a = LN_2_A*exp;"
      },
      {
        "txt": "double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; c = a + lnza; d = -(c - a - lnza); a = c; b = b + d; c = a + LN_2_B*exp;"
      },
      {
        "txt": "d = -(c - a - LN_2_B*exp); a = c; b = b + d; c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; c = a + lnzb; d = -(c - a - lnzb); a = c;"
      },
      {
        "txt": "b = b + d; if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; } return a + b; } public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY;"
      },
      {
        "txt": "} if (x == Double.POSITIVE_INFINITY) { return Double.POSITIVE_INFINITY; } if (x > 1e-6 || x < -1e-6) { final double xpa = 1 + x; final double xpb = -(xpa - 1 - x); final double[] hiPrec = new double[2]; final double lores = log(xpa, hiPrec);"
      },
      {
        "txt": "if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN return lores; } final double fx1 = xpb / xpa; final double epsilon = 0.5 * fx1 + 1; return epsilon * fx1 + hiPrec[1] + hiPrec[0]; } else { final double y = (x * F_1_3 - F_1_2) * x + 1; return y * x; }"
      },
      {
        "txt": "} public static double log10(final double x) { final double hiPrec[] = new double[2]; final double lores = log(x, hiPrec); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } final double tmp = hiPrec[0] * HEX_40000000; final double lna = hiPrec[0] + tmp - tmp; final double lnb = hiPrec[0] - lna + hiPrec[1];"
      },
      {
        "txt": "final double rln10a = 0.4342944622039795; final double rln10b = 1.9699272335463627E-8; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; } public static double log(double base, double x) { return log(x) / log(base); } public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) {"
      },
      {
        "txt": "return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) {"
      },
      {
        "txt": "return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) {"
      },
      {
        "txt": "return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0;"
      },
      {
        "txt": "} else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y;"
      },
      {
        "txt": "if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else {"
      },
      {
        "txt": "return 0.0; } } if (x < 0) { if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else {"
      },
      {
        "txt": "return Double.NaN; } } double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else {"
      },
      {
        "txt": "double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0];"
      },
      {
        "txt": "double lnb = lns[1]; double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0;"
      },
      {
        "txt": "z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); return result; } public static double pow(double d, int e) { if (e == 0) {"
      },
      {
        "txt": "return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd = splitFactor * d; final double d1High = cd - (cd - d); final double d1Low = d - d1High; double resultHigh = 1;"
      },
      {
        "txt": "double resultLow = 0; double d2p = d; double d2pHigh = d1High; double d2pLow = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH = splitFactor * resultHigh; final double rHH = cRH - (cRH - resultHigh); final double rHL = resultHigh - rHH;"
      },
      {
        "txt": "final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH = splitFactor * d2pHigh; final double d2pHH = cD2pH - (cD2pH - d2pHigh); final double d2pHL = d2pHigh - d2pHH; final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH = splitFactor * tmpHigh;"
      },
      {
        "txt": "d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; } private static double polySine(final double x) { double x2 = x*x;"
      },
      {
        "txt": "double p = 2.7553817452272217E-6; p = p * x2 + -1.9841269659586505E-4; p = p * x2 + 0.008333333333329196; p = p * x2 + -0.16666666666666666; p = p * x2 * x; return p; } private static double polyCosine(double x) { double x2 = x*x; double p = 2.479773539153719E-5;"
      },
      {
        "txt": "p = p * x2 + -0.0013888888689039883; p = p * x2 + 0.041666666666621166; p = p * x2 + -0.49999999999999994; p *= x2; return p; } private static double sinQ(double xa, double xb) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx];"
      },
      {
        "txt": "final double sintB = SINE_TABLE_B[idx]; final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); final double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2;"
      },
      {
        "txt": "sinEpsA = temp2; double result; double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA * sinEpsA;"
      },
      {
        "txt": "c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintA * cosEpsB + costA * sinEpsB; t = sintA*cosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;"
      },
      {
        "txt": "t = costA*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; t = sintB; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = costB*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; t = sintB*cosEpsB; c = a + t; d = -(c - a - t); a = c;"
      },
      {
        "txt": "b = b + d; t = costB*sinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d; if (xb != 0.0) { t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; // approximate cosine*xb c = a + t;"
      },
      {
        "txt": "d = -(c - a - t); a = c; b = b + d; } result = a + b; return result; } private static double cosQ(double xa, double xb) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17;"
      },
      {
        "txt": "final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; return sinQ(a, b); } private static double tanQ(double xa, double xb, boolean cotanFlag) { int idx = (int) ((xa * 8.0) + 0.5); final double epsilon = xa - EIGHTHS[idx]; //idx*0.125; final double sintA = SINE_TABLE_A[idx]; final double sintB = SINE_TABLE_B[idx];"
      },
      {
        "txt": "final double costA = COSINE_TABLE_A[idx]; final double costB = COSINE_TABLE_B[idx]; double sinEpsA = epsilon; double sinEpsB = polySine(epsilon); final double cosEpsA = 1.0; final double cosEpsB = polyCosine(epsilon); double temp = sinEpsA * HEX_40000000; double temp2 = (sinEpsA + temp) - temp; sinEpsB += sinEpsA - temp2; sinEpsA = temp2;"
      },
      {
        "txt": "double a = 0; double b = 0; double t = sintA; double c = a + t; double d = -(c - a - t); a = c; b = b + d; t = costA*sinEpsA; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; b = b + sintA*cosEpsB + costA*sinEpsB; b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB; double sina = a + b; double sinb = -(sina - a - b); a = b = c = d = 0.0; t = costA*cosEpsA; c = a + t; d = -(c - a - t);"
      },
      {
        "txt": "a = c; b = b + d; t = -sintA*sinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d; b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB; b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB); double cosa = a + b;"
      },
      {
        "txt": "double cosb = -(cosa - a - b); if (cotanFlag) { double tmp; tmp = cosa; cosa = sina; sina = tmp; tmp = cosb; cosb = sinb; sinb = tmp; } double est = (sina+sinb)/(cosa+cosb); double err = (sina - cosa*est) + (sinb - cosb*est); est += err/(cosa+cosb); err = (sina - cosa*est) + (sinb - cosb*est);"
      },
      {
        "txt": "double est = sina/cosa; temp = est * HEX_40000000; double esta = (est + temp) - temp; double estb = est - esta; temp = cosa * HEX_40000000; double cosaa = (cosa + temp) - temp; double cosab = cosa - cosaa; double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa; // Correction for division rounding err += sinb/cosa; // Change in est due to sinb err += -sina * cosb / cosa / cosa; // Change in est due to cosb"
      },
      {
        "txt": "if (xb != 0.0) { double xbadj = xb + est*est*xb; if (cotanFlag) { xbadj = -xbadj; } err += xbadj; } return est+err; } private static void reducePayneHanek(double x, double result[])"
      },
      {
        "txt": "{ long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; inbits &= 0x000fffffffffffffL; inbits |= 0x0010000000000000L; exponent++; inbits <<= 11; long shpi0; long shpiA; long shpiB;"
      },
      {
        "txt": "int idx = exponent >> 6; int shift = exponent - (idx << 6); if (shift != 0) { shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift); shpi0 |= RECIP_2PI[idx] >>> (64-shift); shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift)); shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift)); } else { shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1]; shpiA = RECIP_2PI[idx];"
      },
      {
        "txt": "shpiB = RECIP_2PI[idx+1]; } long a = inbits >>> 32; long b = inbits & 0xffffffffL; long c = shpiA >>> 32; long d = shpiA & 0xffffffffL; long ac = a * c; long bd = b * d; long bc = b * c; long ad = a * d;"
      },
      {
        "txt": "long prodB = bd + (ad << 32); long prodA = ac + (ad >>> 32); boolean bita = (bd & 0x8000000000000000L) != 0; boolean bitb = (ad & 0x80000000L ) != 0; boolean bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } bita = (prodB & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "bitb = (bc & 0x80000000L ) != 0; prodB = prodB + (bc << 32); prodA = prodA + (bc >>> 32); bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prodA++; } c = shpiB >>> 32; d = shpiB & 0xffffffffL;"
      },
      {
        "txt": "ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prodB & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prodB += ac; bitsum = (prodB & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) {"
      },
      {
        "txt": "prodA++; } c = shpi0 >>> 32; d = shpi0 & 0xffffffffL; bd = b * d; bc = b * c; ad = a * d; prodA += bd + ((bc + ad) << 32); int intPart = (int)(prodA >>> 62); prodA <<= 2;"
      },
      {
        "txt": "prodA |= prodB >>> 62; prodB <<= 2; a = prodA >>> 32; b = prodA & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bd = b * d; bc = b * c; ad = a * d;"
      },
      {
        "txt": "long prod2B = bd + (ad << 32); long prod2A = ac + (ad >>> 32); bita = (bd & 0x8000000000000000L) != 0; bitb = (ad & 0x80000000L ) != 0; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } bita = (prod2B & 0x8000000000000000L) != 0;"
      },
      {
        "txt": "bitb = (bc & 0x80000000L ) != 0; prod2B = prod2B + (bc << 32); prod2A = prod2A + (bc >>> 32); bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } c = PI_O_4_BITS[1] >>> 32; d = PI_O_4_BITS[1] & 0xffffffffL;"
      },
      {
        "txt": "ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32); bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) {"
      },
      {
        "txt": "prod2A++; } a = prodB >>> 32; b = prodB & 0xffffffffL; c = PI_O_4_BITS[0] >>> 32; d = PI_O_4_BITS[0] & 0xffffffffL; ac = a * c; bc = b * c; ad = a * d; ac = ac + ((bc + ad) >>> 32);"
      },
      {
        "txt": "bita = (prod2B & 0x8000000000000000L) != 0; bitb = (ac & 0x8000000000000000L ) != 0; prod2B += ac; bitsum = (prod2B & 0x8000000000000000L) != 0; if ( (bita && bitb) || ((bita || bitb) && !bitsum) ) { prod2A++; } double tmpA = (prod2A >>> 12) / TWO_POWER_52; // High order 52 bits double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits"
      },
      {
        "txt": "double sumA = tmpA + tmpB; double sumB = -(sumA - tmpA - tmpB); result[0] = intPart; result[1] = sumA * 2.0; result[2] = sumB * 2.0; } public static double sin(double x) { boolean negative = false; int quadrant = 0; double xa;"
      },
      {
        "txt": "double xb = 0.0; xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) { return -0.0;"
      },
      {
        "txt": "} return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3;"
      },
      {
        "txt": "xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } if (negative) { quadrant ^= 2; // Flip bit 1"
      },
      {
        "txt": "} switch (quadrant) { case 0: return sinQ(xa, xb); case 1: return cosQ(xa, xb); case 2: return -sinQ(xa, xb); case 3: return -cosQ(xa, xb);"
      },
      {
        "txt": "default: return Double.NaN; } } public static double cos(double x) { int quadrant = 0; double xa = x; if (x < 0) { xa = -xa; }"
      },
      {
        "txt": "if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3]; reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2];"
      },
      {
        "txt": "} else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); } switch (quadrant) { case 0: return cosQ(xa, xb); case 1:"
      },
      {
        "txt": "return -sinQ(xa, xb); case 2: return -cosQ(xa, xb); case 3: return sinQ(xa, xb); default: return Double.NaN; } } public static double tan(double x) {"
      },
      {
        "txt": "boolean negative = false; int quadrant = 0; double xa = x; if (x < 0) { negative = true; xa = -xa; } if (xa == 0.0) { long bits = Double.doubleToLongBits(x); if (bits < 0) {"
      },
      {
        "txt": "return -0.0; } return 0.0; } if (xa != xa || xa == Double.POSITIVE_INFINITY) { return Double.NaN; } double xb = 0; if (xa > 3294198.0) { double reduceResults[] = new double[3];"
      },
      {
        "txt": "reducePayneHanek(xa, reduceResults); quadrant = ((int) reduceResults[0]) & 3; xa = reduceResults[1]; xb = reduceResults[2]; } else if (xa > 1.5707963267948966) { final CodyWaite cw = new CodyWaite(xa, xb); quadrant = cw.getK() & 3; xa = cw.getRemA(); xb = cw.getRemB(); }"
      },
      {
        "txt": "if (xa > 1.5) { final double pi2a = 1.5707963267948966; final double pi2b = 6.123233995736766E-17; final double a = pi2a - xa; double b = -(a - pi2a + xa); b += pi2b - xb; xa = a + b; xb = -(xa - a - b); quadrant ^= 1; negative ^= true;"
      },
      {
        "txt": "} double result; if ((quadrant & 1) == 0) { result = tanQ(xa, xb, false); } else { result = -tanQ(xa, xb, true); } if (negative) { result = -result; }"
      },
      {
        "txt": "return result; } public static double atan(double x) { return atan(x, 0.0, false); } private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx; if (xa == 0.0) { // Matches +/- 0.0; return correct sign return leftPlane ? copySign(Math.PI, xa) : xa;"
      },
      {
        "txt": "} if (xa < 0) { xa = -xa; xb = -xb; negate = true; } if (xa > 1.633123935319537E16) { // Very large input return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); } if (xa < 1) {"
      },
      {
        "txt": "idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; double temp = epsA + epsB; epsB = -(temp - epsA - epsB);"
      },
      {
        "txt": "epsA = temp; temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; if (idx == 0) { final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); ya = epsA * denom; yb = epsB * denom;"
      },
      {
        "txt": "} else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp; zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za;"
      },
      {
        "txt": "temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp; final double yab = ya - yaa; temp = za * HEX_40000000; final double zaa = (za + temp) - temp; final double zab = za - zaa; yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; yb += -epsA * zb / za / za; yb += epsB / za; }"
      },
      {
        "txt": "epsA = ya; epsB = yb; final double epsA2 = epsA * epsA; yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; yb = 0.07490822288864472;"
      },
      {
        "txt": "yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; ya = epsA; temp = ya + yb; yb = -(temp - ya - yb); ya = temp;"
      },
      {
        "txt": "yb += epsB / (1d + epsA * epsA); double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double result = za + zb; double resultb = -(result - za - zb); if (leftPlane) { final double pia = 1.5707963267948966 * 2;"
      },
      {
        "txt": "final double pib = 6.123233995736766E-17 * 2; za = pia - result; zb = -(za - pia + result); zb += pib - resultb; result = za + zb; resultb = -(result - za - zb); } if (negate ^ leftPlane) { result = -result; }"
      },
      {
        "txt": "return result; } public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; } if (y == 0) { final double result = x * y; final double invx = 1d / x; final double invy = 1d / y;"
      },
      {
        "txt": "if (invx == 0) { // X is infinite if (x > 0) { return y; // return +/- 0.0 } else { return copySign(Math.PI, y); } } if (x < 0 || invx < 0) { if (y < 0 || invy < 0) { return -Math.PI;"
      },
      {
        "txt": "} else { return Math.PI; } } else { return result; } } if (y == Double.POSITIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return Math.PI * F_1_4;"
      },
      {
        "txt": "} if (x == Double.NEGATIVE_INFINITY) { return Math.PI * F_3_4; } return Math.PI * F_1_2; } if (y == Double.NEGATIVE_INFINITY) { if (x == Double.POSITIVE_INFINITY) { return -Math.PI * F_1_4; }"
      },
      {
        "txt": "if (x == Double.NEGATIVE_INFINITY) { return -Math.PI * F_3_4; } return -Math.PI * F_1_2; } if (x == Double.POSITIVE_INFINITY) { if (y > 0 || 1 / y > 0) { return 0d; } if (y < 0 || 1 / y < 0) {"
      },
      {
        "txt": "return -0d; } } if (x == Double.NEGATIVE_INFINITY) { if (y > 0.0 || 1 / y > 0.0) { return Math.PI; } if (y < 0 || 1 / y < 0) { return -Math.PI;"
      },
      {
        "txt": "} } if (x == 0) { if (y > 0 || 1 / y > 0) { return Math.PI * F_1_2; } if (y < 0 || 1 / y < 0) { return -Math.PI * F_1_2; } }"
      },
      {
        "txt": "final double r = y / x; if (Double.isInfinite(r)) { // bypass calculations that can create NaN return atan(r, 0, x < 0); } double ra = doubleHighPart(r); double rb = r - ra; final double xa = doubleHighPart(x); final double xb = x - xa; rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; final double temp = ra + rb;"
      },
      {
        "txt": "rb = -(temp - ra - rb); ra = temp; if (ra == 0) { // Fix up the sign so atan works correctly ra = copySign(0d, y); } final double result = atan(ra, rb, x < 0); return result; } public static double asin(double x) { if (x != x) {"
      },
      {
        "txt": "return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN; } if (x == 1.0) { return Math.PI/2.0; } if (x == -1.0) { return -Math.PI/2.0;"
      },
      {
        "txt": "} if (x == 0.0) { // Matches +/- 0.0; return correct sign return x; } double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya;"
      },
      {
        "txt": "yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; double y; y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp;"
      },
      {
        "txt": "yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); double dx = zb / (2.0*y); double r = x/y; temp = r * HEX_40000000; double ra = r + temp - temp; double rb = r - ra; rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y; // Correct for rounding in division rb += -x * dx / y / y; // Add in effect additional bits of sqrt. temp = ra + rb;"
      },
      {
        "txt": "rb = -(temp - ra - rb); ra = temp; return atan(ra, rb, false); } public static double acos(double x) { if (x != x) { return Double.NaN; } if (x > 1.0 || x < -1.0) { return Double.NaN;"
      },
      {
        "txt": "} if (x == -1.0) { return Math.PI; } if (x == 1.0) { return 0.0; } if (x == 0) { return Math.PI/2.0; }"
      },
      {
        "txt": "double temp = x * HEX_40000000; final double xa = x + temp - temp; final double xb = x - xa; double ya = xa*xa; double yb = xa*xb*2.0 + xb*xb; ya = -ya; yb = -yb; double za = 1.0 + ya; double zb = -(za - 1.0 - ya); temp = za + yb;"
      },
      {
        "txt": "zb += -(temp - za - yb); za = temp; double y = sqrt(za); temp = y * HEX_40000000; ya = y + temp - temp; yb = y - ya; yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y); yb += zb / (2.0*y); y = ya+yb; yb = -(y - ya - yb);"
      },
      {
        "txt": "double r = y/x; if (Double.isInfinite(r)) { // x is effectively zero return Math.PI/2; // so return the appropriate value } double ra = doubleHighPart(r); double rb = r - ra; rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x; // Correct for rounding in division rb += yb / x; // Add in effect additional bits of sqrt. temp = ra + rb; rb = -(temp - ra - rb);"
      },
      {
        "txt": "ra = temp; return atan(ra, rb, x<0); } public static double cbrt(double x) { long inbits = Double.doubleToLongBits(x); int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; boolean subnormal = false; if (exponent == -1023) { if (x == 0) { return x;"
      },
      {
        "txt": "} subnormal = true; x *= 1.8014398509481984E16; // 2^54 inbits = Double.doubleToLongBits(x); exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; } if (exponent == 1024) { return x; } int exp3 = exponent / 3;"
      },
      {
        "txt": "double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long)(((exp3 + 1023) & 0x7ff)) << 52); final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); double est = -0.010714690733195933; est = est * mant + 0.0875862700108075; est = est * mant + -0.3058015757857271; est = est * mant + 0.7249995199969751; est = est * mant + 0.5039018405998233; est *= CBRTTWO[exponent % 3 + 2]; final double xs = x / (p2*p2*p2);"
      },
      {
        "txt": "est += (xs - est*est*est) / (3*est*est); est += (xs - est*est*est) / (3*est*est); double temp = est * HEX_40000000; double ya = est + temp - temp; double yb = est - ya; double za = ya * ya; double zb = ya * yb * 2.0 + yb * yb; temp = za * HEX_40000000; double temp2 = za + temp - temp; zb += za - temp2;"
      },
      {
        "txt": "za = temp2; zb = za * yb + ya * zb + zb * yb; za = za * ya; double na = xs - za; double nb = -(na - xs + za); nb -= zb; est += (na+nb)/(3*est*est); est *= p2; if (subnormal) { est *= 3.814697265625E-6; // 2^-18"
      },
      {
        "txt": "} return est; } public static double toRadians(double x) { if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 0.01745329052209854; final double factb = 1.997844754509471E-9;"
      },
      {
        "txt": "double xa = doubleHighPart(x); double xb = x - xa; double result = xb * factb + xb * facta + xa * factb + xa * facta; if (result == 0) { result = result * x; // ensure correct sign if calculation underflows } return result; } public static double toDegrees(double x) {"
      },
      {
        "txt": "if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign return x; } final double facta = 57.2957763671875; final double factb = 3.145894820876798E-6; double xa = doubleHighPart(x); double xb = x - xa; return xb * factb + xb * facta + xa * factb + xa * facta; } public static int abs(final int x) {"
      },
      {
        "txt": "return (x < 0) ? -x : x; } public static long abs(final long x) { return (x < 0l) ? -x : x; } public static float abs(final float x) { return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0 } public static double abs(double x) { return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0"
      },
      {
        "txt": "} public static double ulp(double x) { if (Double.isInfinite(x)) { return Double.POSITIVE_INFINITY; } return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1)); } public static float ulp(float x) { if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY;"
      },
      {
        "txt": "} return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); } public static double scalb(final double d, final int n) { if ((n > -1023) && (n < 1024)) { return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); } if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { return d; }"
      },
      {
        "txt": "if (n < -2098) { return (d > 0) ? 0.0 : -0.0; } if (n > 2097) { return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; int exponent = ((int) (bits >>> 52)) & 0x7ff; long mantissa = bits & 0x000fffffffffffffL;"
      },
      {
        "txt": "int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else if (scaledExponent > -53) { mantissa = mantissa | (1L << 52); final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent); if (mostSignificantLostBit != 0) { mantissa++;"
      },
      {
        "txt": "} return Double.longBitsToDouble(sign | mantissa); } else { return (sign == 0L) ? 0.0 : -0.0; } } else { if (exponent == 0) { while ((mantissa >>> 52) != 1) { mantissa = mantissa << 1; --scaledExponent;"
      },
      {
        "txt": "} ++scaledExponent; mantissa = mantissa & 0x000fffffffffffffL; if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); } else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } else if (scaledExponent < 2047) { return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);"
      },
      {
        "txt": "} else { return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } } } public static float scalb(final float f, final int n) { if ((n > -127) && (n < 128)) { return f * Float.intBitsToFloat((n + 127) << 23); } if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {"
      },
      {
        "txt": "return f; } if (n < -277) { return (f > 0) ? 0.0f : -0.0f; } if (n > 276) { return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000;"
      },
      {
        "txt": "int exponent = (bits >>> 23) & 0xff; int mantissa = bits & 0x007fffff; int scaledExponent = exponent + n; if (n < 0) { if (scaledExponent > 0) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else if (scaledExponent > -24) { mantissa = mantissa | (1 << 23); final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); mantissa = mantissa >>> (1 - scaledExponent);"
      },
      {
        "txt": "if (mostSignificantLostBit != 0) { mantissa++; } return Float.intBitsToFloat(sign | mantissa); } else { return (sign == 0) ? 0.0f : -0.0f; } } else { if (exponent == 0) { while ((mantissa >>> 23) != 1) {"
      },
      {
        "txt": "mantissa = mantissa << 1; --scaledExponent; } ++scaledExponent; mantissa = mantissa & 0x007fffff; if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; }"
      },
      {
        "txt": "} else if (scaledExponent < 255) { return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); } else { return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; } } } public static double nextAfter(double d, double direction) { if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN;"
      },
      {
        "txt": "} else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) {"
      },
      {
        "txt": "return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); } } public static float nextAfter(final float f, final double direction) { if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction;"
      },
      {
        "txt": "} else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else {"
      },
      {
        "txt": "return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } } public static double floor(double x) { long y; if (x != x) { // NaN return x; } if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x;"
      },
      {
        "txt": "} y = (long) x; if (x < 0 && y != x) { y--; } if (y == 0) { return x*y; } return y; }"
      },
      {
        "txt": "public static double ceil(double x) { double y; if (x != x) { // NaN return x; } y = floor(x); if (y == x) { return y; } y += 1.0;"
      },
      {
        "txt": "if (y == 0) { return x*y; } return y; } public static double rint(double x) { double y = floor(x); double d = x - y; if (d > 0.5) { if (y == -1.0) {"
      },
      {
        "txt": "return -0.0; // Preserve sign of operand } return y+1.0; } if (d < 0.5) { return y; } long z = (long) y; return (z & 1) == 0 ? y : y + 1.0; }"
      },
      {
        "txt": "public static long round(double x) { return (long) floor(x + 0.5); } public static int round(final float x) { return (int) floor(x + 0.5f); } public static int min(final int a, final int b) { return (a <= b) ? a : b; } public static long min(final long a, final long b) {"
      },
      {
        "txt": "return (a <= b) ? a : b; } public static float min(final float a, final float b) { if (a > b) { return b; } if (a < b) { return a; } if (a != b) {"
      },
      {
        "txt": "return Float.NaN; } int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return a; } return b; } public static double min(final double a, final double b) { if (a > b) {"
      },
      {
        "txt": "return b; } if (a < b) { return a; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) {"
      },
      {
        "txt": "return a; } return b; } public static int max(final int a, final int b) { return (a <= b) ? b : a; } public static long max(final long a, final long b) { return (a <= b) ? b : a; }"
      },
      {
        "txt": "public static float max(final float a, final float b) { if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Float.NaN; }"
      },
      {
        "txt": "int bits = Float.floatToRawIntBits(a); if (bits == 0x80000000) { return b; } return a; } public static double max(final double a, final double b) { if (a > b) { return a; }"
      },
      {
        "txt": "if (a < b) { return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; }"
      },
      {
        "txt": "return a; } public static double hypot(final double x, final double y) { if (Double.isInfinite(x) || Double.isInfinite(y)) { return Double.POSITIVE_INFINITY; } else if (Double.isNaN(x) || Double.isNaN(y)) { return Double.NaN; } else { final int expX = getExponent(x); final int expY = getExponent(y);"
      },
      {
        "txt": "if (expX > expY + 27) { return abs(x); } else if (expY > expX + 27) { return abs(y); } else { final int middleExp = (expX + expY) / 2; final double scaledX = scalb(x, -middleExp); final double scaledY = scalb(y, -middleExp); final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); return scalb(scaledH, middleExp);"
      },
      {
        "txt": "} } } public static double IEEEremainder(double dividend, double divisor) { return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation } public static double copySign(double magnitude, double sign){ long m = Double.doubleToLongBits(magnitude); long s = Double.doubleToLongBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK"
      },
      {
        "txt": "return magnitude; } return -magnitude; // flip sign } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK return magnitude; }"
      },
      {
        "txt": "return -magnitude; // flip sign } public static int getExponent(final double d) { return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023; } public static int getExponent(final float f) { return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127; } public static void main(String[] a) { PrintStream out = System.out;"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT); FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A); FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B); FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A); FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B); FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);"
      },
      {
        "txt": "FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B); } private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN]; EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN]; final double tmp[] = new double[2];"
      },
      {
        "txt": "final double recip[] = new double[2]; for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) { FastMathCalc.expint(i, tmp); EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0]; EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1]; if (i != 0) { FastMathCalc.splitReciprocal(tmp, recip); EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0]; EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1]; }"
      },
      {
        "txt": "} } else { EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA(); EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB(); } } } private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B;"
      },
      {
        "txt": "static { if (RECOMPUTE_TABLES_AT_RUNTIME) { EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN]; EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN]; final double tmp[] = new double[2]; final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1); for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) { FastMathCalc.slowexp(i * factor, tmp); EXP_FRAC_TABLE_A[i] = tmp[0]; EXP_FRAC_TABLE_B[i] = tmp[1];"
      },
      {
        "txt": "} } else { EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA(); EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB(); } } } private static class lnMant { private static final double[][] LN_MANT; static {"
      },
      {
        "txt": "if (RECOMPUTE_TABLES_AT_RUNTIME) { LN_MANT = new double[FastMath.LN_MANT_LEN][]; for (int i = 0; i < LN_MANT.length; i++) { final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L ); LN_MANT[i] = FastMathCalc.slowLog(d); } } else { LN_MANT = FastMathLiteralArrays.loadLnMant(); } }"
      },
      {
        "txt": "} private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) { int k = (int)(xa * 0.6366197723675814); double remA; double remB;"
      },
      {
        "txt": "while (true) { double a = -k * 1.570796251296997; remA = xa + a; remB = -(remA - xa - a); a = -k * 7.549789948768648E-8; double b = remA; remA = a + b; remB += -(remA - b - a); a = -k * 6.123233995736766E-17; b = remA;"
      },
      {
        "txt": "remA = a + b; remB += -(remA - b - a); if (remA > 0) { break; } --k; } this.finalK = k; this.finalRemA = remA; this.finalRemB = remB;"
      },
      {
        "txt": "} int getK() { return finalK; } double getRemA() { return finalRemA; } double getRemB() { return finalRemB; }"
      }
    ]
  }
]