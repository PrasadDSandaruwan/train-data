[
  {
    "id": 2504,
    "file_path": "src/main/java/org/apache/commons/math3/dfp/Dfp.java",
    "start-bug-line": 1603,
    "end-bug-line": 1603,
    "bug": "",
    "fix": "if (x >= 0 && x < RADIX) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.dfp; import java.util.Arrays; import org.apache.commons.math3.FieldElement; public class Dfp implements FieldElement<Dfp> {"
      },
      {
        "txt": "public static final int RADIX = 10000; public static final int MIN_EXP = -32767; public static final int MAX_EXP = 32768; public static final int ERR_SCALE = 32760; public static final byte FINITE = 0; public static final byte INFINITE = 1; public static final byte SNAN = 2; public static final byte QNAN = 3; private static final String NAN_STRING = \"NaN\"; private static final String POS_INFINITY_STRING = \"Infinity\";"
      },
      {
        "txt": "private static final String NEG_INFINITY_STRING = \"-Infinity\"; private static final String ADD_TRAP = \"add\"; private static final String MULTIPLY_TRAP = \"multiply\"; private static final String DIVIDE_TRAP = \"divide\"; private static final String SQRT_TRAP = \"sqrt\"; private static final String ALIGN_TRAP = \"align\"; private static final String TRUNC_TRAP = \"trunc\"; private static final String NEXT_AFTER_TRAP = \"nextAfter\"; private static final String LESS_THAN_TRAP = \"lessThan\"; private static final String GREATER_THAN_TRAP = \"greaterThan\";"
      },
      {
        "txt": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"; protected int[] mant; protected byte sign; protected int exp; protected byte nans; private final DfpField field; protected Dfp(final DfpField field) { mant = new int[field.getRadixDigits()]; sign = 1; exp = 0;"
      },
      {
        "txt": "nans = FINITE; this.field = field; } protected Dfp(final DfpField field, byte x) { this(field, (long) x); } protected Dfp(final DfpField field, int x) { this(field, (long) x); } protected Dfp(final DfpField field, long x) {"
      },
      {
        "txt": "mant = new int[field.getRadixDigits()]; nans = FINITE; this.field = field; boolean isLongMin = false; if (x == Long.MIN_VALUE) { isLongMin = true; ++x; } if (x < 0) { sign = -1;"
      },
      {
        "txt": "x = -x; } else { sign = 1; } exp = 0; while (x != 0) { System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp); mant[mant.length - 1] = (int) (x % RADIX); x /= RADIX; exp++;"
      },
      {
        "txt": "} if (isLongMin) { for (int i = 0; i < mant.length - 1; i++) { if (mant[i] != 0) { mant[i]++; break; } } } }"
      },
      {
        "txt": "protected Dfp(final DfpField field, double x) { mant = new int[field.getRadixDigits()]; sign = 1; exp = 0; nans = FINITE; this.field = field; long bits = Double.doubleToLongBits(x); long mantissa = bits & 0x000fffffffffffffL; int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023; if (exponent == -1023) {"
      },
      {
        "txt": "if (x == 0) { if ((bits & 0x8000000000000000L) != 0) { sign = -1; } return; } exponent++; while ( (mantissa & 0x0010000000000000L) == 0) { exponent--; mantissa <<= 1;"
      },
      {
        "txt": "} mantissa &= 0x000fffffffffffffL; } if (exponent == 1024) { if (x != x) { sign = (byte) 1; nans = QNAN; } else if (x < 0) { sign = (byte) -1; nans = INFINITE;"
      },
      {
        "txt": "} else { sign = (byte) 1; nans = INFINITE; } return; } Dfp xdfp = new Dfp(field, mantissa); xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne()); // Divide by 2^52, then add one xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent)); if ((bits & 0x8000000000000000L) != 0) {"
      },
      {
        "txt": "xdfp = xdfp.negate(); } System.arraycopy(xdfp.mant, 0, mant, 0, mant.length); sign = xdfp.sign; exp = xdfp.exp; nans = xdfp.nans; } public Dfp(final Dfp d) { mant = d.mant.clone(); sign = d.sign;"
      },
      {
        "txt": "exp = d.exp; nans = d.nans; field = d.field; } protected Dfp(final DfpField field, final String s) { mant = new int[field.getRadixDigits()]; sign = 1; exp = 0; nans = FINITE; this.field = field;"
      },
      {
        "txt": "boolean decimalFound = false; final int rsize = 4; // size of radix in decimal digits final int offset = 4; // Starting offset into Striped final char[] striped = new char[getRadixDigits() * rsize + offset * 2]; if (s.equals(POS_INFINITY_STRING)) { sign = (byte) 1; nans = INFINITE; return; } if (s.equals(NEG_INFINITY_STRING)) {"
      },
      {
        "txt": "sign = (byte) -1; nans = INFINITE; return; } if (s.equals(NAN_STRING)) { sign = (byte) 1; nans = QNAN; return; } int p = s.indexOf(\"e\");"
      },
      {
        "txt": "if (p == -1) { // try upper case? p = s.indexOf(\"E\"); } final String fpdecimal; int sciexp = 0; if (p != -1) { fpdecimal = s.substring(0, p); String fpexp = s.substring(p+1); boolean negative = false; for (int i=0; i<fpexp.length(); i++)"
      },
      {
        "txt": "{ if (fpexp.charAt(i) == '-') { negative = true; continue; } if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9') { sciexp = sciexp * 10 + fpexp.charAt(i) - '0'; } }"
      },
      {
        "txt": "if (negative) { sciexp = -sciexp; } } else { fpdecimal = s; } if (fpdecimal.indexOf(\"-\") != -1) { sign = -1; } p = 0;"
      },
      {
        "txt": "int decimalPos = 0; for (;;) { if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') { break; } if (decimalFound && fpdecimal.charAt(p) == '0') { decimalPos--; } if (fpdecimal.charAt(p) == '.') { decimalFound = true;"
      },
      {
        "txt": "} p++; if (p == fpdecimal.length()) { break; } } int q = offset; striped[0] = '0'; striped[1] = '0'; striped[2] = '0';"
      },
      {
        "txt": "striped[3] = '0'; int significantDigits=0; for(;;) { if (p == (fpdecimal.length())) { break; } if (q == mant.length*rsize+offset+1) { break; } if (fpdecimal.charAt(p) == '.') {"
      },
      {
        "txt": "decimalFound = true; decimalPos = significantDigits; p++; continue; } if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') { p++; continue; } striped[q] = fpdecimal.charAt(p);"
      },
      {
        "txt": "q++; p++; significantDigits++; } if (decimalFound && q != offset) { for (;;) { q--; if (q == offset) { break; }"
      },
      {
        "txt": "if (striped[q] == '0') { significantDigits--; } else { break; } } } if (decimalFound && significantDigits == 0) { decimalPos = 0; }"
      },
      {
        "txt": "if (!decimalFound) { decimalPos = q-offset; } q = offset; // set q to point to first sig digit p = significantDigits-1+offset; while (p > q) { if (striped[p] != '0') { break; } p--;"
      },
      {
        "txt": "} int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize; q -= i; decimalPos += i; while ((p - q) < (mant.length * rsize)) { for (i = 0; i < rsize; i++) { striped[++p] = '0'; } } for (i = mant.length - 1; i >= 0; i--) {"
      },
      {
        "txt": "mant[i] = (striped[q] - '0') * 1000 + (striped[q+1] - '0') * 100 + (striped[q+2] - '0') * 10 + (striped[q+3] - '0'); q += 4; } exp = (decimalPos+sciexp) / rsize; if (q < striped.length) { round((striped[q] - '0')*1000); }"
      },
      {
        "txt": "} protected Dfp(final DfpField field, final byte sign, final byte nans) { this.field = field; this.mant = new int[field.getRadixDigits()]; this.sign = sign; this.exp = 0; this.nans = nans; } public Dfp newInstance() { return new Dfp(getField());"
      },
      {
        "txt": "} public Dfp newInstance(final byte x) { return new Dfp(getField(), x); } public Dfp newInstance(final int x) { return new Dfp(getField(), x); } public Dfp newInstance(final long x) { return new Dfp(getField(), x); }"
      },
      {
        "txt": "public Dfp newInstance(final double x) { return new Dfp(getField(), x); } public Dfp newInstance(final Dfp d) { if (field.getRadixDigits() != d.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result); }"
      },
      {
        "txt": "return new Dfp(d); } public Dfp newInstance(final String s) { return new Dfp(field, s); } public Dfp newInstance(final byte sig, final byte code) { return field.newDfp(sig, code); } public DfpField getField() { return field;"
      },
      {
        "txt": "} public int getRadixDigits() { return field.getRadixDigits(); } public Dfp getZero() { return field.getZero(); } public Dfp getOne() { return field.getOne(); }"
      },
      {
        "txt": "public Dfp getTwo() { return field.getTwo(); } protected void shiftLeft() { for (int i = mant.length - 1; i > 0; i--) { mant[i] = mant[i-1]; } mant[0] = 0; exp--; }"
      },
      {
        "txt": "uses shiftRight() */ protected void shiftRight() { for (int i = 0; i < mant.length - 1; i++) { mant[i] = mant[i+1]; } mant[mant.length - 1] = 0; exp++; } protected int align(int e) { int lostdigit = 0;"
      },
      {
        "txt": "boolean inexact = false; int diff = exp - e; int adiff = diff; if (adiff < 0) { adiff = -adiff; } if (diff == 0) { return 0; } if (adiff > (mant.length + 1)) {"
      },
      {
        "txt": "Arrays.fill(mant, 0); exp = e; field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this); return 0; } for (int i = 0; i < adiff; i++) { if (diff < 0) { if (lostdigit != 0) { inexact = true;"
      },
      {
        "txt": "} lostdigit = mant[0]; shiftRight(); } else { shiftLeft(); } } if (inexact) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);"
      },
      {
        "txt": "} return lostdigit; } public boolean lessThan(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result); return false;"
      },
      {
        "txt": "} if (isNaN() || x.isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero())); return false; } return compare(this, x) < 0; } public boolean greaterThan(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) {"
      },
      {
        "txt": "field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result); return false; } if (isNaN() || x.isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero())); return false;"
      },
      {
        "txt": "} return compare(this, x) > 0; } public boolean negativeOrNull() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false; } return (sign < 0) || ((mant[mant.length - 1] == 0) && !isInfinite());"
      },
      {
        "txt": "} public boolean strictlyNegative() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false; } return (sign < 0) && ((mant[mant.length - 1] != 0) || isInfinite()); } public boolean positiveOrNull() {"
      },
      {
        "txt": "if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false; } return (sign > 0) || ((mant[mant.length - 1] == 0) && !isInfinite()); } public boolean strictlyPositive() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID);"
      },
      {
        "txt": "dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false; } return (sign > 0) && ((mant[mant.length - 1] != 0) || isInfinite()); } public Dfp abs() { Dfp result = newInstance(this); result.sign = 1; return result; }"
      },
      {
        "txt": "public boolean isInfinite() { return nans == INFINITE; } public boolean isNaN() { return (nans == QNAN) || (nans == SNAN); } public boolean isZero() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));"
      },
      {
        "txt": "return false; } return (mant[mant.length - 1] == 0) && !isInfinite(); } @Override public boolean equals(final Object other) { if (other instanceof Dfp) { final Dfp x = (Dfp) other; if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) { return false;"
      },
      {
        "txt": "} return compare(this, x) == 0; } return false; } @Override public int hashCode() { return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant); } public boolean unequal(final Dfp x) {"
      },
      {
        "txt": "if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) { return false; } return greaterThan(x) || lessThan(x); } private static int compare(final Dfp a, final Dfp b) { if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 && a.nans == FINITE && b.nans == FINITE) { return 0; }"
      },
      {
        "txt": "if (a.sign != b.sign) { if (a.sign == -1) { return -1; } else { return 1; } } if (a.nans == INFINITE && b.nans == FINITE) { return a.sign; }"
      },
      {
        "txt": "if (a.nans == FINITE && b.nans == INFINITE) { return -b.sign; } if (a.nans == INFINITE && b.nans == INFINITE) { return 0; } if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) { if (a.exp < b.exp) { return -a.sign; }"
      },
      {
        "txt": "if (a.exp > b.exp) { return a.sign; } } for (int i = a.mant.length - 1; i >= 0; i--) { if (a.mant[i] > b.mant[i]) { return a.sign; } if (a.mant[i] < b.mant[i]) { return -a.sign;"
      },
      {
        "txt": "} } return 0; } public Dfp rint() { return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN); } public Dfp floor() { return trunc(DfpField.RoundingMode.ROUND_FLOOR); }"
      },
      {
        "txt": "public Dfp ceil() { return trunc(DfpField.RoundingMode.ROUND_CEIL); } public Dfp remainder(final Dfp d) { final Dfp result = this.subtract(this.divide(d).rint().multiply(d)); if (result.mant[mant.length-1] == 0) { result.sign = sign; } return result; }"
      },
      {
        "txt": "protected Dfp trunc(final DfpField.RoundingMode rmode) { boolean changed = false; if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length-1] == 0) { return newInstance(this);"
      },
      {
        "txt": "} if (exp < 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } if (exp >= mant.length) { return newInstance(this); }"
      },
      {
        "txt": "Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) { result = result.add(newInstance(-1));"
      },
      {
        "txt": "} break; case ROUND_CEIL: if (result.sign == 1) { result = result.add(getOne()); } break; case ROUND_HALF_EVEN: default: final Dfp half = newInstance(\"0.5\");"
      },
      {
        "txt": "Dfp a = subtract(result); // difference between this and result a.sign = 1; // force positive (take abs) if (a.greaterThan(half)) { a = newInstance(getOne()); a.sign = sign; result = result.add(a); } if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) { a = newInstance(getOne()); a.sign = sign;"
      },
      {
        "txt": "result = result.add(a); } break; } field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); // signal inexact result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } return result; }"
      },
      {
        "txt": "public int intValue() { Dfp rounded; int result = 0; rounded = rint(); if (rounded.greaterThan(newInstance(2147483647))) { return 2147483647; } if (rounded.lessThan(newInstance(-2147483648))) { return -2147483648; }"
      },
      {
        "txt": "for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) { result = result * RADIX + rounded.mant[i]; } if (rounded.sign == -1) { result = -result; } return result; } public int log10K() { return exp - 1;"
      },
      {
        "txt": "} public Dfp power10K(final int e) { Dfp d = newInstance(getOne()); d.exp = e + 1; return d; } public int log10() { if (mant[mant.length-1] > 1000) { return exp * 4 - 1; }"
      },
      {
        "txt": "if (mant[mant.length-1] > 100) { return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } return exp * 4 - 4; } public Dfp power10(final int e) { Dfp d = newInstance(getOne());"
      },
      {
        "txt": "if (e >= 0) { d.exp = e / 4 + 1; } else { d.exp = (e + 1) / 4; } switch ((e % 4 + 4) % 4) { case 0: break; case 1: d = d.multiply(10);"
      },
      {
        "txt": "break; case 2: d = d.multiply(100); break; default: d = d.multiply(1000); } return d; } protected int complement(int extra) {"
      },
      {
        "txt": "extra = RADIX-extra; for (int i = 0; i < mant.length; i++) { mant[i] = RADIX-mant[i]-1; } int rh = extra / RADIX; extra = extra - rh * RADIX; for (int i = 0; i < mant.length; i++) { final int r = mant[i] + rh; rh = r / RADIX; mant[i] = r - rh * RADIX;"
      },
      {
        "txt": "} return extra; } public Dfp add(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result); }"
      },
      {
        "txt": "if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; } if (x.isNaN()) { return x; } if (nans == INFINITE && x.nans == FINITE) { return this; }"
      },
      {
        "txt": "if (x.nans == INFINITE && nans == FINITE) { return x; } if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) { return x; } if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); Dfp result = newInstance(getZero()); result.nans = QNAN;"
      },
      {
        "txt": "result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result); return result; } } Dfp a = newInstance(this); Dfp b = newInstance(x); Dfp result = newInstance(getZero()); final byte asign = a.sign; final byte bsign = b.sign; a.sign = 1;"
      },
      {
        "txt": "b.sign = 1; byte rsign = bsign; if (compare(a, b) > 0) { rsign = asign; } of the zero number equal to the other one. This avoids an alignment which would cause catastropic loss of precision */ if (b.mant[mant.length-1] == 0) { b.exp = a.exp; }"
      },
      {
        "txt": "if (a.mant[mant.length-1] == 0) { a.exp = b.exp; } int aextradigit = 0; int bextradigit = 0; if (a.exp < b.exp) { aextradigit = a.align(b.exp); } else { bextradigit = b.align(a.exp); }"
      },
      {
        "txt": "if (asign != bsign) { if (asign == rsign) { bextradigit = b.complement(bextradigit); } else { aextradigit = a.complement(aextradigit); } } int rh = 0; /* acts as a carry */ for (int i = 0; i < mant.length; i++) { final int r = a.mant[i]+b.mant[i]+rh;"
      },
      {
        "txt": "rh = r / RADIX; result.mant[i] = r - rh * RADIX; } result.exp = a.exp; result.sign = rsign; if (rh != 0 && (asign == bsign)) { final int lostdigit = result.mant[0]; result.shiftRight(); result.mant[mant.length-1] = rh; final int excp = result.round(lostdigit);"
      },
      {
        "txt": "if (excp != 0) { result = dotrap(excp, ADD_TRAP, x, result); } } for (int i = 0; i < mant.length; i++) { if (result.mant[mant.length-1] != 0) { break; } result.shiftLeft(); if (i == 0) {"
      },
      {
        "txt": "result.mant[0] = aextradigit+bextradigit; aextradigit = 0; bextradigit = 0; } } if (result.mant[mant.length-1] == 0) { result.exp = 0; if (asign != bsign) { result.sign = 1; // Per IEEE 854-1987 Section 6.3 }"
      },
      {
        "txt": "} final int excp = result.round(aextradigit + bextradigit); if (excp != 0) { result = dotrap(excp, ADD_TRAP, x, result); } return result; } public Dfp negate() { Dfp result = newInstance(this); result.sign = (byte) - result.sign;"
      },
      {
        "txt": "return result; } public Dfp subtract(final Dfp x) { return add(x.negate()); } protected int round(int n) { boolean inc = false; switch (field.getRoundingMode()) { case ROUND_DOWN: inc = false;"
      },
      {
        "txt": "break; case ROUND_UP: inc = n != 0; // round up if n!=0 break; case ROUND_HALF_UP: inc = n >= 5000; // round half up break; case ROUND_HALF_DOWN: inc = n > 5000; // round half down break;"
      },
      {
        "txt": "case ROUND_HALF_EVEN: inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1); // round half-even break; case ROUND_HALF_ODD: inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0); // round half-odd break; case ROUND_CEIL: inc = sign == 1 && n != 0; // round ceil break; case ROUND_FLOOR:"
      },
      {
        "txt": "default: inc = sign == -1 && n != 0; // round floor break; } if (inc) { int rh = 1; for (int i = 0; i < mant.length; i++) { final int r = mant[i] + rh; rh = r / RADIX; mant[i] = r - rh * RADIX;"
      },
      {
        "txt": "} if (rh != 0) { shiftRight(); mant[mant.length-1] = rh; } } if (exp < MIN_EXP) { field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW); return DfpField.FLAG_UNDERFLOW; }"
      },
      {
        "txt": "if (exp > MAX_EXP) { field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW); return DfpField.FLAG_OVERFLOW; } if (n != 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; } return 0; }"
      },
      {
        "txt": "public Dfp multiply(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); } Dfp result = newInstance(getZero()); if (nans != FINITE || x.nans != FINITE) { if (isNaN()) {"
      },
      {
        "txt": "return this; } if (x.isNaN()) { return x; } if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }"
      },
      {
        "txt": "if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) { result = newInstance(x); result.sign = (byte) (sign * x.sign); return result; } if (x.nans == INFINITE && nans == INFINITE) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }"
      },
      {
        "txt": "if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) || (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; } } int[] product = new int[mant.length*2]; // Big enough to hold even the largest result"
      },
      {
        "txt": "for (int i = 0; i < mant.length; i++) { int rh = 0; // acts as a carry for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j]; // multiply the 2 digits r = r + product[i+j] + rh; // add to the product digit with carry in rh = r / RADIX; product[i+j] = r - rh * RADIX; } product[i+mant.length] = rh; }"
      },
      {
        "txt": "int md = mant.length * 2 - 1; // default, in case result is zero for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { md = i; break; } } for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = product[md - i]; }"
      },
      {
        "txt": "result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1); if (result.mant[mant.length-1] == 0) { result.exp = 0; } final int excp; if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else { excp = result.round(0); // has no effect except to check status"
      },
      {
        "txt": "if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, x, result); } return result; } public Dfp multiply(final int x) { <extra_id_0> } private Dfp multiplyFast(final int x) { Dfp result = newInstance(this); if (nans != FINITE) { if (isNaN()) { return this;"
      },
      {
        "txt": "if (isNaN()) { return this; } if (nans == INFINITE && x != 0) { result = newInstance(this); return result; } if (nans == INFINITE && x == 0) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero());"
      },
      {
        "txt": "result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result); return result; } } if (x < 0 || x >= RADIX) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);"
      },
      {
        "txt": "return result; } int rh = 0; for (int i = 0; i < mant.length; i++) { final int r = mant[i] * x + rh; rh = r / RADIX; result.mant[i] = r - rh * RADIX; } int lostdigit = 0; if (rh != 0) {"
      },
      {
        "txt": "lostdigit = result.mant[0]; result.shiftRight(); result.mant[mant.length-1] = rh; } if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero result.exp = 0; } final int excp = result.round(lostdigit); if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, result, result);"
      },
      {
        "txt": "} return result; } public Dfp divide(Dfp divisor) { int dividend[]; // current status of the dividend int quotient[]; // quotient int remainder[];// remainder int qd; // current quotient digit we're working with int nsqd; // number of significant quotient digits we have int trial=0; // trial quotient digit"
      },
      {
        "txt": "int minadj; // minimum adjustment boolean trialgood; // Flag to indicate a good trail digit int md=0; // most sig digit in result int excp; // exceptions if (field.getRadixDigits() != divisor.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); }"
      },
      {
        "txt": "Dfp result = newInstance(getZero()); if (nans != FINITE || divisor.nans != FINITE) { if (isNaN()) { return this; } if (divisor.isNaN()) { return divisor; } if (nans == INFINITE && divisor.nans == FINITE) { result = newInstance(this);"
      },
      {
        "txt": "result.sign = (byte) (sign * divisor.sign); return result; } if (divisor.nans == INFINITE && nans == FINITE) { result = newInstance(getZero()); result.sign = (byte) (sign * divisor.sign); return result; } if (divisor.nans == INFINITE && nans == INFINITE) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID);"
      },
      {
        "txt": "result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); return result; } } if (divisor.mant[mant.length-1] == 0) { field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO); result = newInstance(getZero()); result.sign = (byte) (sign * divisor.sign);"
      },
      {
        "txt": "result.nans = INFINITE; result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result); return result; } dividend = new int[mant.length+1]; // one extra digit needed quotient = new int[mant.length+2]; // two extra digits needed 1 for overflow, 1 for rounding remainder = new int[mant.length+1]; // one extra digit needed dividend[mant.length] = 0; quotient[mant.length] = 0; quotient[mant.length+1] = 0;"
      },
      {
        "txt": "remainder[mant.length] = 0; quotient while we are at it */ for (int i = 0; i < mant.length; i++) { dividend[i] = mant[i]; quotient[i] = 0; remainder[i] = 0; } nsqd = 0; for (qd = mant.length+1; qd >= 0; qd--) { final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];"
      },
      {
        "txt": "int min = divMsb / (divisor.mant[mant.length-1]+1); int max = (divMsb + 1) / divisor.mant[mant.length-1]; trialgood = false; while (!trialgood) { trial = (min+max)/2; int rh = 0; for (int i = 0; i < mant.length + 1; i++) { int dm = (i<mant.length)?divisor.mant[i]:0; final int r = (dm * trial) + rh; rh = r / RADIX;"
      },
      {
        "txt": "remainder[i] = r - rh * RADIX; } rh = 1; // carry in to aid the subtraction for (int i = 0; i < mant.length + 1; i++) { final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh; rh = r / RADIX; remainder[i] = r - rh * RADIX; } if (rh == 0) { max = trial-1;"
      },
      {
        "txt": "continue; } minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1]; minadj = minadj / (divisor.mant[mant.length-1]+1); if (minadj >= 2) { min = trial+minadj; // update the minimum continue; } its a good one if it is less than the divisor */ trialgood = false; // assume false"
      },
      {
        "txt": "for (int i = mant.length - 1; i >= 0; i--) { if (divisor.mant[i] > remainder[i]) { trialgood = true; } if (divisor.mant[i] < remainder[i]) { break; } } if (remainder[mant.length] != 0) { trialgood = false;"
      },
      {
        "txt": "} if (trialgood == false) { min = trial+1; } } quotient[qd] = trial; if (trial != 0 || nsqd != 0) { nsqd++; } if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {"
      },
      {
        "txt": "break; } if (nsqd > mant.length) { break; } dividend[0] = 0; for (int i = 0; i < mant.length; i++) { dividend[i + 1] = remainder[i]; } }"
      },
      {
        "txt": "md = mant.length; // default for (int i = mant.length + 1; i >= 0; i--) { if (quotient[i] != 0) { md = i; break; } } for (int i=0; i<mant.length; i++) { result.mant[mant.length-i-1] = quotient[md-i]; }"
      },
      {
        "txt": "result.exp = exp - divisor.exp + md - mant.length; result.sign = (byte) ((sign == divisor.sign) ? 1 : -1); if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero result.exp = 0; } if (md > (mant.length-1)) { excp = result.round(quotient[md-mant.length]); } else { excp = result.round(0); }"
      },
      {
        "txt": "if (excp != 0) { result = dotrap(excp, DIVIDE_TRAP, divisor, result); } return result; } public Dfp divide(int divisor) { if (nans != FINITE) { if (isNaN()) { return this; }"
      },
      {
        "txt": "if (nans == INFINITE) { return newInstance(this); } } if (divisor == 0) { field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO); Dfp result = newInstance(getZero()); result.sign = sign; result.nans = INFINITE; result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);"
      },
      {
        "txt": "return result; } if (divisor < 0 || divisor >= RADIX) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); Dfp result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result); return result; } Dfp result = newInstance(this);"
      },
      {
        "txt": "int rl = 0; for (int i = mant.length-1; i >= 0; i--) { final int r = rl*RADIX + result.mant[i]; final int rh = r / divisor; rl = r - rh * divisor; result.mant[i] = rh; } if (result.mant[mant.length-1] == 0) { result.shiftLeft(); final int r = rl * RADIX; // compute the next digit and put it in"
      },
      {
        "txt": "final int rh = r / divisor; rl = r - rh * divisor; result.mant[0] = rh; } final int excp = result.round(rl * RADIX / divisor); // do the rounding if (excp != 0) { result = dotrap(excp, DIVIDE_TRAP, result, result); } return result; }"
      },
      {
        "txt": "public Dfp reciprocal() { return field.getOne().divide(this); } public Dfp sqrt() { if (nans == FINITE && mant[mant.length-1] == 0) { return newInstance(this); } if (nans != FINITE) { if (nans == INFINITE && sign == 1) { return newInstance(this);"
      },
      {
        "txt": "} if (nans == QNAN) { return newInstance(this); } if (nans == SNAN) { Dfp result; field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(this); result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result); return result;"
      },
      {
        "txt": "} } if (sign == -1) { Dfp result; field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(this); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result); return result; }"
      },
      {
        "txt": "Dfp x = newInstance(this); if (x.exp < -1 || x.exp > 1) { x.exp = this.exp / 2; } switch (x.mant[mant.length-1] / 2000) { case 0: x.mant[mant.length-1] = x.mant[mant.length-1]/2+1; break; case 2: x.mant[mant.length-1] = 1500;"
      },
      {
        "txt": "break; case 3: x.mant[mant.length-1] = 2200; break; default: x.mant[mant.length-1] = 3000; } Dfp dx = newInstance(x); by the formula dx = (y - x*x) / (2x); */ Dfp px = getZero();"
      },
      {
        "txt": "Dfp ppx = getZero(); while (x.unequal(px)) { dx = newInstance(x); dx.sign = -1; dx = dx.add(this.divide(x)); dx = dx.divide(2); ppx = px; px = x; x = x.add(dx); if (x.equals(ppx)) {"
      },
      {
        "txt": "break; } if (dx.mant[mant.length-1] == 0) { break; } } return x; } @Override public String toString() {"
      },
      {
        "txt": "if (nans != FINITE) { if (nans == INFINITE) { return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING; } else { return NAN_STRING; } } if (exp > mant.length || exp < -1) { return dfp2sci(); }"
      },
      {
        "txt": "return dfp2string(); } protected String dfp2sci() { char rawdigits[] = new char[mant.length * 4]; char outputbuffer[] = new char[mant.length * 4 + 20]; int p; int q; int e; int ae; int shf;"
      },
      {
        "txt": "p = 0; for (int i = mant.length - 1; i >= 0; i--) { rawdigits[p++] = (char) ((mant[i] / 1000) + '0'); rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0'); rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0'); rawdigits[p++] = (char) (((mant[i]) % 10) + '0'); } for (p = 0; p < rawdigits.length; p++) { if (rawdigits[p] != '0') { break;"
      },
      {
        "txt": "} } shf = p; q = 0; if (sign == -1) { outputbuffer[q++] = '-'; } if (p != rawdigits.length) { outputbuffer[q++] = rawdigits[p++]; outputbuffer[q++] = '.';"
      },
      {
        "txt": "while (p<rawdigits.length) { outputbuffer[q++] = rawdigits[p++]; } } else { outputbuffer[q++] = '0'; outputbuffer[q++] = '.'; outputbuffer[q++] = '0'; outputbuffer[q++] = 'e'; outputbuffer[q++] = '0'; return new String(outputbuffer, 0, 5);"
      },
      {
        "txt": "} outputbuffer[q++] = 'e'; e = exp * 4 - shf - 1; ae = e; if (e < 0) { ae = -e; } for (p = 1000000000; p > ae; p /= 10) { } if (e < 0) {"
      },
      {
        "txt": "outputbuffer[q++] = '-'; } while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; } return new String(outputbuffer, 0, q); } protected String dfp2string() {"
      },
      {
        "txt": "char buffer[] = new char[mant.length*4 + 20]; int p = 1; int q; int e = exp; boolean pointInserted = false; buffer[0] = ' '; if (e <= 0) { buffer[p++] = '0'; buffer[p++] = '.'; pointInserted = true;"
      },
      {
        "txt": "} while (e < 0) { buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e++; } for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0');"
      },
      {
        "txt": "buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) { buffer[p++] = '.'; pointInserted = true; } } while (e > 0) { buffer[p++] = '0';"
      },
      {
        "txt": "buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e--; } if (!pointInserted) { buffer[p++] = '.'; } q = 1; while (buffer[q] == '0') {"
      },
      {
        "txt": "q++; } if (buffer[q] == '.') { q--; } while (buffer[p-1] == '0') { p--; } if (sign < 0) { buffer[--q] = '-';"
      },
      {
        "txt": "} return new String(buffer, q, p - q); } public Dfp dotrap(int type, String what, Dfp oper, Dfp result) { Dfp def = result; switch (type) { case DfpField.FLAG_INVALID: def = newInstance(getZero()); def.sign = result.sign; def.nans = QNAN;"
      },
      {
        "txt": "break; case DfpField.FLAG_DIV_ZERO: if (nans == FINITE && mant[mant.length-1] != 0) { def = newInstance(getZero()); def.sign = (byte)(sign*oper.sign); def.nans = INFINITE; } if (nans == FINITE && mant[mant.length-1] == 0) { def = newInstance(getZero()); def.nans = QNAN;"
      },
      {
        "txt": "} if (nans == INFINITE || nans == QNAN) { def = newInstance(getZero()); def.nans = QNAN; } if (nans == INFINITE || nans == SNAN) { def = newInstance(getZero()); def.nans = QNAN; } break;"
      },
      {
        "txt": "case DfpField.FLAG_UNDERFLOW: if ( (result.exp+mant.length) < MIN_EXP) { def = newInstance(getZero()); def.sign = result.sign; } else { def = newInstance(result); // gradual underflow } result.exp = result.exp + ERR_SCALE; break; case DfpField.FLAG_OVERFLOW:"
      },
      {
        "txt": "result.exp = result.exp - ERR_SCALE; def = newInstance(getZero()); def.sign = result.sign; def.nans = INFINITE; break; default: def = result; break; } return trap(type, what, oper, def, result); } protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {"
      },
      {
        "txt": "return def; } public int classify() { return nans; } public static Dfp copysign(final Dfp x, final Dfp y) { Dfp result = x.newInstance(x); result.sign = y.sign; return result; }"
      },
      {
        "txt": "public Dfp nextAfter(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result); } boolean up = false; if (this.lessThan(x)) { up = true;"
      },
      {
        "txt": "} if (compare(this, x) == 0) { return newInstance(x); } if (lessThan(getZero())) { up = !up; } final Dfp inc; Dfp result; if (up) {"
      },
      {
        "txt": "inc = newInstance(getOne()); inc.exp = this.exp-mant.length+1; inc.sign = this.sign; if (this.equals(getZero())) { inc.exp = MIN_EXP-mant.length; } result = add(inc); } else { inc = newInstance(getOne()); inc.exp = this.exp;"
      },
      {
        "txt": "inc.sign = this.sign; if (this.equals(inc)) { inc.exp = this.exp-mant.length; } else { inc.exp = this.exp-mant.length+1; } if (this.equals(getZero())) { inc.exp = MIN_EXP-mant.length; } result = this.subtract(inc);"
      },
      {
        "txt": "} if (result.classify() == INFINITE && this.classify() != INFINITE) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } if (result.equals(getZero()) && this.equals(getZero()) == false) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } return result;"
      },
      {
        "txt": "} public double toDouble() { if (isInfinite()) { if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) {"
      },
      {
        "txt": "return Double.NaN; } Dfp y = this; boolean negate = false; int cmp0 = compare(this, getZero()); if (cmp0 == 0) { return sign < 0 ? -0.0 : +0.0; } else if (cmp0 < 0) { y = negate(); negate = true;"
      },
      {
        "txt": "} Should be faster than doing a natural logarithm. */ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++;"
      },
      {
        "txt": "} exponent--; y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) {"
      },
      {
        "txt": "return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; } y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) { mantissa = 0; exponent++; }"
      },
      {
        "txt": "if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) {"
      },
      {
        "txt": "x = -x; } return x; } public double[] toSplitDouble() { double split[] = new double[2]; long mask = 0xffffffffc0000000L; split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask); split[1] = subtract(newInstance(split[0])).toDouble(); return split;"
      }
    ]
  },
  {
    "id": 2505,
    "file_path": "src/main/java/org/apache/commons/math3/dfp/Dfp.java",
    "start-bug-line": 1604,
    "end-bug-line": 1604,
    "bug": "",
    "fix": "} else { return multiply(newInstance(x)); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.dfp; import java.util.Arrays; import org.apache.commons.math3.FieldElement; public class Dfp implements FieldElement<Dfp> { public static final int RADIX = 10000;"
      },
      {
        "txt": "public static final int MIN_EXP = -32767; public static final int MAX_EXP = 32768; public static final int ERR_SCALE = 32760; public static final byte FINITE = 0; public static final byte INFINITE = 1; public static final byte SNAN = 2; public static final byte QNAN = 3; private static final String NAN_STRING = \"NaN\"; private static final String POS_INFINITY_STRING = \"Infinity\"; private static final String NEG_INFINITY_STRING = \"-Infinity\";"
      },
      {
        "txt": "private static final String ADD_TRAP = \"add\"; private static final String MULTIPLY_TRAP = \"multiply\"; private static final String DIVIDE_TRAP = \"divide\"; private static final String SQRT_TRAP = \"sqrt\"; private static final String ALIGN_TRAP = \"align\"; private static final String TRUNC_TRAP = \"trunc\"; private static final String NEXT_AFTER_TRAP = \"nextAfter\"; private static final String LESS_THAN_TRAP = \"lessThan\"; private static final String GREATER_THAN_TRAP = \"greaterThan\"; private static final String NEW_INSTANCE_TRAP = \"newInstance\";"
      },
      {
        "txt": "protected int[] mant; protected byte sign; protected int exp; protected byte nans; private final DfpField field; protected Dfp(final DfpField field) { mant = new int[field.getRadixDigits()]; sign = 1; exp = 0; nans = FINITE;"
      },
      {
        "txt": "this.field = field; } protected Dfp(final DfpField field, byte x) { this(field, (long) x); } protected Dfp(final DfpField field, int x) { this(field, (long) x); } protected Dfp(final DfpField field, long x) { mant = new int[field.getRadixDigits()];"
      },
      {
        "txt": "nans = FINITE; this.field = field; boolean isLongMin = false; if (x == Long.MIN_VALUE) { isLongMin = true; ++x; } if (x < 0) { sign = -1; x = -x;"
      },
      {
        "txt": "} else { sign = 1; } exp = 0; while (x != 0) { System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp); mant[mant.length - 1] = (int) (x % RADIX); x /= RADIX; exp++; }"
      },
      {
        "txt": "if (isLongMin) { for (int i = 0; i < mant.length - 1; i++) { if (mant[i] != 0) { mant[i]++; break; } } } } protected Dfp(final DfpField field, double x) {"
      },
      {
        "txt": "mant = new int[field.getRadixDigits()]; sign = 1; exp = 0; nans = FINITE; this.field = field; long bits = Double.doubleToLongBits(x); long mantissa = bits & 0x000fffffffffffffL; int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023; if (exponent == -1023) { if (x == 0) {"
      },
      {
        "txt": "if ((bits & 0x8000000000000000L) != 0) { sign = -1; } return; } exponent++; while ( (mantissa & 0x0010000000000000L) == 0) { exponent--; mantissa <<= 1; }"
      },
      {
        "txt": "mantissa &= 0x000fffffffffffffL; } if (exponent == 1024) { if (x != x) { sign = (byte) 1; nans = QNAN; } else if (x < 0) { sign = (byte) -1; nans = INFINITE; } else {"
      },
      {
        "txt": "sign = (byte) 1; nans = INFINITE; } return; } Dfp xdfp = new Dfp(field, mantissa); xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne()); // Divide by 2^52, then add one xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent)); if ((bits & 0x8000000000000000L) != 0) { xdfp = xdfp.negate();"
      },
      {
        "txt": "} System.arraycopy(xdfp.mant, 0, mant, 0, mant.length); sign = xdfp.sign; exp = xdfp.exp; nans = xdfp.nans; } public Dfp(final Dfp d) { mant = d.mant.clone(); sign = d.sign; exp = d.exp;"
      },
      {
        "txt": "nans = d.nans; field = d.field; } protected Dfp(final DfpField field, final String s) { mant = new int[field.getRadixDigits()]; sign = 1; exp = 0; nans = FINITE; this.field = field; boolean decimalFound = false;"
      },
      {
        "txt": "final int rsize = 4; // size of radix in decimal digits final int offset = 4; // Starting offset into Striped final char[] striped = new char[getRadixDigits() * rsize + offset * 2]; if (s.equals(POS_INFINITY_STRING)) { sign = (byte) 1; nans = INFINITE; return; } if (s.equals(NEG_INFINITY_STRING)) { sign = (byte) -1;"
      },
      {
        "txt": "nans = INFINITE; return; } if (s.equals(NAN_STRING)) { sign = (byte) 1; nans = QNAN; return; } int p = s.indexOf(\"e\"); if (p == -1) { // try upper case?"
      },
      {
        "txt": "p = s.indexOf(\"E\"); } final String fpdecimal; int sciexp = 0; if (p != -1) { fpdecimal = s.substring(0, p); String fpexp = s.substring(p+1); boolean negative = false; for (int i=0; i<fpexp.length(); i++) {"
      },
      {
        "txt": "if (fpexp.charAt(i) == '-') { negative = true; continue; } if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9') { sciexp = sciexp * 10 + fpexp.charAt(i) - '0'; } } if (negative) {"
      },
      {
        "txt": "sciexp = -sciexp; } } else { fpdecimal = s; } if (fpdecimal.indexOf(\"-\") != -1) { sign = -1; } p = 0; int decimalPos = 0;"
      },
      {
        "txt": "for (;;) { if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') { break; } if (decimalFound && fpdecimal.charAt(p) == '0') { decimalPos--; } if (fpdecimal.charAt(p) == '.') { decimalFound = true; }"
      },
      {
        "txt": "p++; if (p == fpdecimal.length()) { break; } } int q = offset; striped[0] = '0'; striped[1] = '0'; striped[2] = '0'; striped[3] = '0';"
      },
      {
        "txt": "int significantDigits=0; for(;;) { if (p == (fpdecimal.length())) { break; } if (q == mant.length*rsize+offset+1) { break; } if (fpdecimal.charAt(p) == '.') { decimalFound = true;"
      },
      {
        "txt": "decimalPos = significantDigits; p++; continue; } if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') { p++; continue; } striped[q] = fpdecimal.charAt(p); q++;"
      },
      {
        "txt": "p++; significantDigits++; } if (decimalFound && q != offset) { for (;;) { q--; if (q == offset) { break; } if (striped[q] == '0') {"
      },
      {
        "txt": "significantDigits--; } else { break; } } } if (decimalFound && significantDigits == 0) { decimalPos = 0; } if (!decimalFound) {"
      },
      {
        "txt": "decimalPos = q-offset; } q = offset; // set q to point to first sig digit p = significantDigits-1+offset; while (p > q) { if (striped[p] != '0') { break; } p--; }"
      },
      {
        "txt": "int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize; q -= i; decimalPos += i; while ((p - q) < (mant.length * rsize)) { for (i = 0; i < rsize; i++) { striped[++p] = '0'; } } for (i = mant.length - 1; i >= 0; i--) { mant[i] = (striped[q] - '0') * 1000 +"
      },
      {
        "txt": "(striped[q+1] - '0') * 100 + (striped[q+2] - '0') * 10 + (striped[q+3] - '0'); q += 4; } exp = (decimalPos+sciexp) / rsize; if (q < striped.length) { round((striped[q] - '0')*1000); } }"
      },
      {
        "txt": "protected Dfp(final DfpField field, final byte sign, final byte nans) { this.field = field; this.mant = new int[field.getRadixDigits()]; this.sign = sign; this.exp = 0; this.nans = nans; } public Dfp newInstance() { return new Dfp(getField()); }"
      },
      {
        "txt": "public Dfp newInstance(final byte x) { return new Dfp(getField(), x); } public Dfp newInstance(final int x) { return new Dfp(getField(), x); } public Dfp newInstance(final long x) { return new Dfp(getField(), x); } public Dfp newInstance(final double x) {"
      },
      {
        "txt": "return new Dfp(getField(), x); } public Dfp newInstance(final Dfp d) { if (field.getRadixDigits() != d.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result); } return new Dfp(d);"
      },
      {
        "txt": "} public Dfp newInstance(final String s) { return new Dfp(field, s); } public Dfp newInstance(final byte sig, final byte code) { return field.newDfp(sig, code); } public DfpField getField() { return field; }"
      },
      {
        "txt": "public int getRadixDigits() { return field.getRadixDigits(); } public Dfp getZero() { return field.getZero(); } public Dfp getOne() { return field.getOne(); } public Dfp getTwo() {"
      },
      {
        "txt": "return field.getTwo(); } protected void shiftLeft() { for (int i = mant.length - 1; i > 0; i--) { mant[i] = mant[i-1]; } mant[0] = 0; exp--; } uses shiftRight() */"
      },
      {
        "txt": "protected void shiftRight() { for (int i = 0; i < mant.length - 1; i++) { mant[i] = mant[i+1]; } mant[mant.length - 1] = 0; exp++; } protected int align(int e) { int lostdigit = 0; boolean inexact = false;"
      },
      {
        "txt": "int diff = exp - e; int adiff = diff; if (adiff < 0) { adiff = -adiff; } if (diff == 0) { return 0; } if (adiff > (mant.length + 1)) { Arrays.fill(mant, 0);"
      },
      {
        "txt": "exp = e; field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this); return 0; } for (int i = 0; i < adiff; i++) { if (diff < 0) { if (lostdigit != 0) { inexact = true; }"
      },
      {
        "txt": "lostdigit = mant[0]; shiftRight(); } else { shiftLeft(); } } if (inexact) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this); }"
      },
      {
        "txt": "return lostdigit; } public boolean lessThan(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result); return false; }"
      },
      {
        "txt": "if (isNaN() || x.isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero())); return false; } return compare(this, x) < 0; } public boolean greaterThan(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID);"
      },
      {
        "txt": "final Dfp result = newInstance(getZero()); result.nans = QNAN; dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result); return false; } if (isNaN() || x.isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero())); return false; }"
      },
      {
        "txt": "return compare(this, x) > 0; } public boolean negativeOrNull() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false; } return (sign < 0) || ((mant[mant.length - 1] == 0) && !isInfinite()); }"
      },
      {
        "txt": "public boolean strictlyNegative() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false; } return (sign < 0) && ((mant[mant.length - 1] != 0) || isInfinite()); } public boolean positiveOrNull() { if (isNaN()) {"
      },
      {
        "txt": "field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false; } return (sign > 0) || ((mant[mant.length - 1] == 0) && !isInfinite()); } public boolean strictlyPositive() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));"
      },
      {
        "txt": "return false; } return (sign > 0) && ((mant[mant.length - 1] != 0) || isInfinite()); } public Dfp abs() { Dfp result = newInstance(this); result.sign = 1; return result; } public boolean isInfinite() {"
      },
      {
        "txt": "return nans == INFINITE; } public boolean isNaN() { return (nans == QNAN) || (nans == SNAN); } public boolean isZero() { if (isNaN()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); return false;"
      },
      {
        "txt": "} return (mant[mant.length - 1] == 0) && !isInfinite(); } @Override public boolean equals(final Object other) { if (other instanceof Dfp) { final Dfp x = (Dfp) other; if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) { return false; }"
      },
      {
        "txt": "return compare(this, x) == 0; } return false; } @Override public int hashCode() { return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant); } public boolean unequal(final Dfp x) { if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {"
      },
      {
        "txt": "return false; } return greaterThan(x) || lessThan(x); } private static int compare(final Dfp a, final Dfp b) { if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 && a.nans == FINITE && b.nans == FINITE) { return 0; } if (a.sign != b.sign) {"
      },
      {
        "txt": "if (a.sign == -1) { return -1; } else { return 1; } } if (a.nans == INFINITE && b.nans == FINITE) { return a.sign; } if (a.nans == FINITE && b.nans == INFINITE) {"
      },
      {
        "txt": "return -b.sign; } if (a.nans == INFINITE && b.nans == INFINITE) { return 0; } if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) { if (a.exp < b.exp) { return -a.sign; } if (a.exp > b.exp) {"
      },
      {
        "txt": "return a.sign; } } for (int i = a.mant.length - 1; i >= 0; i--) { if (a.mant[i] > b.mant[i]) { return a.sign; } if (a.mant[i] < b.mant[i]) { return -a.sign; }"
      },
      {
        "txt": "} return 0; } public Dfp rint() { return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN); } public Dfp floor() { return trunc(DfpField.RoundingMode.ROUND_FLOOR); } public Dfp ceil() {"
      },
      {
        "txt": "return trunc(DfpField.RoundingMode.ROUND_CEIL); } public Dfp remainder(final Dfp d) { final Dfp result = this.subtract(this.divide(d).rint().multiply(d)); if (result.mant[mant.length-1] == 0) { result.sign = sign; } return result; } protected Dfp trunc(final DfpField.RoundingMode rmode) {"
      },
      {
        "txt": "boolean changed = false; if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length-1] == 0) { return newInstance(this); }"
      },
      {
        "txt": "if (exp < 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } if (exp >= mant.length) { return newInstance(this); } Dfp result = newInstance(this);"
      },
      {
        "txt": "for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) { result = result.add(newInstance(-1)); }"
      },
      {
        "txt": "break; case ROUND_CEIL: if (result.sign == 1) { result = result.add(getOne()); } break; case ROUND_HALF_EVEN: default: final Dfp half = newInstance(\"0.5\"); Dfp a = subtract(result); // difference between this and result"
      },
      {
        "txt": "a.sign = 1; // force positive (take abs) if (a.greaterThan(half)) { a = newInstance(getOne()); a.sign = sign; result = result.add(a); } if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) { a = newInstance(getOne()); a.sign = sign; result = result.add(a);"
      },
      {
        "txt": "} break; } field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); // signal inexact result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } return result; } public int intValue() {"
      },
      {
        "txt": "Dfp rounded; int result = 0; rounded = rint(); if (rounded.greaterThan(newInstance(2147483647))) { return 2147483647; } if (rounded.lessThan(newInstance(-2147483648))) { return -2147483648; } for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {"
      },
      {
        "txt": "result = result * RADIX + rounded.mant[i]; } if (rounded.sign == -1) { result = -result; } return result; } public int log10K() { return exp - 1; }"
      },
      {
        "txt": "public Dfp power10K(final int e) { Dfp d = newInstance(getOne()); d.exp = e + 1; return d; } public int log10() { if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } if (mant[mant.length-1] > 100) {"
      },
      {
        "txt": "return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } return exp * 4 - 4; } public Dfp power10(final int e) { Dfp d = newInstance(getOne()); if (e >= 0) {"
      },
      {
        "txt": "d.exp = e / 4 + 1; } else { d.exp = (e + 1) / 4; } switch ((e % 4 + 4) % 4) { case 0: break; case 1: d = d.multiply(10); break;"
      },
      {
        "txt": "case 2: d = d.multiply(100); break; default: d = d.multiply(1000); } return d; } protected int complement(int extra) { extra = RADIX-extra;"
      },
      {
        "txt": "for (int i = 0; i < mant.length; i++) { mant[i] = RADIX-mant[i]-1; } int rh = extra / RADIX; extra = extra - rh * RADIX; for (int i = 0; i < mant.length; i++) { final int r = mant[i] + rh; rh = r / RADIX; mant[i] = r - rh * RADIX; }"
      },
      {
        "txt": "return extra; } public Dfp add(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result); } if (nans != FINITE || x.nans != FINITE) {"
      },
      {
        "txt": "if (isNaN()) { return this; } if (x.isNaN()) { return x; } if (nans == INFINITE && x.nans == FINITE) { return this; } if (x.nans == INFINITE && nans == FINITE) {"
      },
      {
        "txt": "return x; } if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) { return x; } if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); Dfp result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);"
      },
      {
        "txt": "return result; } } Dfp a = newInstance(this); Dfp b = newInstance(x); Dfp result = newInstance(getZero()); final byte asign = a.sign; final byte bsign = b.sign; a.sign = 1; b.sign = 1;"
      },
      {
        "txt": "byte rsign = bsign; if (compare(a, b) > 0) { rsign = asign; } of the zero number equal to the other one. This avoids an alignment which would cause catastropic loss of precision */ if (b.mant[mant.length-1] == 0) { b.exp = a.exp; } if (a.mant[mant.length-1] == 0) {"
      },
      {
        "txt": "a.exp = b.exp; } int aextradigit = 0; int bextradigit = 0; if (a.exp < b.exp) { aextradigit = a.align(b.exp); } else { bextradigit = b.align(a.exp); } if (asign != bsign) {"
      },
      {
        "txt": "if (asign == rsign) { bextradigit = b.complement(bextradigit); } else { aextradigit = a.complement(aextradigit); } } int rh = 0; /* acts as a carry */ for (int i = 0; i < mant.length; i++) { final int r = a.mant[i]+b.mant[i]+rh; rh = r / RADIX;"
      },
      {
        "txt": "result.mant[i] = r - rh * RADIX; } result.exp = a.exp; result.sign = rsign; if (rh != 0 && (asign == bsign)) { final int lostdigit = result.mant[0]; result.shiftRight(); result.mant[mant.length-1] = rh; final int excp = result.round(lostdigit); if (excp != 0) {"
      },
      {
        "txt": "result = dotrap(excp, ADD_TRAP, x, result); } } for (int i = 0; i < mant.length; i++) { if (result.mant[mant.length-1] != 0) { break; } result.shiftLeft(); if (i == 0) { result.mant[0] = aextradigit+bextradigit;"
      },
      {
        "txt": "aextradigit = 0; bextradigit = 0; } } if (result.mant[mant.length-1] == 0) { result.exp = 0; if (asign != bsign) { result.sign = 1; // Per IEEE 854-1987 Section 6.3 } }"
      },
      {
        "txt": "final int excp = result.round(aextradigit + bextradigit); if (excp != 0) { result = dotrap(excp, ADD_TRAP, x, result); } return result; } public Dfp negate() { Dfp result = newInstance(this); result.sign = (byte) - result.sign; return result;"
      },
      {
        "txt": "} public Dfp subtract(final Dfp x) { return add(x.negate()); } protected int round(int n) { boolean inc = false; switch (field.getRoundingMode()) { case ROUND_DOWN: inc = false; break;"
      },
      {
        "txt": "case ROUND_UP: inc = n != 0; // round up if n!=0 break; case ROUND_HALF_UP: inc = n >= 5000; // round half up break; case ROUND_HALF_DOWN: inc = n > 5000; // round half down break; case ROUND_HALF_EVEN:"
      },
      {
        "txt": "inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1); // round half-even break; case ROUND_HALF_ODD: inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0); // round half-odd break; case ROUND_CEIL: inc = sign == 1 && n != 0; // round ceil break; case ROUND_FLOOR: default:"
      },
      {
        "txt": "inc = sign == -1 && n != 0; // round floor break; } if (inc) { int rh = 1; for (int i = 0; i < mant.length; i++) { final int r = mant[i] + rh; rh = r / RADIX; mant[i] = r - rh * RADIX; }"
      },
      {
        "txt": "if (rh != 0) { shiftRight(); mant[mant.length-1] = rh; } } if (exp < MIN_EXP) { field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW); return DfpField.FLAG_UNDERFLOW; } if (exp > MAX_EXP) {"
      },
      {
        "txt": "field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW); return DfpField.FLAG_OVERFLOW; } if (n != 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; } return 0; } public Dfp multiply(final Dfp x) {"
      },
      {
        "txt": "if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); } Dfp result = newInstance(getZero()); if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this;"
      },
      {
        "txt": "} if (x.isNaN()) { return x; } if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; } if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {"
      },
      {
        "txt": "result = newInstance(x); result.sign = (byte) (sign * x.sign); return result; } if (x.nans == INFINITE && nans == INFINITE) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; } if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||"
      },
      {
        "txt": "(nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; } } int[] product = new int[mant.length*2]; // Big enough to hold even the largest result for (int i = 0; i < mant.length; i++) {"
      },
      {
        "txt": "int rh = 0; // acts as a carry for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j]; // multiply the 2 digits r = r + product[i+j] + rh; // add to the product digit with carry in rh = r / RADIX; product[i+j] = r - rh * RADIX; } product[i+mant.length] = rh; } int md = mant.length * 2 - 1; // default, in case result is zero"
      },
      {
        "txt": "for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { md = i; break; } } for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = product[md - i]; } result.exp = exp + x.exp + md - 2 * mant.length + 1;"
      },
      {
        "txt": "result.sign = (byte)((sign == x.sign)?1:-1); if (result.mant[mant.length-1] == 0) { result.exp = 0; } final int excp; if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else { excp = result.round(0); // has no effect except to check status }"
      },
      {
        "txt": "result = dotrap(excp, MULTIPLY_TRAP, x, result); } return result; } public Dfp multiply(final int x) { return multiplyFast(x); <extra_id_0> private Dfp multiplyFast(final int x) { Dfp result = newInstance(this); if (nans != FINITE) { if (isNaN()) { return this; }"
      },
      {
        "txt": "return this; } if (nans == INFINITE && x != 0) { result = newInstance(this); return result; } if (nans == INFINITE && x == 0) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN;"
      },
      {
        "txt": "result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result); return result; } } if (x < 0 || x >= RADIX) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result); return result;"
      },
      {
        "txt": "} int rh = 0; for (int i = 0; i < mant.length; i++) { final int r = mant[i] * x + rh; rh = r / RADIX; result.mant[i] = r - rh * RADIX; } int lostdigit = 0; if (rh != 0) { lostdigit = result.mant[0];"
      },
      {
        "txt": "result.shiftRight(); result.mant[mant.length-1] = rh; } if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero result.exp = 0; } final int excp = result.round(lostdigit); if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, result, result); }"
      },
      {
        "txt": "return result; } public Dfp divide(Dfp divisor) { int dividend[]; // current status of the dividend int quotient[]; // quotient int remainder[];// remainder int qd; // current quotient digit we're working with int nsqd; // number of significant quotient digits we have int trial=0; // trial quotient digit int minadj; // minimum adjustment"
      },
      {
        "txt": "boolean trialgood; // Flag to indicate a good trail digit int md=0; // most sig digit in result int excp; // exceptions if (field.getRadixDigits() != divisor.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); } Dfp result = newInstance(getZero());"
      },
      {
        "txt": "if (nans != FINITE || divisor.nans != FINITE) { if (isNaN()) { return this; } if (divisor.isNaN()) { return divisor; } if (nans == INFINITE && divisor.nans == FINITE) { result = newInstance(this); result.sign = (byte) (sign * divisor.sign);"
      },
      {
        "txt": "return result; } if (divisor.nans == INFINITE && nans == FINITE) { result = newInstance(getZero()); result.sign = (byte) (sign * divisor.sign); return result; } if (divisor.nans == INFINITE && nans == INFINITE) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero());"
      },
      {
        "txt": "result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); return result; } } if (divisor.mant[mant.length-1] == 0) { field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO); result = newInstance(getZero()); result.sign = (byte) (sign * divisor.sign); result.nans = INFINITE;"
      },
      {
        "txt": "result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result); return result; } dividend = new int[mant.length+1]; // one extra digit needed quotient = new int[mant.length+2]; // two extra digits needed 1 for overflow, 1 for rounding remainder = new int[mant.length+1]; // one extra digit needed dividend[mant.length] = 0; quotient[mant.length] = 0; quotient[mant.length+1] = 0; remainder[mant.length] = 0;"
      },
      {
        "txt": "quotient while we are at it */ for (int i = 0; i < mant.length; i++) { dividend[i] = mant[i]; quotient[i] = 0; remainder[i] = 0; } nsqd = 0; for (qd = mant.length+1; qd >= 0; qd--) { final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1]; int min = divMsb / (divisor.mant[mant.length-1]+1);"
      },
      {
        "txt": "int max = (divMsb + 1) / divisor.mant[mant.length-1]; trialgood = false; while (!trialgood) { trial = (min+max)/2; int rh = 0; for (int i = 0; i < mant.length + 1; i++) { int dm = (i<mant.length)?divisor.mant[i]:0; final int r = (dm * trial) + rh; rh = r / RADIX; remainder[i] = r - rh * RADIX;"
      },
      {
        "txt": "} rh = 1; // carry in to aid the subtraction for (int i = 0; i < mant.length + 1; i++) { final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh; rh = r / RADIX; remainder[i] = r - rh * RADIX; } if (rh == 0) { max = trial-1; continue;"
      },
      {
        "txt": "} minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1]; minadj = minadj / (divisor.mant[mant.length-1]+1); if (minadj >= 2) { min = trial+minadj; // update the minimum continue; } its a good one if it is less than the divisor */ trialgood = false; // assume false for (int i = mant.length - 1; i >= 0; i--) {"
      },
      {
        "txt": "if (divisor.mant[i] > remainder[i]) { trialgood = true; } if (divisor.mant[i] < remainder[i]) { break; } } if (remainder[mant.length] != 0) { trialgood = false; }"
      },
      {
        "txt": "if (trialgood == false) { min = trial+1; } } quotient[qd] = trial; if (trial != 0 || nsqd != 0) { nsqd++; } if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) { break;"
      },
      {
        "txt": "} if (nsqd > mant.length) { break; } dividend[0] = 0; for (int i = 0; i < mant.length; i++) { dividend[i + 1] = remainder[i]; } } md = mant.length; // default"
      },
      {
        "txt": "for (int i = mant.length + 1; i >= 0; i--) { if (quotient[i] != 0) { md = i; break; } } for (int i=0; i<mant.length; i++) { result.mant[mant.length-i-1] = quotient[md-i]; } result.exp = exp - divisor.exp + md - mant.length;"
      },
      {
        "txt": "result.sign = (byte) ((sign == divisor.sign) ? 1 : -1); if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero result.exp = 0; } if (md > (mant.length-1)) { excp = result.round(quotient[md-mant.length]); } else { excp = result.round(0); } if (excp != 0) {"
      },
      {
        "txt": "result = dotrap(excp, DIVIDE_TRAP, divisor, result); } return result; } public Dfp divide(int divisor) { if (nans != FINITE) { if (isNaN()) { return this; } if (nans == INFINITE) {"
      },
      {
        "txt": "return newInstance(this); } } if (divisor == 0) { field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO); Dfp result = newInstance(getZero()); result.sign = sign; result.nans = INFINITE; result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result); return result;"
      },
      {
        "txt": "} if (divisor < 0 || divisor >= RADIX) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); Dfp result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result); return result; } Dfp result = newInstance(this); int rl = 0;"
      },
      {
        "txt": "for (int i = mant.length-1; i >= 0; i--) { final int r = rl*RADIX + result.mant[i]; final int rh = r / divisor; rl = r - rh * divisor; result.mant[i] = rh; } if (result.mant[mant.length-1] == 0) { result.shiftLeft(); final int r = rl * RADIX; // compute the next digit and put it in final int rh = r / divisor;"
      },
      {
        "txt": "rl = r - rh * divisor; result.mant[0] = rh; } final int excp = result.round(rl * RADIX / divisor); // do the rounding if (excp != 0) { result = dotrap(excp, DIVIDE_TRAP, result, result); } return result; } public Dfp reciprocal() {"
      },
      {
        "txt": "return field.getOne().divide(this); } public Dfp sqrt() { if (nans == FINITE && mant[mant.length-1] == 0) { return newInstance(this); } if (nans != FINITE) { if (nans == INFINITE && sign == 1) { return newInstance(this); }"
      },
      {
        "txt": "if (nans == QNAN) { return newInstance(this); } if (nans == SNAN) { Dfp result; field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(this); result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result); return result; }"
      },
      {
        "txt": "} if (sign == -1) { Dfp result; field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(this); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result); return result; } Dfp x = newInstance(this);"
      },
      {
        "txt": "if (x.exp < -1 || x.exp > 1) { x.exp = this.exp / 2; } switch (x.mant[mant.length-1] / 2000) { case 0: x.mant[mant.length-1] = x.mant[mant.length-1]/2+1; break; case 2: x.mant[mant.length-1] = 1500; break;"
      },
      {
        "txt": "case 3: x.mant[mant.length-1] = 2200; break; default: x.mant[mant.length-1] = 3000; } Dfp dx = newInstance(x); by the formula dx = (y - x*x) / (2x); */ Dfp px = getZero(); Dfp ppx = getZero();"
      },
      {
        "txt": "while (x.unequal(px)) { dx = newInstance(x); dx.sign = -1; dx = dx.add(this.divide(x)); dx = dx.divide(2); ppx = px; px = x; x = x.add(dx); if (x.equals(ppx)) { break;"
      },
      {
        "txt": "} if (dx.mant[mant.length-1] == 0) { break; } } return x; } @Override public String toString() { if (nans != FINITE) {"
      },
      {
        "txt": "if (nans == INFINITE) { return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING; } else { return NAN_STRING; } } if (exp > mant.length || exp < -1) { return dfp2sci(); } return dfp2string();"
      },
      {
        "txt": "} protected String dfp2sci() { char rawdigits[] = new char[mant.length * 4]; char outputbuffer[] = new char[mant.length * 4 + 20]; int p; int q; int e; int ae; int shf; p = 0;"
      },
      {
        "txt": "for (int i = mant.length - 1; i >= 0; i--) { rawdigits[p++] = (char) ((mant[i] / 1000) + '0'); rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0'); rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0'); rawdigits[p++] = (char) (((mant[i]) % 10) + '0'); } for (p = 0; p < rawdigits.length; p++) { if (rawdigits[p] != '0') { break; }"
      },
      {
        "txt": "} shf = p; q = 0; if (sign == -1) { outputbuffer[q++] = '-'; } if (p != rawdigits.length) { outputbuffer[q++] = rawdigits[p++]; outputbuffer[q++] = '.'; while (p<rawdigits.length) {"
      },
      {
        "txt": "outputbuffer[q++] = rawdigits[p++]; } } else { outputbuffer[q++] = '0'; outputbuffer[q++] = '.'; outputbuffer[q++] = '0'; outputbuffer[q++] = 'e'; outputbuffer[q++] = '0'; return new String(outputbuffer, 0, 5); }"
      },
      {
        "txt": "outputbuffer[q++] = 'e'; e = exp * 4 - shf - 1; ae = e; if (e < 0) { ae = -e; } for (p = 1000000000; p > ae; p /= 10) { } if (e < 0) { outputbuffer[q++] = '-';"
      },
      {
        "txt": "} while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; } return new String(outputbuffer, 0, q); } protected String dfp2string() { char buffer[] = new char[mant.length*4 + 20];"
      },
      {
        "txt": "int p = 1; int q; int e = exp; boolean pointInserted = false; buffer[0] = ' '; if (e <= 0) { buffer[p++] = '0'; buffer[p++] = '.'; pointInserted = true; }"
      },
      {
        "txt": "while (e < 0) { buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e++; } for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0'); buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');"
      },
      {
        "txt": "buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) { buffer[p++] = '.'; pointInserted = true; } } while (e > 0) { buffer[p++] = '0'; buffer[p++] = '0';"
      },
      {
        "txt": "buffer[p++] = '0'; buffer[p++] = '0'; e--; } if (!pointInserted) { buffer[p++] = '.'; } q = 1; while (buffer[q] == '0') { q++;"
      },
      {
        "txt": "} if (buffer[q] == '.') { q--; } while (buffer[p-1] == '0') { p--; } if (sign < 0) { buffer[--q] = '-'; }"
      },
      {
        "txt": "return new String(buffer, q, p - q); } public Dfp dotrap(int type, String what, Dfp oper, Dfp result) { Dfp def = result; switch (type) { case DfpField.FLAG_INVALID: def = newInstance(getZero()); def.sign = result.sign; def.nans = QNAN; break;"
      },
      {
        "txt": "case DfpField.FLAG_DIV_ZERO: if (nans == FINITE && mant[mant.length-1] != 0) { def = newInstance(getZero()); def.sign = (byte)(sign*oper.sign); def.nans = INFINITE; } if (nans == FINITE && mant[mant.length-1] == 0) { def = newInstance(getZero()); def.nans = QNAN; }"
      },
      {
        "txt": "if (nans == INFINITE || nans == QNAN) { def = newInstance(getZero()); def.nans = QNAN; } if (nans == INFINITE || nans == SNAN) { def = newInstance(getZero()); def.nans = QNAN; } break; case DfpField.FLAG_UNDERFLOW:"
      },
      {
        "txt": "if ( (result.exp+mant.length) < MIN_EXP) { def = newInstance(getZero()); def.sign = result.sign; } else { def = newInstance(result); // gradual underflow } result.exp = result.exp + ERR_SCALE; break; case DfpField.FLAG_OVERFLOW: result.exp = result.exp - ERR_SCALE;"
      },
      {
        "txt": "def = newInstance(getZero()); def.sign = result.sign; def.nans = INFINITE; break; default: def = result; break; } return trap(type, what, oper, def, result); } protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) { return def;"
      },
      {
        "txt": "} public int classify() { return nans; } public static Dfp copysign(final Dfp x, final Dfp y) { Dfp result = x.newInstance(x); result.sign = y.sign; return result; } public Dfp nextAfter(final Dfp x) {"
      },
      {
        "txt": "if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result); } boolean up = false; if (this.lessThan(x)) { up = true; }"
      },
      {
        "txt": "if (compare(this, x) == 0) { return newInstance(x); } if (lessThan(getZero())) { up = !up; } final Dfp inc; Dfp result; if (up) { inc = newInstance(getOne());"
      },
      {
        "txt": "inc.exp = this.exp-mant.length+1; inc.sign = this.sign; if (this.equals(getZero())) { inc.exp = MIN_EXP-mant.length; } result = add(inc); } else { inc = newInstance(getOne()); inc.exp = this.exp; inc.sign = this.sign;"
      },
      {
        "txt": "if (this.equals(inc)) { inc.exp = this.exp-mant.length; } else { inc.exp = this.exp-mant.length+1; } if (this.equals(getZero())) { inc.exp = MIN_EXP-mant.length; } result = this.subtract(inc); }"
      },
      {
        "txt": "if (result.classify() == INFINITE && this.classify() != INFINITE) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } if (result.equals(getZero()) && this.equals(getZero()) == false) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } return result; }"
      },
      {
        "txt": "public double toDouble() { if (isInfinite()) { if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN;"
      },
      {
        "txt": "} Dfp y = this; boolean negate = false; int cmp0 = compare(this, getZero()); if (cmp0 == 0) { return sign < 0 ? -0.0 : +0.0; } else if (cmp0 < 0) { y = negate(); negate = true; }"
      },
      {
        "txt": "Should be faster than doing a natural logarithm. */ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; }"
      },
      {
        "txt": "exponent--; y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;"
      },
      {
        "txt": "} y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) { mantissa = 0; exponent++; } if (exponent <= -1023) {"
      },
      {
        "txt": "exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x;"
      },
      {
        "txt": "} return x; } public double[] toSplitDouble() { double split[] = new double[2]; long mask = 0xffffffffc0000000L; split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask); split[1] = subtract(newInstance(split[0])).toDouble(); return split; }"
      }
    ]
  }
]