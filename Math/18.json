[
  {
    "id": 2506,
    "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
    "start-bug-line": 932,
    "end-bug-line": 932,
    "bug": "res[i] = (x[i] - boundaries[0][i]) / diff;",
    "fix": "res[i] = x[i] / diff;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.TooManyEvaluationsException;"
      },
      {
        "txt": "import org.apache.commons.math3.exception.util.LocalizedFormats; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.EigenDecomposition; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.ConvergenceChecker; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.MultivariateOptimizer; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimpleValueChecker;"
      },
      {
        "txt": "import org.apache.commons.math3.random.MersenneTwister; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.util.MathArrays; public class CMAESOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int DEFAULT_CHECKFEASABLECOUNT = 0; public static final double DEFAULT_STOPFITNESS = 0; public static final boolean DEFAULT_ISACTIVECMA = true; public static final int DEFAULT_MAXITERATIONS = 30000;"
      },
      {
        "txt": "public static final int DEFAULT_DIAGONALONLY = 0; public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister(); private int lambda; // population size private boolean isActiveCMA; private int checkFeasableCount; private double[][] boundaries; private double[] inputSigma; private int dimension; private int diagonalOnly = 0; private boolean isMinimize = true;"
      },
      {
        "txt": "private boolean generateStatistics = false; private int maxIterations; private double stopFitness; private double stopTolUpX; private double stopTolX; private double stopTolFun; private double stopTolHistFun; private int mu; // private double logMu2; private RealMatrix weights;"
      },
      {
        "txt": "private double mueff; // private double sigma; private double cc; private double cs; private double damps; private double ccov1; private double ccovmu; private double chiN; private double ccov1Sep; private double ccovmuSep;"
      },
      {
        "txt": "private RealMatrix xmean; private RealMatrix pc; private RealMatrix ps; private double normps; private RealMatrix B; private RealMatrix D; private RealMatrix BD; private RealMatrix diagD; private RealMatrix C; private RealMatrix diagC;"
      },
      {
        "txt": "private int iterations; private double[] fitnessHistory; private int historySize; private RandomGenerator random; private List<Double> statisticsSigmaHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>(); private List<Double> statisticsFitnessHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>(); public CMAESOptimizer() { this(0);"
      },
      {
        "txt": "} public CMAESOptimizer(int lambda) { this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } public CMAESOptimizer(int lambda, double[] inputSigma) { this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);"
      },
      {
        "txt": "} @Deprecated public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) { this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA, diagonalOnly, checkFeasableCount, random, generateStatistics, new SimpleValueChecker()); }"
      },
      {
        "txt": "public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) { super(checker); this.lambda = lambda; this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone(); this.maxIterations = maxIterations; this.stopFitness = stopFitness;"
      },
      {
        "txt": "this.isActiveCMA = isActiveCMA; this.diagonalOnly = diagonalOnly; this.checkFeasableCount = checkFeasableCount; this.random = random; this.generateStatistics = generateStatistics; } public List<Double> getStatisticsSigmaHistory() { return statisticsSigmaHistory; } public List<RealMatrix> getStatisticsMeanHistory() {"
      },
      {
        "txt": "return statisticsMeanHistory; } public List<Double> getStatisticsFitnessHistory() { return statisticsFitnessHistory; } public List<RealMatrix> getStatisticsDHistory() { return statisticsDHistory; } @Override protected PointValuePair doOptimize() {"
      },
      {
        "txt": "checkParameters(); isMinimize = getGoalType().equals(GoalType.MINIMIZE); final FitnessFunction fitfun = new FitnessFunction(); final double[] guess = fitfun.encode(getStartPoint()); dimension = guess.length; initializeCMA(guess); iterations = 0; double bestValue = fitfun.value(guess); push(fitnessHistory, bestValue); PointValuePair optimum = new PointValuePair(getStartPoint(),"
      },
      {
        "txt": "isMinimize ? bestValue : -bestValue); PointValuePair lastResult = null; generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { RealMatrix arz = randn1(dimension, lambda); RealMatrix arx = zeros(dimension, lambda); double[] fitness = new double[lambda]; for (int k = 0; k < lambda; k++) { RealMatrix arxk = null; for (int i = 0; i < checkFeasableCount+1; i++) {"
      },
      {
        "txt": "if (diagonalOnly <= 0) { arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)) .scalarMultiply(sigma)); // m + sig * Normal(0,C) } else { arxk = xmean.add(times(diagD,arz.getColumnMatrix(k)) .scalarMultiply(sigma)); } if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) { break; }"
      },
      {
        "txt": "arz.setColumn(k, randn(dimension)); } copyColumn(arxk, 0, arx, k); try { fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness } catch (TooManyEvaluationsException e) { break generationLoop; } } int[] arindex = sortedIndices(fitness);"
      },
      {
        "txt": "RealMatrix xold = xmean; // for speed up of Eq. (2) and (3) RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu)); xmean = bestArx.multiply(weights); RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu)); RealMatrix zmean = bestArz.multiply(weights); boolean hsig = updateEvolutionPaths(zmean, xold); if (diagonalOnly <= 0) { updateCovariance(hsig, bestArx, arz, arindex, xold); } else { updateCovarianceDiagonalOnly(hsig, bestArz, xold);"
      },
      {
        "txt": "} sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps)); double bestFitness = fitness[arindex[0]]; double worstFitness = fitness[arindex[arindex.length-1]]; if (bestValue > bestFitness) { bestValue = bestFitness; lastResult = optimum; optimum = new PointValuePair( fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);"
      },
      {
        "txt": "if (getConvergenceChecker() != null && lastResult != null) { if (getConvergenceChecker().converged(iterations, optimum, lastResult)) { break generationLoop; } } } if (stopFitness != 0) { // only if stopFitness is defined if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) { break generationLoop; }"
      },
      {
        "txt": "} double[] sqrtDiagC = sqrt(diagC).getColumn(0); double[] pcCol = pc.getColumn(0); for (int i = 0; i < dimension; i++) { if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) { break; } if (i >= dimension-1) { break generationLoop; }"
      },
      {
        "txt": "} for (int i = 0; i < dimension; i++) { if (sigma*sqrtDiagC[i] > stopTolUpX) { break generationLoop; } } double historyBest = min(fitnessHistory); double historyWorst = max(fitnessHistory); if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {"
      },
      {
        "txt": "break generationLoop; } if (iterations > fitnessHistory.length && historyWorst-historyBest < stopTolHistFun) { break generationLoop; } if (max(diagD)/min(diagD) > 1e7) { break generationLoop; } if (getConvergenceChecker() != null) {"
      },
      {
        "txt": "PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { break generationLoop; } lastResult = current; } if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {"
      },
      {
        "txt": "sigma = sigma * Math.exp(0.2+cs/damps); } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); } push(fitnessHistory,bestFitness); fitfun.setValueRange(worstFitness-bestFitness); if (generateStatistics) { statisticsSigmaHistory.add(sigma);"
      },
      {
        "txt": "statisticsFitnessHistory.add(bestFitness); statisticsMeanHistory.add(xmean.transpose()); statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5)); } } return optimum; } private void checkParameters() { final double[] init = getStartPoint(); final double[] lB = getLowerBound();"
      },
      {
        "txt": "final double[] uB = getUpperBound(); boolean hasFiniteBounds = false; for (int i = 0; i < lB.length; i++) { if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) { hasFiniteBounds = true; break; } } boolean hasInfiniteBounds = false;"
      },
      {
        "txt": "if (hasFiniteBounds) { for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) { hasInfiniteBounds = true; break; } } if (hasInfiniteBounds) { throw new MathUnsupportedOperationException();"
      },
      {
        "txt": "} else { boundaries = new double[2][]; boundaries[0] = lB; boundaries[1] = uB; for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max,"
      },
      {
        "txt": "true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } } } } else { boundaries = null; }"
      },
      {
        "txt": "if (inputSigma != null) { if (inputSigma.length != init.length) { throw new DimensionMismatchException(inputSigma.length, init.length); } for (int i = 0; i < init.length; i++) { if (inputSigma[i] < 0) { throw new NotPositiveException(inputSigma[i]); } if (boundaries != null) { if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {"
      },
      {
        "txt": "throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]); } } } } } private void initializeCMA(double[] guess) { if (lambda <= 0) { lambda = 4 + (int) (3. * Math.log(dimension)); }"
      },
      {
        "txt": "double[][] sigmaArray = new double[guess.length][1]; for (int i = 0; i < guess.length; i++) { final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i]; sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range; } RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false); sigma = max(insigma); // overall standard deviation stopTolUpX = 1e3 * max(insigma); stopTolX = 1e-11 * max(insigma); stopTolFun = 1e-12;"
      },
      {
        "txt": "stopTolHistFun = 1e-13; mu = lambda / 2; // number of parents/points for recombination logMu2 = Math.log(mu + 0.5); weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2); double sumw = 0; double sumwq = 0; for (int i = 0; i < mu; i++) { double w = weights.getEntry(i, 0); sumw += w; sumwq += w * w;"
      },
      {
        "txt": "} weights = weights.scalarMultiply(1. / sumw); mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i cc = (4. + mueff / dimension) / (dimension + 4. + 2. * mueff / dimension); cs = (mueff + 2.) / (dimension + mueff + 3.); damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) / (dimension + 1.)) - 1.)) * Math.max(0.3, 1. - dimension / (1e-6 + Math.min(maxIterations, getMaxEvaluations() /"
      },
      {
        "txt": "lambda))) + cs; // minor increment ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff); ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) / ((dimension + 2.) * (dimension + 2.) + mueff)); ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.); ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.); chiN = Math.sqrt(dimension) * (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension)); xmean = MatrixUtils.createColumnRealMatrix(guess); // objective diagD = insigma.scalarMultiply(1. / sigma);"
      },
      {
        "txt": "diagC = square(diagD); pc = zeros(dimension, 1); // evolution paths for C and sigma ps = zeros(dimension, 1); // B defines the coordinate system normps = ps.getFrobeniusNorm(); B = eye(dimension, dimension); D = ones(dimension, 1); // diagonal D defines the scaling BD = times(B, repmat(diagD.transpose(), dimension, 1)); C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance historySize = 10 + (int) (3. * 10. * dimension / lambda); fitnessHistory = new double[historySize]; // history of fitness values"
      },
      {
        "txt": "for (int i = 0; i < historySize; i++) { fitnessHistory[i] = Double.MAX_VALUE; } } private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) { ps = ps.scalarMultiply(1. - cs).add( B.multiply(zmean).scalarMultiply( Math.sqrt(cs * (2. - cs) * mueff))); normps = ps.getFrobeniusNorm(); boolean hsig = normps /"
      },
      {
        "txt": "Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) / chiN < 1.4 + 2. / (dimension + 1.); pc = pc.scalarMultiply(1. - cc); if (hsig) { pc = pc.add(xmean.subtract(xold).scalarMultiply( Math.sqrt(cc * (2. - cc) * mueff) / sigma)); } return hsig; } private void updateCovarianceDiagonalOnly(boolean hsig,"
      },
      {
        "txt": "final RealMatrix bestArz, final RealMatrix xold) { double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc); oldFac += 1. - ccov1Sep - ccovmuSep; diagC = diagC.scalarMultiply(oldFac) // regard old matrix .add(square(pc).scalarMultiply(ccov1Sep)) .add((times(diagC, square(bestArz).multiply(weights))) .scalarMultiply(ccovmuSep)); diagD = sqrt(diagC); // replaces eig(C) if (diagonalOnly > 1 && iterations > diagonalOnly) {"
      },
      {
        "txt": "diagonalOnly = 0; B = eye(dimension, dimension); BD = diag(diagD); C = diag(diagC); } } private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold) { double negccov = 0; if (ccov1 + ccovmu > 0) {"
      },
      {
        "txt": "RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu)) .scalarMultiply(1. / sigma); // mu difference vectors RealMatrix roneu = pc.multiply(pc.transpose()) .scalarMultiply(ccov1); // rank one update double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc); oldFac += 1. - ccov1 - ccovmu; if (isActiveCMA) { negccov = (1. - ccovmu) * 0.25 * mueff / (Math.pow(dimension + 2., 1.5) + 2. * mueff); double negminresidualvariance = 0.66;"
      },
      {
        "txt": "double negalphaold = 0.5; // where to make up for the variance int[] arReverseIndex = reverse(arindex); RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu)); RealMatrix arnorms = sqrt(sumRows(square(arzneg))); int[] idxnorms = sortedIndices(arnorms.getRow(0)); RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms); int[] idxReverse = reverse(idxnorms); RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse); arnorms = divide(arnormsReverse, arnormsSorted);"
      },
      {
        "txt": "int[] idxInv = inverse(idxnorms); RealMatrix arnormsInv = selectColumns(arnorms, idxInv); double negcovMax = (1. - negminresidualvariance) / square(arnormsInv).multiply(weights).getEntry(0, 0); if (negccov > negcovMax) { negccov = negcovMax; } arzneg = times(arzneg, repmat(arnormsInv, dimension, 1)); RealMatrix artmp = BD.multiply(arzneg); RealMatrix Cneg = artmp.multiply(diag(weights)).multiply("
      },
      {
        "txt": "artmp.transpose()); oldFac += negalphaold * negccov; C = C.scalarMultiply(oldFac) .add(roneu) .add(arpos.scalarMultiply( ccovmu + (1. - negalphaold) * negccov) .multiply( times(repmat(weights, 1, dimension), arpos.transpose()))) .subtract(Cneg.scalarMultiply(negccov));"
      },
      {
        "txt": "} else { C = C.scalarMultiply(oldFac) // regard old matrix .add(roneu) .add(arpos.scalarMultiply(ccovmu) // plus rank mu update .multiply( times(repmat(weights, 1, dimension), arpos.transpose()))); } } updateBD(negccov);"
      },
      {
        "txt": "} private void updateBD(double negccov) { if (ccov1 + ccovmu + negccov > 0 && (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) { C = triu(C, 0).add(triu(C, 1).transpose()); EigenDecomposition eig = new EigenDecomposition(C); B = eig.getV(); // eigen decomposition, B==normalized eigenvectors D = eig.getD(); diagD = diag(D); if (min(diagD) <= 0) {"
      },
      {
        "txt": "for (int i = 0; i < dimension; i++) { if (diagD.getEntry(i, 0) < 0) { diagD.setEntry(i, 0, 0.); } } double tfac = max(diagD) / 1e14; C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } if (max(diagD) > 1e14 * min(diagD)) {"
      },
      {
        "txt": "double tfac = max(diagD) / 1e14 - min(diagD); C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } diagC = diag(C); diagD = sqrt(diagD); // D contains standard deviations now BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2) } } private static void push(double[] vals, double val) {"
      },
      {
        "txt": "for (int i = vals.length-1; i > 0; i--) { vals[i] = vals[i-1]; } vals[0] = val; } private int[] sortedIndices(final double[] doubles) { DoubleIndex[] dis = new DoubleIndex[doubles.length]; for (int i = 0; i < doubles.length; i++) { dis[i] = new DoubleIndex(doubles[i], i); }"
      },
      {
        "txt": "Arrays.sort(dis); int[] indices = new int[doubles.length]; for (int i = 0; i < doubles.length; i++) { indices[i] = dis[i].index; } return indices; } private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index;"
      },
      {
        "txt": "DoubleIndex(double value, int index) { this.value = value; this.index = index; } public int compareTo(DoubleIndex o) { return Double.compare(value, o.value); } @Override public boolean equals(Object other) { if (this == other) {"
      },
      {
        "txt": "return true; } if (other instanceof DoubleIndex) { return Double.compare(value, ((DoubleIndex) other).value) == 0; } return false; } @Override public int hashCode() { long bits = Double.doubleToLongBits(value);"
      },
      {
        "txt": "return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff); } } private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction() { valueRange = 1.0; isRepairMode = true; }"
      },
      {
        "txt": "if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; <extra_id_0> } return res; } public double[] repairAndDecode(final double[] x) { return boundaries != null && isRepairMode ? decode(repair(x)) :"
      },
      {
        "txt": "return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); } public double[] decode(final double[] x) { if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) {"
      },
      {
        "txt": "double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i] + boundaries[0][i]; } return res; } public double value(final double[] point) { double value; if (boundaries != null && isRepairMode) { double[] repaired = repair(point); value = CMAESOptimizer.this"
      },
      {
        "txt": ".computeObjectiveValue(decode(repaired)) + penalty(point, repaired); } else { value = CMAESOptimizer.this .computeObjectiveValue(decode(point)); } return isMinimize ? value : -value; } public boolean isFeasible(final double[] x) { if (boundaries == null) {"
      },
      {
        "txt": "return true; } for (int i = 0; i < x.length; i++) { if (x[i] < 0) { return false; } if (x[i] > 1.0) { return false; } }"
      },
      {
        "txt": "return true; } public void setValueRange(double valueRange) { this.valueRange = valueRange; } private double[] repair(final double[] x) { double[] repaired = new double[x.length]; for (int i = 0; i < x.length; i++) { if (x[i] < 0) { repaired[i] = 0;"
      },
      {
        "txt": "} else if (x[i] > 1.0) { repaired[i] = 1.0; } else { repaired[i] = x[i]; } } return repaired; } private double penalty(final double[] x, final double[] repaired) { double penalty = 0;"
      },
      {
        "txt": "for (int i = 0; i < x.length; i++) { double diff = Math.abs(x[i] - repaired[i]); penalty += diff * valueRange; } return isMinimize ? penalty : -penalty; } } private static RealMatrix log(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) {"
      },
      {
        "txt": "for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.log(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sqrt(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "d[r][c] = Math.sqrt(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix square(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c);"
      },
      {
        "txt": "d[r][c] = e * e; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix times(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);"
      },
      {
        "txt": "} } return new Array2DRowRealMatrix(d, false); } private static RealMatrix divide(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) / n.getEntry(r, c); }"
      },
      {
        "txt": "} return new Array2DRowRealMatrix(d, false); } private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) { double[][] d = new double[m.getRowDimension()][cols.length]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < cols.length; c++) { d[r][c] = m.getEntry(r, cols[c]); } }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } private static RealMatrix triu(final RealMatrix m, int k) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = r <= c - k ? m.getEntry(r, c) : 0; } } return new Array2DRowRealMatrix(d, false);"
      },
      {
        "txt": "} private static RealMatrix sumRows(final RealMatrix m) { double[][] d = new double[1][m.getColumnDimension()]; for (int c = 0; c < m.getColumnDimension(); c++) { double sum = 0; for (int r = 0; r < m.getRowDimension(); r++) { sum += m.getEntry(r, c); } d[0][c] = sum; }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } private static RealMatrix diag(final RealMatrix m) { if (m.getColumnDimension() == 1) { double[][] d = new double[m.getRowDimension()][m.getRowDimension()]; for (int i = 0; i < m.getRowDimension(); i++) { d[i][i] = m.getEntry(i, 0); } return new Array2DRowRealMatrix(d, false); } else {"
      },
      {
        "txt": "double[][] d = new double[m.getRowDimension()][1]; for (int i = 0; i < m.getColumnDimension(); i++) { d[i][0] = m.getEntry(i, i); } return new Array2DRowRealMatrix(d, false); } } private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) { for (int i = 0; i < m1.getRowDimension(); i++) { m2.setEntry(i, col2, m1.getEntry(i, col1));"
      },
      {
        "txt": "} } private static RealMatrix ones(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { Arrays.fill(d[r], 1.0); } return new Array2DRowRealMatrix(d, false); } private static RealMatrix eye(int n, int m) {"
      },
      {
        "txt": "double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { if (r < m) { d[r][r] = 1; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix zeros(int n, int m) { return new Array2DRowRealMatrix(n, m);"
      },
      {
        "txt": "} private static RealMatrix repmat(final RealMatrix mat, int n, int m) { int rd = mat.getRowDimension(); int cd = mat.getColumnDimension(); double[][] d = new double[n * rd][m * cd]; for (int r = 0; r < n * rd; r++) { for (int c = 0; c < m * cd; c++) { d[r][c] = mat.getEntry(r % rd, c % cd); } }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } private static RealMatrix sequence(double start, double end, double step) { int size = (int) ((end - start) / step + 1); double[][] d = new double[size][1]; double value = start; for (int r = 0; r < size; r++) { d[r][0] = value; value += step; }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } private static double max(final RealMatrix m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); if (max < e) { max = e; }"
      },
      {
        "txt": "} } return max; } private static double min(final RealMatrix m) { double min = Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); if (min > e) {"
      },
      {
        "txt": "min = e; } } } return min; } private static double max(final double[] m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (max < m[r]) {"
      },
      {
        "txt": "max = m[r]; } } return max; } private static double min(final double[] m) { double min = Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (min > m[r]) { min = m[r];"
      },
      {
        "txt": "} } return min; } private static int[] inverse(final int[] indices) { int[] inverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { inverse[indices[i]] = i; } return inverse;"
      },
      {
        "txt": "} private static int[] reverse(final int[] indices) { int[] reverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { reverse[i] = indices[indices.length - i - 1]; } return reverse; } private double[] randn(int size) { double[] randn = new double[size];"
      },
      {
        "txt": "for (int i = 0; i < size; i++) { randn[i] = random.nextGaussian(); } return randn; } private RealMatrix randn1(int size, int popSize) { double[][] d = new double[size][popSize]; for (int r = 0; r < size; r++) { for (int c = 0; c < popSize; c++) { d[r][c] = random.nextGaussian();"
      },
      {
        "txt": "} } return new Array2DRowRealMatrix(d, false); }"
      }
    ]
  },
  {
    "id": 2507,
    "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
    "start-bug-line": 958,
    "end-bug-line": 958,
    "bug": "res[i] = diff * x[i] + boundaries[0][i];",
    "fix": "res[i] = diff * x[i];",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.optimization.direct; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathUnsupportedOperationException;"
      },
      {
        "txt": "import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.util.LocalizedFormats; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.EigenDecomposition; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.ConvergenceChecker;"
      },
      {
        "txt": "import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.MultivariateOptimizer; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimpleValueChecker; import org.apache.commons.math3.random.MersenneTwister; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.util.MathArrays; public class CMAESOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer {"
      },
      {
        "txt": "public static final int DEFAULT_CHECKFEASABLECOUNT = 0; public static final double DEFAULT_STOPFITNESS = 0; public static final boolean DEFAULT_ISACTIVECMA = true; public static final int DEFAULT_MAXITERATIONS = 30000; public static final int DEFAULT_DIAGONALONLY = 0; public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister(); private int lambda; // population size private boolean isActiveCMA; private int checkFeasableCount; private double[][] boundaries;"
      },
      {
        "txt": "private double[] inputSigma; private int dimension; private int diagonalOnly = 0; private boolean isMinimize = true; private boolean generateStatistics = false; private int maxIterations; private double stopFitness; private double stopTolUpX; private double stopTolX; private double stopTolFun;"
      },
      {
        "txt": "private double stopTolHistFun; private int mu; // private double logMu2; private RealMatrix weights; private double mueff; // private double sigma; private double cc; private double cs; private double damps; private double ccov1;"
      },
      {
        "txt": "private double ccovmu; private double chiN; private double ccov1Sep; private double ccovmuSep; private RealMatrix xmean; private RealMatrix pc; private RealMatrix ps; private double normps; private RealMatrix B; private RealMatrix D;"
      },
      {
        "txt": "private RealMatrix BD; private RealMatrix diagD; private RealMatrix C; private RealMatrix diagC; private int iterations; private double[] fitnessHistory; private int historySize; private RandomGenerator random; private List<Double> statisticsSigmaHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>();"
      },
      {
        "txt": "private List<Double> statisticsFitnessHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>(); public CMAESOptimizer() { this(0); } public CMAESOptimizer(int lambda) { this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); }"
      },
      {
        "txt": "public CMAESOptimizer(int lambda, double[] inputSigma) { this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } @Deprecated public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) {"
      },
      {
        "txt": "this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA, diagonalOnly, checkFeasableCount, random, generateStatistics, new SimpleValueChecker()); } public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) { super(checker);"
      },
      {
        "txt": "this.lambda = lambda; this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone(); this.maxIterations = maxIterations; this.stopFitness = stopFitness; this.isActiveCMA = isActiveCMA; this.diagonalOnly = diagonalOnly; this.checkFeasableCount = checkFeasableCount; this.random = random; this.generateStatistics = generateStatistics; }"
      },
      {
        "txt": "public List<Double> getStatisticsSigmaHistory() { return statisticsSigmaHistory; } public List<RealMatrix> getStatisticsMeanHistory() { return statisticsMeanHistory; } public List<Double> getStatisticsFitnessHistory() { return statisticsFitnessHistory; } public List<RealMatrix> getStatisticsDHistory() {"
      },
      {
        "txt": "return statisticsDHistory; } @Override protected PointValuePair doOptimize() { checkParameters(); isMinimize = getGoalType().equals(GoalType.MINIMIZE); final FitnessFunction fitfun = new FitnessFunction(); final double[] guess = fitfun.encode(getStartPoint()); dimension = guess.length; initializeCMA(guess);"
      },
      {
        "txt": "iterations = 0; double bestValue = fitfun.value(guess); push(fitnessHistory, bestValue); PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue); PointValuePair lastResult = null; generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { RealMatrix arz = randn1(dimension, lambda); RealMatrix arx = zeros(dimension, lambda);"
      },
      {
        "txt": "double[] fitness = new double[lambda]; for (int k = 0; k < lambda; k++) { RealMatrix arxk = null; for (int i = 0; i < checkFeasableCount+1; i++) { if (diagonalOnly <= 0) { arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)) .scalarMultiply(sigma)); // m + sig * Normal(0,C) } else { arxk = xmean.add(times(diagD,arz.getColumnMatrix(k)) .scalarMultiply(sigma));"
      },
      {
        "txt": "} if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) { break; } arz.setColumn(k, randn(dimension)); } copyColumn(arxk, 0, arx, k); try { fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness } catch (TooManyEvaluationsException e) {"
      },
      {
        "txt": "break generationLoop; } } int[] arindex = sortedIndices(fitness); RealMatrix xold = xmean; // for speed up of Eq. (2) and (3) RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu)); xmean = bestArx.multiply(weights); RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu)); RealMatrix zmean = bestArz.multiply(weights); boolean hsig = updateEvolutionPaths(zmean, xold);"
      },
      {
        "txt": "if (diagonalOnly <= 0) { updateCovariance(hsig, bestArx, arz, arindex, xold); } else { updateCovarianceDiagonalOnly(hsig, bestArz, xold); } sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps)); double bestFitness = fitness[arindex[0]]; double worstFitness = fitness[arindex[arindex.length-1]]; if (bestValue > bestFitness) { bestValue = bestFitness;"
      },
      {
        "txt": "lastResult = optimum; optimum = new PointValuePair( fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness); if (getConvergenceChecker() != null && lastResult != null) { if (getConvergenceChecker().converged(iterations, optimum, lastResult)) { break generationLoop; } } }"
      },
      {
        "txt": "if (stopFitness != 0) { // only if stopFitness is defined if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) { break generationLoop; } } double[] sqrtDiagC = sqrt(diagC).getColumn(0); double[] pcCol = pc.getColumn(0); for (int i = 0; i < dimension; i++) { if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) { break;"
      },
      {
        "txt": "} if (i >= dimension-1) { break generationLoop; } } for (int i = 0; i < dimension; i++) { if (sigma*sqrtDiagC[i] > stopTolUpX) { break generationLoop; } }"
      },
      {
        "txt": "double historyBest = min(fitnessHistory); double historyWorst = max(fitnessHistory); if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) { break generationLoop; } if (iterations > fitnessHistory.length && historyWorst-historyBest < stopTolHistFun) { break generationLoop; }"
      },
      {
        "txt": "if (max(diagD)/min(diagD) > 1e7) { break generationLoop; } if (getConvergenceChecker() != null) { PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { break generationLoop;"
      },
      {
        "txt": "} lastResult = current; } if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { sigma = sigma * Math.exp(0.2+cs/damps); } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); }"
      },
      {
        "txt": "push(fitnessHistory,bestFitness); fitfun.setValueRange(worstFitness-bestFitness); if (generateStatistics) { statisticsSigmaHistory.add(sigma); statisticsFitnessHistory.add(bestFitness); statisticsMeanHistory.add(xmean.transpose()); statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5)); } } return optimum;"
      },
      {
        "txt": "} private void checkParameters() { final double[] init = getStartPoint(); final double[] lB = getLowerBound(); final double[] uB = getUpperBound(); boolean hasFiniteBounds = false; for (int i = 0; i < lB.length; i++) { if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) { hasFiniteBounds = true;"
      },
      {
        "txt": "break; } } boolean hasInfiniteBounds = false; if (hasFiniteBounds) { for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) { hasInfiniteBounds = true; break;"
      },
      {
        "txt": "} } if (hasInfiniteBounds) { throw new MathUnsupportedOperationException(); } else { boundaries = new double[2][]; boundaries[0] = lB; boundaries[1] = uB; for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {"
      },
      {
        "txt": "final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } }"
      },
      {
        "txt": "} } else { boundaries = null; } if (inputSigma != null) { if (inputSigma.length != init.length) { throw new DimensionMismatchException(inputSigma.length, init.length); } for (int i = 0; i < init.length; i++) { if (inputSigma[i] < 0) {"
      },
      {
        "txt": "throw new NotPositiveException(inputSigma[i]); } if (boundaries != null) { if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) { throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]); } } } } }"
      },
      {
        "txt": "private void initializeCMA(double[] guess) { if (lambda <= 0) { lambda = 4 + (int) (3. * Math.log(dimension)); } double[][] sigmaArray = new double[guess.length][1]; for (int i = 0; i < guess.length; i++) { final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i]; sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range; } RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);"
      },
      {
        "txt": "sigma = max(insigma); // overall standard deviation stopTolUpX = 1e3 * max(insigma); stopTolX = 1e-11 * max(insigma); stopTolFun = 1e-12; stopTolHistFun = 1e-13; mu = lambda / 2; // number of parents/points for recombination logMu2 = Math.log(mu + 0.5); weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2); double sumw = 0; double sumwq = 0;"
      },
      {
        "txt": "for (int i = 0; i < mu; i++) { double w = weights.getEntry(i, 0); sumw += w; sumwq += w * w; } weights = weights.scalarMultiply(1. / sumw); mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i cc = (4. + mueff / dimension) / (dimension + 4. + 2. * mueff / dimension); cs = (mueff + 2.) / (dimension + mueff + 3.);"
      },
      {
        "txt": "damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) / (dimension + 1.)) - 1.)) * Math.max(0.3, 1. - dimension / (1e-6 + Math.min(maxIterations, getMaxEvaluations() / lambda))) + cs; // minor increment ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff); ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) / ((dimension + 2.) * (dimension + 2.) + mueff)); ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.); ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);"
      },
      {
        "txt": "chiN = Math.sqrt(dimension) * (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension)); xmean = MatrixUtils.createColumnRealMatrix(guess); // objective diagD = insigma.scalarMultiply(1. / sigma); diagC = square(diagD); pc = zeros(dimension, 1); // evolution paths for C and sigma ps = zeros(dimension, 1); // B defines the coordinate system normps = ps.getFrobeniusNorm(); B = eye(dimension, dimension); D = ones(dimension, 1); // diagonal D defines the scaling"
      },
      {
        "txt": "BD = times(B, repmat(diagD.transpose(), dimension, 1)); C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance historySize = 10 + (int) (3. * 10. * dimension / lambda); fitnessHistory = new double[historySize]; // history of fitness values for (int i = 0; i < historySize; i++) { fitnessHistory[i] = Double.MAX_VALUE; } } private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) { ps = ps.scalarMultiply(1. - cs).add("
      },
      {
        "txt": "B.multiply(zmean).scalarMultiply( Math.sqrt(cs * (2. - cs) * mueff))); normps = ps.getFrobeniusNorm(); boolean hsig = normps / Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) / chiN < 1.4 + 2. / (dimension + 1.); pc = pc.scalarMultiply(1. - cc); if (hsig) { pc = pc.add(xmean.subtract(xold).scalarMultiply( Math.sqrt(cc * (2. - cc) * mueff) / sigma));"
      },
      {
        "txt": "} return hsig; } private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz, final RealMatrix xold) { double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc); oldFac += 1. - ccov1Sep - ccovmuSep; diagC = diagC.scalarMultiply(oldFac) // regard old matrix .add(square(pc).scalarMultiply(ccov1Sep))"
      },
      {
        "txt": ".add((times(diagC, square(bestArz).multiply(weights))) .scalarMultiply(ccovmuSep)); diagD = sqrt(diagC); // replaces eig(C) if (diagonalOnly > 1 && iterations > diagonalOnly) { diagonalOnly = 0; B = eye(dimension, dimension); BD = diag(diagD); C = diag(diagC); } }"
      },
      {
        "txt": "private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold) { double negccov = 0; if (ccov1 + ccovmu > 0) { RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu)) .scalarMultiply(1. / sigma); // mu difference vectors RealMatrix roneu = pc.multiply(pc.transpose()) .scalarMultiply(ccov1); // rank one update double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc); oldFac += 1. - ccov1 - ccovmu;"
      },
      {
        "txt": "if (isActiveCMA) { negccov = (1. - ccovmu) * 0.25 * mueff / (Math.pow(dimension + 2., 1.5) + 2. * mueff); double negminresidualvariance = 0.66; double negalphaold = 0.5; // where to make up for the variance int[] arReverseIndex = reverse(arindex); RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu)); RealMatrix arnorms = sqrt(sumRows(square(arzneg))); int[] idxnorms = sortedIndices(arnorms.getRow(0));"
      },
      {
        "txt": "RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms); int[] idxReverse = reverse(idxnorms); RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse); arnorms = divide(arnormsReverse, arnormsSorted); int[] idxInv = inverse(idxnorms); RealMatrix arnormsInv = selectColumns(arnorms, idxInv); double negcovMax = (1. - negminresidualvariance) / square(arnormsInv).multiply(weights).getEntry(0, 0); if (negccov > negcovMax) { negccov = negcovMax;"
      },
      {
        "txt": "} arzneg = times(arzneg, repmat(arnormsInv, dimension, 1)); RealMatrix artmp = BD.multiply(arzneg); RealMatrix Cneg = artmp.multiply(diag(weights)).multiply( artmp.transpose()); oldFac += negalphaold * negccov; C = C.scalarMultiply(oldFac) .add(roneu) .add(arpos.scalarMultiply( ccovmu + (1. - negalphaold) * negccov)"
      },
      {
        "txt": ".multiply( times(repmat(weights, 1, dimension), arpos.transpose()))) .subtract(Cneg.scalarMultiply(negccov)); } else { C = C.scalarMultiply(oldFac) // regard old matrix .add(roneu) .add(arpos.scalarMultiply(ccovmu) // plus rank mu update .multiply( times(repmat(weights, 1, dimension),"
      },
      {
        "txt": "arpos.transpose()))); } } updateBD(negccov); } private void updateBD(double negccov) { if (ccov1 + ccovmu + negccov > 0 && (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) { C = triu(C, 0).add(triu(C, 1).transpose()); EigenDecomposition eig = new EigenDecomposition(C);"
      },
      {
        "txt": "B = eig.getV(); // eigen decomposition, B==normalized eigenvectors D = eig.getD(); diagD = diag(D); if (min(diagD) <= 0) { for (int i = 0; i < dimension; i++) { if (diagD.getEntry(i, 0) < 0) { diagD.setEntry(i, 0, 0.); } } double tfac = max(diagD) / 1e14;"
      },
      {
        "txt": "C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } if (max(diagD) > 1e14 * min(diagD)) { double tfac = max(diagD) / 1e14 - min(diagD); C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } diagC = diag(C); diagD = sqrt(diagD); // D contains standard deviations now"
      },
      {
        "txt": "BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2) } } private static void push(double[] vals, double val) { for (int i = vals.length-1; i > 0; i--) { vals[i] = vals[i-1]; } vals[0] = val; } private int[] sortedIndices(final double[] doubles) {"
      },
      {
        "txt": "DoubleIndex[] dis = new DoubleIndex[doubles.length]; for (int i = 0; i < doubles.length; i++) { dis[i] = new DoubleIndex(doubles[i], i); } Arrays.sort(dis); int[] indices = new int[doubles.length]; for (int i = 0; i < doubles.length; i++) { indices[i] = dis[i].index; } return indices;"
      },
      {
        "txt": "} private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index; DoubleIndex(double value, int index) { this.value = value; this.index = index; } public int compareTo(DoubleIndex o) { return Double.compare(value, o.value);"
      },
      {
        "txt": "} @Override public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof DoubleIndex) { return Double.compare(value, ((DoubleIndex) other).value) == 0; } return false;"
      },
      {
        "txt": "} @Override public int hashCode() { long bits = Double.doubleToLongBits(value); return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff); } } private class FitnessFunction { private double valueRange; private boolean isRepairMode;"
      },
      {
        "txt": "public FitnessFunction() { valueRange = 1.0; isRepairMode = true; } public double[] encode(final double[] x) { if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) {"
      },
      {
        "txt": "double diff = boundaries[1][i] - boundaries[0][i]; res[i] = (x[i] - boundaries[0][i]) / diff; } return res; } public double[] repairAndDecode(final double[] x) { return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); }"
      },
      {
        "txt": "if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; <extra_id_0> } return res; } public double value(final double[] point) { double value; if (boundaries != null && isRepairMode) {"
      },
      {
        "txt": "double value; if (boundaries != null && isRepairMode) { double[] repaired = repair(point); value = CMAESOptimizer.this .computeObjectiveValue(decode(repaired)) + penalty(point, repaired); } else { value = CMAESOptimizer.this .computeObjectiveValue(decode(point)); }"
      },
      {
        "txt": "return isMinimize ? value : -value; } public boolean isFeasible(final double[] x) { if (boundaries == null) { return true; } for (int i = 0; i < x.length; i++) { if (x[i] < 0) { return false; }"
      },
      {
        "txt": "if (x[i] > 1.0) { return false; } } return true; } public void setValueRange(double valueRange) { this.valueRange = valueRange; } private double[] repair(final double[] x) {"
      },
      {
        "txt": "double[] repaired = new double[x.length]; for (int i = 0; i < x.length; i++) { if (x[i] < 0) { repaired[i] = 0; } else if (x[i] > 1.0) { repaired[i] = 1.0; } else { repaired[i] = x[i]; } }"
      },
      {
        "txt": "return repaired; } private double penalty(final double[] x, final double[] repaired) { double penalty = 0; for (int i = 0; i < x.length; i++) { double diff = Math.abs(x[i] - repaired[i]); penalty += diff * valueRange; } return isMinimize ? penalty : -penalty; }"
      },
      {
        "txt": "} private static RealMatrix log(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.log(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); }"
      },
      {
        "txt": "private static RealMatrix sqrt(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.sqrt(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix square(final RealMatrix m) {"
      },
      {
        "txt": "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); d[r][c] = e * e; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix times(final RealMatrix m, final RealMatrix n) {"
      },
      {
        "txt": "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) * n.getEntry(r, c); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix divide(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];"
      },
      {
        "txt": "for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) / n.getEntry(r, c); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) { double[][] d = new double[m.getRowDimension()][cols.length]; for (int r = 0; r < m.getRowDimension(); r++) {"
      },
      {
        "txt": "for (int c = 0; c < cols.length; c++) { d[r][c] = m.getEntry(r, cols[c]); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix triu(final RealMatrix m, int k) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "d[r][c] = r <= c - k ? m.getEntry(r, c) : 0; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sumRows(final RealMatrix m) { double[][] d = new double[1][m.getColumnDimension()]; for (int c = 0; c < m.getColumnDimension(); c++) { double sum = 0; for (int r = 0; r < m.getRowDimension(); r++) {"
      },
      {
        "txt": "sum += m.getEntry(r, c); } d[0][c] = sum; } return new Array2DRowRealMatrix(d, false); } private static RealMatrix diag(final RealMatrix m) { if (m.getColumnDimension() == 1) { double[][] d = new double[m.getRowDimension()][m.getRowDimension()]; for (int i = 0; i < m.getRowDimension(); i++) {"
      },
      {
        "txt": "d[i][i] = m.getEntry(i, 0); } return new Array2DRowRealMatrix(d, false); } else { double[][] d = new double[m.getRowDimension()][1]; for (int i = 0; i < m.getColumnDimension(); i++) { d[i][0] = m.getEntry(i, i); } return new Array2DRowRealMatrix(d, false); }"
      },
      {
        "txt": "} private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) { for (int i = 0; i < m1.getRowDimension(); i++) { m2.setEntry(i, col2, m1.getEntry(i, col1)); } } private static RealMatrix ones(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { Arrays.fill(d[r], 1.0);"
      },
      {
        "txt": "} return new Array2DRowRealMatrix(d, false); } private static RealMatrix eye(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { if (r < m) { d[r][r] = 1; } }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } private static RealMatrix zeros(int n, int m) { return new Array2DRowRealMatrix(n, m); } private static RealMatrix repmat(final RealMatrix mat, int n, int m) { int rd = mat.getRowDimension(); int cd = mat.getColumnDimension(); double[][] d = new double[n * rd][m * cd]; for (int r = 0; r < n * rd; r++) {"
      },
      {
        "txt": "for (int c = 0; c < m * cd; c++) { d[r][c] = mat.getEntry(r % rd, c % cd); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sequence(double start, double end, double step) { int size = (int) ((end - start) / step + 1); double[][] d = new double[size][1]; double value = start;"
      },
      {
        "txt": "for (int r = 0; r < size; r++) { d[r][0] = value; value += step; } return new Array2DRowRealMatrix(d, false); } private static double max(final RealMatrix m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "double e = m.getEntry(r, c); if (max < e) { max = e; } } } return max; } private static double min(final RealMatrix m) { double min = Double.MAX_VALUE;"
      },
      {
        "txt": "for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); if (min > e) { min = e; } } } return min; }"
      },
      {
        "txt": "private static double max(final double[] m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (max < m[r]) { max = m[r]; } } return max; } private static double min(final double[] m) {"
      },
      {
        "txt": "double min = Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (min > m[r]) { min = m[r]; } } return min; } private static int[] inverse(final int[] indices) { int[] inverse = new int[indices.length];"
      },
      {
        "txt": "for (int i = 0; i < indices.length; i++) { inverse[indices[i]] = i; } return inverse; } private static int[] reverse(final int[] indices) { int[] reverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { reverse[i] = indices[indices.length - i - 1]; }"
      },
      {
        "txt": "return reverse; } private double[] randn(int size) { double[] randn = new double[size]; for (int i = 0; i < size; i++) { randn[i] = random.nextGaussian(); } return randn; } private RealMatrix randn1(int size, int popSize) {"
      },
      {
        "txt": "double[][] d = new double[size][popSize]; for (int r = 0; r < size; r++) { for (int c = 0; c < popSize; c++) { d[r][c] = random.nextGaussian(); } } return new Array2DRowRealMatrix(d, false); }"
      }
    ]
  },
  {
    "id": 2508,
    "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
    "start-bug-line": 990,
    "end-bug-line": 990,
    "bug": "",
    "fix": "final double[] bLoEnc = encode(boundaries[0]); final double[] bHiEnc = encode(boundaries[1]);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.optimization.direct; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.exception.NotPositiveException;"
      },
      {
        "txt": "import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.util.LocalizedFormats; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.EigenDecomposition; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.ConvergenceChecker; import org.apache.commons.math3.optimization.GoalType;"
      },
      {
        "txt": "import org.apache.commons.math3.optimization.MultivariateOptimizer; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimpleValueChecker; import org.apache.commons.math3.random.MersenneTwister; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.util.MathArrays; public class CMAESOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
      },
      {
        "txt": "public static final double DEFAULT_STOPFITNESS = 0; public static final boolean DEFAULT_ISACTIVECMA = true; public static final int DEFAULT_MAXITERATIONS = 30000; public static final int DEFAULT_DIAGONALONLY = 0; public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister(); private int lambda; // population size private boolean isActiveCMA; private int checkFeasableCount; private double[][] boundaries; private double[] inputSigma;"
      },
      {
        "txt": "private int dimension; private int diagonalOnly = 0; private boolean isMinimize = true; private boolean generateStatistics = false; private int maxIterations; private double stopFitness; private double stopTolUpX; private double stopTolX; private double stopTolFun; private double stopTolHistFun;"
      },
      {
        "txt": "private int mu; // private double logMu2; private RealMatrix weights; private double mueff; // private double sigma; private double cc; private double cs; private double damps; private double ccov1; private double ccovmu;"
      },
      {
        "txt": "private double chiN; private double ccov1Sep; private double ccovmuSep; private RealMatrix xmean; private RealMatrix pc; private RealMatrix ps; private double normps; private RealMatrix B; private RealMatrix D; private RealMatrix BD;"
      },
      {
        "txt": "private RealMatrix diagD; private RealMatrix C; private RealMatrix diagC; private int iterations; private double[] fitnessHistory; private int historySize; private RandomGenerator random; private List<Double> statisticsSigmaHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>(); private List<Double> statisticsFitnessHistory = new ArrayList<Double>();"
      },
      {
        "txt": "private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>(); public CMAESOptimizer() { this(0); } public CMAESOptimizer(int lambda) { this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } public CMAESOptimizer(int lambda, double[] inputSigma) {"
      },
      {
        "txt": "this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } @Deprecated public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) { this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,"
      },
      {
        "txt": "diagonalOnly, checkFeasableCount, random, generateStatistics, new SimpleValueChecker()); } public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) { super(checker); this.lambda = lambda;"
      },
      {
        "txt": "this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone(); this.maxIterations = maxIterations; this.stopFitness = stopFitness; this.isActiveCMA = isActiveCMA; this.diagonalOnly = diagonalOnly; this.checkFeasableCount = checkFeasableCount; this.random = random; this.generateStatistics = generateStatistics; } public List<Double> getStatisticsSigmaHistory() {"
      },
      {
        "txt": "return statisticsSigmaHistory; } public List<RealMatrix> getStatisticsMeanHistory() { return statisticsMeanHistory; } public List<Double> getStatisticsFitnessHistory() { return statisticsFitnessHistory; } public List<RealMatrix> getStatisticsDHistory() { return statisticsDHistory;"
      },
      {
        "txt": "} @Override protected PointValuePair doOptimize() { checkParameters(); isMinimize = getGoalType().equals(GoalType.MINIMIZE); final FitnessFunction fitfun = new FitnessFunction(); final double[] guess = fitfun.encode(getStartPoint()); dimension = guess.length; initializeCMA(guess); iterations = 0;"
      },
      {
        "txt": "double bestValue = fitfun.value(guess); push(fitnessHistory, bestValue); PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue); PointValuePair lastResult = null; generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { RealMatrix arz = randn1(dimension, lambda); RealMatrix arx = zeros(dimension, lambda); double[] fitness = new double[lambda];"
      },
      {
        "txt": "for (int k = 0; k < lambda; k++) { RealMatrix arxk = null; for (int i = 0; i < checkFeasableCount+1; i++) { if (diagonalOnly <= 0) { arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)) .scalarMultiply(sigma)); // m + sig * Normal(0,C) } else { arxk = xmean.add(times(diagD,arz.getColumnMatrix(k)) .scalarMultiply(sigma)); }"
      },
      {
        "txt": "if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) { break; } arz.setColumn(k, randn(dimension)); } copyColumn(arxk, 0, arx, k); try { fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness } catch (TooManyEvaluationsException e) { break generationLoop;"
      },
      {
        "txt": "} } int[] arindex = sortedIndices(fitness); RealMatrix xold = xmean; // for speed up of Eq. (2) and (3) RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu)); xmean = bestArx.multiply(weights); RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu)); RealMatrix zmean = bestArz.multiply(weights); boolean hsig = updateEvolutionPaths(zmean, xold); if (diagonalOnly <= 0) {"
      },
      {
        "txt": "updateCovariance(hsig, bestArx, arz, arindex, xold); } else { updateCovarianceDiagonalOnly(hsig, bestArz, xold); } sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps)); double bestFitness = fitness[arindex[0]]; double worstFitness = fitness[arindex[arindex.length-1]]; if (bestValue > bestFitness) { bestValue = bestFitness; lastResult = optimum;"
      },
      {
        "txt": "optimum = new PointValuePair( fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness); if (getConvergenceChecker() != null && lastResult != null) { if (getConvergenceChecker().converged(iterations, optimum, lastResult)) { break generationLoop; } } } if (stopFitness != 0) { // only if stopFitness is defined"
      },
      {
        "txt": "if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) { break generationLoop; } } double[] sqrtDiagC = sqrt(diagC).getColumn(0); double[] pcCol = pc.getColumn(0); for (int i = 0; i < dimension; i++) { if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) { break; }"
      },
      {
        "txt": "if (i >= dimension-1) { break generationLoop; } } for (int i = 0; i < dimension; i++) { if (sigma*sqrtDiagC[i] > stopTolUpX) { break generationLoop; } } double historyBest = min(fitnessHistory);"
      },
      {
        "txt": "double historyWorst = max(fitnessHistory); if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) { break generationLoop; } if (iterations > fitnessHistory.length && historyWorst-historyBest < stopTolHistFun) { break generationLoop; } if (max(diagD)/min(diagD) > 1e7) {"
      },
      {
        "txt": "break generationLoop; } if (getConvergenceChecker() != null) { PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { break generationLoop; }"
      },
      {
        "txt": "lastResult = current; } if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { sigma = sigma * Math.exp(0.2+cs/damps); } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); } push(fitnessHistory,bestFitness);"
      },
      {
        "txt": "fitfun.setValueRange(worstFitness-bestFitness); if (generateStatistics) { statisticsSigmaHistory.add(sigma); statisticsFitnessHistory.add(bestFitness); statisticsMeanHistory.add(xmean.transpose()); statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5)); } } return optimum; }"
      },
      {
        "txt": "private void checkParameters() { final double[] init = getStartPoint(); final double[] lB = getLowerBound(); final double[] uB = getUpperBound(); boolean hasFiniteBounds = false; for (int i = 0; i < lB.length; i++) { if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) { hasFiniteBounds = true; break;"
      },
      {
        "txt": "} } boolean hasInfiniteBounds = false; if (hasFiniteBounds) { for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) { hasInfiniteBounds = true; break; }"
      },
      {
        "txt": "} if (hasInfiniteBounds) { throw new MathUnsupportedOperationException(); } else { boundaries = new double[2][]; boundaries[0] = lB; boundaries[1] = uB; for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i];"
      },
      {
        "txt": "final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } } }"
      },
      {
        "txt": "} else { boundaries = null; } if (inputSigma != null) { if (inputSigma.length != init.length) { throw new DimensionMismatchException(inputSigma.length, init.length); } for (int i = 0; i < init.length; i++) { if (inputSigma[i] < 0) { throw new NotPositiveException(inputSigma[i]);"
      },
      {
        "txt": "} if (boundaries != null) { if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) { throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]); } } } } } private void initializeCMA(double[] guess) {"
      },
      {
        "txt": "if (lambda <= 0) { lambda = 4 + (int) (3. * Math.log(dimension)); } double[][] sigmaArray = new double[guess.length][1]; for (int i = 0; i < guess.length; i++) { final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i]; sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range; } RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false); sigma = max(insigma); // overall standard deviation"
      },
      {
        "txt": "stopTolUpX = 1e3 * max(insigma); stopTolX = 1e-11 * max(insigma); stopTolFun = 1e-12; stopTolHistFun = 1e-13; mu = lambda / 2; // number of parents/points for recombination logMu2 = Math.log(mu + 0.5); weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2); double sumw = 0; double sumwq = 0; for (int i = 0; i < mu; i++) {"
      },
      {
        "txt": "double w = weights.getEntry(i, 0); sumw += w; sumwq += w * w; } weights = weights.scalarMultiply(1. / sumw); mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i cc = (4. + mueff / dimension) / (dimension + 4. + 2. * mueff / dimension); cs = (mueff + 2.) / (dimension + mueff + 3.); damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /"
      },
      {
        "txt": "(dimension + 1.)) - 1.)) * Math.max(0.3, 1. - dimension / (1e-6 + Math.min(maxIterations, getMaxEvaluations() / lambda))) + cs; // minor increment ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff); ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) / ((dimension + 2.) * (dimension + 2.) + mueff)); ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.); ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.); chiN = Math.sqrt(dimension) *"
      },
      {
        "txt": "(1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension)); xmean = MatrixUtils.createColumnRealMatrix(guess); // objective diagD = insigma.scalarMultiply(1. / sigma); diagC = square(diagD); pc = zeros(dimension, 1); // evolution paths for C and sigma ps = zeros(dimension, 1); // B defines the coordinate system normps = ps.getFrobeniusNorm(); B = eye(dimension, dimension); D = ones(dimension, 1); // diagonal D defines the scaling BD = times(B, repmat(diagD.transpose(), dimension, 1));"
      },
      {
        "txt": "C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance historySize = 10 + (int) (3. * 10. * dimension / lambda); fitnessHistory = new double[historySize]; // history of fitness values for (int i = 0; i < historySize; i++) { fitnessHistory[i] = Double.MAX_VALUE; } } private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) { ps = ps.scalarMultiply(1. - cs).add( B.multiply(zmean).scalarMultiply("
      },
      {
        "txt": "Math.sqrt(cs * (2. - cs) * mueff))); normps = ps.getFrobeniusNorm(); boolean hsig = normps / Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) / chiN < 1.4 + 2. / (dimension + 1.); pc = pc.scalarMultiply(1. - cc); if (hsig) { pc = pc.add(xmean.subtract(xold).scalarMultiply( Math.sqrt(cc * (2. - cc) * mueff) / sigma)); }"
      },
      {
        "txt": "return hsig; } private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz, final RealMatrix xold) { double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc); oldFac += 1. - ccov1Sep - ccovmuSep; diagC = diagC.scalarMultiply(oldFac) // regard old matrix .add(square(pc).scalarMultiply(ccov1Sep)) .add((times(diagC, square(bestArz).multiply(weights)))"
      },
      {
        "txt": ".scalarMultiply(ccovmuSep)); diagD = sqrt(diagC); // replaces eig(C) if (diagonalOnly > 1 && iterations > diagonalOnly) { diagonalOnly = 0; B = eye(dimension, dimension); BD = diag(diagD); C = diag(diagC); } } private void updateCovariance(boolean hsig, final RealMatrix bestArx,"
      },
      {
        "txt": "final RealMatrix arz, final int[] arindex, final RealMatrix xold) { double negccov = 0; if (ccov1 + ccovmu > 0) { RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu)) .scalarMultiply(1. / sigma); // mu difference vectors RealMatrix roneu = pc.multiply(pc.transpose()) .scalarMultiply(ccov1); // rank one update double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc); oldFac += 1. - ccov1 - ccovmu; if (isActiveCMA) {"
      },
      {
        "txt": "negccov = (1. - ccovmu) * 0.25 * mueff / (Math.pow(dimension + 2., 1.5) + 2. * mueff); double negminresidualvariance = 0.66; double negalphaold = 0.5; // where to make up for the variance int[] arReverseIndex = reverse(arindex); RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu)); RealMatrix arnorms = sqrt(sumRows(square(arzneg))); int[] idxnorms = sortedIndices(arnorms.getRow(0)); RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);"
      },
      {
        "txt": "int[] idxReverse = reverse(idxnorms); RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse); arnorms = divide(arnormsReverse, arnormsSorted); int[] idxInv = inverse(idxnorms); RealMatrix arnormsInv = selectColumns(arnorms, idxInv); double negcovMax = (1. - negminresidualvariance) / square(arnormsInv).multiply(weights).getEntry(0, 0); if (negccov > negcovMax) { negccov = negcovMax; }"
      },
      {
        "txt": "arzneg = times(arzneg, repmat(arnormsInv, dimension, 1)); RealMatrix artmp = BD.multiply(arzneg); RealMatrix Cneg = artmp.multiply(diag(weights)).multiply( artmp.transpose()); oldFac += negalphaold * negccov; C = C.scalarMultiply(oldFac) .add(roneu) .add(arpos.scalarMultiply( ccovmu + (1. - negalphaold) * negccov) .multiply("
      },
      {
        "txt": "times(repmat(weights, 1, dimension), arpos.transpose()))) .subtract(Cneg.scalarMultiply(negccov)); } else { C = C.scalarMultiply(oldFac) // regard old matrix .add(roneu) .add(arpos.scalarMultiply(ccovmu) // plus rank mu update .multiply( times(repmat(weights, 1, dimension), arpos.transpose())));"
      },
      {
        "txt": "} } updateBD(negccov); } private void updateBD(double negccov) { if (ccov1 + ccovmu + negccov > 0 && (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) { C = triu(C, 0).add(triu(C, 1).transpose()); EigenDecomposition eig = new EigenDecomposition(C); B = eig.getV(); // eigen decomposition, B==normalized eigenvectors"
      },
      {
        "txt": "D = eig.getD(); diagD = diag(D); if (min(diagD) <= 0) { for (int i = 0; i < dimension; i++) { if (diagD.getEntry(i, 0) < 0) { diagD.setEntry(i, 0, 0.); } } double tfac = max(diagD) / 1e14; C = C.add(eye(dimension, dimension).scalarMultiply(tfac));"
      },
      {
        "txt": "diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } if (max(diagD) > 1e14 * min(diagD)) { double tfac = max(diagD) / 1e14 - min(diagD); C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } diagC = diag(C); diagD = sqrt(diagD); // D contains standard deviations now BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)"
      },
      {
        "txt": "} } private static void push(double[] vals, double val) { for (int i = vals.length-1; i > 0; i--) { vals[i] = vals[i-1]; } vals[0] = val; } private int[] sortedIndices(final double[] doubles) { DoubleIndex[] dis = new DoubleIndex[doubles.length];"
      },
      {
        "txt": "for (int i = 0; i < doubles.length; i++) { dis[i] = new DoubleIndex(doubles[i], i); } Arrays.sort(dis); int[] indices = new int[doubles.length]; for (int i = 0; i < doubles.length; i++) { indices[i] = dis[i].index; } return indices; }"
      },
      {
        "txt": "private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index; DoubleIndex(double value, int index) { this.value = value; this.index = index; } public int compareTo(DoubleIndex o) { return Double.compare(value, o.value); }"
      },
      {
        "txt": "@Override public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof DoubleIndex) { return Double.compare(value, ((DoubleIndex) other).value) == 0; } return false; }"
      },
      {
        "txt": "@Override public int hashCode() { long bits = Double.doubleToLongBits(value); return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff); } } private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction() {"
      },
      {
        "txt": "valueRange = 1.0; isRepairMode = true; } public double[] encode(final double[] x) { if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i];"
      },
      {
        "txt": "res[i] = (x[i] - boundaries[0][i]) / diff; } return res; } public double[] repairAndDecode(final double[] x) { return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); } public double[] decode(final double[] x) {"
      },
      {
        "txt": "if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i] + boundaries[0][i]; } return res; }"
      },
      {
        "txt": "public double value(final double[] point) { double value; if (boundaries != null && isRepairMode) { double[] repaired = repair(point); value = CMAESOptimizer.this .computeObjectiveValue(decode(repaired)) + penalty(point, repaired); } else { value = CMAESOptimizer.this .computeObjectiveValue(decode(point));"
      },
      {
        "txt": "return isMinimize ? value : -value; } public boolean isFeasible(final double[] x) { if (boundaries == null) { return true; } <extra_id_0> for (int i = 0; i < x.length; i++) { if (x[i] < 0) { return false; } if (x[i] > 1.0) { return false;"
      },
      {
        "txt": "if (x[i] > 1.0) { return false; } } return true; } public void setValueRange(double valueRange) { this.valueRange = valueRange; } private double[] repair(final double[] x) {"
      },
      {
        "txt": "double[] repaired = new double[x.length]; for (int i = 0; i < x.length; i++) { if (x[i] < 0) { repaired[i] = 0; } else if (x[i] > 1.0) { repaired[i] = 1.0; } else { repaired[i] = x[i]; } }"
      },
      {
        "txt": "return repaired; } private double penalty(final double[] x, final double[] repaired) { double penalty = 0; for (int i = 0; i < x.length; i++) { double diff = Math.abs(x[i] - repaired[i]); penalty += diff * valueRange; } return isMinimize ? penalty : -penalty; }"
      },
      {
        "txt": "} private static RealMatrix log(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.log(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); }"
      },
      {
        "txt": "private static RealMatrix sqrt(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.sqrt(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix square(final RealMatrix m) {"
      },
      {
        "txt": "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); d[r][c] = e * e; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix times(final RealMatrix m, final RealMatrix n) {"
      },
      {
        "txt": "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) * n.getEntry(r, c); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix divide(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];"
      },
      {
        "txt": "for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) / n.getEntry(r, c); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) { double[][] d = new double[m.getRowDimension()][cols.length]; for (int r = 0; r < m.getRowDimension(); r++) {"
      },
      {
        "txt": "for (int c = 0; c < cols.length; c++) { d[r][c] = m.getEntry(r, cols[c]); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix triu(final RealMatrix m, int k) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "d[r][c] = r <= c - k ? m.getEntry(r, c) : 0; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sumRows(final RealMatrix m) { double[][] d = new double[1][m.getColumnDimension()]; for (int c = 0; c < m.getColumnDimension(); c++) { double sum = 0; for (int r = 0; r < m.getRowDimension(); r++) {"
      },
      {
        "txt": "sum += m.getEntry(r, c); } d[0][c] = sum; } return new Array2DRowRealMatrix(d, false); } private static RealMatrix diag(final RealMatrix m) { if (m.getColumnDimension() == 1) { double[][] d = new double[m.getRowDimension()][m.getRowDimension()]; for (int i = 0; i < m.getRowDimension(); i++) {"
      },
      {
        "txt": "d[i][i] = m.getEntry(i, 0); } return new Array2DRowRealMatrix(d, false); } else { double[][] d = new double[m.getRowDimension()][1]; for (int i = 0; i < m.getColumnDimension(); i++) { d[i][0] = m.getEntry(i, i); } return new Array2DRowRealMatrix(d, false); }"
      },
      {
        "txt": "} private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) { for (int i = 0; i < m1.getRowDimension(); i++) { m2.setEntry(i, col2, m1.getEntry(i, col1)); } } private static RealMatrix ones(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { Arrays.fill(d[r], 1.0);"
      },
      {
        "txt": "} return new Array2DRowRealMatrix(d, false); } private static RealMatrix eye(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { if (r < m) { d[r][r] = 1; } }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } private static RealMatrix zeros(int n, int m) { return new Array2DRowRealMatrix(n, m); } private static RealMatrix repmat(final RealMatrix mat, int n, int m) { int rd = mat.getRowDimension(); int cd = mat.getColumnDimension(); double[][] d = new double[n * rd][m * cd]; for (int r = 0; r < n * rd; r++) {"
      },
      {
        "txt": "for (int c = 0; c < m * cd; c++) { d[r][c] = mat.getEntry(r % rd, c % cd); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sequence(double start, double end, double step) { int size = (int) ((end - start) / step + 1); double[][] d = new double[size][1]; double value = start;"
      },
      {
        "txt": "for (int r = 0; r < size; r++) { d[r][0] = value; value += step; } return new Array2DRowRealMatrix(d, false); } private static double max(final RealMatrix m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "double e = m.getEntry(r, c); if (max < e) { max = e; } } } return max; } private static double min(final RealMatrix m) { double min = Double.MAX_VALUE;"
      },
      {
        "txt": "for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); if (min > e) { min = e; } } } return min; }"
      },
      {
        "txt": "private static double max(final double[] m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (max < m[r]) { max = m[r]; } } return max; } private static double min(final double[] m) {"
      },
      {
        "txt": "double min = Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (min > m[r]) { min = m[r]; } } return min; } private static int[] inverse(final int[] indices) { int[] inverse = new int[indices.length];"
      },
      {
        "txt": "for (int i = 0; i < indices.length; i++) { inverse[indices[i]] = i; } return inverse; } private static int[] reverse(final int[] indices) { int[] reverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { reverse[i] = indices[indices.length - i - 1]; }"
      },
      {
        "txt": "return reverse; } private double[] randn(int size) { double[] randn = new double[size]; for (int i = 0; i < size; i++) { randn[i] = random.nextGaussian(); } return randn; } private RealMatrix randn1(int size, int popSize) {"
      },
      {
        "txt": "double[][] d = new double[size][popSize]; for (int r = 0; r < size; r++) { for (int c = 0; c < popSize; c++) { d[r][c] = random.nextGaussian(); } } return new Array2DRowRealMatrix(d, false); }"
      }
    ]
  },
  {
    "id": 2509,
    "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
    "start-bug-line": 992,
    "end-bug-line": 992,
    "bug": "if (x[i] < 0) {",
    "fix": "if (x[i] < bLoEnc[i]) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.optimization.direct; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException;"
      },
      {
        "txt": "import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.util.LocalizedFormats; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.EigenDecomposition; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.ConvergenceChecker; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.MultivariateOptimizer;"
      },
      {
        "txt": "import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimpleValueChecker; import org.apache.commons.math3.random.MersenneTwister; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.util.MathArrays; public class CMAESOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int DEFAULT_CHECKFEASABLECOUNT = 0; public static final double DEFAULT_STOPFITNESS = 0;"
      },
      {
        "txt": "public static final boolean DEFAULT_ISACTIVECMA = true; public static final int DEFAULT_MAXITERATIONS = 30000; public static final int DEFAULT_DIAGONALONLY = 0; public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister(); private int lambda; // population size private boolean isActiveCMA; private int checkFeasableCount; private double[][] boundaries; private double[] inputSigma; private int dimension;"
      },
      {
        "txt": "private int diagonalOnly = 0; private boolean isMinimize = true; private boolean generateStatistics = false; private int maxIterations; private double stopFitness; private double stopTolUpX; private double stopTolX; private double stopTolFun; private double stopTolHistFun; private int mu; //"
      },
      {
        "txt": "private double logMu2; private RealMatrix weights; private double mueff; // private double sigma; private double cc; private double cs; private double damps; private double ccov1; private double ccovmu; private double chiN;"
      },
      {
        "txt": "private double ccov1Sep; private double ccovmuSep; private RealMatrix xmean; private RealMatrix pc; private RealMatrix ps; private double normps; private RealMatrix B; private RealMatrix D; private RealMatrix BD; private RealMatrix diagD;"
      },
      {
        "txt": "private RealMatrix C; private RealMatrix diagC; private int iterations; private double[] fitnessHistory; private int historySize; private RandomGenerator random; private List<Double> statisticsSigmaHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>(); private List<Double> statisticsFitnessHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>();"
      },
      {
        "txt": "public CMAESOptimizer() { this(0); } public CMAESOptimizer(int lambda) { this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } public CMAESOptimizer(int lambda, double[] inputSigma) { this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,"
      },
      {
        "txt": "DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } @Deprecated public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) { this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA, diagonalOnly, checkFeasableCount, random, generateStatistics,"
      },
      {
        "txt": "new SimpleValueChecker()); } public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) { super(checker); this.lambda = lambda; this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();"
      },
      {
        "txt": "this.maxIterations = maxIterations; this.stopFitness = stopFitness; this.isActiveCMA = isActiveCMA; this.diagonalOnly = diagonalOnly; this.checkFeasableCount = checkFeasableCount; this.random = random; this.generateStatistics = generateStatistics; } public List<Double> getStatisticsSigmaHistory() { return statisticsSigmaHistory;"
      },
      {
        "txt": "} public List<RealMatrix> getStatisticsMeanHistory() { return statisticsMeanHistory; } public List<Double> getStatisticsFitnessHistory() { return statisticsFitnessHistory; } public List<RealMatrix> getStatisticsDHistory() { return statisticsDHistory; }"
      },
      {
        "txt": "@Override protected PointValuePair doOptimize() { checkParameters(); isMinimize = getGoalType().equals(GoalType.MINIMIZE); final FitnessFunction fitfun = new FitnessFunction(); final double[] guess = fitfun.encode(getStartPoint()); dimension = guess.length; initializeCMA(guess); iterations = 0; double bestValue = fitfun.value(guess);"
      },
      {
        "txt": "push(fitnessHistory, bestValue); PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue); PointValuePair lastResult = null; generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { RealMatrix arz = randn1(dimension, lambda); RealMatrix arx = zeros(dimension, lambda); double[] fitness = new double[lambda]; for (int k = 0; k < lambda; k++) {"
      },
      {
        "txt": "RealMatrix arxk = null; for (int i = 0; i < checkFeasableCount+1; i++) { if (diagonalOnly <= 0) { arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)) .scalarMultiply(sigma)); // m + sig * Normal(0,C) } else { arxk = xmean.add(times(diagD,arz.getColumnMatrix(k)) .scalarMultiply(sigma)); } if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {"
      },
      {
        "txt": "break; } arz.setColumn(k, randn(dimension)); } copyColumn(arxk, 0, arx, k); try { fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness } catch (TooManyEvaluationsException e) { break generationLoop; }"
      },
      {
        "txt": "} int[] arindex = sortedIndices(fitness); RealMatrix xold = xmean; // for speed up of Eq. (2) and (3) RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu)); xmean = bestArx.multiply(weights); RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu)); RealMatrix zmean = bestArz.multiply(weights); boolean hsig = updateEvolutionPaths(zmean, xold); if (diagonalOnly <= 0) { updateCovariance(hsig, bestArx, arz, arindex, xold);"
      },
      {
        "txt": "} else { updateCovarianceDiagonalOnly(hsig, bestArz, xold); } sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps)); double bestFitness = fitness[arindex[0]]; double worstFitness = fitness[arindex[arindex.length-1]]; if (bestValue > bestFitness) { bestValue = bestFitness; lastResult = optimum; optimum = new PointValuePair("
      },
      {
        "txt": "fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness); if (getConvergenceChecker() != null && lastResult != null) { if (getConvergenceChecker().converged(iterations, optimum, lastResult)) { break generationLoop; } } } if (stopFitness != 0) { // only if stopFitness is defined if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {"
      },
      {
        "txt": "break generationLoop; } } double[] sqrtDiagC = sqrt(diagC).getColumn(0); double[] pcCol = pc.getColumn(0); for (int i = 0; i < dimension; i++) { if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) { break; } if (i >= dimension-1) {"
      },
      {
        "txt": "break generationLoop; } } for (int i = 0; i < dimension; i++) { if (sigma*sqrtDiagC[i] > stopTolUpX) { break generationLoop; } } double historyBest = min(fitnessHistory); double historyWorst = max(fitnessHistory);"
      },
      {
        "txt": "if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) { break generationLoop; } if (iterations > fitnessHistory.length && historyWorst-historyBest < stopTolHistFun) { break generationLoop; } if (max(diagD)/min(diagD) > 1e7) { break generationLoop;"
      },
      {
        "txt": "} if (getConvergenceChecker() != null) { PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { break generationLoop; } lastResult = current;"
      },
      {
        "txt": "} if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { sigma = sigma * Math.exp(0.2+cs/damps); } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); } push(fitnessHistory,bestFitness); fitfun.setValueRange(worstFitness-bestFitness);"
      },
      {
        "txt": "if (generateStatistics) { statisticsSigmaHistory.add(sigma); statisticsFitnessHistory.add(bestFitness); statisticsMeanHistory.add(xmean.transpose()); statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5)); } } return optimum; } private void checkParameters() {"
      },
      {
        "txt": "final double[] init = getStartPoint(); final double[] lB = getLowerBound(); final double[] uB = getUpperBound(); boolean hasFiniteBounds = false; for (int i = 0; i < lB.length; i++) { if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) { hasFiniteBounds = true; break; }"
      },
      {
        "txt": "} boolean hasInfiniteBounds = false; if (hasFiniteBounds) { for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) { hasInfiniteBounds = true; break; } }"
      },
      {
        "txt": "if (hasInfiniteBounds) { throw new MathUnsupportedOperationException(); } else { boundaries = new double[2][]; boundaries[0] = lB; boundaries[1] = uB; for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e"
      },
      {
        "txt": "= new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } } } } else {"
      },
      {
        "txt": "boundaries = null; } if (inputSigma != null) { if (inputSigma.length != init.length) { throw new DimensionMismatchException(inputSigma.length, init.length); } for (int i = 0; i < init.length; i++) { if (inputSigma[i] < 0) { throw new NotPositiveException(inputSigma[i]); }"
      },
      {
        "txt": "if (boundaries != null) { if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) { throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]); } } } } } private void initializeCMA(double[] guess) { if (lambda <= 0) {"
      },
      {
        "txt": "lambda = 4 + (int) (3. * Math.log(dimension)); } double[][] sigmaArray = new double[guess.length][1]; for (int i = 0; i < guess.length; i++) { final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i]; sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range; } RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false); sigma = max(insigma); // overall standard deviation stopTolUpX = 1e3 * max(insigma);"
      },
      {
        "txt": "stopTolX = 1e-11 * max(insigma); stopTolFun = 1e-12; stopTolHistFun = 1e-13; mu = lambda / 2; // number of parents/points for recombination logMu2 = Math.log(mu + 0.5); weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2); double sumw = 0; double sumwq = 0; for (int i = 0; i < mu; i++) { double w = weights.getEntry(i, 0);"
      },
      {
        "txt": "sumw += w; sumwq += w * w; } weights = weights.scalarMultiply(1. / sumw); mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i cc = (4. + mueff / dimension) / (dimension + 4. + 2. * mueff / dimension); cs = (mueff + 2.) / (dimension + mueff + 3.); damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) / (dimension + 1.)) - 1.)) *"
      },
      {
        "txt": "Math.max(0.3, 1. - dimension / (1e-6 + Math.min(maxIterations, getMaxEvaluations() / lambda))) + cs; // minor increment ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff); ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) / ((dimension + 2.) * (dimension + 2.) + mueff)); ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.); ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.); chiN = Math.sqrt(dimension) * (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));"
      },
      {
        "txt": "xmean = MatrixUtils.createColumnRealMatrix(guess); // objective diagD = insigma.scalarMultiply(1. / sigma); diagC = square(diagD); pc = zeros(dimension, 1); // evolution paths for C and sigma ps = zeros(dimension, 1); // B defines the coordinate system normps = ps.getFrobeniusNorm(); B = eye(dimension, dimension); D = ones(dimension, 1); // diagonal D defines the scaling BD = times(B, repmat(diagD.transpose(), dimension, 1)); C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance"
      },
      {
        "txt": "historySize = 10 + (int) (3. * 10. * dimension / lambda); fitnessHistory = new double[historySize]; // history of fitness values for (int i = 0; i < historySize; i++) { fitnessHistory[i] = Double.MAX_VALUE; } } private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) { ps = ps.scalarMultiply(1. - cs).add( B.multiply(zmean).scalarMultiply( Math.sqrt(cs * (2. - cs) * mueff)));"
      },
      {
        "txt": "normps = ps.getFrobeniusNorm(); boolean hsig = normps / Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) / chiN < 1.4 + 2. / (dimension + 1.); pc = pc.scalarMultiply(1. - cc); if (hsig) { pc = pc.add(xmean.subtract(xold).scalarMultiply( Math.sqrt(cc * (2. - cc) * mueff) / sigma)); } return hsig;"
      },
      {
        "txt": "} private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz, final RealMatrix xold) { double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc); oldFac += 1. - ccov1Sep - ccovmuSep; diagC = diagC.scalarMultiply(oldFac) // regard old matrix .add(square(pc).scalarMultiply(ccov1Sep)) .add((times(diagC, square(bestArz).multiply(weights))) .scalarMultiply(ccovmuSep));"
      },
      {
        "txt": "diagD = sqrt(diagC); // replaces eig(C) if (diagonalOnly > 1 && iterations > diagonalOnly) { diagonalOnly = 0; B = eye(dimension, dimension); BD = diag(diagD); C = diag(diagC); } } private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold) {"
      },
      {
        "txt": "double negccov = 0; if (ccov1 + ccovmu > 0) { RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu)) .scalarMultiply(1. / sigma); // mu difference vectors RealMatrix roneu = pc.multiply(pc.transpose()) .scalarMultiply(ccov1); // rank one update double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc); oldFac += 1. - ccov1 - ccovmu; if (isActiveCMA) { negccov = (1. - ccovmu) * 0.25 * mueff /"
      },
      {
        "txt": "(Math.pow(dimension + 2., 1.5) + 2. * mueff); double negminresidualvariance = 0.66; double negalphaold = 0.5; // where to make up for the variance int[] arReverseIndex = reverse(arindex); RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu)); RealMatrix arnorms = sqrt(sumRows(square(arzneg))); int[] idxnorms = sortedIndices(arnorms.getRow(0)); RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms); int[] idxReverse = reverse(idxnorms);"
      },
      {
        "txt": "RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse); arnorms = divide(arnormsReverse, arnormsSorted); int[] idxInv = inverse(idxnorms); RealMatrix arnormsInv = selectColumns(arnorms, idxInv); double negcovMax = (1. - negminresidualvariance) / square(arnormsInv).multiply(weights).getEntry(0, 0); if (negccov > negcovMax) { negccov = negcovMax; } arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));"
      },
      {
        "txt": "RealMatrix artmp = BD.multiply(arzneg); RealMatrix Cneg = artmp.multiply(diag(weights)).multiply( artmp.transpose()); oldFac += negalphaold * negccov; C = C.scalarMultiply(oldFac) .add(roneu) .add(arpos.scalarMultiply( ccovmu + (1. - negalphaold) * negccov) .multiply( times(repmat(weights, 1, dimension),"
      },
      {
        "txt": "arpos.transpose()))) .subtract(Cneg.scalarMultiply(negccov)); } else { C = C.scalarMultiply(oldFac) // regard old matrix .add(roneu) .add(arpos.scalarMultiply(ccovmu) // plus rank mu update .multiply( times(repmat(weights, 1, dimension), arpos.transpose()))); }"
      },
      {
        "txt": "} updateBD(negccov); } private void updateBD(double negccov) { if (ccov1 + ccovmu + negccov > 0 && (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) { C = triu(C, 0).add(triu(C, 1).transpose()); EigenDecomposition eig = new EigenDecomposition(C); B = eig.getV(); // eigen decomposition, B==normalized eigenvectors D = eig.getD();"
      },
      {
        "txt": "diagD = diag(D); if (min(diagD) <= 0) { for (int i = 0; i < dimension; i++) { if (diagD.getEntry(i, 0) < 0) { diagD.setEntry(i, 0, 0.); } } double tfac = max(diagD) / 1e14; C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));"
      },
      {
        "txt": "} if (max(diagD) > 1e14 * min(diagD)) { double tfac = max(diagD) / 1e14 - min(diagD); C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } diagC = diag(C); diagD = sqrt(diagD); // D contains standard deviations now BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2) }"
      },
      {
        "txt": "} private static void push(double[] vals, double val) { for (int i = vals.length-1; i > 0; i--) { vals[i] = vals[i-1]; } vals[0] = val; } private int[] sortedIndices(final double[] doubles) { DoubleIndex[] dis = new DoubleIndex[doubles.length]; for (int i = 0; i < doubles.length; i++) {"
      },
      {
        "txt": "dis[i] = new DoubleIndex(doubles[i], i); } Arrays.sort(dis); int[] indices = new int[doubles.length]; for (int i = 0; i < doubles.length; i++) { indices[i] = dis[i].index; } return indices; } private static class DoubleIndex implements Comparable<DoubleIndex> {"
      },
      {
        "txt": "private double value; private int index; DoubleIndex(double value, int index) { this.value = value; this.index = index; } public int compareTo(DoubleIndex o) { return Double.compare(value, o.value); } @Override"
      },
      {
        "txt": "public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof DoubleIndex) { return Double.compare(value, ((DoubleIndex) other).value) == 0; } return false; } @Override"
      },
      {
        "txt": "public int hashCode() { long bits = Double.doubleToLongBits(value); return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff); } } private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction() { valueRange = 1.0;"
      },
      {
        "txt": "isRepairMode = true; } public double[] encode(final double[] x) { if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = (x[i] - boundaries[0][i]) / diff;"
      },
      {
        "txt": "} return res; } public double[] repairAndDecode(final double[] x) { return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); } public double[] decode(final double[] x) { if (boundaries == null) {"
      },
      {
        "txt": "return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i] + boundaries[0][i]; } return res; } public double value(final double[] point) {"
      },
      {
        "txt": "double value; if (boundaries != null && isRepairMode) { double[] repaired = repair(point); value = CMAESOptimizer.this .computeObjectiveValue(decode(repaired)) + penalty(point, repaired); } else { value = CMAESOptimizer.this .computeObjectiveValue(decode(point)); }"
      },
      {
        "txt": "} public boolean isFeasible(final double[] x) { if (boundaries == null) { return true; } for (int i = 0; i < x.length; i++) { <extra_id_0> return false; } if (x[i] > 1.0) { return false; } }"
      },
      {
        "txt": "} } return true; } public void setValueRange(double valueRange) { this.valueRange = valueRange; } private double[] repair(final double[] x) { double[] repaired = new double[x.length]; for (int i = 0; i < x.length; i++) {"
      },
      {
        "txt": "if (x[i] < 0) { repaired[i] = 0; } else if (x[i] > 1.0) { repaired[i] = 1.0; } else { repaired[i] = x[i]; } } return repaired; }"
      },
      {
        "txt": "private double penalty(final double[] x, final double[] repaired) { double penalty = 0; for (int i = 0; i < x.length; i++) { double diff = Math.abs(x[i] - repaired[i]); penalty += diff * valueRange; } return isMinimize ? penalty : -penalty; } } private static RealMatrix log(final RealMatrix m) {"
      },
      {
        "txt": "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.log(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sqrt(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];"
      },
      {
        "txt": "for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.sqrt(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix square(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) {"
      },
      {
        "txt": "for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); d[r][c] = e * e; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix times(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) {"
      },
      {
        "txt": "for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) * n.getEntry(r, c); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix divide(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "d[r][c] = m.getEntry(r, c) / n.getEntry(r, c); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) { double[][] d = new double[m.getRowDimension()][cols.length]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < cols.length; c++) { d[r][c] = m.getEntry(r, cols[c]);"
      },
      {
        "txt": "} } return new Array2DRowRealMatrix(d, false); } private static RealMatrix triu(final RealMatrix m, int k) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = r <= c - k ? m.getEntry(r, c) : 0; }"
      },
      {
        "txt": "} return new Array2DRowRealMatrix(d, false); } private static RealMatrix sumRows(final RealMatrix m) { double[][] d = new double[1][m.getColumnDimension()]; for (int c = 0; c < m.getColumnDimension(); c++) { double sum = 0; for (int r = 0; r < m.getRowDimension(); r++) { sum += m.getEntry(r, c); }"
      },
      {
        "txt": "d[0][c] = sum; } return new Array2DRowRealMatrix(d, false); } private static RealMatrix diag(final RealMatrix m) { if (m.getColumnDimension() == 1) { double[][] d = new double[m.getRowDimension()][m.getRowDimension()]; for (int i = 0; i < m.getRowDimension(); i++) { d[i][i] = m.getEntry(i, 0); }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } else { double[][] d = new double[m.getRowDimension()][1]; for (int i = 0; i < m.getColumnDimension(); i++) { d[i][0] = m.getEntry(i, i); } return new Array2DRowRealMatrix(d, false); } } private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) {"
      },
      {
        "txt": "for (int i = 0; i < m1.getRowDimension(); i++) { m2.setEntry(i, col2, m1.getEntry(i, col1)); } } private static RealMatrix ones(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { Arrays.fill(d[r], 1.0); } return new Array2DRowRealMatrix(d, false);"
      },
      {
        "txt": "} private static RealMatrix eye(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { if (r < m) { d[r][r] = 1; } } return new Array2DRowRealMatrix(d, false); }"
      },
      {
        "txt": "private static RealMatrix zeros(int n, int m) { return new Array2DRowRealMatrix(n, m); } private static RealMatrix repmat(final RealMatrix mat, int n, int m) { int rd = mat.getRowDimension(); int cd = mat.getColumnDimension(); double[][] d = new double[n * rd][m * cd]; for (int r = 0; r < n * rd; r++) { for (int c = 0; c < m * cd; c++) { d[r][c] = mat.getEntry(r % rd, c % cd);"
      },
      {
        "txt": "} } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sequence(double start, double end, double step) { int size = (int) ((end - start) / step + 1); double[][] d = new double[size][1]; double value = start; for (int r = 0; r < size; r++) { d[r][0] = value;"
      },
      {
        "txt": "value += step; } return new Array2DRowRealMatrix(d, false); } private static double max(final RealMatrix m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); if (max < e) {"
      },
      {
        "txt": "max = e; } } } return max; } private static double min(final RealMatrix m) { double min = Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "double e = m.getEntry(r, c); if (min > e) { min = e; } } } return min; } private static double max(final double[] m) { double max = -Double.MAX_VALUE;"
      },
      {
        "txt": "for (int r = 0; r < m.length; r++) { if (max < m[r]) { max = m[r]; } } return max; } private static double min(final double[] m) { double min = Double.MAX_VALUE; for (int r = 0; r < m.length; r++) {"
      },
      {
        "txt": "if (min > m[r]) { min = m[r]; } } return min; } private static int[] inverse(final int[] indices) { int[] inverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { inverse[indices[i]] = i;"
      },
      {
        "txt": "} return inverse; } private static int[] reverse(final int[] indices) { int[] reverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { reverse[i] = indices[indices.length - i - 1]; } return reverse; }"
      },
      {
        "txt": "private double[] randn(int size) { double[] randn = new double[size]; for (int i = 0; i < size; i++) { randn[i] = random.nextGaussian(); } return randn; } private RealMatrix randn1(int size, int popSize) { double[][] d = new double[size][popSize]; for (int r = 0; r < size; r++) {"
      },
      {
        "txt": "for (int c = 0; c < popSize; c++) { d[r][c] = random.nextGaussian(); } } return new Array2DRowRealMatrix(d, false); }"
      }
    ]
  },
  {
    "id": 2510,
    "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
    "start-bug-line": 995,
    "end-bug-line": 995,
    "bug": "if (x[i] > 1.0) {",
    "fix": "if (x[i] > bHiEnc[i]) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.math3.optimization.direct; import java.util.ArrayList;"
      },
      {
        "txt": "import java.util.Arrays; import java.util.List; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.util.LocalizedFormats;"
      },
      {
        "txt": "import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.EigenDecomposition; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.ConvergenceChecker; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.MultivariateOptimizer; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimpleValueChecker; import org.apache.commons.math3.random.MersenneTwister;"
      },
      {
        "txt": "import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.util.MathArrays; public class CMAESOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int DEFAULT_CHECKFEASABLECOUNT = 0; public static final double DEFAULT_STOPFITNESS = 0; public static final boolean DEFAULT_ISACTIVECMA = true; public static final int DEFAULT_MAXITERATIONS = 30000; public static final int DEFAULT_DIAGONALONLY = 0;"
      },
      {
        "txt": "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister(); private int lambda; // population size private boolean isActiveCMA; private int checkFeasableCount; private double[][] boundaries; private double[] inputSigma; private int dimension; private int diagonalOnly = 0; private boolean isMinimize = true; private boolean generateStatistics = false;"
      },
      {
        "txt": "private int maxIterations; private double stopFitness; private double stopTolUpX; private double stopTolX; private double stopTolFun; private double stopTolHistFun; private int mu; // private double logMu2; private RealMatrix weights; private double mueff; //"
      },
      {
        "txt": "private double sigma; private double cc; private double cs; private double damps; private double ccov1; private double ccovmu; private double chiN; private double ccov1Sep; private double ccovmuSep; private RealMatrix xmean;"
      },
      {
        "txt": "private RealMatrix pc; private RealMatrix ps; private double normps; private RealMatrix B; private RealMatrix D; private RealMatrix BD; private RealMatrix diagD; private RealMatrix C; private RealMatrix diagC; private int iterations;"
      },
      {
        "txt": "private double[] fitnessHistory; private int historySize; private RandomGenerator random; private List<Double> statisticsSigmaHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>(); private List<Double> statisticsFitnessHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>(); public CMAESOptimizer() { this(0); }"
      },
      {
        "txt": "public CMAESOptimizer(int lambda) { this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } public CMAESOptimizer(int lambda, double[] inputSigma) { this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); }"
      },
      {
        "txt": "@Deprecated public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) { this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA, diagonalOnly, checkFeasableCount, random, generateStatistics, new SimpleValueChecker()); } public CMAESOptimizer(int lambda, double[] inputSigma,"
      },
      {
        "txt": "int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) { super(checker); this.lambda = lambda; this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone(); this.maxIterations = maxIterations; this.stopFitness = stopFitness; this.isActiveCMA = isActiveCMA;"
      },
      {
        "txt": "this.diagonalOnly = diagonalOnly; this.checkFeasableCount = checkFeasableCount; this.random = random; this.generateStatistics = generateStatistics; } public List<Double> getStatisticsSigmaHistory() { return statisticsSigmaHistory; } public List<RealMatrix> getStatisticsMeanHistory() { return statisticsMeanHistory;"
      },
      {
        "txt": "} public List<Double> getStatisticsFitnessHistory() { return statisticsFitnessHistory; } public List<RealMatrix> getStatisticsDHistory() { return statisticsDHistory; } @Override protected PointValuePair doOptimize() { checkParameters();"
      },
      {
        "txt": "isMinimize = getGoalType().equals(GoalType.MINIMIZE); final FitnessFunction fitfun = new FitnessFunction(); final double[] guess = fitfun.encode(getStartPoint()); dimension = guess.length; initializeCMA(guess); iterations = 0; double bestValue = fitfun.value(guess); push(fitnessHistory, bestValue); PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);"
      },
      {
        "txt": "PointValuePair lastResult = null; generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { RealMatrix arz = randn1(dimension, lambda); RealMatrix arx = zeros(dimension, lambda); double[] fitness = new double[lambda]; for (int k = 0; k < lambda; k++) { RealMatrix arxk = null; for (int i = 0; i < checkFeasableCount+1; i++) { if (diagonalOnly <= 0) {"
      },
      {
        "txt": "arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)) .scalarMultiply(sigma)); // m + sig * Normal(0,C) } else { arxk = xmean.add(times(diagD,arz.getColumnMatrix(k)) .scalarMultiply(sigma)); } if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) { break; } arz.setColumn(k, randn(dimension));"
      },
      {
        "txt": "} copyColumn(arxk, 0, arx, k); try { fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness } catch (TooManyEvaluationsException e) { break generationLoop; } } int[] arindex = sortedIndices(fitness); RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)"
      },
      {
        "txt": "RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu)); xmean = bestArx.multiply(weights); RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu)); RealMatrix zmean = bestArz.multiply(weights); boolean hsig = updateEvolutionPaths(zmean, xold); if (diagonalOnly <= 0) { updateCovariance(hsig, bestArx, arz, arindex, xold); } else { updateCovarianceDiagonalOnly(hsig, bestArz, xold); }"
      },
      {
        "txt": "sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps)); double bestFitness = fitness[arindex[0]]; double worstFitness = fitness[arindex[arindex.length-1]]; if (bestValue > bestFitness) { bestValue = bestFitness; lastResult = optimum; optimum = new PointValuePair( fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness); if (getConvergenceChecker() != null && lastResult != null) {"
      },
      {
        "txt": "if (getConvergenceChecker().converged(iterations, optimum, lastResult)) { break generationLoop; } } } if (stopFitness != 0) { // only if stopFitness is defined if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) { break generationLoop; } }"
      },
      {
        "txt": "double[] sqrtDiagC = sqrt(diagC).getColumn(0); double[] pcCol = pc.getColumn(0); for (int i = 0; i < dimension; i++) { if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) { break; } if (i >= dimension-1) { break generationLoop; } }"
      },
      {
        "txt": "for (int i = 0; i < dimension; i++) { if (sigma*sqrtDiagC[i] > stopTolUpX) { break generationLoop; } } double historyBest = min(fitnessHistory); double historyWorst = max(fitnessHistory); if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) { break generationLoop;"
      },
      {
        "txt": "} if (iterations > fitnessHistory.length && historyWorst-historyBest < stopTolHistFun) { break generationLoop; } if (max(diagD)/min(diagD) > 1e7) { break generationLoop; } if (getConvergenceChecker() != null) { PointValuePair current ="
      },
      {
        "txt": "new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { break generationLoop; } lastResult = current; } if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { sigma = sigma * Math.exp(0.2+cs/damps);"
      },
      {
        "txt": "} if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); } push(fitnessHistory,bestFitness); fitfun.setValueRange(worstFitness-bestFitness); if (generateStatistics) { statisticsSigmaHistory.add(sigma); statisticsFitnessHistory.add(bestFitness);"
      },
      {
        "txt": "statisticsMeanHistory.add(xmean.transpose()); statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5)); } } return optimum; } private void checkParameters() { final double[] init = getStartPoint(); final double[] lB = getLowerBound(); final double[] uB = getUpperBound();"
      },
      {
        "txt": "boolean hasFiniteBounds = false; for (int i = 0; i < lB.length; i++) { if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) { hasFiniteBounds = true; break; } } boolean hasInfiniteBounds = false; if (hasFiniteBounds) {"
      },
      {
        "txt": "for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) { hasInfiniteBounds = true; break; } } if (hasInfiniteBounds) { throw new MathUnsupportedOperationException(); } else {"
      },
      {
        "txt": "boundaries = new double[2][]; boundaries[0] = lB; boundaries[1] = uB; for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);"
      },
      {
        "txt": "e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } } } } else { boundaries = null; } if (inputSigma != null) {"
      },
      {
        "txt": "if (inputSigma.length != init.length) { throw new DimensionMismatchException(inputSigma.length, init.length); } for (int i = 0; i < init.length; i++) { if (inputSigma[i] < 0) { throw new NotPositiveException(inputSigma[i]); } if (boundaries != null) { if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) { throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);"
      },
      {
        "txt": "} } } } } private void initializeCMA(double[] guess) { if (lambda <= 0) { lambda = 4 + (int) (3. * Math.log(dimension)); } double[][] sigmaArray = new double[guess.length][1];"
      },
      {
        "txt": "for (int i = 0; i < guess.length; i++) { final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i]; sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range; } RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false); sigma = max(insigma); // overall standard deviation stopTolUpX = 1e3 * max(insigma); stopTolX = 1e-11 * max(insigma); stopTolFun = 1e-12; stopTolHistFun = 1e-13;"
      },
      {
        "txt": "mu = lambda / 2; // number of parents/points for recombination logMu2 = Math.log(mu + 0.5); weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2); double sumw = 0; double sumwq = 0; for (int i = 0; i < mu; i++) { double w = weights.getEntry(i, 0); sumw += w; sumwq += w * w; }"
      },
      {
        "txt": "weights = weights.scalarMultiply(1. / sumw); mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i cc = (4. + mueff / dimension) / (dimension + 4. + 2. * mueff / dimension); cs = (mueff + 2.) / (dimension + mueff + 3.); damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) / (dimension + 1.)) - 1.)) * Math.max(0.3, 1. - dimension / (1e-6 + Math.min(maxIterations, getMaxEvaluations() / lambda))) + cs; // minor increment"
      },
      {
        "txt": "ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff); ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) / ((dimension + 2.) * (dimension + 2.) + mueff)); ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.); ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.); chiN = Math.sqrt(dimension) * (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension)); xmean = MatrixUtils.createColumnRealMatrix(guess); // objective diagD = insigma.scalarMultiply(1. / sigma); diagC = square(diagD);"
      },
      {
        "txt": "pc = zeros(dimension, 1); // evolution paths for C and sigma ps = zeros(dimension, 1); // B defines the coordinate system normps = ps.getFrobeniusNorm(); B = eye(dimension, dimension); D = ones(dimension, 1); // diagonal D defines the scaling BD = times(B, repmat(diagD.transpose(), dimension, 1)); C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance historySize = 10 + (int) (3. * 10. * dimension / lambda); fitnessHistory = new double[historySize]; // history of fitness values for (int i = 0; i < historySize; i++) {"
      },
      {
        "txt": "fitnessHistory[i] = Double.MAX_VALUE; } } private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) { ps = ps.scalarMultiply(1. - cs).add( B.multiply(zmean).scalarMultiply( Math.sqrt(cs * (2. - cs) * mueff))); normps = ps.getFrobeniusNorm(); boolean hsig = normps / Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /"
      },
      {
        "txt": "chiN < 1.4 + 2. / (dimension + 1.); pc = pc.scalarMultiply(1. - cc); if (hsig) { pc = pc.add(xmean.subtract(xold).scalarMultiply( Math.sqrt(cc * (2. - cc) * mueff) / sigma)); } return hsig; } private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz,"
      },
      {
        "txt": "final RealMatrix xold) { double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc); oldFac += 1. - ccov1Sep - ccovmuSep; diagC = diagC.scalarMultiply(oldFac) // regard old matrix .add(square(pc).scalarMultiply(ccov1Sep)) .add((times(diagC, square(bestArz).multiply(weights))) .scalarMultiply(ccovmuSep)); diagD = sqrt(diagC); // replaces eig(C) if (diagonalOnly > 1 && iterations > diagonalOnly) { diagonalOnly = 0;"
      },
      {
        "txt": "B = eye(dimension, dimension); BD = diag(diagD); C = diag(diagC); } } private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold) { double negccov = 0; if (ccov1 + ccovmu > 0) { RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))"
      },
      {
        "txt": ".scalarMultiply(1. / sigma); // mu difference vectors RealMatrix roneu = pc.multiply(pc.transpose()) .scalarMultiply(ccov1); // rank one update double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc); oldFac += 1. - ccov1 - ccovmu; if (isActiveCMA) { negccov = (1. - ccovmu) * 0.25 * mueff / (Math.pow(dimension + 2., 1.5) + 2. * mueff); double negminresidualvariance = 0.66; double negalphaold = 0.5; // where to make up for the variance"
      },
      {
        "txt": "int[] arReverseIndex = reverse(arindex); RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu)); RealMatrix arnorms = sqrt(sumRows(square(arzneg))); int[] idxnorms = sortedIndices(arnorms.getRow(0)); RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms); int[] idxReverse = reverse(idxnorms); RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse); arnorms = divide(arnormsReverse, arnormsSorted); int[] idxInv = inverse(idxnorms);"
      },
      {
        "txt": "RealMatrix arnormsInv = selectColumns(arnorms, idxInv); double negcovMax = (1. - negminresidualvariance) / square(arnormsInv).multiply(weights).getEntry(0, 0); if (negccov > negcovMax) { negccov = negcovMax; } arzneg = times(arzneg, repmat(arnormsInv, dimension, 1)); RealMatrix artmp = BD.multiply(arzneg); RealMatrix Cneg = artmp.multiply(diag(weights)).multiply( artmp.transpose());"
      },
      {
        "txt": "oldFac += negalphaold * negccov; C = C.scalarMultiply(oldFac) .add(roneu) .add(arpos.scalarMultiply( ccovmu + (1. - negalphaold) * negccov) .multiply( times(repmat(weights, 1, dimension), arpos.transpose()))) .subtract(Cneg.scalarMultiply(negccov)); } else {"
      },
      {
        "txt": "C = C.scalarMultiply(oldFac) // regard old matrix .add(roneu) .add(arpos.scalarMultiply(ccovmu) // plus rank mu update .multiply( times(repmat(weights, 1, dimension), arpos.transpose()))); } } updateBD(negccov); }"
      },
      {
        "txt": "private void updateBD(double negccov) { if (ccov1 + ccovmu + negccov > 0 && (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) { C = triu(C, 0).add(triu(C, 1).transpose()); EigenDecomposition eig = new EigenDecomposition(C); B = eig.getV(); // eigen decomposition, B==normalized eigenvectors D = eig.getD(); diagD = diag(D); if (min(diagD) <= 0) { for (int i = 0; i < dimension; i++) {"
      },
      {
        "txt": "if (diagD.getEntry(i, 0) < 0) { diagD.setEntry(i, 0, 0.); } } double tfac = max(diagD) / 1e14; C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } if (max(diagD) > 1e14 * min(diagD)) { double tfac = max(diagD) / 1e14 - min(diagD);"
      },
      {
        "txt": "C = C.add(eye(dimension, dimension).scalarMultiply(tfac)); diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac)); } diagC = diag(C); diagD = sqrt(diagD); // D contains standard deviations now BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2) } } private static void push(double[] vals, double val) { for (int i = vals.length-1; i > 0; i--) {"
      },
      {
        "txt": "vals[i] = vals[i-1]; } vals[0] = val; } private int[] sortedIndices(final double[] doubles) { DoubleIndex[] dis = new DoubleIndex[doubles.length]; for (int i = 0; i < doubles.length; i++) { dis[i] = new DoubleIndex(doubles[i], i); } Arrays.sort(dis);"
      },
      {
        "txt": "int[] indices = new int[doubles.length]; for (int i = 0; i < doubles.length; i++) { indices[i] = dis[i].index; } return indices; } private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index; DoubleIndex(double value, int index) {"
      },
      {
        "txt": "this.value = value; this.index = index; } public int compareTo(DoubleIndex o) { return Double.compare(value, o.value); } @Override public boolean equals(Object other) { if (this == other) { return true;"
      },
      {
        "txt": "} if (other instanceof DoubleIndex) { return Double.compare(value, ((DoubleIndex) other).value) == 0; } return false; } @Override public int hashCode() { long bits = Double.doubleToLongBits(value); return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);"
      },
      {
        "txt": "} } private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction() { valueRange = 1.0; isRepairMode = true; } public double[] encode(final double[] x) {"
      },
      {
        "txt": "if (boundaries == null) { return x; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = (x[i] - boundaries[0][i]) / diff; } return res; }"
      },
      {
        "txt": "public double[] repairAndDecode(final double[] x) { return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); } public double[] decode(final double[] x) { if (boundaries == null) { return x; } double[] res = new double[x.length];"
      },
      {
        "txt": "for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i] + boundaries[0][i]; } return res; } public double value(final double[] point) { double value; if (boundaries != null && isRepairMode) { double[] repaired = repair(point);"
      },
      {
        "txt": "value = CMAESOptimizer.this .computeObjectiveValue(decode(repaired)) + penalty(point, repaired); } else { value = CMAESOptimizer.this .computeObjectiveValue(decode(point)); } return isMinimize ? value : -value; } public boolean isFeasible(final double[] x) {"
      },
      {
        "txt": "return true; } for (int i = 0; i < x.length; i++) { if (x[i] < 0) { return false; } <extra_id_0> return false; } } return true; } public void setValueRange(double valueRange) {"
      },
      {
        "txt": "} public void setValueRange(double valueRange) { this.valueRange = valueRange; } private double[] repair(final double[] x) { double[] repaired = new double[x.length]; for (int i = 0; i < x.length; i++) { if (x[i] < 0) { repaired[i] = 0; } else if (x[i] > 1.0) {"
      },
      {
        "txt": "repaired[i] = 1.0; } else { repaired[i] = x[i]; } } return repaired; } private double penalty(final double[] x, final double[] repaired) { double penalty = 0; for (int i = 0; i < x.length; i++) {"
      },
      {
        "txt": "double diff = Math.abs(x[i] - repaired[i]); penalty += diff * valueRange; } return isMinimize ? penalty : -penalty; } } private static RealMatrix log(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) {"
      },
      {
        "txt": "d[r][c] = Math.log(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix sqrt(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.sqrt(m.getEntry(r, c));"
      },
      {
        "txt": "} } return new Array2DRowRealMatrix(d, false); } private static RealMatrix square(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); d[r][c] = e * e;"
      },
      {
        "txt": "} } return new Array2DRowRealMatrix(d, false); } private static RealMatrix times(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) * n.getEntry(r, c); }"
      },
      {
        "txt": "} return new Array2DRowRealMatrix(d, false); } private static RealMatrix divide(final RealMatrix m, final RealMatrix n) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = m.getEntry(r, c) / n.getEntry(r, c); } }"
      },
      {
        "txt": "return new Array2DRowRealMatrix(d, false); } private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) { double[][] d = new double[m.getRowDimension()][cols.length]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < cols.length; c++) { d[r][c] = m.getEntry(r, cols[c]); } } return new Array2DRowRealMatrix(d, false);"
      },
      {
        "txt": "} private static RealMatrix triu(final RealMatrix m, int k) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = r <= c - k ? m.getEntry(r, c) : 0; } } return new Array2DRowRealMatrix(d, false); }"
      },
      {
        "txt": "private static RealMatrix sumRows(final RealMatrix m) { double[][] d = new double[1][m.getColumnDimension()]; for (int c = 0; c < m.getColumnDimension(); c++) { double sum = 0; for (int r = 0; r < m.getRowDimension(); r++) { sum += m.getEntry(r, c); } d[0][c] = sum; } return new Array2DRowRealMatrix(d, false);"
      },
      {
        "txt": "} private static RealMatrix diag(final RealMatrix m) { if (m.getColumnDimension() == 1) { double[][] d = new double[m.getRowDimension()][m.getRowDimension()]; for (int i = 0; i < m.getRowDimension(); i++) { d[i][i] = m.getEntry(i, 0); } return new Array2DRowRealMatrix(d, false); } else { double[][] d = new double[m.getRowDimension()][1];"
      },
      {
        "txt": "for (int i = 0; i < m.getColumnDimension(); i++) { d[i][0] = m.getEntry(i, i); } return new Array2DRowRealMatrix(d, false); } } private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) { for (int i = 0; i < m1.getRowDimension(); i++) { m2.setEntry(i, col2, m1.getEntry(i, col1)); }"
      },
      {
        "txt": "} private static RealMatrix ones(int n, int m) { double[][] d = new double[n][m]; for (int r = 0; r < n; r++) { Arrays.fill(d[r], 1.0); } return new Array2DRowRealMatrix(d, false); } private static RealMatrix eye(int n, int m) { double[][] d = new double[n][m];"
      },
      {
        "txt": "for (int r = 0; r < n; r++) { if (r < m) { d[r][r] = 1; } } return new Array2DRowRealMatrix(d, false); } private static RealMatrix zeros(int n, int m) { return new Array2DRowRealMatrix(n, m); }"
      },
      {
        "txt": "private static RealMatrix repmat(final RealMatrix mat, int n, int m) { int rd = mat.getRowDimension(); int cd = mat.getColumnDimension(); double[][] d = new double[n * rd][m * cd]; for (int r = 0; r < n * rd; r++) { for (int c = 0; c < m * cd; c++) { d[r][c] = mat.getEntry(r % rd, c % cd); } } return new Array2DRowRealMatrix(d, false);"
      },
      {
        "txt": "} private static RealMatrix sequence(double start, double end, double step) { int size = (int) ((end - start) / step + 1); double[][] d = new double[size][1]; double value = start; for (int r = 0; r < size; r++) { d[r][0] = value; value += step; } return new Array2DRowRealMatrix(d, false);"
      },
      {
        "txt": "} private static double max(final RealMatrix m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); if (max < e) { max = e; } }"
      },
      {
        "txt": "} return max; } private static double min(final RealMatrix m) { double min = Double.MAX_VALUE; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { double e = m.getEntry(r, c); if (min > e) { min = e;"
      },
      {
        "txt": "} } } return min; } private static double max(final double[] m) { double max = -Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (max < m[r]) { max = m[r];"
      },
      {
        "txt": "} } return max; } private static double min(final double[] m) { double min = Double.MAX_VALUE; for (int r = 0; r < m.length; r++) { if (min > m[r]) { min = m[r]; }"
      },
      {
        "txt": "} return min; } private static int[] inverse(final int[] indices) { int[] inverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { inverse[indices[i]] = i; } return inverse; }"
      },
      {
        "txt": "private static int[] reverse(final int[] indices) { int[] reverse = new int[indices.length]; for (int i = 0; i < indices.length; i++) { reverse[i] = indices[indices.length - i - 1]; } return reverse; } private double[] randn(int size) { double[] randn = new double[size]; for (int i = 0; i < size; i++) {"
      },
      {
        "txt": "randn[i] = random.nextGaussian(); } return randn; } private RealMatrix randn1(int size, int popSize) { double[][] d = new double[size][popSize]; for (int r = 0; r < size; r++) { for (int c = 0; c < popSize; c++) { d[r][c] = random.nextGaussian(); }"
      },
      {
        "txt": "} return new Array2DRowRealMatrix(d, false); }"
      }
    ]
  }
]