[
  {
    "id": 1038,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
    "start-bug-line": 331,
    "end-bug-line": 331,
    "bug": "if (mode != 0){",
    "fix": "if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.cpio; import java.io.EOFException;"
      },
      {
        "txt": "import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.archivers.ArchiveEntry; import org.apache.commons.compress.archivers.ArchiveInputStream; import org.apache.commons.compress.utils.ArchiveUtils; public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0;"
      },
      {
        "txt": "private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; public CpioArchiveInputStream(final InputStream in) { this(in, BLOCK_SIZE);"
      },
      {
        "txt": "} public CpioArchiveInputStream(final InputStream in, int blockSize) { this.in = in; this.blockSize = blockSize; } @Override public int available() throws IOException { ensureOpen(); if (this.entryEOF) { return 0;"
      },
      {
        "txt": "} return 1; } @Override public void close() throws IOException { if (!this.closed) { in.close(); this.closed = true; } }"
      },
      {
        "txt": "private void closeEntry() throws IOException { ensureOpen(); while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD } this.entryEOF = true; } private void ensureOpen() throws IOException { if (this.closed) { throw new IOException(\"Stream closed\"); }"
      },
      {
        "txt": "} public CpioArchiveEntry getNextCPIOEntry() throws IOException { ensureOpen(); if (this.entry != null) { closeEntry(); } readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length); if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(false); } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)"
      },
      {
        "txt": "== MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(true); } else { System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length); readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length); String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF); if (magicString.equals(MAGIC_NEW)) { this.entry = readNewEntry(false);"
      },
      {
        "txt": "} else if (magicString.equals(MAGIC_NEW_CRC)) { this.entry = readNewEntry(true); } else if (magicString.equals(MAGIC_OLD_ASCII)) { this.entry = readOldAsciiEntry(); } else { throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead()); } } this.entryBytesRead = 0; this.entryEOF = false;"
      },
      {
        "txt": "this.crc = 0; if (this.entry.getName().equals(CPIO_TRAILER)) { this.entryEOF = true; skipRemainderOfLastBlock(); return null; } return this.entry; } private void skip(int bytes) throws IOException{ if (bytes > 0) {"
      },
      {
        "txt": "readFully(FOUR_BYTES_BUF, 0, bytes); } } @Override public int read(final byte[] b, final int off, final int len) throws IOException { ensureOpen(); if (off < 0 || len < 0 || off > b.length - len) { throw new IndexOutOfBoundsException(); } else if (len == 0) {"
      },
      {
        "txt": "return 0; } if (this.entry == null || this.entryEOF) { return -1; } if (this.entryBytesRead == this.entry.getSize()) { skip(entry.getDataPadCount()); this.entryEOF = true; if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) {"
      },
      {
        "txt": "throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead()); } return -1; // EOF for this entry } int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead); if (tmplength < 0) { return -1; }"
      },
      {
        "txt": "int tmpread = readFully(b, off, tmplength); if (this.entry.getFormat() == FORMAT_NEW_CRC) { for (int pos = 0; pos < tmpread; pos++) { this.crc += b[pos] & 0xFF; } } this.entryBytesRead += tmpread; return tmpread; } private final int readFully(final byte[] b, final int off, final int len)"
      },
      {
        "txt": "throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(); } int n = 0; while (n < len) { int count = this.in.read(b, off + n, len - n); count(count); if (count < 0) { throw new EOFException();"
      },
      {
        "txt": "} n += count; } return n; } private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException { byte tmp[] = new byte[length]; readFully(tmp, 0, tmp.length); return CpioUtil.byteArray2long(tmp, swapHalfWord);"
      },
      {
        "txt": "} private long readAsciiLong(final int length, final int radix) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix); } private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException { CpioArchiveEntry ret;"
      },
      {
        "txt": "ret = new CpioArchiveEntry(FORMAT_NEW_CRC); } else { ret = new CpioArchiveEntry(FORMAT_NEW); } ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); <extra_id_0> ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16)); ret.setGID(readAsciiLong(8, 16)); ret.setNumberOfLinks(readAsciiLong(8, 16)); ret.setTime(readAsciiLong(8, 16));"
      },
      {
        "txt": "ret.setNumberOfLinks(readAsciiLong(8, 16)); ret.setTime(readAsciiLong(8, 16)); ret.setSize(readAsciiLong(8, 16)); ret.setDeviceMaj(readAsciiLong(8, 16)); ret.setDeviceMin(readAsciiLong(8, 16)); ret.setRemoteDeviceMaj(readAsciiLong(8, 16)); ret.setRemoteDeviceMin(readAsciiLong(8, 16)); long namesize = readAsciiLong(8, 16); ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize);"
      },
      {
        "txt": "ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; } private CpioArchiveEntry readOldAsciiEntry() throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII); ret.setDevice(readAsciiLong(6, 8));"
      },
      {
        "txt": "ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (mode != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8)); ret.setGID(readAsciiLong(6, 8)); ret.setNumberOfLinks(readAsciiLong(6, 8)); ret.setRemoteDevice(readAsciiLong(6, 8)); ret.setTime(readAsciiLong(11, 8));"
      },
      {
        "txt": "long namesize = readAsciiLong(6, 8); ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead()); } return ret; } private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)"
      },
      {
        "txt": "throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY); ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (mode != 0){ ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord)); ret.setGID(readBinaryLong(2, swapHalfWord));"
      },
      {
        "txt": "ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord)); ret.setRemoteDevice(readBinaryLong(2, swapHalfWord)); ret.setTime(readBinaryLong(4, swapHalfWord)); long namesize = readBinaryLong(2, swapHalfWord); ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead()); }"
      },
      {
        "txt": "skip(ret.getHeaderPadCount()); return ret; } private String readCString(final int length) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset? } @Override public long skip(final long n) throws IOException {"
      },
      {
        "txt": "if (n < 0) { throw new IllegalArgumentException(\"negative skip length\"); } ensureOpen(); int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > this.tmpbuf.length) { len = this.tmpbuf.length;"
      },
      {
        "txt": "} len = read(this.tmpbuf, 0, len); if (len == -1) { this.entryEOF = true; break; } total += len; } return total; }"
      },
      {
        "txt": "@Override public CpioArchiveEntry getNextEntry() throws IOException { return getNextCPIOEntry(); } private void skipRemainderOfLastBlock() throws IOException { long readFromLastBlock = getBytesRead() % blockSize; long remainingBytes = readFromLastBlock == 0 ? 0 : blockSize - readFromLastBlock; while (remainingBytes > 0) { long skipped = skip(blockSize - readFromLastBlock);"
      },
      {
        "txt": "if (skipped <= 0) { break; } remainingBytes -= skipped; } } public static boolean matches(byte[] signature, int length) { if (length < 6) { return false; }"
      },
      {
        "txt": "if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) { return true; } if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) { return true; } if (signature[0] != 0x30) { return false; } if (signature[1] != 0x37) {"
      },
      {
        "txt": "return false; } if (signature[2] != 0x30) { return false; } if (signature[3] != 0x37) { return false; } if (signature[4] != 0x30) { return false;"
      },
      {
        "txt": "} if (signature[5] == 0x31) { return true; } if (signature[5] == 0x32) { return true; } if (signature[5] == 0x37) { return true; }"
      },
      {
        "txt": "return false; }"
      }
    ]
  },
  {
    "id": 1039,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
    "start-bug-line": 347,
    "end-bug-line": 347,
    "bug": "if (mode == 0 && !name.equals(CPIO_TRAILER)){",
    "fix": "if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.cpio; import java.io.EOFException; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.archivers.ArchiveEntry; import org.apache.commons.compress.archivers.ArchiveInputStream; import org.apache.commons.compress.utils.ArchiveUtils; public class CpioArchiveInputStream extends ArchiveInputStream implements"
      },
      {
        "txt": "CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4];"
      },
      {
        "txt": "private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; public CpioArchiveInputStream(final InputStream in) { this(in, BLOCK_SIZE); } public CpioArchiveInputStream(final InputStream in, int blockSize) { this.in = in; this.blockSize = blockSize; } @Override"
      },
      {
        "txt": "public int available() throws IOException { ensureOpen(); if (this.entryEOF) { return 0; } return 1; } @Override public void close() throws IOException { if (!this.closed) {"
      },
      {
        "txt": "in.close(); this.closed = true; } } private void closeEntry() throws IOException { ensureOpen(); while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD } this.entryEOF = true; }"
      },
      {
        "txt": "private void ensureOpen() throws IOException { if (this.closed) { throw new IOException(\"Stream closed\"); } } public CpioArchiveEntry getNextCPIOEntry() throws IOException { ensureOpen(); if (this.entry != null) { closeEntry(); }"
      },
      {
        "txt": "readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length); if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(false); } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(true); } else { System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length); readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,"
      },
      {
        "txt": "FOUR_BYTES_BUF.length); String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF); if (magicString.equals(MAGIC_NEW)) { this.entry = readNewEntry(false); } else if (magicString.equals(MAGIC_NEW_CRC)) { this.entry = readNewEntry(true); } else if (magicString.equals(MAGIC_OLD_ASCII)) { this.entry = readOldAsciiEntry(); } else { throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead());"
      },
      {
        "txt": "} } this.entryBytesRead = 0; this.entryEOF = false; this.crc = 0; if (this.entry.getName().equals(CPIO_TRAILER)) { this.entryEOF = true; skipRemainderOfLastBlock(); return null; }"
      },
      {
        "txt": "return this.entry; } private void skip(int bytes) throws IOException{ if (bytes > 0) { readFully(FOUR_BYTES_BUF, 0, bytes); } } @Override public int read(final byte[] b, final int off, final int len) throws IOException {"
      },
      {
        "txt": "ensureOpen(); if (off < 0 || len < 0 || off > b.length - len) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } if (this.entry == null || this.entryEOF) { return -1; } if (this.entryBytesRead == this.entry.getSize()) {"
      },
      {
        "txt": "skip(entry.getDataPadCount()); this.entryEOF = true; if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) { throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead()); } return -1; // EOF for this entry } int tmplength = (int) Math.min(len, this.entry.getSize()"
      },
      {
        "txt": "- this.entryBytesRead); if (tmplength < 0) { return -1; } int tmpread = readFully(b, off, tmplength); if (this.entry.getFormat() == FORMAT_NEW_CRC) { for (int pos = 0; pos < tmpread; pos++) { this.crc += b[pos] & 0xFF; } }"
      },
      {
        "txt": "this.entryBytesRead += tmpread; return tmpread; } private final int readFully(final byte[] b, final int off, final int len) throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(); } int n = 0; while (n < len) {"
      },
      {
        "txt": "int count = this.in.read(b, off + n, len - n); count(count); if (count < 0) { throw new EOFException(); } n += count; } return n; } private long readBinaryLong(final int length, final boolean swapHalfWord)"
      },
      {
        "txt": "throws IOException { byte tmp[] = new byte[length]; readFully(tmp, 0, tmp.length); return CpioUtil.byteArray2long(tmp, swapHalfWord); } private long readAsciiLong(final int length, final int radix) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);"
      },
      {
        "txt": "} private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException { CpioArchiveEntry ret; if (hasCrc) { ret = new CpioArchiveEntry(FORMAT_NEW_CRC); } else { ret = new CpioArchiveEntry(FORMAT_NEW); } ret.setInode(readAsciiLong(8, 16));"
      },
      {
        "txt": "long mode = readAsciiLong(8, 16); if (mode != 0){ ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16)); ret.setGID(readAsciiLong(8, 16)); ret.setNumberOfLinks(readAsciiLong(8, 16)); ret.setTime(readAsciiLong(8, 16)); ret.setSize(readAsciiLong(8, 16)); ret.setDeviceMaj(readAsciiLong(8, 16));"
      },
      {
        "txt": "ret.setRemoteDeviceMaj(readAsciiLong(8, 16)); ret.setRemoteDeviceMin(readAsciiLong(8, 16)); long namesize = readAsciiLong(8, 16); ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); <extra_id_0> throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; } private CpioArchiveEntry readOldAsciiEntry() throws IOException {"
      },
      {
        "txt": "} private CpioArchiveEntry readOldAsciiEntry() throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII); ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (mode != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8));"
      },
      {
        "txt": "ret.setGID(readAsciiLong(6, 8)); ret.setNumberOfLinks(readAsciiLong(6, 8)); ret.setRemoteDevice(readAsciiLong(6, 8)); ret.setTime(readAsciiLong(11, 8)); long namesize = readAsciiLong(6, 8); ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());"
      },
      {
        "txt": "} return ret; } private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY); ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (mode != 0){"
      },
      {
        "txt": "ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord)); ret.setGID(readBinaryLong(2, swapHalfWord)); ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord)); ret.setRemoteDevice(readBinaryLong(2, swapHalfWord)); ret.setTime(readBinaryLong(4, swapHalfWord)); long namesize = readBinaryLong(2, swapHalfWord); ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize);"
      },
      {
        "txt": "ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; } private String readCString(final int length) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length);"
      },
      {
        "txt": "return new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset? } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(\"negative skip length\"); } ensureOpen(); int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0;"
      },
      {
        "txt": "while (total < max) { int len = max - total; if (len > this.tmpbuf.length) { len = this.tmpbuf.length; } len = read(this.tmpbuf, 0, len); if (len == -1) { this.entryEOF = true; break; }"
      },
      {
        "txt": "total += len; } return total; } @Override public CpioArchiveEntry getNextEntry() throws IOException { return getNextCPIOEntry(); } private void skipRemainderOfLastBlock() throws IOException { long readFromLastBlock = getBytesRead() % blockSize;"
      },
      {
        "txt": "long remainingBytes = readFromLastBlock == 0 ? 0 : blockSize - readFromLastBlock; while (remainingBytes > 0) { long skipped = skip(blockSize - readFromLastBlock); if (skipped <= 0) { break; } remainingBytes -= skipped; } }"
      },
      {
        "txt": "public static boolean matches(byte[] signature, int length) { if (length < 6) { return false; } if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) { return true; } if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) { return true; }"
      },
      {
        "txt": "if (signature[0] != 0x30) { return false; } if (signature[1] != 0x37) { return false; } if (signature[2] != 0x30) { return false; } if (signature[3] != 0x37) {"
      },
      {
        "txt": "return false; } if (signature[4] != 0x30) { return false; } if (signature[5] == 0x31) { return true; } if (signature[5] == 0x32) { return true;"
      },
      {
        "txt": "} if (signature[5] == 0x37) { return true; } return false; }"
      }
    ]
  },
  {
    "id": 1040,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
    "start-bug-line": 361,
    "end-bug-line": 361,
    "bug": "if (mode != 0) {",
    "fix": "if (CpioUtil.fileType(mode) != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.cpio; import java.io.EOFException; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.archivers.ArchiveEntry; import org.apache.commons.compress.archivers.ArchiveInputStream; import org.apache.commons.compress.utils.ArchiveUtils; public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants {"
      },
      {
        "txt": "private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6];"
      },
      {
        "txt": "private final int blockSize; public CpioArchiveInputStream(final InputStream in) { this(in, BLOCK_SIZE); } public CpioArchiveInputStream(final InputStream in, int blockSize) { this.in = in; this.blockSize = blockSize; } @Override public int available() throws IOException {"
      },
      {
        "txt": "ensureOpen(); if (this.entryEOF) { return 0; } return 1; } @Override public void close() throws IOException { if (!this.closed) { in.close();"
      },
      {
        "txt": "this.closed = true; } } private void closeEntry() throws IOException { ensureOpen(); while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD } this.entryEOF = true; } private void ensureOpen() throws IOException {"
      },
      {
        "txt": "if (this.closed) { throw new IOException(\"Stream closed\"); } } public CpioArchiveEntry getNextCPIOEntry() throws IOException { ensureOpen(); if (this.entry != null) { closeEntry(); } readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);"
      },
      {
        "txt": "if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(false); } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(true); } else { System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length); readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length);"
      },
      {
        "txt": "String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF); if (magicString.equals(MAGIC_NEW)) { this.entry = readNewEntry(false); } else if (magicString.equals(MAGIC_NEW_CRC)) { this.entry = readNewEntry(true); } else if (magicString.equals(MAGIC_OLD_ASCII)) { this.entry = readOldAsciiEntry(); } else { throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead()); }"
      },
      {
        "txt": "} this.entryBytesRead = 0; this.entryEOF = false; this.crc = 0; if (this.entry.getName().equals(CPIO_TRAILER)) { this.entryEOF = true; skipRemainderOfLastBlock(); return null; } return this.entry;"
      },
      {
        "txt": "} private void skip(int bytes) throws IOException{ if (bytes > 0) { readFully(FOUR_BYTES_BUF, 0, bytes); } } @Override public int read(final byte[] b, final int off, final int len) throws IOException { ensureOpen();"
      },
      {
        "txt": "if (off < 0 || len < 0 || off > b.length - len) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } if (this.entry == null || this.entryEOF) { return -1; } if (this.entryBytesRead == this.entry.getSize()) { skip(entry.getDataPadCount());"
      },
      {
        "txt": "this.entryEOF = true; if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) { throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead()); } return -1; // EOF for this entry } int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead);"
      },
      {
        "txt": "if (tmplength < 0) { return -1; } int tmpread = readFully(b, off, tmplength); if (this.entry.getFormat() == FORMAT_NEW_CRC) { for (int pos = 0; pos < tmpread; pos++) { this.crc += b[pos] & 0xFF; } } this.entryBytesRead += tmpread;"
      },
      {
        "txt": "return tmpread; } private final int readFully(final byte[] b, final int off, final int len) throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(); } int n = 0; while (n < len) { int count = this.in.read(b, off + n, len - n);"
      },
      {
        "txt": "count(count); if (count < 0) { throw new EOFException(); } n += count; } return n; } private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException {"
      },
      {
        "txt": "byte tmp[] = new byte[length]; readFully(tmp, 0, tmp.length); return CpioUtil.byteArray2long(tmp, swapHalfWord); } private long readAsciiLong(final int length, final int radix) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix); }"
      },
      {
        "txt": "private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException { CpioArchiveEntry ret; if (hasCrc) { ret = new CpioArchiveEntry(FORMAT_NEW_CRC); } else { ret = new CpioArchiveEntry(FORMAT_NEW); } ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16);"
      },
      {
        "txt": "if (mode != 0){ ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16)); ret.setGID(readAsciiLong(8, 16)); ret.setNumberOfLinks(readAsciiLong(8, 16)); ret.setTime(readAsciiLong(8, 16)); ret.setSize(readAsciiLong(8, 16)); ret.setDeviceMaj(readAsciiLong(8, 16)); ret.setDeviceMin(readAsciiLong(8, 16));"
      },
      {
        "txt": "ret.setRemoteDeviceMaj(readAsciiLong(8, 16)); ret.setRemoteDeviceMin(readAsciiLong(8, 16)); long namesize = readAsciiLong(8, 16); ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount());"
      },
      {
        "txt": "} private CpioArchiveEntry readOldAsciiEntry() throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII); ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); <extra_id_0> ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8)); ret.setGID(readAsciiLong(6, 8)); ret.setNumberOfLinks(readAsciiLong(6, 8)); ret.setRemoteDevice(readAsciiLong(6, 8));"
      },
      {
        "txt": "ret.setNumberOfLinks(readAsciiLong(6, 8)); ret.setRemoteDevice(readAsciiLong(6, 8)); ret.setTime(readAsciiLong(11, 8)); long namesize = readAsciiLong(6, 8); ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead()); }"
      },
      {
        "txt": "return ret; } private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY); ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (mode != 0){ ret.setMode(mode);"
      },
      {
        "txt": "} ret.setUID(readBinaryLong(2, swapHalfWord)); ret.setGID(readBinaryLong(2, swapHalfWord)); ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord)); ret.setRemoteDevice(readBinaryLong(2, swapHalfWord)); ret.setTime(readBinaryLong(4, swapHalfWord)); long namesize = readBinaryLong(2, swapHalfWord); ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name);"
      },
      {
        "txt": "if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; } private String readCString(final int length) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset?"
      },
      {
        "txt": "} @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(\"negative skip length\"); } ensureOpen(); int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) {"
      },
      {
        "txt": "int len = max - total; if (len > this.tmpbuf.length) { len = this.tmpbuf.length; } len = read(this.tmpbuf, 0, len); if (len == -1) { this.entryEOF = true; break; } total += len;"
      },
      {
        "txt": "} return total; } @Override public CpioArchiveEntry getNextEntry() throws IOException { return getNextCPIOEntry(); } private void skipRemainderOfLastBlock() throws IOException { long readFromLastBlock = getBytesRead() % blockSize; long remainingBytes = readFromLastBlock == 0 ? 0"
      },
      {
        "txt": ": blockSize - readFromLastBlock; while (remainingBytes > 0) { long skipped = skip(blockSize - readFromLastBlock); if (skipped <= 0) { break; } remainingBytes -= skipped; } } public static boolean matches(byte[] signature, int length) {"
      },
      {
        "txt": "if (length < 6) { return false; } if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) { return true; } if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) { return true; } if (signature[0] != 0x30) {"
      },
      {
        "txt": "return false; } if (signature[1] != 0x37) { return false; } if (signature[2] != 0x30) { return false; } if (signature[3] != 0x37) { return false;"
      },
      {
        "txt": "} if (signature[4] != 0x30) { return false; } if (signature[5] == 0x31) { return true; } if (signature[5] == 0x32) { return true; }"
      },
      {
        "txt": "if (signature[5] == 0x37) { return true; } return false; }"
      }
    ]
  },
  {
    "id": 1041,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
    "start-bug-line": 373,
    "end-bug-line": 373,
    "bug": "if (mode == 0 && !name.equals(CPIO_TRAILER)){",
    "fix": "if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.EOFException; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.archivers.ArchiveEntry; import org.apache.commons.compress.archivers.ArchiveInputStream; import org.apache.commons.compress.utils.ArchiveUtils; public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry;"
      },
      {
        "txt": "private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; public CpioArchiveInputStream(final InputStream in) {"
      },
      {
        "txt": "this(in, BLOCK_SIZE); } public CpioArchiveInputStream(final InputStream in, int blockSize) { this.in = in; this.blockSize = blockSize; } @Override public int available() throws IOException { ensureOpen(); if (this.entryEOF) {"
      },
      {
        "txt": "return 0; } return 1; } @Override public void close() throws IOException { if (!this.closed) { in.close(); this.closed = true; }"
      },
      {
        "txt": "} private void closeEntry() throws IOException { ensureOpen(); while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD } this.entryEOF = true; } private void ensureOpen() throws IOException { if (this.closed) { throw new IOException(\"Stream closed\");"
      },
      {
        "txt": "} } public CpioArchiveEntry getNextCPIOEntry() throws IOException { ensureOpen(); if (this.entry != null) { closeEntry(); } readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length); if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(false);"
      },
      {
        "txt": "} else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(true); } else { System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length); readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length); String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF); if (magicString.equals(MAGIC_NEW)) {"
      },
      {
        "txt": "this.entry = readNewEntry(false); } else if (magicString.equals(MAGIC_NEW_CRC)) { this.entry = readNewEntry(true); } else if (magicString.equals(MAGIC_OLD_ASCII)) { this.entry = readOldAsciiEntry(); } else { throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead()); } } this.entryBytesRead = 0;"
      },
      {
        "txt": "this.entryEOF = false; this.crc = 0; if (this.entry.getName().equals(CPIO_TRAILER)) { this.entryEOF = true; skipRemainderOfLastBlock(); return null; } return this.entry; } private void skip(int bytes) throws IOException{"
      },
      {
        "txt": "if (bytes > 0) { readFully(FOUR_BYTES_BUF, 0, bytes); } } @Override public int read(final byte[] b, final int off, final int len) throws IOException { ensureOpen(); if (off < 0 || len < 0 || off > b.length - len) { throw new IndexOutOfBoundsException();"
      },
      {
        "txt": "} else if (len == 0) { return 0; } if (this.entry == null || this.entryEOF) { return -1; } if (this.entryBytesRead == this.entry.getSize()) { skip(entry.getDataPadCount()); this.entryEOF = true; if (this.entry.getFormat() == FORMAT_NEW_CRC"
      },
      {
        "txt": "&& this.crc != this.entry.getChksum()) { throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead()); } return -1; // EOF for this entry } int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead); if (tmplength < 0) { return -1;"
      },
      {
        "txt": "} int tmpread = readFully(b, off, tmplength); if (this.entry.getFormat() == FORMAT_NEW_CRC) { for (int pos = 0; pos < tmpread; pos++) { this.crc += b[pos] & 0xFF; } } this.entryBytesRead += tmpread; return tmpread; }"
      },
      {
        "txt": "private final int readFully(final byte[] b, final int off, final int len) throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(); } int n = 0; while (n < len) { int count = this.in.read(b, off + n, len - n); count(count); if (count < 0) {"
      },
      {
        "txt": "throw new EOFException(); } n += count; } return n; } private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException { byte tmp[] = new byte[length]; readFully(tmp, 0, tmp.length);"
      },
      {
        "txt": "return CpioUtil.byteArray2long(tmp, swapHalfWord); } private long readAsciiLong(final int length, final int radix) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix); } private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {"
      },
      {
        "txt": "CpioArchiveEntry ret; if (hasCrc) { ret = new CpioArchiveEntry(FORMAT_NEW_CRC); } else { ret = new CpioArchiveEntry(FORMAT_NEW); } ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); if (mode != 0){ ret.setMode(mode);"
      },
      {
        "txt": "} ret.setUID(readAsciiLong(8, 16)); ret.setGID(readAsciiLong(8, 16)); ret.setNumberOfLinks(readAsciiLong(8, 16)); ret.setTime(readAsciiLong(8, 16)); ret.setSize(readAsciiLong(8, 16)); ret.setDeviceMaj(readAsciiLong(8, 16)); ret.setDeviceMin(readAsciiLong(8, 16)); ret.setRemoteDeviceMaj(readAsciiLong(8, 16)); ret.setRemoteDeviceMin(readAsciiLong(8, 16));"
      },
      {
        "txt": "long namesize = readAsciiLong(8, 16); ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; }"
      },
      {
        "txt": "private CpioArchiveEntry readOldAsciiEntry() throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII); ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (mode != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8)); ret.setGID(readAsciiLong(6, 8));"
      },
      {
        "txt": "ret.setRemoteDevice(readAsciiLong(6, 8)); ret.setTime(readAsciiLong(11, 8)); long namesize = readAsciiLong(6, 8); ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); <extra_id_0> throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead()); } return ret; } private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {"
      },
      {
        "txt": "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY); ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (mode != 0){ ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord));"
      },
      {
        "txt": "ret.setGID(readBinaryLong(2, swapHalfWord)); ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord)); ret.setRemoteDevice(readBinaryLong(2, swapHalfWord)); ret.setTime(readBinaryLong(4, swapHalfWord)); long namesize = readBinaryLong(2, swapHalfWord); ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());"
      },
      {
        "txt": "} skip(ret.getHeaderPadCount()); return ret; } private String readCString(final int length) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset? } @Override"
      },
      {
        "txt": "public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(\"negative skip length\"); } ensureOpen(); int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > this.tmpbuf.length) {"
      },
      {
        "txt": "len = this.tmpbuf.length; } len = read(this.tmpbuf, 0, len); if (len == -1) { this.entryEOF = true; break; } total += len; } return total;"
      },
      {
        "txt": "} @Override public CpioArchiveEntry getNextEntry() throws IOException { return getNextCPIOEntry(); } private void skipRemainderOfLastBlock() throws IOException { long readFromLastBlock = getBytesRead() % blockSize; long remainingBytes = readFromLastBlock == 0 ? 0 : blockSize - readFromLastBlock; while (remainingBytes > 0) {"
      },
      {
        "txt": "long skipped = skip(blockSize - readFromLastBlock); if (skipped <= 0) { break; } remainingBytes -= skipped; } } public static boolean matches(byte[] signature, int length) { if (length < 6) { return false;"
      },
      {
        "txt": "} if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) { return true; } if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) { return true; } if (signature[0] != 0x30) { return false; }"
      },
      {
        "txt": "if (signature[1] != 0x37) { return false; } if (signature[2] != 0x30) { return false; } if (signature[3] != 0x37) { return false; } if (signature[4] != 0x30) {"
      },
      {
        "txt": "return false; } if (signature[5] == 0x31) { return true; } if (signature[5] == 0x32) { return true; } if (signature[5] == 0x37) { return true;"
      },
      {
        "txt": "} return false; }"
      }
    ]
  },
  {
    "id": 1042,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
    "start-bug-line": 387,
    "end-bug-line": 387,
    "bug": "if (mode != 0){",
    "fix": "if (CpioUtil.fileType(mode) != 0){",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.cpio; import java.io.EOFException;"
      },
      {
        "txt": "import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.archivers.ArchiveEntry; import org.apache.commons.compress.archivers.ArchiveInputStream; import org.apache.commons.compress.utils.ArchiveUtils; public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0;"
      },
      {
        "txt": "private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; public CpioArchiveInputStream(final InputStream in) { this(in, BLOCK_SIZE);"
      },
      {
        "txt": "} public CpioArchiveInputStream(final InputStream in, int blockSize) { this.in = in; this.blockSize = blockSize; } @Override public int available() throws IOException { ensureOpen(); if (this.entryEOF) { return 0;"
      },
      {
        "txt": "} return 1; } @Override public void close() throws IOException { if (!this.closed) { in.close(); this.closed = true; } }"
      },
      {
        "txt": "private void closeEntry() throws IOException { ensureOpen(); while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD } this.entryEOF = true; } private void ensureOpen() throws IOException { if (this.closed) { throw new IOException(\"Stream closed\"); }"
      },
      {
        "txt": "} public CpioArchiveEntry getNextCPIOEntry() throws IOException { ensureOpen(); if (this.entry != null) { closeEntry(); } readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length); if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(false); } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)"
      },
      {
        "txt": "== MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(true); } else { System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length); readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length); String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF); if (magicString.equals(MAGIC_NEW)) { this.entry = readNewEntry(false);"
      },
      {
        "txt": "} else if (magicString.equals(MAGIC_NEW_CRC)) { this.entry = readNewEntry(true); } else if (magicString.equals(MAGIC_OLD_ASCII)) { this.entry = readOldAsciiEntry(); } else { throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead()); } } this.entryBytesRead = 0; this.entryEOF = false;"
      },
      {
        "txt": "this.crc = 0; if (this.entry.getName().equals(CPIO_TRAILER)) { this.entryEOF = true; skipRemainderOfLastBlock(); return null; } return this.entry; } private void skip(int bytes) throws IOException{ if (bytes > 0) {"
      },
      {
        "txt": "readFully(FOUR_BYTES_BUF, 0, bytes); } } @Override public int read(final byte[] b, final int off, final int len) throws IOException { ensureOpen(); if (off < 0 || len < 0 || off > b.length - len) { throw new IndexOutOfBoundsException(); } else if (len == 0) {"
      },
      {
        "txt": "return 0; } if (this.entry == null || this.entryEOF) { return -1; } if (this.entryBytesRead == this.entry.getSize()) { skip(entry.getDataPadCount()); this.entryEOF = true; if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) {"
      },
      {
        "txt": "throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead()); } return -1; // EOF for this entry } int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead); if (tmplength < 0) { return -1; }"
      },
      {
        "txt": "int tmpread = readFully(b, off, tmplength); if (this.entry.getFormat() == FORMAT_NEW_CRC) { for (int pos = 0; pos < tmpread; pos++) { this.crc += b[pos] & 0xFF; } } this.entryBytesRead += tmpread; return tmpread; } private final int readFully(final byte[] b, final int off, final int len)"
      },
      {
        "txt": "throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(); } int n = 0; while (n < len) { int count = this.in.read(b, off + n, len - n); count(count); if (count < 0) { throw new EOFException();"
      },
      {
        "txt": "} n += count; } return n; } private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException { byte tmp[] = new byte[length]; readFully(tmp, 0, tmp.length); return CpioUtil.byteArray2long(tmp, swapHalfWord);"
      },
      {
        "txt": "} private long readAsciiLong(final int length, final int radix) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix); } private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException { CpioArchiveEntry ret;"
      },
      {
        "txt": "if (hasCrc) { ret = new CpioArchiveEntry(FORMAT_NEW_CRC); } else { ret = new CpioArchiveEntry(FORMAT_NEW); } ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); if (mode != 0){ ret.setMode(mode); }"
      },
      {
        "txt": "ret.setUID(readAsciiLong(8, 16)); ret.setGID(readAsciiLong(8, 16)); ret.setNumberOfLinks(readAsciiLong(8, 16)); ret.setTime(readAsciiLong(8, 16)); ret.setSize(readAsciiLong(8, 16)); ret.setDeviceMaj(readAsciiLong(8, 16)); ret.setDeviceMin(readAsciiLong(8, 16)); ret.setRemoteDeviceMaj(readAsciiLong(8, 16)); ret.setRemoteDeviceMin(readAsciiLong(8, 16)); long namesize = readAsciiLong(8, 16);"
      },
      {
        "txt": "ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; } private CpioArchiveEntry readOldAsciiEntry() throws IOException {"
      },
      {
        "txt": "CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII); ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (mode != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8)); ret.setGID(readAsciiLong(6, 8)); ret.setNumberOfLinks(readAsciiLong(6, 8));"
      },
      {
        "txt": "ret.setRemoteDevice(readAsciiLong(6, 8)); ret.setTime(readAsciiLong(11, 8)); long namesize = readAsciiLong(6, 8); ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead()); } return ret;"
      },
      {
        "txt": "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY); ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); <extra_id_0> ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord)); ret.setGID(readBinaryLong(2, swapHalfWord)); ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord)); ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));"
      },
      {
        "txt": "ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord)); ret.setRemoteDevice(readBinaryLong(2, swapHalfWord)); ret.setTime(readBinaryLong(4, swapHalfWord)); long namesize = readBinaryLong(2, swapHalfWord); ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead()); }"
      },
      {
        "txt": "skip(ret.getHeaderPadCount()); return ret; } private String readCString(final int length) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset? } @Override public long skip(final long n) throws IOException {"
      },
      {
        "txt": "if (n < 0) { throw new IllegalArgumentException(\"negative skip length\"); } ensureOpen(); int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > this.tmpbuf.length) { len = this.tmpbuf.length;"
      },
      {
        "txt": "} len = read(this.tmpbuf, 0, len); if (len == -1) { this.entryEOF = true; break; } total += len; } return total; }"
      },
      {
        "txt": "@Override public CpioArchiveEntry getNextEntry() throws IOException { return getNextCPIOEntry(); } private void skipRemainderOfLastBlock() throws IOException { long readFromLastBlock = getBytesRead() % blockSize; long remainingBytes = readFromLastBlock == 0 ? 0 : blockSize - readFromLastBlock; while (remainingBytes > 0) { long skipped = skip(blockSize - readFromLastBlock);"
      },
      {
        "txt": "if (skipped <= 0) { break; } remainingBytes -= skipped; } } public static boolean matches(byte[] signature, int length) { if (length < 6) { return false; }"
      },
      {
        "txt": "if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) { return true; } if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) { return true; } if (signature[0] != 0x30) { return false; } if (signature[1] != 0x37) {"
      },
      {
        "txt": "return false; } if (signature[2] != 0x30) { return false; } if (signature[3] != 0x37) { return false; } if (signature[4] != 0x30) { return false;"
      },
      {
        "txt": "} if (signature[5] == 0x31) { return true; } if (signature[5] == 0x32) { return true; } if (signature[5] == 0x37) { return true; }"
      },
      {
        "txt": "return false; }"
      }
    ]
  },
  {
    "id": 1043,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
    "start-bug-line": 399,
    "end-bug-line": 399,
    "bug": "if (mode == 0 && !name.equals(CPIO_TRAILER)){",
    "fix": "if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.cpio; import java.io.EOFException; import java.io.IOException; import java.io.InputStream;"
      },
      {
        "txt": "import org.apache.commons.compress.archivers.ArchiveEntry; import org.apache.commons.compress.archivers.ArchiveInputStream; import org.apache.commons.compress.utils.ArchiveUtils; public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096];"
      },
      {
        "txt": "private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; public CpioArchiveInputStream(final InputStream in) { this(in, BLOCK_SIZE); } public CpioArchiveInputStream(final InputStream in, int blockSize) {"
      },
      {
        "txt": "this.in = in; this.blockSize = blockSize; } @Override public int available() throws IOException { ensureOpen(); if (this.entryEOF) { return 0; } return 1;"
      },
      {
        "txt": "} @Override public void close() throws IOException { if (!this.closed) { in.close(); this.closed = true; } } private void closeEntry() throws IOException { ensureOpen();"
      },
      {
        "txt": "while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD } this.entryEOF = true; } private void ensureOpen() throws IOException { if (this.closed) { throw new IOException(\"Stream closed\"); } } public CpioArchiveEntry getNextCPIOEntry() throws IOException {"
      },
      {
        "txt": "ensureOpen(); if (this.entry != null) { closeEntry(); } readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length); if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(false); } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(true);"
      },
      {
        "txt": "} else { System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length); readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length); String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF); if (magicString.equals(MAGIC_NEW)) { this.entry = readNewEntry(false); } else if (magicString.equals(MAGIC_NEW_CRC)) { this.entry = readNewEntry(true);"
      },
      {
        "txt": "} else if (magicString.equals(MAGIC_OLD_ASCII)) { this.entry = readOldAsciiEntry(); } else { throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead()); } } this.entryBytesRead = 0; this.entryEOF = false; this.crc = 0; if (this.entry.getName().equals(CPIO_TRAILER)) {"
      },
      {
        "txt": "this.entryEOF = true; skipRemainderOfLastBlock(); return null; } return this.entry; } private void skip(int bytes) throws IOException{ if (bytes > 0) { readFully(FOUR_BYTES_BUF, 0, bytes); }"
      },
      {
        "txt": "} @Override public int read(final byte[] b, final int off, final int len) throws IOException { ensureOpen(); if (off < 0 || len < 0 || off > b.length - len) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; }"
      },
      {
        "txt": "if (this.entry == null || this.entryEOF) { return -1; } if (this.entryBytesRead == this.entry.getSize()) { skip(entry.getDataPadCount()); this.entryEOF = true; if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) { throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead());"
      },
      {
        "txt": "} return -1; // EOF for this entry } int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead); if (tmplength < 0) { return -1; } int tmpread = readFully(b, off, tmplength); if (this.entry.getFormat() == FORMAT_NEW_CRC) {"
      },
      {
        "txt": "for (int pos = 0; pos < tmpread; pos++) { this.crc += b[pos] & 0xFF; } } this.entryBytesRead += tmpread; return tmpread; } private final int readFully(final byte[] b, final int off, final int len) throws IOException { if (len < 0) {"
      },
      {
        "txt": "throw new IndexOutOfBoundsException(); } int n = 0; while (n < len) { int count = this.in.read(b, off + n, len - n); count(count); if (count < 0) { throw new EOFException(); } n += count;"
      },
      {
        "txt": "} return n; } private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException { byte tmp[] = new byte[length]; readFully(tmp, 0, tmp.length); return CpioUtil.byteArray2long(tmp, swapHalfWord); } private long readAsciiLong(final int length, final int radix)"
      },
      {
        "txt": "throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix); } private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException { CpioArchiveEntry ret; if (hasCrc) { ret = new CpioArchiveEntry(FORMAT_NEW_CRC);"
      },
      {
        "txt": "} else { ret = new CpioArchiveEntry(FORMAT_NEW); } ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); if (mode != 0){ ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16)); ret.setGID(readAsciiLong(8, 16));"
      },
      {
        "txt": "ret.setNumberOfLinks(readAsciiLong(8, 16)); ret.setTime(readAsciiLong(8, 16)); ret.setSize(readAsciiLong(8, 16)); ret.setDeviceMaj(readAsciiLong(8, 16)); ret.setDeviceMin(readAsciiLong(8, 16)); ret.setRemoteDeviceMaj(readAsciiLong(8, 16)); ret.setRemoteDeviceMin(readAsciiLong(8, 16)); long namesize = readAsciiLong(8, 16); ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize);"
      },
      {
        "txt": "ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; } private CpioArchiveEntry readOldAsciiEntry() throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII); ret.setDevice(readAsciiLong(6, 8));"
      },
      {
        "txt": "ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (mode != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8)); ret.setGID(readAsciiLong(6, 8)); ret.setNumberOfLinks(readAsciiLong(6, 8)); ret.setRemoteDevice(readAsciiLong(6, 8)); ret.setTime(readAsciiLong(11, 8));"
      },
      {
        "txt": "long namesize = readAsciiLong(6, 8); ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead()); } return ret; } private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)"
      },
      {
        "txt": "throws IOException { CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY); ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (mode != 0){ ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord)); ret.setGID(readBinaryLong(2, swapHalfWord));"
      },
      {
        "txt": "ret.setRemoteDevice(readBinaryLong(2, swapHalfWord)); ret.setTime(readBinaryLong(4, swapHalfWord)); long namesize = readBinaryLong(2, swapHalfWord); ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); <extra_id_0> throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead()); } skip(ret.getHeaderPadCount()); return ret; } private String readCString(final int length) throws IOException {"
      },
      {
        "txt": "} private String readCString(final int length) throws IOException { byte tmpBuffer[] = new byte[length]; readFully(tmpBuffer, 0, tmpBuffer.length); return new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset? } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(\"negative skip length\");"
      },
      {
        "txt": "} ensureOpen(); int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > this.tmpbuf.length) { len = this.tmpbuf.length; } len = read(this.tmpbuf, 0, len);"
      },
      {
        "txt": "if (len == -1) { this.entryEOF = true; break; } total += len; } return total; } @Override public CpioArchiveEntry getNextEntry() throws IOException {"
      },
      {
        "txt": "return getNextCPIOEntry(); } private void skipRemainderOfLastBlock() throws IOException { long readFromLastBlock = getBytesRead() % blockSize; long remainingBytes = readFromLastBlock == 0 ? 0 : blockSize - readFromLastBlock; while (remainingBytes > 0) { long skipped = skip(blockSize - readFromLastBlock); if (skipped <= 0) { break;"
      },
      {
        "txt": "} remainingBytes -= skipped; } } public static boolean matches(byte[] signature, int length) { if (length < 6) { return false; } if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) { return true;"
      },
      {
        "txt": "} if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) { return true; } if (signature[0] != 0x30) { return false; } if (signature[1] != 0x37) { return false; }"
      },
      {
        "txt": "if (signature[2] != 0x30) { return false; } if (signature[3] != 0x37) { return false; } if (signature[4] != 0x30) { return false; } if (signature[5] == 0x31) {"
      },
      {
        "txt": "return true; } if (signature[5] == 0x32) { return true; } if (signature[5] == 0x37) { return true; } return false; }"
      }
    ]
  }
]