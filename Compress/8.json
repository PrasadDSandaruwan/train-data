[
  {
    "id": 1009,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 53,
    "end-bug-line": 53,
    "bug": "boolean stillPadding = true;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){ } public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; <extra_id_0> int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break;"
      },
      {
        "txt": "if (currentByte == 0) { break; } if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break; }"
      },
      {
        "txt": "} stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; }"
      },
      {
        "txt": "private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length; return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length;"
      },
      {
        "txt": "for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; } result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {"
      },
      {
        "txt": "int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) { buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer,"
      },
      {
        "txt": "final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0'; } else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3;"
      },
      {
        "txt": "} if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); } } for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } }"
      },
      {
        "txt": "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx);"
      },
      {
        "txt": "buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; }"
      },
      {
        "txt": "public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; } return sum; }"
      }
    ]
  },
  {
    "id": 1010,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 57,
    "end-bug-line": 57,
    "bug": "",
    "fix": "if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); }  boolean allNUL = true;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255;"
      },
      {
        "txt": "} public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; <extra_id_0> final byte currentByte = buffer[i]; if (currentByte == 0) { break; } if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) {"
      },
      {
        "txt": "if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break; } } stillPadding = false; if (currentByte < '0' || currentByte > '7'){"
      },
      {
        "txt": "throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length);"
      },
      {
        "txt": "string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length; return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null"
      },
      {
        "txt": "break; } result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i);"
      },
      {
        "txt": "} for (; i < length; ++i) { buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--;"
      },
      {
        "txt": "if (value == 0) { buffer[offset + remaining--] = (byte) '0'; } else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException"
      },
      {
        "txt": "(value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); } } for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx);"
      },
      {
        "txt": "buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; }"
      },
      {
        "txt": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) {"
      },
      {
        "txt": "sum += BYTE_MASK & buf[i]; } return sum; }"
      }
    ]
  },
  {
    "id": 1011,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 58,
    "end-bug-line": 59,
    "bug": "final byte currentByte = buffer[i]; if (currentByte == 0) {",
    "fix": "if (buffer[i] != 0){ allNUL = false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){"
      },
      {
        "txt": "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ <extra_id_0> break; } if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; }"
      },
      {
        "txt": "continue; } if (currentByte == (byte) ' ') { break; } } stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte));"
      },
      {
        "txt": "} result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;"
      },
      {
        "txt": "return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; }"
      },
      {
        "txt": "result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) {"
      },
      {
        "txt": "buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0';"
      },
      {
        "txt": "} else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); }"
      },
      {
        "txt": "} for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null"
      },
      {
        "txt": "return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space"
      },
      {
        "txt": "formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; }"
      },
      {
        "txt": "return sum; }"
      }
    ]
  },
  {
    "id": 1012,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 62,
    "end-bug-line": 62,
    "bug": "",
    "fix": "} if (allNUL) { return 0L; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){ } public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; boolean stillPadding = true;"
      },
      {
        "txt": "int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } <extra_id_0> if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break;"
      },
      {
        "txt": "if (currentByte == (byte) ' ') { break; } } stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII"
      },
      {
        "txt": "} return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length; return s; }"
      },
      {
        "txt": "public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; } result.append((char) (b & 0xFF)); // Allow for sign-extension }"
      },
      {
        "txt": "return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) { buf[offset + i] = 0; }"
      },
      {
        "txt": "return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0'; } else { long val = value;"
      },
      {
        "txt": "for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); } } for (; remaining >= 0; --remaining) { // leading zeros"
      },
      {
        "txt": "buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null return offset + length; }"
      },
      {
        "txt": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null"
      },
      {
        "txt": "buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; } return sum; }"
      }
    ]
  },
  {
    "id": 1013,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 64,
    "end-bug-line": 68,
    "bug": "if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') {",
    "fix": "while (start < end){ if (buffer[start] == ' '){ start++; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){ } public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; boolean stillPadding = true;"
      },
      {
        "txt": "int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } <extra_id_0> break; } } stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException("
      },
      {
        "txt": "if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) {"
      },
      {
        "txt": "String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length; return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i];"
      },
      {
        "txt": "if (b == 0) { // Trailing null break; } result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) {"
      },
      {
        "txt": "buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) { buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length;"
      },
      {
        "txt": "remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0'; } else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){"
      },
      {
        "txt": "throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); } } for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null"
      },
      {
        "txt": "formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length;"
      },
      {
        "txt": "} public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0;"
      },
      {
        "txt": "for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; } return sum; }"
      }
    ]
  },
  {
    "id": 1014,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 70,
    "end-bug-line": 70,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){"
      },
      {
        "txt": "} public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break;"
      },
      {
        "txt": "if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break; <extra_id_0> } stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); }"
      },
      {
        "txt": "exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed"
      },
      {
        "txt": "final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length; return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break;"
      },
      {
        "txt": "} result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); }"
      },
      {
        "txt": "for (; i < length; ++i) { buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) {"
      },
      {
        "txt": "buffer[offset + remaining--] = (byte) '0'; } else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);"
      },
      {
        "txt": "} } for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space"
      },
      {
        "txt": "buf[offset + idx] = 0; // Trailing null return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {"
      },
      {
        "txt": "int idx=length-2; // for NUL and space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i];"
      },
      {
        "txt": "} return sum; }"
      }
    ]
  },
  {
    "id": 1015,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 72,
    "end-bug-line": 72,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){ } public static long parseOctal(final byte[] buffer, final int offset, final int length) {"
      },
      {
        "txt": "long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } if (currentByte == (byte) ' ' || currentByte == '0') {"
      },
      {
        "txt": "continue; } if (currentByte == (byte) ' ') { break; } } <extra_id_0> stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII"
      },
      {
        "txt": "} result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;"
      },
      {
        "txt": "return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; }"
      },
      {
        "txt": "result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) {"
      },
      {
        "txt": "buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0';"
      },
      {
        "txt": "} else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); }"
      },
      {
        "txt": "} for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null"
      },
      {
        "txt": "return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space"
      },
      {
        "txt": "formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; }"
      },
      {
        "txt": "return sum; }"
      }
    ]
  },
  {
    "id": 1016,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 74,
    "end-bug-line": 74,
    "bug": "",
    "fix": "byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){ } public static long parseOctal(final byte[] buffer, final int offset, final int length) {"
      },
      {
        "txt": "long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } if (currentByte == (byte) ' ' || currentByte == '0') {"
      },
      {
        "txt": "continue; } if (currentByte == (byte) ' ') { break; } } <extra_id_0> stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII"
      },
      {
        "txt": "} result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;"
      },
      {
        "txt": "return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; }"
      },
      {
        "txt": "result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) {"
      },
      {
        "txt": "buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0';"
      },
      {
        "txt": "} else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); }"
      },
      {
        "txt": "} for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null"
      },
      {
        "txt": "return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space"
      },
      {
        "txt": "formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; }"
      },
      {
        "txt": "return sum; }"
      }
    ]
  },
  {
    "id": 1017,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 75,
    "end-bug-line": 75,
    "bug": "",
    "fix": "trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){ } public static long parseOctal(final byte[] buffer, final int offset, final int length) {"
      },
      {
        "txt": "long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } if (currentByte == (byte) ' ' || currentByte == '0') {"
      },
      {
        "txt": "continue; } if (currentByte == (byte) ' ') { break; } } <extra_id_0> stillPadding = false; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII"
      },
      {
        "txt": "} result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;"
      },
      {
        "txt": "return s; } public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; }"
      },
      {
        "txt": "result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) {"
      },
      {
        "txt": "buf[offset + i] = 0; } return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0';"
      },
      {
        "txt": "} else { long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); }"
      },
      {
        "txt": "} for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null"
      },
      {
        "txt": "return offset + length; } public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space"
      },
      {
        "txt": "formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; }"
      },
      {
        "txt": "return sum; }"
      }
    ]
  },
  {
    "id": 1018,
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
    "start-bug-line": 76,
    "end-bug-line": 76,
    "bug": "stillPadding = false;",
    "fix": "for ( ;start < end; start++) { final byte currentByte = buffer[start];",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.archivers.tar; public class TarUtils { private static final int BYTE_MASK = 255; private TarUtils(){ } public static long parseOctal(final byte[] buffer, final int offset, final int length) {"
      },
      {
        "txt": "long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } if (currentByte == (byte) ' ' || currentByte == '0') {"
      },
      {
        "txt": "continue; } if (currentByte == (byte) ' ') { break; } } <extra_id_0> if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII }"
      },
      {
        "txt": "result = (result << 3) + (currentByte - '0'); // convert from ASCII } return result; } private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length; return s;"
      },
      {
        "txt": "} public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; } result.append((char) (b & 0xFF)); // Allow for sign-extension"
      },
      {
        "txt": "} return result.toString(); } public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) { int i; for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); } for (; i < length; ++i) { buf[offset + i] = 0;"
      },
      {
        "txt": "} return offset + length; } public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { buffer[offset + remaining--] = (byte) '0'; } else {"
      },
      {
        "txt": "long val = value; for (; remaining >= 0 && val != 0; --remaining) { buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3; } if (val != 0){ throw new IllegalArgumentException (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length); } }"
      },
      {
        "txt": "for (; remaining >= 0; --remaining) { // leading zeros buffer[offset + remaining] = (byte) '0'; } } public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // For space and trailing null formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx++] = (byte) ' '; // Trailing space buf[offset + idx] = 0; // Trailing null return offset + length;"
      },
      {
        "txt": "} public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) { int idx=length-2; // for NUL and space formatUnsignedOctalString(value, buf, offset, idx);"
      },
      {
        "txt": "buf[offset + idx++] = 0; // Trailing null buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } public static long computeCheckSum(final byte[] buf) { long sum = 0; for (int i = 0; i < buf.length; ++i) { sum += BYTE_MASK & buf[i]; } return sum;"
      }
    ]
  }
]