[
  {
    "id": 1046,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 67,
    "end-bug-line": 67,
    "bug": "private int currentChar = -1;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k;"
      },
      {
        "txt": "private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; <extra_id_0> private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5;"
      },
      {
        "txt": "private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2; private int su_chPrev;"
      },
      {
        "txt": "private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); }"
      },
      {
        "txt": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); } @Override public int read() throws IOException { if (this.in != null) {"
      },
      {
        "txt": "int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len) throws IOException {"
      },
      {
        "txt": "if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); }"
      },
      {
        "txt": "if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); }"
      },
      {
        "txt": "int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i;"
      },
      {
        "txt": "} } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); }"
      },
      {
        "txt": "return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; }"
      },
      {
        "txt": "int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\");"
      },
      {
        "txt": "} this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1; char magic2;"
      },
      {
        "txt": "char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte();"
      },
      {
        "txt": "if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')'"
      },
      {
        "txt": "magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1;"
      },
      {
        "txt": "if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC();"
      },
      {
        "txt": "if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; }"
      },
      {
        "txt": "private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override"
      },
      {
        "txt": "public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null; this.in = null;"
      },
      {
        "txt": "} } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();"
      },
      {
        "txt": "if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);"
      },
      {
        "txt": "} private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException {"
      },
      {
        "txt": "return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; }"
      },
      {
        "txt": "} } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {"
      },
      {
        "txt": "b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; }"
      },
      {
        "txt": "for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf;"
      },
      {
        "txt": "int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) {"
      },
      {
        "txt": "if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } } makeMaps();"
      },
      {
        "txt": "final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; }"
      },
      {
        "txt": "for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; }"
      },
      {
        "txt": "pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1;"
      },
      {
        "txt": "} len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d;"
      },
      {
        "txt": "final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i];"
      },
      {
        "txt": "if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen;"
      },
      {
        "txt": "} } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector;"
      },
      {
        "txt": "final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0;"
      },
      {
        "txt": "} int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt];"
      },
      {
        "txt": "int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) {"
      },
      {
        "txt": "s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt];"
      },
      {
        "txt": "minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++;"
      },
      {
        "txt": "while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\"); }"
      },
      {
        "txt": "} bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) {"
      },
      {
        "txt": "ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1];"
      },
      {
        "txt": "unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp;"
      },
      {
        "txt": "if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; }"
      },
      {
        "txt": "int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "} int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]];"
      },
      {
        "txt": "} } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff;"
      },
      {
        "txt": "final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1);"
      },
      {
        "txt": "final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; }"
      },
      {
        "txt": "if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0;"
      },
      {
        "txt": "return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) {"
      },
      {
        "txt": "this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow;"
      },
      {
        "txt": "this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException {"
      },
      {
        "txt": "if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;"
      },
      {
        "txt": "} else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE;"
      },
      {
        "txt": "this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; }"
      },
      {
        "txt": "} else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else {"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;"
      },
      {
        "txt": "} else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1;"
      },
      {
        "txt": "return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } }"
      },
      {
        "txt": "private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++;"
      },
      {
        "txt": "this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte"
      },
      {
        "txt": "final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte"
      },
      {
        "txt": "Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; }"
      },
      {
        "txt": "} public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false;"
      },
      {
        "txt": "} if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1047,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 135,
    "end-bug-line": 135,
    "bug": "setupBlock();",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k;"
      },
      {
        "txt": "private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1;"
      },
      {
        "txt": "private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count;"
      },
      {
        "txt": "private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException {"
      },
      {
        "txt": "} public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); <extra_id_0> } @Override public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1);"
      },
      {
        "txt": "int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len) throws IOException {"
      },
      {
        "txt": "if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); }"
      },
      {
        "txt": "if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); }"
      },
      {
        "txt": "int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i;"
      },
      {
        "txt": "} } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); }"
      },
      {
        "txt": "return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; }"
      },
      {
        "txt": "int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\");"
      },
      {
        "txt": "} this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1; char magic2;"
      },
      {
        "txt": "char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte();"
      },
      {
        "txt": "if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')'"
      },
      {
        "txt": "magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1;"
      },
      {
        "txt": "if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC();"
      },
      {
        "txt": "if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; }"
      },
      {
        "txt": "private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override"
      },
      {
        "txt": "public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null; this.in = null;"
      },
      {
        "txt": "} } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();"
      },
      {
        "txt": "if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);"
      },
      {
        "txt": "} private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException {"
      },
      {
        "txt": "return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; }"
      },
      {
        "txt": "} } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {"
      },
      {
        "txt": "b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; }"
      },
      {
        "txt": "for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf;"
      },
      {
        "txt": "int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) {"
      },
      {
        "txt": "if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } } makeMaps();"
      },
      {
        "txt": "final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; }"
      },
      {
        "txt": "for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; }"
      },
      {
        "txt": "pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1;"
      },
      {
        "txt": "} len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d;"
      },
      {
        "txt": "final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i];"
      },
      {
        "txt": "if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen;"
      },
      {
        "txt": "} } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector;"
      },
      {
        "txt": "final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0;"
      },
      {
        "txt": "} int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt];"
      },
      {
        "txt": "int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) {"
      },
      {
        "txt": "s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt];"
      },
      {
        "txt": "minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++;"
      },
      {
        "txt": "while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\"); }"
      },
      {
        "txt": "} bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) {"
      },
      {
        "txt": "ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1];"
      },
      {
        "txt": "unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp;"
      },
      {
        "txt": "if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; }"
      },
      {
        "txt": "int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "} int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]];"
      },
      {
        "txt": "} } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff;"
      },
      {
        "txt": "final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1);"
      },
      {
        "txt": "final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; }"
      },
      {
        "txt": "if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0;"
      },
      {
        "txt": "return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) {"
      },
      {
        "txt": "this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow;"
      },
      {
        "txt": "this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException {"
      },
      {
        "txt": "if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;"
      },
      {
        "txt": "} else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE;"
      },
      {
        "txt": "this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; }"
      },
      {
        "txt": "} else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else {"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;"
      },
      {
        "txt": "} else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1;"
      },
      {
        "txt": "return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } }"
      },
      {
        "txt": "private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++;"
      },
      {
        "txt": "this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte"
      },
      {
        "txt": "final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte"
      },
      {
        "txt": "Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; }"
      },
      {
        "txt": "} public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false;"
      },
      {
        "txt": "} if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1048,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 199,
    "end-bug-line": 199,
    "bug": "final int retChar = this.currentChar;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k;"
      },
      {
        "txt": "private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1;"
      },
      {
        "txt": "private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count;"
      },
      {
        "txt": "private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException {"
      },
      {
        "txt": "this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); } @Override"
      },
      {
        "txt": "public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } } @Override"
      },
      {
        "txt": "public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\""
      },
      {
        "txt": "+ len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b;"
      },
      {
        "txt": "count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) {"
      },
      {
        "txt": "seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow; } private int read0() throws IOException { <extra_id_0> switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); }"
      },
      {
        "txt": "return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; }"
      },
      {
        "txt": "int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\");"
      },
      {
        "txt": "} this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1; char magic2;"
      },
      {
        "txt": "char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte();"
      },
      {
        "txt": "if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')'"
      },
      {
        "txt": "magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1;"
      },
      {
        "txt": "if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC();"
      },
      {
        "txt": "if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; }"
      },
      {
        "txt": "private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override"
      },
      {
        "txt": "public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null; this.in = null;"
      },
      {
        "txt": "} } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();"
      },
      {
        "txt": "if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);"
      },
      {
        "txt": "} private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException {"
      },
      {
        "txt": "return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; }"
      },
      {
        "txt": "} } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {"
      },
      {
        "txt": "b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; }"
      },
      {
        "txt": "for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf;"
      },
      {
        "txt": "int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) {"
      },
      {
        "txt": "if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } } makeMaps();"
      },
      {
        "txt": "final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; }"
      },
      {
        "txt": "for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; }"
      },
      {
        "txt": "pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1;"
      },
      {
        "txt": "} len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d;"
      },
      {
        "txt": "final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i];"
      },
      {
        "txt": "if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen;"
      },
      {
        "txt": "} } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector;"
      },
      {
        "txt": "final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0;"
      },
      {
        "txt": "} int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt];"
      },
      {
        "txt": "int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) {"
      },
      {
        "txt": "s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt];"
      },
      {
        "txt": "minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++;"
      },
      {
        "txt": "while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\"); }"
      },
      {
        "txt": "} bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) {"
      },
      {
        "txt": "ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1];"
      },
      {
        "txt": "unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp;"
      },
      {
        "txt": "if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; }"
      },
      {
        "txt": "int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "} int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]];"
      },
      {
        "txt": "} } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff;"
      },
      {
        "txt": "final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1);"
      },
      {
        "txt": "final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; }"
      },
      {
        "txt": "if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0;"
      },
      {
        "txt": "return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) {"
      },
      {
        "txt": "this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow;"
      },
      {
        "txt": "this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException {"
      },
      {
        "txt": "if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;"
      },
      {
        "txt": "} else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE;"
      },
      {
        "txt": "this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; }"
      },
      {
        "txt": "} else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else {"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;"
      },
      {
        "txt": "} else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1;"
      },
      {
        "txt": "return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } }"
      },
      {
        "txt": "private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++;"
      },
      {
        "txt": "this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte"
      },
      {
        "txt": "final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte"
      },
      {
        "txt": "Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; }"
      },
      {
        "txt": "} public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false;"
      },
      {
        "txt": "} if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1049,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 205,
    "end-bug-line": 205,
    "bug": "throw new IllegalStateException();",
    "fix": "return setupBlock();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream;"
      },
      {
        "txt": "public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k; private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse;"
      },
      {
        "txt": "private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6;"
      },
      {
        "txt": "private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo;"
      },
      {
        "txt": "private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated;"
      },
      {
        "txt": "init(true); initBlock(); setupBlock(); } @Override public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r;"
      },
      {
        "txt": "} else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); }"
      },
      {
        "txt": "if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\"); }"
      },
      {
        "txt": "final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; }"
      },
      {
        "txt": "private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow;"
      },
      {
        "txt": "private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: <extra_id_0> case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE:"
      },
      {
        "txt": "break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE:"
      },
      {
        "txt": "setupNoRandPartC(); break; default: throw new IllegalStateException(); } return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\");"
      },
      {
        "txt": "} int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; } int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\""
      },
      {
        "txt": ": \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true;"
      },
      {
        "txt": "} private void initBlock() throws IOException { char magic0; char magic1; char magic2; char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte();"
      },
      {
        "txt": "magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) {"
      },
      {
        "txt": "return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) {"
      },
      {
        "txt": "this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC();"
      },
      {
        "txt": "this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\");"
      },
      {
        "txt": "} this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; } private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) {"
      },
      {
        "txt": "throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) {"
      },
      {
        "txt": "inShadow.close(); } } finally { this.data = null; this.in = null; } } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive;"
      },
      {
        "txt": "int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "} while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) {"
      },
      {
        "txt": "int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;"
      },
      {
        "txt": "} private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) {"
      },
      {
        "txt": "for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; } } } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0;"
      },
      {
        "txt": "} for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1];"
      },
      {
        "txt": "vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; } for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException {"
      },
      {
        "txt": "final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; }"
      },
      {
        "txt": "} for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true;"
      },
      {
        "txt": "} } } } makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0;"
      },
      {
        "txt": "while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; } for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff;"
      },
      {
        "txt": "final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; } pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) {"
      },
      {
        "txt": "int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups);"
      },
      {
        "txt": "} private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) {"
      },
      {
        "txt": "int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent;"
      },
      {
        "txt": "} } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen; } } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables();"
      },
      {
        "txt": "final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base;"
      },
      {
        "txt": "final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0);"
      },
      {
        "txt": "int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) {"
      },
      {
        "txt": "int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) { s += n << 1; } else { break; } if (groupPos == 0) {"
      },
      {
        "txt": "groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt;"
      },
      {
        "txt": "while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } }"
      },
      {
        "txt": "int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException( \"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); }"
      },
      {
        "txt": "} else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j];"
      },
      {
        "txt": "} } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt];"
      },
      {
        "txt": "perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) {"
      },
      {
        "txt": "zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "} bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow;"
      },
      {
        "txt": "} private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;"
      },
      {
        "txt": "while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\");"
      },
      {
        "txt": "} } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException {"
      },
      {
        "txt": "if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i];"
      },
      {
        "txt": "cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; } if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0;"
      },
      {
        "txt": "this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0; return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException {"
      },
      {
        "txt": "if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else {"
      },
      {
        "txt": "this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock();"
      },
      {
        "txt": "initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos];"
      },
      {
        "txt": "this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock();"
      },
      {
        "txt": "} } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos];"
      },
      {
        "txt": "if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE;"
      },
      {
        "txt": "if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException {"
      },
      {
        "txt": "if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA();"
      },
      {
        "txt": "} } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0;"
      },
      {
        "txt": "return setupNoRandPartC(); } else { return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow);"
      },
      {
        "txt": "this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++; this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object {"
      },
      {
        "txt": "final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte"
      },
      {
        "txt": "final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt;"
      },
      {
        "txt": "if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; } } public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; }"
      },
      {
        "txt": "if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false; } if (signature[2] != 'h') { return false; } return true;"
      }
    ]
  },
  {
    "id": 1050,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 211,
    "end-bug-line": 212,
    "bug": "setupRandPartB(); break;",
    "fix": "return setupRandPartB();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr;"
      },
      {
        "txt": "private int blockSize100k; private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0;"
      },
      {
        "txt": "private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC;"
      },
      {
        "txt": "private int su_count; private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data;"
      },
      {
        "txt": "public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); }"
      },
      {
        "txt": "@Override public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } }"
      },
      {
        "txt": "@Override public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) {"
      },
      {
        "txt": "throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) {"
      },
      {
        "txt": "dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0;"
      },
      {
        "txt": "for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) {"
      },
      {
        "txt": "return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: <extra_id_0> case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); }"
      },
      {
        "txt": "return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; }"
      },
      {
        "txt": "int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\");"
      },
      {
        "txt": "} this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1; char magic2;"
      },
      {
        "txt": "char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte();"
      },
      {
        "txt": "if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')'"
      },
      {
        "txt": "magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1;"
      },
      {
        "txt": "if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC();"
      },
      {
        "txt": "if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; }"
      },
      {
        "txt": "private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override"
      },
      {
        "txt": "public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null; this.in = null;"
      },
      {
        "txt": "} } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();"
      },
      {
        "txt": "if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);"
      },
      {
        "txt": "} private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException {"
      },
      {
        "txt": "return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; }"
      },
      {
        "txt": "} } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {"
      },
      {
        "txt": "b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; }"
      },
      {
        "txt": "for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf;"
      },
      {
        "txt": "int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) {"
      },
      {
        "txt": "if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } } makeMaps();"
      },
      {
        "txt": "final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; }"
      },
      {
        "txt": "for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; }"
      },
      {
        "txt": "pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1;"
      },
      {
        "txt": "} len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d;"
      },
      {
        "txt": "final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i];"
      },
      {
        "txt": "if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen;"
      },
      {
        "txt": "} } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector;"
      },
      {
        "txt": "final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0;"
      },
      {
        "txt": "} int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt];"
      },
      {
        "txt": "int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) {"
      },
      {
        "txt": "s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt];"
      },
      {
        "txt": "minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++;"
      },
      {
        "txt": "while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\"); }"
      },
      {
        "txt": "} bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) {"
      },
      {
        "txt": "ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1];"
      },
      {
        "txt": "unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp;"
      },
      {
        "txt": "if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; }"
      },
      {
        "txt": "int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "} int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]];"
      },
      {
        "txt": "} } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff;"
      },
      {
        "txt": "final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1);"
      },
      {
        "txt": "final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; }"
      },
      {
        "txt": "if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0;"
      },
      {
        "txt": "return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) {"
      },
      {
        "txt": "this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow;"
      },
      {
        "txt": "this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException {"
      },
      {
        "txt": "if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;"
      },
      {
        "txt": "} else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE;"
      },
      {
        "txt": "this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; }"
      },
      {
        "txt": "} else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else {"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;"
      },
      {
        "txt": "} else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1;"
      },
      {
        "txt": "return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } }"
      },
      {
        "txt": "private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++;"
      },
      {
        "txt": "this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte"
      },
      {
        "txt": "final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte"
      },
      {
        "txt": "Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; }"
      },
      {
        "txt": "} public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false;"
      },
      {
        "txt": "} if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1051,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 215,
    "end-bug-line": 216,
    "bug": "setupRandPartC(); break;",
    "fix": "return setupRandPartC();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k; private boolean blockRandomised; private int bsBuff;"
      },
      {
        "txt": "private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3;"
      },
      {
        "txt": "private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2; private int su_chPrev;"
      },
      {
        "txt": "private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); }"
      },
      {
        "txt": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); } @Override public int read() throws IOException { if (this.in != null) {"
      },
      {
        "txt": "int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len) throws IOException {"
      },
      {
        "txt": "if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); }"
      },
      {
        "txt": "if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); }"
      },
      {
        "txt": "int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i;"
      },
      {
        "txt": "} } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE:"
      },
      {
        "txt": "case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: <extra_id_0> case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE:"
      },
      {
        "txt": "break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); } return retChar; } private boolean init(boolean isFirstStream) throws IOException {"
      },
      {
        "txt": "if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; } int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {"
      },
      {
        "txt": "throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0'; this.bsLive = 0;"
      },
      {
        "txt": "this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1; char magic2; char magic3; char magic4; char magic5;"
      },
      {
        "txt": "while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break;"
      },
      {
        "txt": "} if (complete()) { return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S'"
      },
      {
        "txt": "magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k); }"
      },
      {
        "txt": "getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31);"
      },
      {
        "txt": "this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; } private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF;"
      },
      {
        "txt": "this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) {"
      },
      {
        "txt": "try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null; this.in = null; } } }"
      },
      {
        "txt": "private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive;"
      },
      {
        "txt": "int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow; }"
      },
      {
        "txt": "this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit,"
      },
      {
        "txt": "final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; } } } for (int i = MAX_CODE_LEN; --i > 0;) {"
      },
      {
        "txt": "base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b; }"
      },
      {
        "txt": "for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; } for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; }"
      },
      {
        "txt": "} private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) {"
      },
      {
        "txt": "inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) {"
      },
      {
        "txt": "if (bsGetBit()) { inUse[i16 + j] = true; } } } } makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15);"
      },
      {
        "txt": "for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; } for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; }"
      },
      {
        "txt": "for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; } pos[0] = tmp; selector[i] = tmp; }"
      },
      {
        "txt": "final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr; }"
      },
      {
        "txt": "} createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base;"
      },
      {
        "txt": "final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent; }"
      },
      {
        "txt": "if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen; } } private void getAndMoveToFrontDecode() throws IOException {"
      },
      {
        "txt": "this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens;"
      },
      {
        "txt": "final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1;"
      },
      {
        "txt": "final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt];"
      },
      {
        "txt": "while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) { s += n << 1; } else { break;"
      },
      {
        "txt": "} if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--;"
      },
      {
        "txt": "} int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\");"
      },
      {
        "txt": "} } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1)"
      },
      {
        "txt": "| ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) {"
      },
      {
        "txt": "throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) {"
      },
      {
        "txt": "for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff;"
      },
      {
        "txt": "base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read();"
      },
      {
        "txt": "if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);"
      },
      {
        "txt": "bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else {"
      },
      {
        "txt": "throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow;"
      },
      {
        "txt": "this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn);"
      },
      {
        "txt": "int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue;"
      },
      {
        "txt": "} else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];"
      },
      {
        "txt": "} private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);"
      },
      {
        "txt": "for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; } if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); }"
      },
      {
        "txt": "this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0; return setupRandPartA(); } return setupNoRandPartA();"
      },
      {
        "txt": "} private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0;"
      },
      {
        "txt": "} } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;"
      },
      {
        "txt": "} else { endBlock(); initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;"
      },
      {
        "txt": "this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock();"
      },
      {
        "txt": "initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) {"
      },
      {
        "txt": "this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; }"
      },
      {
        "txt": "this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE; return setupRandPartA(); }"
      },
      {
        "txt": "} private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else { this.currentState = RAND_PART_A_STATE; this.su_i2++;"
      },
      {
        "txt": "this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);"
      },
      {
        "txt": "this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2;"
      },
      {
        "txt": "this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++; this.su_count = 0; return setupNoRandPartA(); }"
      },
      {
        "txt": "} private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte"
      },
      {
        "txt": "final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; }"
      },
      {
        "txt": "int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; } } public static boolean matches(byte[] signature, int length) { if (length < 3) {"
      },
      {
        "txt": "return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false; } if (signature[2] != 'h') { return false;"
      },
      {
        "txt": "} return true; }"
      }
    ]
  },
  {
    "id": 1052,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 222,
    "end-bug-line": 223,
    "bug": "setupNoRandPartB(); break;",
    "fix": "return setupNoRandPartB();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants {"
      },
      {
        "txt": "private int last; private int origPtr; private int blockSize100k; private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated;"
      },
      {
        "txt": "private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE;"
      },
      {
        "txt": "private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos;"
      },
      {
        "txt": "private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock();"
      },
      {
        "txt": "setupBlock(); } @Override public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\");"
      },
      {
        "txt": "} } @Override public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");"
      },
      {
        "txt": "} if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs;"
      },
      {
        "txt": "int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse;"
      },
      {
        "txt": "final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow; } private int read0() throws IOException {"
      },
      {
        "txt": "final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB();"
      },
      {
        "txt": "case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: <extra_id_0> case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); }"
      },
      {
        "txt": "throw new IllegalStateException(); } return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) {"
      },
      {
        "txt": "return false; } int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read();"
      },
      {
        "txt": "if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0;"
      },
      {
        "txt": "char magic1; char magic2; char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte();"
      },
      {
        "txt": "magic4 = bsGetUByte(); magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } }"
      },
      {
        "txt": "if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else {"
      },
      {
        "txt": "this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } }"
      },
      {
        "txt": "private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31);"
      },
      {
        "txt": "this.computedCombinedCRC ^= this.computedBlockCRC; } private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false);"
      },
      {
        "txt": "} @Override public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally {"
      },
      {
        "txt": "this.data = null; this.in = null; } } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in;"
      },
      {
        "txt": "do { int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; }"
      },
      {
        "txt": "this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\");"
      },
      {
        "txt": "} bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8);"
      },
      {
        "txt": "} private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) {"
      },
      {
        "txt": "perm[pp++] = j; } } } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++;"
      },
      {
        "txt": "} for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1;"
      },
      {
        "txt": "vec <<= 1; } for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos;"
      },
      {
        "txt": "final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false;"
      },
      {
        "txt": "} for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } }"
      },
      {
        "txt": "} makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; }"
      },
      {
        "txt": "selectorMtf[i] = (byte) j; } for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1];"
      },
      {
        "txt": "v--; } pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) {"
      },
      {
        "txt": "while (bsGetBit()) { curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) {"
      },
      {
        "txt": "final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t];"
      },
      {
        "txt": "for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,"
      },
      {
        "txt": "maxLen, alphaSize); minLens[t] = minLen; } } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8;"
      },
      {
        "txt": "final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) {"
      },
      {
        "txt": "yy[i] = (char) i; unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1;"
      },
      {
        "txt": "int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) {"
      },
      {
        "txt": "s += n; } else if (nextSym == RUNB) { s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt];"
      },
      {
        "txt": "limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn;"
      },
      {
        "txt": "while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException("
      },
      {
        "txt": "\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]];"
      },
      {
        "txt": "unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\");"
      },
      {
        "txt": "} final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1);"
      },
      {
        "txt": "} yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else {"
      },
      {
        "txt": "groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else {"
      },
      {
        "txt": "throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read();"
      },
      {
        "txt": "if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);"
      },
      {
        "txt": "} nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in;"
      },
      {
        "txt": "final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) {"
      },
      {
        "txt": "final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--;"
      },
      {
        "txt": "zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; }"
      },
      {
        "txt": "final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {"
      },
      {
        "txt": "tt[cftab[ll8[i] & 0xff]++] = i; } if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) {"
      },
      {
        "txt": "this.su_rNToGo = 0; this.su_rTPos = 0; return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;"
      },
      {
        "txt": "this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;"
      },
      {
        "txt": "this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); }"
      },
      {
        "txt": "} private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE;"
      },
      {
        "txt": "this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException {"
      },
      {
        "txt": "if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) {"
      },
      {
        "txt": "this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; }"
      },
      {
        "txt": "return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2);"
      },
      {
        "txt": "this.su_j2++; return this.su_ch2; } else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException {"
      },
      {
        "txt": "if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA();"
      },
      {
        "txt": "} } private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow;"
      },
      {
        "txt": "} else { this.su_i2++; this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte"
      },
      {
        "txt": "final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte"
      },
      {
        "txt": "int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; }"
      },
      {
        "txt": "return ttShadow; } } public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; }"
      },
      {
        "txt": "if (signature[1] != 'Z') { return false; } if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1053,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 226,
    "end-bug-line": 227,
    "bug": "setupNoRandPartC(); break;",
    "fix": "return setupNoRandPartC();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k;"
      },
      {
        "txt": "private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1;"
      },
      {
        "txt": "private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count;"
      },
      {
        "txt": "private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException {"
      },
      {
        "txt": "this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); } @Override"
      },
      {
        "txt": "public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } } @Override"
      },
      {
        "txt": "public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\""
      },
      {
        "txt": "+ len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b;"
      },
      {
        "txt": "count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) {"
      },
      {
        "txt": "if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF:"
      },
      {
        "txt": "return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC();"
      },
      {
        "txt": "case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: <extra_id_0> default: throw new IllegalStateException(); } return retChar; } private boolean init(boolean isFirstStream) throws IOException {"
      },
      {
        "txt": "} private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; } int magic1 = this.in.read();"
      },
      {
        "txt": "int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\"); }"
      },
      {
        "txt": "this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1; char magic2; char magic3;"
      },
      {
        "txt": "char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45"
      },
      {
        "txt": "|| magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y'"
      },
      {
        "txt": "magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1; if (this.data == null) {"
      },
      {
        "txt": "this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) {"
      },
      {
        "txt": "this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; } private boolean complete() throws IOException {"
      },
      {
        "txt": "this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override public void close() throws IOException {"
      },
      {
        "txt": "InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null; this.in = null; }"
      },
      {
        "txt": "} } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read(); if (thech < 0) {"
      },
      {
        "txt": "throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); }"
      },
      {
        "txt": "private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);"
      },
      {
        "txt": "} private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; } }"
      },
      {
        "txt": "} for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i];"
      },
      {
        "txt": "base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; } for (int i = minLen + 1; i <= maxLen; i++) {"
      },
      {
        "txt": "base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0;"
      },
      {
        "txt": "for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) {"
      },
      {
        "txt": "final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } } makeMaps(); final int alphaSize = this.nInUse + 2;"
      },
      {
        "txt": "final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; } for (int v = nGroups; --v >= 0;) {"
      },
      {
        "txt": "pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; } pos[0] = tmp;"
      },
      {
        "txt": "selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1; }"
      },
      {
        "txt": "len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens;"
      },
      {
        "txt": "final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i]; if (lent > maxLen) {"
      },
      {
        "txt": "maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen; }"
      },
      {
        "txt": "} private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq;"
      },
      {
        "txt": "final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0; }"
      },
      {
        "txt": "int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt];"
      },
      {
        "txt": "int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) { s += n << 1;"
      },
      {
        "txt": "} else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt];"
      },
      {
        "txt": "} else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue;"
      },
      {
        "txt": "} else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) {"
      },
      {
        "txt": "final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\"); } }"
      },
      {
        "txt": "bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch;"
      },
      {
        "txt": "} if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++;"
      },
      {
        "txt": "ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp; if (groupPos == 0) {"
      },
      {
        "txt": "groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt;"
      },
      {
        "txt": "while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } }"
      },
      {
        "txt": "int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; }"
      },
      {
        "txt": "} this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt];"
      },
      {
        "txt": "int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } this.bsLive = bsLiveShadow;"
      },
      {
        "txt": "this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8;"
      },
      {
        "txt": "cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; } if ((this.origPtr < 0) || (this.origPtr >= tt.length)) {"
      },
      {
        "txt": "throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0; return setupRandPartA();"
      },
      {
        "txt": "} return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;"
      },
      {
        "txt": "if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE;"
      },
      {
        "txt": "this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) {"
      },
      {
        "txt": "this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else {"
      },
      {
        "txt": "this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1;"
      },
      {
        "txt": "return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else {"
      },
      {
        "txt": "this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE;"
      },
      {
        "txt": "return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else {"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA();"
      },
      {
        "txt": "} else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException {"
      },
      {
        "txt": "if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++; this.su_count = 0;"
      },
      {
        "txt": "return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte"
      },
      {
        "txt": "final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) {"
      },
      {
        "txt": "this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; } }"
      },
      {
        "txt": "public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false; }"
      },
      {
        "txt": "if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1054,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 232,
    "end-bug-line": 232,
    "bug": "return retChar;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream;"
      },
      {
        "txt": "public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k; private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse;"
      },
      {
        "txt": "private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6;"
      },
      {
        "txt": "private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo;"
      },
      {
        "txt": "private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated;"
      },
      {
        "txt": "init(true); initBlock(); setupBlock(); } @Override public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r;"
      },
      {
        "txt": "} else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); }"
      },
      {
        "txt": "if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\"); }"
      },
      {
        "txt": "final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; }"
      },
      {
        "txt": "private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow;"
      },
      {
        "txt": "} private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException();"
      },
      {
        "txt": "case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB();"
      },
      {
        "txt": "case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); } <extra_id_0> } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read();"
      },
      {
        "txt": "} int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; } int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\""
      },
      {
        "txt": ": \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true;"
      },
      {
        "txt": "} private void initBlock() throws IOException { char magic0; char magic1; char magic2; char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte();"
      },
      {
        "txt": "magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) {"
      },
      {
        "txt": "return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) {"
      },
      {
        "txt": "this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC();"
      },
      {
        "txt": "this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\");"
      },
      {
        "txt": "} this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; } private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) {"
      },
      {
        "txt": "throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) {"
      },
      {
        "txt": "inShadow.close(); } } finally { this.data = null; this.in = null; } } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive;"
      },
      {
        "txt": "int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "} while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) {"
      },
      {
        "txt": "int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;"
      },
      {
        "txt": "} private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) {"
      },
      {
        "txt": "for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; } } } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0;"
      },
      {
        "txt": "} for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1];"
      },
      {
        "txt": "vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; } for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException {"
      },
      {
        "txt": "final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; }"
      },
      {
        "txt": "} for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true;"
      },
      {
        "txt": "} } } } makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0;"
      },
      {
        "txt": "while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; } for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff;"
      },
      {
        "txt": "final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; } pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) {"
      },
      {
        "txt": "int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups);"
      },
      {
        "txt": "} private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) {"
      },
      {
        "txt": "int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent;"
      },
      {
        "txt": "} } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen; } } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables();"
      },
      {
        "txt": "final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base;"
      },
      {
        "txt": "final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0);"
      },
      {
        "txt": "int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) {"
      },
      {
        "txt": "int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) { s += n << 1; } else { break; } if (groupPos == 0) {"
      },
      {
        "txt": "groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt;"
      },
      {
        "txt": "while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } }"
      },
      {
        "txt": "int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException( \"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); }"
      },
      {
        "txt": "} else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j];"
      },
      {
        "txt": "} } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt];"
      },
      {
        "txt": "perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) {"
      },
      {
        "txt": "zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "} bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow;"
      },
      {
        "txt": "} private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;"
      },
      {
        "txt": "while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\");"
      },
      {
        "txt": "} } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException {"
      },
      {
        "txt": "if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i];"
      },
      {
        "txt": "cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; } if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0;"
      },
      {
        "txt": "this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0; return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException {"
      },
      {
        "txt": "if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else {"
      },
      {
        "txt": "this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock();"
      },
      {
        "txt": "initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos];"
      },
      {
        "txt": "this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock();"
      },
      {
        "txt": "} } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos];"
      },
      {
        "txt": "if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE;"
      },
      {
        "txt": "if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException {"
      },
      {
        "txt": "if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA();"
      },
      {
        "txt": "} } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0;"
      },
      {
        "txt": "return setupNoRandPartC(); } else { return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow);"
      },
      {
        "txt": "this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++; this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object {"
      },
      {
        "txt": "final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte"
      },
      {
        "txt": "final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt;"
      },
      {
        "txt": "if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; } } public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; }"
      },
      {
        "txt": "if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false; } if (signature[2] != 'h') { return false; } return true;"
      }
    ]
  },
  {
    "id": 1055,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 853,
    "end-bug-line": 853,
    "bug": "this.currentChar = su_ch2Shadow;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream;"
      },
      {
        "txt": "import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k; private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC();"
      },
      {
        "txt": "private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5;"
      },
      {
        "txt": "private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2;"
      },
      {
        "txt": "private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in;"
      },
      {
        "txt": "this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); } @Override public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1);"
      },
      {
        "txt": "return r; } else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");"
      },
      {
        "txt": "} if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\");"
      },
      {
        "txt": "} final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c;"
      },
      {
        "txt": "} private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i; } }"
      },
      {
        "txt": "this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE:"
      },
      {
        "txt": "throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE:"
      },
      {
        "txt": "setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); } return retChar; }"
      },
      {
        "txt": "private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; } int magic1 = this.in.read(); int magic2 = this.in.read();"
      },
      {
        "txt": "if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0';"
      },
      {
        "txt": "this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1; char magic2; char magic3; char magic4;"
      },
      {
        "txt": "char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) {"
      },
      {
        "txt": "break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&'"
      },
      {
        "txt": "magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k);"
      },
      {
        "txt": "} getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1)"
      },
      {
        "txt": "| (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; } private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt();"
      },
      {
        "txt": "this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); } @Override public void close() throws IOException { InputStream inShadow = this.in;"
      },
      {
        "txt": "if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null; this.in = null; } }"
      },
      {
        "txt": "} private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\");"
      },
      {
        "txt": "} bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException {"
      },
      {
        "txt": "int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow;"
      },
      {
        "txt": "} this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); }"
      },
      {
        "txt": "private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; } } }"
      },
      {
        "txt": "for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b;"
      },
      {
        "txt": "} for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1; } for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i];"
      },
      {
        "txt": "} } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) {"
      },
      {
        "txt": "if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4;"
      },
      {
        "txt": "for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } } makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3);"
      },
      {
        "txt": "final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j; } for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v;"
      },
      {
        "txt": "} for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--; } pos[0] = tmp; selector[i] = tmp;"
      },
      {
        "txt": "} final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr;"
      },
      {
        "txt": "} } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit;"
      },
      {
        "txt": "final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent;"
      },
      {
        "txt": "} if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen; } }"
      },
      {
        "txt": "private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;"
      },
      {
        "txt": "final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0; } int groupNo = 0;"
      },
      {
        "txt": "int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt];"
      },
      {
        "txt": "int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) { s += n << 1; } else {"
      },
      {
        "txt": "break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else {"
      },
      {
        "txt": "groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else {"
      },
      {
        "txt": "throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read();"
      },
      {
        "txt": "if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\"); } } bsLiveShadow--;"
      },
      {
        "txt": "zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch; }"
      },
      {
        "txt": "if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp];"
      },
      {
        "txt": "if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1;"
      },
      {
        "txt": "zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) {"
      },
      {
        "txt": "final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn))"
      },
      {
        "txt": "& ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue;"
      },
      {
        "txt": "} else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } }"
      },
      {
        "txt": "this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt];"
      },
      {
        "txt": "int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow;"
      },
      {
        "txt": "return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0;"
      },
      {
        "txt": "System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; } if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\");"
      },
      {
        "txt": "} this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0; return setupRandPartA(); }"
      },
      {
        "txt": "return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) {"
      },
      {
        "txt": "} } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; <extra_id_0> this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock();"
      },
      {
        "txt": "endBlock(); initBlock(); return setupBlock(); } } private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow;"
      },
      {
        "txt": "this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock();"
      },
      {
        "txt": "return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);"
      },
      {
        "txt": "this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_j2 = 0;"
      },
      {
        "txt": "this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } }"
      },
      {
        "txt": "private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0;"
      },
      {
        "txt": "return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos];"
      },
      {
        "txt": "this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow;"
      },
      {
        "txt": "this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++; this.su_count = 0; return setupNoRandPartA(); } }"
      },
      {
        "txt": "private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte"
      },
      {
        "txt": "final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) {"
      },
      {
        "txt": "int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; } } public static boolean matches(byte[] signature, int length) { if (length < 3) { return false;"
      },
      {
        "txt": "} if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false; } if (signature[2] != 'h') { return false; }"
      },
      {
        "txt": "return true; }"
      }
    ]
  },
  {
    "id": 1056,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 871,
    "end-bug-line": 871,
    "bug": "this.currentChar = su_ch2Shadow;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k; private boolean blockRandomised;"
      },
      {
        "txt": "private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2;"
      },
      {
        "txt": "private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2;"
      },
      {
        "txt": "private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false);"
      },
      {
        "txt": "} public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); } @Override public int read() throws IOException {"
      },
      {
        "txt": "if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len)"
      },
      {
        "txt": "throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\");"
      },
      {
        "txt": "} if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1);"
      },
      {
        "txt": "} int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) {"
      },
      {
        "txt": "seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1;"
      },
      {
        "txt": "case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break;"
      },
      {
        "txt": "case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException();"
      },
      {
        "txt": "} return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false;"
      },
      {
        "txt": "} int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) {"
      },
      {
        "txt": "throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1;"
      },
      {
        "txt": "char magic2; char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte();"
      },
      {
        "txt": "magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1'"
      },
      {
        "txt": "magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt();"
      },
      {
        "txt": "this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException {"
      },
      {
        "txt": "this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC;"
      },
      {
        "txt": "} private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); }"
      },
      {
        "txt": "@Override public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null;"
      },
      {
        "txt": "this.in = null; } } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do {"
      },
      {
        "txt": "int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n;"
      },
      {
        "txt": "return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); }"
      },
      {
        "txt": "private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j;"
      },
      {
        "txt": "} } } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; }"
      },
      {
        "txt": "for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1;"
      },
      {
        "txt": "} for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector;"
      },
      {
        "txt": "final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; }"
      },
      {
        "txt": "for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } }"
      },
      {
        "txt": "makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j;"
      },
      {
        "txt": "} for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--;"
      },
      {
        "txt": "} pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) {"
      },
      {
        "txt": "curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data;"
      },
      {
        "txt": "final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) {"
      },
      {
        "txt": "final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize);"
      },
      {
        "txt": "minLens[t] = minLen; } } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab;"
      },
      {
        "txt": "final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i;"
      },
      {
        "txt": "unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff;"
      },
      {
        "txt": "int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n;"
      },
      {
        "txt": "} else if (nextSym == RUNB) { s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt];"
      },
      {
        "txt": "perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) {"
      },
      {
        "txt": "zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\");"
      },
      {
        "txt": "} } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1;"
      },
      {
        "txt": "while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); }"
      },
      {
        "txt": "final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); }"
      },
      {
        "txt": "yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--;"
      },
      {
        "txt": "} int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\");"
      },
      {
        "txt": "} } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data;"
      },
      {
        "txt": "final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read();"
      },
      {
        "txt": "if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);"
      },
      {
        "txt": "} this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab;"
      },
      {
        "txt": "final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i;"
      },
      {
        "txt": "} if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0;"
      },
      {
        "txt": "this.su_rTPos = 0; return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos];"
      },
      {
        "txt": "if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++;"
      },
      {
        "txt": "this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); } }"
      },
      {
        "txt": "if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; <extra_id_0> this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock();"
      },
      {
        "txt": "this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1;"
      },
      {
        "txt": "return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else {"
      },
      {
        "txt": "this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE;"
      },
      {
        "txt": "return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else {"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA();"
      },
      {
        "txt": "} else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException {"
      },
      {
        "txt": "if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++; this.su_count = 0;"
      },
      {
        "txt": "return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte"
      },
      {
        "txt": "final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) {"
      },
      {
        "txt": "this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; } }"
      },
      {
        "txt": "public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false; }"
      },
      {
        "txt": "if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1057,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 913,
    "end-bug-line": 913,
    "bug": "this.currentChar = this.su_ch2;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last; private int origPtr; private int blockSize100k; private boolean blockRandomised;"
      },
      {
        "txt": "private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2;"
      },
      {
        "txt": "private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC; private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2;"
      },
      {
        "txt": "private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z; private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false);"
      },
      {
        "txt": "} public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock(); } @Override public int read() throws IOException {"
      },
      {
        "txt": "if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); } } @Override public int read(final byte[] dest, final int offs, final int len)"
      },
      {
        "txt": "throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\");"
      },
      {
        "txt": "} if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1);"
      },
      {
        "txt": "} int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq; int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) {"
      },
      {
        "txt": "seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1;"
      },
      {
        "txt": "case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break;"
      },
      {
        "txt": "case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException();"
      },
      {
        "txt": "} return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); } int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false;"
      },
      {
        "txt": "} int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\"); } int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) {"
      },
      {
        "txt": "throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; } private void initBlock() throws IOException { char magic0; char magic1;"
      },
      {
        "txt": "char magic2; char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte(); magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte();"
      },
      {
        "txt": "magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return; } } if (magic0 != 0x31 || // '1'"
      },
      {
        "txt": "magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF; throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt();"
      },
      {
        "txt": "this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE; } } private void endBlock() throws IOException {"
      },
      {
        "txt": "this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); } this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC;"
      },
      {
        "txt": "} private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\"); } return !decompressConcatenated || !init(false); }"
      },
      {
        "txt": "@Override public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close(); } } finally { this.data = null;"
      },
      {
        "txt": "this.in = null; } } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < n) { final InputStream inShadow = this.in; do {"
      },
      {
        "txt": "int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n;"
      },
      {
        "txt": "return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; } private char bsGetUByte() throws IOException { return (char) bsR(8); }"
      },
      {
        "txt": "private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) { for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j;"
      },
      {
        "txt": "} } } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; } for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; }"
      },
      {
        "txt": "for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b; b = nb; limit[i] = vec - 1; vec <<= 1;"
      },
      {
        "txt": "} for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data; final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector;"
      },
      {
        "txt": "final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } } for (int i = 256; --i >= 0;) { inUse[i] = false; }"
      },
      {
        "txt": "for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; } } } }"
      },
      {
        "txt": "makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) { j++; } selectorMtf[i] = (byte) j;"
      },
      {
        "txt": "} for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v]; while (v > 0) { pos[v] = pos[v - 1]; v--;"
      },
      {
        "txt": "} pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5); final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) {"
      },
      {
        "txt": "curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); } private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data;"
      },
      {
        "txt": "final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32; int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) {"
      },
      {
        "txt": "final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; } } hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize);"
      },
      {
        "txt": "minLens[t] = minLen; } } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab;"
      },
      {
        "txt": "final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i;"
      },
      {
        "txt": "unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff;"
      },
      {
        "txt": "int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n;"
      },
      {
        "txt": "} else if (nextSym == RUNB) { s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt];"
      },
      {
        "txt": "perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech;"
      },
      {
        "txt": "bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) {"
      },
      {
        "txt": "zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException( \"unexpected end of stream\");"
      },
      {
        "txt": "} } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1;"
      },
      {
        "txt": "while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); }"
      },
      {
        "txt": "final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); }"
      },
      {
        "txt": "yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--;"
      },
      {
        "txt": "} int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\");"
      },
      {
        "txt": "} } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) {"
      },
      {
        "txt": "bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); }"
      },
      {
        "txt": "nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; } private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data;"
      },
      {
        "txt": "final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read();"
      },
      {
        "txt": "if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);"
      },
      {
        "txt": "} this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) { return -1; } final int[] cftab = this.data.cftab;"
      },
      {
        "txt": "final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c; } for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i;"
      },
      {
        "txt": "} if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0; this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0;"
      },
      {
        "txt": "this.su_rTPos = 0; return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos];"
      },
      {
        "txt": "if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++;"
      },
      {
        "txt": "this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock(); return setupBlock(); } }"
      },
      {
        "txt": "private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow);"
      },
      {
        "txt": "return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); } } private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) {"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0;"
      },
      {
        "txt": "} } else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) { this.su_z ^= 1; } return setupRandPartC();"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { <extra_id_0> this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else { this.currentState = RAND_PART_A_STATE; this.su_i2++;"
      },
      {
        "txt": "this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); } } private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA();"
      },
      {
        "txt": "} else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC(); } else { return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException {"
      },
      {
        "txt": "if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++; this.su_count = 0;"
      },
      {
        "txt": "return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte"
      },
      {
        "txt": "final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) {"
      },
      {
        "txt": "this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; } return ttShadow; } }"
      },
      {
        "txt": "public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; } if (signature[1] != 'Z') { return false; }"
      },
      {
        "txt": "if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  },
  {
    "id": 1058,
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
    "start-bug-line": 942,
    "end-bug-line": 942,
    "bug": "this.currentChar = su_ch2Shadow;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.compress.compressors.bzip2; import java.io.IOException; import java.io.InputStream; import org.apache.commons.compress.compressors.CompressorInputStream; public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants { private int last;"
      },
      {
        "txt": "private int origPtr; private int blockSize100k; private boolean blockRandomised; private int bsBuff; private int bsLive; private final CRC crc = new CRC(); private int nInUse; private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1;"
      },
      {
        "txt": "private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2; private static final int RAND_PART_B_STATE = 3; private static final int RAND_PART_C_STATE = 4; private static final int NO_RAND_PART_A_STATE = 5; private static final int NO_RAND_PART_B_STATE = 6; private static final int NO_RAND_PART_C_STATE = 7; private int currentState = START_BLOCK_STATE; private int storedBlockCRC, storedCombinedCRC;"
      },
      {
        "txt": "private int computedBlockCRC, computedCombinedCRC; private int su_count; private int su_ch2; private int su_chPrev; private int su_i2; private int su_j2; private int su_rNToGo; private int su_rTPos; private int su_tPos; private char su_z;"
      },
      {
        "txt": "private BZip2CompressorInputStream.Data data; public BZip2CompressorInputStream(final InputStream in) throws IOException { this(in, false); } public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException { this.in = in; this.decompressConcatenated = decompressConcatenated; init(true); initBlock(); setupBlock();"
      },
      {
        "txt": "} @Override public int read() throws IOException { if (this.in != null) { int r = read0(); count(r < 0 ? -1 : 1); return r; } else { throw new IOException(\"stream closed\"); }"
      },
      {
        "txt": "} @Override public int read(final byte[] dest, final int offs, final int len) throws IOException { if (offs < 0) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\"); } if (len < 0) { throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\"); }"
      },
      {
        "txt": "if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\"); } if (this.in == null) { throw new IOException(\"stream closed\"); } final int hi = offs + len; int destOffs = offs; int b;"
      },
      {
        "txt": "while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; } private void makeMaps() { final boolean[] inUse = this.data.inUse; final byte[] seqToUnseq = this.data.seqToUnseq;"
      },
      {
        "txt": "int nInUseShadow = 0; for (int i = 0; i < 256; i++) { if (inUse[i]) { seqToUnseq[nInUseShadow++] = (byte) i; } } this.nInUse = nInUseShadow; } private int read0() throws IOException { final int retChar = this.currentChar;"
      },
      {
        "txt": "switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break;"
      },
      {
        "txt": "case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC();"
      },
      {
        "txt": "break; default: throw new IllegalStateException(); } return retChar; } private boolean init(boolean isFirstStream) throws IOException { if (null == in) { throw new IOException(\"No InputStream\"); }"
      },
      {
        "txt": "int magic0 = this.in.read(); if (magic0 == -1 && !isFirstStream) { return false; } int magic1 = this.in.read(); int magic2 = this.in.read(); if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') { throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\");"
      },
      {
        "txt": "} int blockSize = this.in.read(); if ((blockSize < '1') || (blockSize > '9')) { throw new IOException(\"BZip2 block size is invalid\"); } this.blockSize100k = blockSize - '0'; this.bsLive = 0; this.computedCombinedCRC = 0; return true; }"
      },
      {
        "txt": "private void initBlock() throws IOException { char magic0; char magic1; char magic2; char magic3; char magic4; char magic5; while (true) { magic0 = bsGetUByte(); magic1 = bsGetUByte();"
      },
      {
        "txt": "magic2 = bsGetUByte(); magic3 = bsGetUByte(); magic4 = bsGetUByte(); magic5 = bsGetUByte(); if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45 || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) { break; } if (complete()) { return;"
      },
      {
        "txt": "} } if (magic0 != 0x31 || // '1' magic1 != 0x41 || // ')' magic2 != 0x59 || // 'Y' magic3 != 0x26 || // '&' magic4 != 0x53 || // 'S' magic5 != 0x59 // 'Y' ) { this.currentState = EOF;"
      },
      {
        "txt": "throw new IOException(\"bad block header\"); } else { this.storedBlockCRC = bsGetInt(); this.blockRandomised = bsR(1) == 1; if (this.data == null) { this.data = new Data(this.blockSize100k); } getAndMoveToFrontDecode(); this.crc.initialiseCRC(); this.currentState = START_BLOCK_STATE;"
      },
      {
        "txt": "} } private void endBlock() throws IOException { this.computedBlockCRC = this.crc.getFinalCRC(); if (this.storedBlockCRC != this.computedBlockCRC) { this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.storedBlockCRC; throw new IOException(\"BZip2 CRC error\"); }"
      },
      {
        "txt": "this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); this.computedCombinedCRC ^= this.computedBlockCRC; } private boolean complete() throws IOException { this.storedCombinedCRC = bsGetInt(); this.currentState = EOF; this.data = null; if (this.storedCombinedCRC != this.computedCombinedCRC) { throw new IOException(\"BZip2 CRC error\");"
      },
      {
        "txt": "} return !decompressConcatenated || !init(false); } @Override public void close() throws IOException { InputStream inShadow = this.in; if (inShadow != null) { try { if (inShadow != System.in) { inShadow.close();"
      },
      {
        "txt": "} } finally { this.data = null; this.in = null; } } } private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;"
      },
      {
        "txt": "if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read(); if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n);"
      },
      {
        "txt": "this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); } private boolean bsGetBit() throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; if (bsLiveShadow < 1) { int thech = this.in.read();"
      },
      {
        "txt": "if (thech < 0) { throw new IOException(\"unexpected end of stream\"); } bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; this.bsBuff = bsBuffShadow; } this.bsLive = bsLiveShadow - 1; return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; }"
      },
      {
        "txt": "private char bsGetUByte() throws IOException { return (char) bsR(8); } private int bsGetInt() throws IOException { return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); } private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { for (int i = minLen, pp = 0; i <= maxLen; i++) {"
      },
      {
        "txt": "for (int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp++] = j; } } } for (int i = MAX_CODE_LEN; --i > 0;) { base[i] = 0; limit[i] = 0; }"
      },
      {
        "txt": "for (int i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { b += base[i]; base[i] = b; } for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { final int nb = base[i + 1]; vec += nb - b;"
      },
      {
        "txt": "b = nb; limit[i] = vec - 1; vec <<= 1; } for (int i = minLen + 1; i <= maxLen; i++) { base[i] = ((limit[i - 1] + 1) << 1) - base[i]; } } private void recvDecodingTables() throws IOException { final Data dataShadow = this.data;"
      },
      {
        "txt": "final boolean[] inUse = dataShadow.inUse; final byte[] pos = dataShadow.recvDecodingTables_pos; final byte[] selector = dataShadow.selector; final byte[] selectorMtf = dataShadow.selectorMtf; int inUse16 = 0; for (int i = 0; i < 16; i++) { if (bsGetBit()) { inUse16 |= 1 << i; } }"
      },
      {
        "txt": "for (int i = 256; --i >= 0;) { inUse[i] = false; } for (int i = 0; i < 16; i++) { if ((inUse16 & (1 << i)) != 0) { final int i16 = i << 4; for (int j = 0; j < 16; j++) { if (bsGetBit()) { inUse[i16 + j] = true; }"
      },
      {
        "txt": "} } } makeMaps(); final int alphaSize = this.nInUse + 2; final int nGroups = bsR(3); final int nSelectors = bsR(15); for (int i = 0; i < nSelectors; i++) { int j = 0; while (bsGetBit()) {"
      },
      {
        "txt": "j++; } selectorMtf[i] = (byte) j; } for (int v = nGroups; --v >= 0;) { pos[v] = (byte) v; } for (int i = 0; i < nSelectors; i++) { int v = selectorMtf[i] & 0xff; final byte tmp = pos[v];"
      },
      {
        "txt": "while (v > 0) { pos[v] = pos[v - 1]; v--; } pos[0] = tmp; selector[i] = tmp; } final char[][] len = dataShadow.temp_charArray2d; for (int t = 0; t < nGroups; t++) { int curr = bsR(5);"
      },
      {
        "txt": "final char[] len_t = len[t]; for (int i = 0; i < alphaSize; i++) { while (bsGetBit()) { curr += bsGetBit() ? -1 : 1; } len_t[i] = (char) curr; } } createHuffmanDecodingTables(alphaSize, nGroups); }"
      },
      {
        "txt": "private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { final Data dataShadow = this.data; final char[][] len = dataShadow.temp_charArray2d; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; for (int t = 0; t < nGroups; t++) { int minLen = 32;"
      },
      {
        "txt": "int maxLen = 0; final char[] len_t = len[t]; for (int i = alphaSize; --i >= 0;) { final char lent = len_t[i]; if (lent > maxLen) { maxLen = lent; } if (lent < minLen) { minLen = lent; }"
      },
      {
        "txt": "} hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); minLens[t] = minLen; } } private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in;"
      },
      {
        "txt": "final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm;"
      },
      {
        "txt": "final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0;) { yy[i] = (char) i; unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff;"
      },
      {
        "txt": "int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1;"
      },
      {
        "txt": "for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) { s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1;"
      },
      {
        "txt": "zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) {"
      },
      {
        "txt": "final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn))"
      },
      {
        "txt": "& ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue;"
      },
      {
        "txt": "} else { throw new IOException( \"unexpected end of stream\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]];"
      },
      {
        "txt": "} final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } } else {"
      },
      {
        "txt": "if (++lastShadow >= limitLast) { throw new IOException(\"block overrun\"); } final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0;) { yy[j] = yy[--j]; }"
      },
      {
        "txt": "} else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt];"
      },
      {
        "txt": "minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8;"
      },
      {
        "txt": "continue; } else { throw new IOException(\"unexpected end of stream\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++;"
      },
      {
        "txt": "while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); } }"
      },
      {
        "txt": "bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; }"
      },
      {
        "txt": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { final InputStream inShadow = this.in; final Data dataShadow = this.data; final int zt = dataShadow.selector[groupNo] & 0xff; final int[] limit_zt = dataShadow.limit[zt]; int zn = dataShadow.minLens[zt]; int zvec = bsR(zn); int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; while (zvec > limit_zt[zn]) {"
      },
      {
        "txt": "zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\"unexpected end of stream\"); }"
      },
      {
        "txt": "} bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; } private int setupBlock() throws IOException { if (currentState == EOF || this.data == null) {"
      },
      {
        "txt": "return -1; } final int[] cftab = this.data.cftab; final int[] tt = this.data.initTT(this.last + 1); final byte[] ll8 = this.data.ll8; cftab[0] = 0; System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); for (int i = 1, c = cftab[0]; i <= 256; i++) { c += cftab[i]; cftab[i] = c;"
      },
      {
        "txt": "} for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { tt[cftab[ll8[i] & 0xff]++] = i; } if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { throw new IOException(\"stream corrupted\"); } this.su_tPos = tt[this.origPtr]; this.su_count = 0; this.su_i2 = 0;"
      },
      {
        "txt": "this.su_ch2 = 256; /* not a char and not EOF */ if (this.blockRandomised) { this.su_rNToGo = 0; this.su_rTPos = 0; return setupRandPartA(); } return setupNoRandPartA(); } private int setupRandPartA() throws IOException { if (this.su_i2 <= this.last) {"
      },
      {
        "txt": "this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) { this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--;"
      },
      {
        "txt": "} this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { endBlock(); initBlock();"
      },
      {
        "txt": "return setupBlock(); } } private int setupNoRandPartA() throws IOException { if (this.su_i2 <= this.last) { this.su_chPrev = this.su_ch2; int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++;"
      },
      {
        "txt": "this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow; } else { this.currentState = NO_RAND_PART_A_STATE; endBlock(); initBlock(); return setupBlock(); }"
      },
      {
        "txt": "} private int setupRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.currentState = RAND_PART_A_STATE; this.su_count = 1; return setupRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; if (this.su_rNToGo == 0) {"
      },
      {
        "txt": "this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1; if (++this.su_rTPos == 512) { this.su_rTPos = 0; } } else { this.su_rNToGo--; } this.su_j2 = 0; this.currentState = RAND_PART_C_STATE; if (this.su_rNToGo == 1) {"
      },
      {
        "txt": "this.su_z ^= 1; } return setupRandPartC(); } else { this.currentState = RAND_PART_A_STATE; return setupRandPartA(); } } private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) {"
      },
      {
        "txt": "this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2; } else { this.currentState = RAND_PART_A_STATE; this.su_i2++; this.su_count = 0; return setupRandPartA(); }"
      },
      {
        "txt": "} private int setupNoRandPartB() throws IOException { if (this.su_ch2 != this.su_chPrev) { this.su_count = 1; return setupNoRandPartA(); } else if (++this.su_count >= 4) { this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); this.su_tPos = this.data.tt[this.su_tPos]; this.su_j2 = 0; return setupNoRandPartC();"
      },
      {
        "txt": "return setupNoRandPartA(); } } private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; <extra_id_0> this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE; return su_ch2Shadow; } else { this.su_i2++;"
      },
      {
        "txt": "} else { this.su_i2++; this.su_count = 0; return setupNoRandPartA(); } } private static final class Data extends Object { final boolean[] inUse = new boolean[256]; // 256 byte final byte[] seqToUnseq = new byte[256]; // 256 byte final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte"
      },
      {
        "txt": "final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte final int[] unzftab = new int[256]; // 1024 byte final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte final int[] minLens = new int[N_GROUPS]; // 24 byte final int[] cftab = new int[257]; // 1028 byte final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096 final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte"
      },
      {
        "txt": "int[] tt; // 3600000 byte byte[] ll8; // 900000 byte Data(int blockSize100k) { this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE]; } int[] initTT(int length) { int[] ttShadow = this.tt; if ((ttShadow == null) || (ttShadow.length < length)) { this.tt = ttShadow = new int[length]; }"
      },
      {
        "txt": "return ttShadow; } } public static boolean matches(byte[] signature, int length) { if (length < 3) { return false; } if (signature[0] != 'B') { return false; }"
      },
      {
        "txt": "if (signature[1] != 'Z') { return false; } if (signature[2] != 'h') { return false; } return true; }"
      }
    ]
  }
]