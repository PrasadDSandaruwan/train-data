[
  {
    "id": 1176,
    "file_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
    "start-bug-line": 954,
    "end-bug-line": 954,
    "bug": "} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {",
    "fix": "} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.gson.stream; import com.google.gson.internal.JsonReaderInternalAccess; import com.google.gson.internal.bind.JsonTreeReader; import java.io.Closeable; import java.io.EOFException; import java.io.IOException; import java.io.Reader;"
      },
      {
        "txt": "public class JsonReader implements Closeable { private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray(); private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10; private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6;"
      },
      {
        "txt": "private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16;"
      },
      {
        "txt": "private static final int PEEKED_EOF = 17; private static final int NUMBER_CHAR_NONE = 0; private static final int NUMBER_CHAR_SIGN = 1; private static final int NUMBER_CHAR_DIGIT = 2; private static final int NUMBER_CHAR_DECIMAL = 3; private static final int NUMBER_CHAR_FRACTION_DIGIT = 4; private static final int NUMBER_CHAR_EXP_E = 5; private static final int NUMBER_CHAR_EXP_SIGN = 6; private static final int NUMBER_CHAR_EXP_DIGIT = 7; private final Reader in;"
      },
      {
        "txt": "private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private int limit = 0; private int lineNumber = 0; private int lineStart = 0; int peeked = PEEKED_NONE; private long peekedLong; private int peekedNumberLength; private String peekedString;"
      },
      {
        "txt": "private int[] stack = new int[32]; private int stackSize = 0; { stack[stackSize++] = JsonScope.EMPTY_DOCUMENT; } private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; public JsonReader(Reader in) { if (in == null) { throw new NullPointerException(\"in == null\");"
      },
      {
        "txt": "} this.in = in; } public final void setLenient(boolean lenient) { this.lenient = lenient; } public final boolean isLenient() { return lenient; } public void beginArray() throws IOException {"
      },
      {
        "txt": "int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--;"
      },
      {
        "txt": "pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) {"
      },
      {
        "txt": "p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } }"
      },
      {
        "txt": "public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected! pathIndices[stackSize - 1]++; peeked = PEEKED_NONE;"
      },
      {
        "txt": "} else { throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); }"
      },
      {
        "txt": "return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT;"
      },
      {
        "txt": "case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME;"
      },
      {
        "txt": "case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING;"
      },
      {
        "txt": "case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } int doPeek() throws IOException {"
      },
      {
        "txt": "int peekStack = stack[stackSize - 1]; if (peekStack == JsonScope.EMPTY_ARRAY) { stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY; } else if (peekStack == JsonScope.NONEMPTY_ARRAY) { int c = nextNonWhitespace(true); switch (c) { case ']': return peeked = PEEKED_END_ARRAY; case ';': checkLenient(); // fall-through"
      },
      {
        "txt": "case ',': break; default: throw syntaxError(\"Unterminated array\"); } } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) { stack[stackSize - 1] = JsonScope.DANGLING_NAME; if (peekStack == JsonScope.NONEMPTY_OBJECT) { int c = nextNonWhitespace(true); switch (c) {"
      },
      {
        "txt": "case '}': return peeked = PEEKED_END_OBJECT; case ';': checkLenient(); // fall-through case ',': break; default: throw syntaxError(\"Unterminated object\"); } }"
      },
      {
        "txt": "int c = nextNonWhitespace(true); switch (c) { case '\"': return peeked = PEEKED_DOUBLE_QUOTED_NAME; case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED_NAME; case '}': if (peekStack != JsonScope.NONEMPTY_OBJECT) { return peeked = PEEKED_END_OBJECT;"
      },
      {
        "txt": "} else { throw syntaxError(\"Expected name\"); } default: checkLenient(); pos--; // Don't consume the first character in an unquoted string. if (isLiteral((char) c)) { return peeked = PEEKED_UNQUOTED_NAME; } else { throw syntaxError(\"Expected name\");"
      },
      {
        "txt": "} } } else if (peekStack == JsonScope.DANGLING_NAME) { stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT; int c = nextNonWhitespace(true); switch (c) { case ':': break; case '=': checkLenient();"
      },
      {
        "txt": "if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { pos++; } break; default: throw syntaxError(\"Expected ':'\"); } } else if (peekStack == JsonScope.EMPTY_DOCUMENT) { if (lenient) { consumeNonExecutePrefix();"
      },
      {
        "txt": "} stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT; } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) { int c = nextNonWhitespace(false); if (c == -1) { return peeked = PEEKED_EOF; } else { checkLenient(); pos--; }"
      },
      {
        "txt": "} else if (peekStack == JsonScope.CLOSED) { throw new IllegalStateException(\"JsonReader is closed\"); } int c = nextNonWhitespace(true); switch (c) { case ']': if (peekStack == JsonScope.EMPTY_ARRAY) { return peeked = PEEKED_END_ARRAY; } case ';':"
      },
      {
        "txt": "case ',': if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) { checkLenient(); pos--; return peeked = PEEKED_NULL; } else { throw syntaxError(\"Unexpected value\"); } case '\\'': checkLenient();"
      },
      {
        "txt": "return peeked = PEEKED_SINGLE_QUOTED; case '\"': return peeked = PEEKED_DOUBLE_QUOTED; case '[': return peeked = PEEKED_BEGIN_ARRAY; case '{': return peeked = PEEKED_BEGIN_OBJECT; default: pos--; // Don't consume the first character in a literal value. }"
      },
      {
        "txt": "int result = peekKeyword(); if (result != PEEKED_NONE) { return result; } result = peekNumber(); if (result != PEEKED_NONE) { return result; } if (!isLiteral(buffer[pos])) { throw syntaxError(\"Expected value\");"
      },
      {
        "txt": "} checkLenient(); return peeked = PEEKED_UNQUOTED; } private int peekKeyword() throws IOException { char c = buffer[pos]; String keyword; String keywordUpper; int peeking; if (c == 't' || c == 'T') {"
      },
      {
        "txt": "keyword = \"true\"; keywordUpper = \"TRUE\"; peeking = PEEKED_TRUE; } else if (c == 'f' || c == 'F') { keyword = \"false\"; keywordUpper = \"FALSE\"; peeking = PEEKED_FALSE; } else if (c == 'n' || c == 'N') { keyword = \"null\"; keywordUpper = \"NULL\";"
      },
      {
        "txt": "peeking = PEEKED_NULL; } else { return PEEKED_NONE; } int length = keyword.length(); for (int i = 1; i < length; i++) { if (pos + i >= limit && !fillBuffer(i + 1)) { return PEEKED_NONE; } c = buffer[pos + i];"
      },
      {
        "txt": "if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) { return PEEKED_NONE; } } if ((pos + length < limit || fillBuffer(length + 1)) && isLiteral(buffer[pos + length])) { return PEEKED_NONE; // Don't match trues, falsey or nullsoft! } pos += length; return peeked = peeking;"
      },
      {
        "txt": "} private int peekNumber() throws IOException { char[] buffer = this.buffer; int p = pos; int l = limit; long value = 0; // Negative to accommodate Long.MIN_VALUE more easily. boolean negative = false; boolean fitsInLong = true; int last = NUMBER_CHAR_NONE; int i = 0;"
      },
      {
        "txt": "charactersOfNumber: for (; true; i++) { if (p + i == l) { if (i == buffer.length) { return PEEKED_NONE; } if (!fillBuffer(i + 1)) { break; } p = pos;"
      },
      {
        "txt": "l = limit; } char c = buffer[p + i]; switch (c) { case '-': if (last == NUMBER_CHAR_NONE) { negative = true; last = NUMBER_CHAR_SIGN; continue; } else if (last == NUMBER_CHAR_EXP_E) {"
      },
      {
        "txt": "last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE; case '+': if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE;"
      },
      {
        "txt": "case 'e': case 'E': if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) { last = NUMBER_CHAR_EXP_E; continue; } return PEEKED_NONE; case '.': if (last == NUMBER_CHAR_DIGIT) { last = NUMBER_CHAR_DECIMAL;"
      },
      {
        "txt": "continue; } return PEEKED_NONE; default: if (c < '0' || c > '9') { if (!isLiteral(c)) { break charactersOfNumber; } return PEEKED_NONE; }"
      },
      {
        "txt": "if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) { value = -(c - '0'); last = NUMBER_CHAR_DIGIT; } else if (last == NUMBER_CHAR_DIGIT) { if (value == 0) { return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal). } long newValue = value * 10 - (c - '0'); fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);"
      },
      {
        "txt": "value = newValue; } else if (last == NUMBER_CHAR_DECIMAL) { last = NUMBER_CHAR_FRACTION_DIGIT; } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) { last = NUMBER_CHAR_EXP_DIGIT; } } } if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { peekedLong = negative ? value : -value;"
      },
      {
        "txt": "pos += i; return peeked = PEEKED_LONG; } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) { peekedNumberLength = i; return peeked = PEEKED_NUMBER; } else { return PEEKED_NONE; } }"
      },
      {
        "txt": "private boolean isLiteral(char c) throws IOException { switch (c) { case '/': case '\\\\': case ';': case '#': case '=': checkLenient(); // fall-through case '{': case '}':"
      },
      {
        "txt": "case '[': case ']': case ':': case ',': case ' ': case '\\t': case '\\f': case '\\r': case '\\n': return false;"
      },
      {
        "txt": "default: return true; } } public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result;"
      },
      {
        "txt": "if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('\"'); } else { throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); }"
      },
      {
        "txt": "peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result;"
      },
      {
        "txt": "if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('\"'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) {"
      },
      {
        "txt": "result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(\"Expected a string but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "return result; } public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(\"Expected a boolean but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } public void nextNull() throws IOException {"
      },
      {
        "txt": "int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(\"Expected null but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());"
      },
      {
        "txt": "} } public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) {"
      },
      {
        "txt": "throw new IllegalStateException(\"Expected a double but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException. if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null;"
      },
      {
        "txt": "peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) {"
      },
      {
        "txt": "pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; <extra_id_0> peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result;"
      },
      {
        "txt": "pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\"Expected a long but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException."
      },
      {
        "txt": "long result = (long) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'long'. throw new NumberFormatException(\"Expected a long but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
      },
      {
        "txt": "private String nextQuotedValue(char quote) throws IOException { char[] buffer = this.buffer; StringBuilder builder = new StringBuilder(); while (true) { int p = pos; int l = limit; int start = p; while (p < l) { int c = buffer[p++]; if (c == quote) {"
      },
      {
        "txt": "pos = p; builder.append(buffer, start, p - start - 1); return builder.toString(); } else if (c == '\\\\') { pos = p; builder.append(buffer, start, p - start - 1); builder.append(readEscapeCharacter()); p = pos; l = limit; start = p;"
      },
      {
        "txt": "} else if (c == '\\n') { lineNumber++; lineStart = p; } } builder.append(buffer, start, p - start); pos = p; if (!fillBuffer(1)) { throw syntaxError(\"Unterminated string\"); }"
      },
      {
        "txt": "} } @SuppressWarnings(\"fallthrough\") private String nextUnquotedValue() throws IOException { StringBuilder builder = null; int i = 0; findNonLiteralCharacter: while (true) { for (; pos + i < limit; i++) { switch (buffer[pos + i]) {"
      },
      {
        "txt": "case '/': case '\\\\': case ';': case '#': case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']':"
      },
      {
        "txt": "case ':': case ',': case ' ': case '\\t': case '\\f': case '\\r': case '\\n': break findNonLiteralCharacter; } }"
      },
      {
        "txt": "if (i < buffer.length) { if (fillBuffer(i + 1)) { continue; } else { break; } } if (builder == null) { builder = new StringBuilder(); }"
      },
      {
        "txt": "builder.append(buffer, pos, i); pos += i; i = 0; if (!fillBuffer(1)) { break; } } String result; if (builder == null) { result = new String(buffer, pos, i);"
      },
      {
        "txt": "} else { builder.append(buffer, pos, i); result = builder.toString(); } pos += i; return result; } private void skipQuotedValue(char quote) throws IOException { char[] buffer = this.buffer; do {"
      },
      {
        "txt": "int p = pos; int l = limit; while (p < l) { int c = buffer[p++]; if (c == quote) { pos = p; return; } else if (c == '\\\\') { pos = p; readEscapeCharacter();"
      },
      {
        "txt": "p = pos; l = limit; } else if (c == '\\n') { lineNumber++; lineStart = p; } } pos = p; } while (fillBuffer(1)); throw syntaxError(\"Unterminated string\");"
      },
      {
        "txt": "} private void skipUnquotedValue() throws IOException { do { int i = 0; for (; pos + i < limit; i++) { switch (buffer[pos + i]) { case '/': case '\\\\': case ';': case '#':"
      },
      {
        "txt": "case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']': case ':': case ',': case ' ': case '\\t':"
      },
      {
        "txt": "case '\\f': case '\\r': case '\\n': pos += i; return; } } pos += i; } while (fillBuffer(1)); }"
      },
      {
        "txt": "public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { // Make sure no precision was lost casting to 'int'. throw new NumberFormatException(\"Expected an int but was \" + peekedLong"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {"
      },
      {
        "txt": "peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\"Expected an int but was \" + peek()"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException. result = (int) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'int'. throw new NumberFormatException(\"Expected an int but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null;"
      },
      {
        "txt": "peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); }"
      },
      {
        "txt": "public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++;"
      },
      {
        "txt": "} else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {"
      },
      {
        "txt": "skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('\"'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0);"
      },
      {
        "txt": "pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = \"null\"; } private void push(int newTop) { if (stackSize == stack.length) { int[] newStack = new int[stackSize * 2]; int[] newPathIndices = new int[stackSize * 2]; String[] newPathNames = new String[stackSize * 2]; System.arraycopy(stack, 0, newStack, 0, stackSize); System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);"
      },
      {
        "txt": "System.arraycopy(pathNames, 0, newPathNames, 0, stackSize); stack = newStack; pathIndices = newPathIndices; pathNames = newPathNames; } stack[stackSize++] = newTop; } private boolean fillBuffer(int minimum) throws IOException { char[] buffer = this.buffer; lineStart -= pos;"
      },
      {
        "txt": "if (limit != pos) { limit -= pos; System.arraycopy(buffer, pos, buffer, 0, limit); } else { limit = 0; } pos = 0; int total; while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { limit += total;"
      },
      {
        "txt": "if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') { pos++; lineStart++; minimum++; } if (limit >= minimum) { return true; } } return false;"
      },
      {
        "txt": "} int getLineNumber() { return lineNumber + 1; } int getColumnNumber() { return pos - lineStart + 1; } private int nextNonWhitespace(boolean throwOnEof) throws IOException { char[] buffer = this.buffer; int p = pos;"
      },
      {
        "txt": "int l = limit; while (true) { if (p == l) { pos = p; if (!fillBuffer(1)) { break; } p = pos; l = limit; }"
      },
      {
        "txt": "int c = buffer[p++]; if (c == '\\n') { lineNumber++; lineStart = p; continue; } else if (c == ' ' || c == '\\r' || c == '\\t') { continue; } if (c == '/') { pos = p;"
      },
      {
        "txt": "if (p == l) { pos--; // push back '/' so it's still in the buffer when this method returns boolean charsLoaded = fillBuffer(2); pos++; // consume the '/' again if (!charsLoaded) { return c; } } checkLenient(); char peek = buffer[pos];"
      },
      {
        "txt": "switch (peek) { case '*': pos++; if (!skipTo(\"*/\")) { throw syntaxError(\"Unterminated comment\"); } p = pos + 2; l = limit; continue; case '/':"
      },
      {
        "txt": "pos++; skipToEndOfLine(); p = pos; l = limit; continue; default: return c; } } else if (c == '#') { pos = p;"
      },
      {
        "txt": "checkLenient(); skipToEndOfLine(); p = pos; l = limit; } else { pos = p; return c; } } if (throwOnEof) {"
      },
      {
        "txt": "throw new EOFException(\"End of input\" + \" at line \" + getLineNumber() + \" column \" + getColumnNumber()); } else { return -1; } } private void checkLenient() throws IOException { if (!lenient) { throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\"); }"
      },
      {
        "txt": "} private void skipToEndOfLine() throws IOException { while (pos < limit || fillBuffer(1)) { char c = buffer[pos++]; if (c == '\\n') { lineNumber++; lineStart = pos; break; } else if (c == '\\r') { break;"
      },
      {
        "txt": "} } } private boolean skipTo(String toFind) throws IOException { outer: for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) { if (buffer[pos] == '\\n') { lineNumber++; lineStart = pos + 1; continue;"
      },
      {
        "txt": "} for (int c = 0; c < toFind.length(); c++) { if (buffer[pos + c] != toFind.charAt(c)) { continue outer; } } return true; } return false; }"
      },
      {
        "txt": "@Override public String toString() { return getClass().getSimpleName() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber(); } public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY:"
      },
      {
        "txt": "result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break;"
      },
      {
        "txt": "case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } private char readEscapeCharacter() throws IOException { if (pos == limit && !fillBuffer(1)) {"
      },
      {
        "txt": "throw syntaxError(\"Unterminated escape sequence\"); } char escaped = buffer[pos++]; switch (escaped) { case 'u': if (pos + 4 > limit && !fillBuffer(4)) { throw syntaxError(\"Unterminated escape sequence\"); } char result = 0; for (int i = pos, end = i + 4; i < end; i++) {"
      },
      {
        "txt": "char c = buffer[i]; result <<= 4; if (c >= '0' && c <= '9') { result += (c - '0'); } else if (c >= 'a' && c <= 'f') { result += (c - 'a' + 10); } else if (c >= 'A' && c <= 'F') { result += (c - 'A' + 10); } else { throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));"
      },
      {
        "txt": "} } pos += 4; return result; case 't': return '\\t'; case 'b': return '\\b'; case 'n': return '\\n';"
      },
      {
        "txt": "case 'r': return '\\r'; case 'f': return '\\f'; case '\\n': lineNumber++; lineStart = pos; case '\\'': case '\"': case '\\\\':"
      },
      {
        "txt": "default: return escaped; } } private IOException syntaxError(String message) throws IOException { throw new MalformedJsonException(message + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } private void consumeNonExecutePrefix() throws IOException { nextNonWhitespace(true);"
      },
      {
        "txt": "pos--; if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { return; } for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { return; // not a security token! } } pos += NON_EXECUTE_PREFIX.length;"
      },
      {
        "txt": "} static { JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() { @Override public void promoteNameToValue(JsonReader reader) throws IOException { if (reader instanceof JsonTreeReader) { ((JsonTreeReader)reader).promoteNameToValue(); return; } int p = reader.peeked; if (p == PEEKED_NONE) {"
      },
      {
        "txt": "p = reader.doPeek(); } if (p == PEEKED_DOUBLE_QUOTED_NAME) { reader.peeked = PEEKED_DOUBLE_QUOTED; } else if (p == PEEKED_SINGLE_QUOTED_NAME) { reader.peeked = PEEKED_SINGLE_QUOTED; } else if (p == PEEKED_UNQUOTED_NAME) { reader.peeked = PEEKED_UNQUOTED; } else { throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \""
      },
      {
        "txt": "+ \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber() + \" path \" + reader.getPath()); } } }; }"
      }
    ]
  },
  {
    "id": 1177,
    "file_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
    "start-bug-line": 956,
    "end-bug-line": 956,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.gson.stream; import com.google.gson.internal.JsonReaderInternalAccess; import com.google.gson.internal.bind.JsonTreeReader; import java.io.Closeable; import java.io.EOFException; import java.io.IOException; import java.io.Reader; public class JsonReader implements Closeable { private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();"
      },
      {
        "txt": "private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10; private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8;"
      },
      {
        "txt": "private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; private static final int NUMBER_CHAR_NONE = 0;"
      },
      {
        "txt": "private static final int NUMBER_CHAR_SIGN = 1; private static final int NUMBER_CHAR_DIGIT = 2; private static final int NUMBER_CHAR_DECIMAL = 3; private static final int NUMBER_CHAR_FRACTION_DIGIT = 4; private static final int NUMBER_CHAR_EXP_E = 5; private static final int NUMBER_CHAR_EXP_SIGN = 6; private static final int NUMBER_CHAR_EXP_DIGIT = 7; private final Reader in; private boolean lenient = false; private final char[] buffer = new char[1024];"
      },
      {
        "txt": "private int pos = 0; private int limit = 0; private int lineNumber = 0; private int lineStart = 0; int peeked = PEEKED_NONE; private long peekedLong; private int peekedNumberLength; private String peekedString; private int[] stack = new int[32]; private int stackSize = 0;"
      },
      {
        "txt": "{ stack[stackSize++] = JsonScope.EMPTY_DOCUMENT; } private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; public JsonReader(Reader in) { if (in == null) { throw new NullPointerException(\"in == null\"); } this.in = in;"
      },
      {
        "txt": "} public final void setLenient(boolean lenient) { this.lenient = lenient; } public final boolean isLenient() { return lenient; } public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) {"
      },
      {
        "txt": "p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); }"
      },
      {
        "txt": "} public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE;"
      },
      {
        "txt": "} else { throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); }"
      },
      {
        "txt": "if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void endObject() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected! pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; }"
      },
      {
        "txt": "public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT;"
      },
      {
        "txt": "case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE:"
      },
      {
        "txt": "return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER:"
      },
      {
        "txt": "return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } int doPeek() throws IOException { int peekStack = stack[stackSize - 1]; if (peekStack == JsonScope.EMPTY_ARRAY) {"
      },
      {
        "txt": "stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY; } else if (peekStack == JsonScope.NONEMPTY_ARRAY) { int c = nextNonWhitespace(true); switch (c) { case ']': return peeked = PEEKED_END_ARRAY; case ';': checkLenient(); // fall-through case ',': break;"
      },
      {
        "txt": "default: throw syntaxError(\"Unterminated array\"); } } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) { stack[stackSize - 1] = JsonScope.DANGLING_NAME; if (peekStack == JsonScope.NONEMPTY_OBJECT) { int c = nextNonWhitespace(true); switch (c) { case '}': return peeked = PEEKED_END_OBJECT;"
      },
      {
        "txt": "case ';': checkLenient(); // fall-through case ',': break; default: throw syntaxError(\"Unterminated object\"); } } int c = nextNonWhitespace(true); switch (c) {"
      },
      {
        "txt": "case '\"': return peeked = PEEKED_DOUBLE_QUOTED_NAME; case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED_NAME; case '}': if (peekStack != JsonScope.NONEMPTY_OBJECT) { return peeked = PEEKED_END_OBJECT; } else { throw syntaxError(\"Expected name\");"
      },
      {
        "txt": "} default: checkLenient(); pos--; // Don't consume the first character in an unquoted string. if (isLiteral((char) c)) { return peeked = PEEKED_UNQUOTED_NAME; } else { throw syntaxError(\"Expected name\"); } }"
      },
      {
        "txt": "} else if (peekStack == JsonScope.DANGLING_NAME) { stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT; int c = nextNonWhitespace(true); switch (c) { case ':': break; case '=': checkLenient(); if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { pos++;"
      },
      {
        "txt": "} break; default: throw syntaxError(\"Expected ':'\"); } } else if (peekStack == JsonScope.EMPTY_DOCUMENT) { if (lenient) { consumeNonExecutePrefix(); } stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;"
      },
      {
        "txt": "} else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) { int c = nextNonWhitespace(false); if (c == -1) { return peeked = PEEKED_EOF; } else { checkLenient(); pos--; } } else if (peekStack == JsonScope.CLOSED) { throw new IllegalStateException(\"JsonReader is closed\");"
      },
      {
        "txt": "} int c = nextNonWhitespace(true); switch (c) { case ']': if (peekStack == JsonScope.EMPTY_ARRAY) { return peeked = PEEKED_END_ARRAY; } case ';': case ',': if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {"
      },
      {
        "txt": "checkLenient(); pos--; return peeked = PEEKED_NULL; } else { throw syntaxError(\"Unexpected value\"); } case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case '\"':"
      },
      {
        "txt": "return peeked = PEEKED_DOUBLE_QUOTED; case '[': return peeked = PEEKED_BEGIN_ARRAY; case '{': return peeked = PEEKED_BEGIN_OBJECT; default: pos--; // Don't consume the first character in a literal value. } int result = peekKeyword(); if (result != PEEKED_NONE) {"
      },
      {
        "txt": "return result; } result = peekNumber(); if (result != PEEKED_NONE) { return result; } if (!isLiteral(buffer[pos])) { throw syntaxError(\"Expected value\"); } checkLenient();"
      },
      {
        "txt": "return peeked = PEEKED_UNQUOTED; } private int peekKeyword() throws IOException { char c = buffer[pos]; String keyword; String keywordUpper; int peeking; if (c == 't' || c == 'T') { keyword = \"true\"; keywordUpper = \"TRUE\";"
      },
      {
        "txt": "peeking = PEEKED_TRUE; } else if (c == 'f' || c == 'F') { keyword = \"false\"; keywordUpper = \"FALSE\"; peeking = PEEKED_FALSE; } else if (c == 'n' || c == 'N') { keyword = \"null\"; keywordUpper = \"NULL\"; peeking = PEEKED_NULL; } else {"
      },
      {
        "txt": "return PEEKED_NONE; } int length = keyword.length(); for (int i = 1; i < length; i++) { if (pos + i >= limit && !fillBuffer(i + 1)) { return PEEKED_NONE; } c = buffer[pos + i]; if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) { return PEEKED_NONE;"
      },
      {
        "txt": "} } if ((pos + length < limit || fillBuffer(length + 1)) && isLiteral(buffer[pos + length])) { return PEEKED_NONE; // Don't match trues, falsey or nullsoft! } pos += length; return peeked = peeking; } private int peekNumber() throws IOException {"
      },
      {
        "txt": "char[] buffer = this.buffer; int p = pos; int l = limit; long value = 0; // Negative to accommodate Long.MIN_VALUE more easily. boolean negative = false; boolean fitsInLong = true; int last = NUMBER_CHAR_NONE; int i = 0; charactersOfNumber: for (; true; i++) {"
      },
      {
        "txt": "if (p + i == l) { if (i == buffer.length) { return PEEKED_NONE; } if (!fillBuffer(i + 1)) { break; } p = pos; l = limit; }"
      },
      {
        "txt": "char c = buffer[p + i]; switch (c) { case '-': if (last == NUMBER_CHAR_NONE) { negative = true; last = NUMBER_CHAR_SIGN; continue; } else if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue;"
      },
      {
        "txt": "} return PEEKED_NONE; case '+': if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE; case 'e': case 'E':"
      },
      {
        "txt": "if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) { last = NUMBER_CHAR_EXP_E; continue; } return PEEKED_NONE; case '.': if (last == NUMBER_CHAR_DIGIT) { last = NUMBER_CHAR_DECIMAL; continue; }"
      },
      {
        "txt": "return PEEKED_NONE; default: if (c < '0' || c > '9') { if (!isLiteral(c)) { break charactersOfNumber; } return PEEKED_NONE; } if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) { value = -(c - '0');"
      },
      {
        "txt": "last = NUMBER_CHAR_DIGIT; } else if (last == NUMBER_CHAR_DIGIT) { if (value == 0) { return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal). } long newValue = value * 10 - (c - '0'); fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value); value = newValue; } else if (last == NUMBER_CHAR_DECIMAL) {"
      },
      {
        "txt": "last = NUMBER_CHAR_FRACTION_DIGIT; } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) { last = NUMBER_CHAR_EXP_DIGIT; } } } if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG;"
      },
      {
        "txt": "} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) { peekedNumberLength = i; return peeked = PEEKED_NUMBER; } else { return PEEKED_NONE; } } private boolean isLiteral(char c) throws IOException { switch (c) {"
      },
      {
        "txt": "case '/': case '\\\\': case ';': case '#': case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']':"
      },
      {
        "txt": "case ':': case ',': case ' ': case '\\t': case '\\f': case '\\r': case '\\n': return false; default: return true;"
      },
      {
        "txt": "} } public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue();"
      },
      {
        "txt": "} else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('\"'); } else { throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result;"
      },
      {
        "txt": "return result; } public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue();"
      },
      {
        "txt": "} else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('\"'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) {"
      },
      {
        "txt": "result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(\"Expected a string but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
      },
      {
        "txt": "public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) {"
      },
      {
        "txt": "peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(\"Expected a boolean but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) {"
      },
      {
        "txt": "p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(\"Expected null but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } }"
      },
      {
        "txt": "public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; }"
      },
      {
        "txt": "if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(\"Expected a double but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());"
      },
      {
        "txt": "} peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException. if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "return result; } public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "} if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); <extra_id_0> long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { }"
      },
      {
        "txt": "} catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\"Expected a long but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException. long result = (long) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'long'."
      },
      {
        "txt": "throw new NumberFormatException(\"Expected a long but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } private String nextQuotedValue(char quote) throws IOException { char[] buffer = this.buffer;"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(); while (true) { int p = pos; int l = limit; int start = p; while (p < l) { int c = buffer[p++]; if (c == quote) { pos = p; builder.append(buffer, start, p - start - 1);"
      },
      {
        "txt": "return builder.toString(); } else if (c == '\\\\') { pos = p; builder.append(buffer, start, p - start - 1); builder.append(readEscapeCharacter()); p = pos; l = limit; start = p; } else if (c == '\\n') { lineNumber++;"
      },
      {
        "txt": "lineStart = p; } } builder.append(buffer, start, p - start); pos = p; if (!fillBuffer(1)) { throw syntaxError(\"Unterminated string\"); } } }"
      },
      {
        "txt": "@SuppressWarnings(\"fallthrough\") private String nextUnquotedValue() throws IOException { StringBuilder builder = null; int i = 0; findNonLiteralCharacter: while (true) { for (; pos + i < limit; i++) { switch (buffer[pos + i]) { case '/': case '\\\\':"
      },
      {
        "txt": "case ';': case '#': case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']': case ':': case ',':"
      },
      {
        "txt": "case ' ': case '\\t': case '\\f': case '\\r': case '\\n': break findNonLiteralCharacter; } } if (i < buffer.length) { if (fillBuffer(i + 1)) {"
      },
      {
        "txt": "continue; } else { break; } } if (builder == null) { builder = new StringBuilder(); } builder.append(buffer, pos, i); pos += i;"
      },
      {
        "txt": "i = 0; if (!fillBuffer(1)) { break; } } String result; if (builder == null) { result = new String(buffer, pos, i); } else { builder.append(buffer, pos, i);"
      },
      {
        "txt": "result = builder.toString(); } pos += i; return result; } private void skipQuotedValue(char quote) throws IOException { char[] buffer = this.buffer; do { int p = pos; int l = limit;"
      },
      {
        "txt": "while (p < l) { int c = buffer[p++]; if (c == quote) { pos = p; return; } else if (c == '\\\\') { pos = p; readEscapeCharacter(); p = pos; l = limit;"
      },
      {
        "txt": "} else if (c == '\\n') { lineNumber++; lineStart = p; } } pos = p; } while (fillBuffer(1)); throw syntaxError(\"Unterminated string\"); } private void skipUnquotedValue() throws IOException {"
      },
      {
        "txt": "do { int i = 0; for (; pos + i < limit; i++) { switch (buffer[pos + i]) { case '/': case '\\\\': case ';': case '#': case '=': checkLenient(); // fall-through"
      },
      {
        "txt": "case '{': case '}': case '[': case ']': case ':': case ',': case ' ': case '\\t': case '\\f': case '\\r':"
      },
      {
        "txt": "case '\\n': pos += i; return; } } pos += i; } while (fillBuffer(1)); } public int nextInt() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { // Make sure no precision was lost casting to 'int'. throw new NumberFormatException(\"Expected an int but was \" + peekedLong + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); }"
      },
      {
        "txt": "peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); try {"
      },
      {
        "txt": "result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\"Expected an int but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); }"
      },
      {
        "txt": "peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException. result = (int) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'int'. throw new NumberFormatException(\"Expected an int but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "return result; } public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public void skipValue() throws IOException { int count = 0;"
      },
      {
        "txt": "do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT);"
      },
      {
        "txt": "count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {"
      },
      {
        "txt": "skipQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('\"'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = \"null\";"
      },
      {
        "txt": "} private void push(int newTop) { if (stackSize == stack.length) { int[] newStack = new int[stackSize * 2]; int[] newPathIndices = new int[stackSize * 2]; String[] newPathNames = new String[stackSize * 2]; System.arraycopy(stack, 0, newStack, 0, stackSize); System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize); System.arraycopy(pathNames, 0, newPathNames, 0, stackSize); stack = newStack;"
      },
      {
        "txt": "pathIndices = newPathIndices; pathNames = newPathNames; } stack[stackSize++] = newTop; } private boolean fillBuffer(int minimum) throws IOException { char[] buffer = this.buffer; lineStart -= pos; if (limit != pos) { limit -= pos;"
      },
      {
        "txt": "System.arraycopy(buffer, pos, buffer, 0, limit); } else { limit = 0; } pos = 0; int total; while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { limit += total; if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') { pos++;"
      },
      {
        "txt": "lineStart++; minimum++; } if (limit >= minimum) { return true; } } return false; } int getLineNumber() {"
      },
      {
        "txt": "return lineNumber + 1; } int getColumnNumber() { return pos - lineStart + 1; } private int nextNonWhitespace(boolean throwOnEof) throws IOException { char[] buffer = this.buffer; int p = pos; int l = limit; while (true) {"
      },
      {
        "txt": "if (p == l) { pos = p; if (!fillBuffer(1)) { break; } p = pos; l = limit; } int c = buffer[p++]; if (c == '\\n') {"
      },
      {
        "txt": "lineNumber++; lineStart = p; continue; } else if (c == ' ' || c == '\\r' || c == '\\t') { continue; } if (c == '/') { pos = p; if (p == l) { pos--; // push back '/' so it's still in the buffer when this method returns"
      },
      {
        "txt": "boolean charsLoaded = fillBuffer(2); pos++; // consume the '/' again if (!charsLoaded) { return c; } } checkLenient(); char peek = buffer[pos]; switch (peek) { case '*':"
      },
      {
        "txt": "pos++; if (!skipTo(\"*/\")) { throw syntaxError(\"Unterminated comment\"); } p = pos + 2; l = limit; continue; case '/': pos++; skipToEndOfLine();"
      },
      {
        "txt": "p = pos; l = limit; continue; default: return c; } } else if (c == '#') { pos = p; checkLenient(); skipToEndOfLine();"
      },
      {
        "txt": "p = pos; l = limit; } else { pos = p; return c; } } if (throwOnEof) { throw new EOFException(\"End of input\" + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());"
      },
      {
        "txt": "} else { return -1; } } private void checkLenient() throws IOException { if (!lenient) { throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\"); } } private void skipToEndOfLine() throws IOException {"
      },
      {
        "txt": "while (pos < limit || fillBuffer(1)) { char c = buffer[pos++]; if (c == '\\n') { lineNumber++; lineStart = pos; break; } else if (c == '\\r') { break; } }"
      },
      {
        "txt": "} private boolean skipTo(String toFind) throws IOException { outer: for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) { if (buffer[pos] == '\\n') { lineNumber++; lineStart = pos + 1; continue; } for (int c = 0; c < toFind.length(); c++) {"
      },
      {
        "txt": "if (buffer[pos + c] != toFind.charAt(c)) { continue outer; } } return true; } return false; } @Override public String toString() { return getClass().getSimpleName()"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber(); } public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break;"
      },
      {
        "txt": "case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT:"
      },
      {
        "txt": "case JsonScope.CLOSED: break; } } return result.toString(); } private char readEscapeCharacter() throws IOException { if (pos == limit && !fillBuffer(1)) { throw syntaxError(\"Unterminated escape sequence\"); }"
      },
      {
        "txt": "char escaped = buffer[pos++]; switch (escaped) { case 'u': if (pos + 4 > limit && !fillBuffer(4)) { throw syntaxError(\"Unterminated escape sequence\"); } char result = 0; for (int i = pos, end = i + 4; i < end; i++) { char c = buffer[i]; result <<= 4;"
      },
      {
        "txt": "if (c >= '0' && c <= '9') { result += (c - '0'); } else if (c >= 'a' && c <= 'f') { result += (c - 'a' + 10); } else if (c >= 'A' && c <= 'F') { result += (c - 'A' + 10); } else { throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4)); } }"
      },
      {
        "txt": "pos += 4; return result; case 't': return '\\t'; case 'b': return '\\b'; case 'n': return '\\n'; case 'r': return '\\r';"
      },
      {
        "txt": "case 'f': return '\\f'; case '\\n': lineNumber++; lineStart = pos; case '\\'': case '\"': case '\\\\': default: return escaped;"
      },
      {
        "txt": "} } private IOException syntaxError(String message) throws IOException { throw new MalformedJsonException(message + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } private void consumeNonExecutePrefix() throws IOException { nextNonWhitespace(true); pos--; if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {"
      },
      {
        "txt": "return; } for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { return; // not a security token! } } pos += NON_EXECUTE_PREFIX.length; } static {"
      },
      {
        "txt": "JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() { @Override public void promoteNameToValue(JsonReader reader) throws IOException { if (reader instanceof JsonTreeReader) { ((JsonTreeReader)reader).promoteNameToValue(); return; } int p = reader.peeked; if (p == PEEKED_NONE) { p = reader.doPeek(); }"
      },
      {
        "txt": "if (p == PEEKED_DOUBLE_QUOTED_NAME) { reader.peeked = PEEKED_DOUBLE_QUOTED; } else if (p == PEEKED_SINGLE_QUOTED_NAME) { reader.peeked = PEEKED_SINGLE_QUOTED; } else if (p == PEEKED_UNQUOTED_NAME) { reader.peeked = PEEKED_UNQUOTED; } else { throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \" + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber() + \" path \" + reader.getPath());"
      },
      {
        "txt": "} } }; }"
      }
    ]
  },
  {
    "id": 1178,
    "file_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
    "start-bug-line": 1182,
    "end-bug-line": 1182,
    "bug": "} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {",
    "fix": "} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.gson.internal.JsonReaderInternalAccess; import com.google.gson.internal.bind.JsonTreeReader; import java.io.Closeable; import java.io.EOFException; import java.io.IOException; import java.io.Reader; public class JsonReader implements Closeable { private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray(); private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10; private static final int PEEKED_NONE = 0;"
      },
      {
        "txt": "private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10;"
      },
      {
        "txt": "private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; private static final int NUMBER_CHAR_NONE = 0; private static final int NUMBER_CHAR_SIGN = 1; private static final int NUMBER_CHAR_DIGIT = 2;"
      },
      {
        "txt": "private static final int NUMBER_CHAR_DECIMAL = 3; private static final int NUMBER_CHAR_FRACTION_DIGIT = 4; private static final int NUMBER_CHAR_EXP_E = 5; private static final int NUMBER_CHAR_EXP_SIGN = 6; private static final int NUMBER_CHAR_EXP_DIGIT = 7; private final Reader in; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private int limit = 0;"
      },
      {
        "txt": "private int lineNumber = 0; private int lineStart = 0; int peeked = PEEKED_NONE; private long peekedLong; private int peekedNumberLength; private String peekedString; private int[] stack = new int[32]; private int stackSize = 0; { stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;"
      },
      {
        "txt": "} private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; public JsonReader(Reader in) { if (in == null) { throw new NullPointerException(\"in == null\"); } this.in = in; } public final void setLenient(boolean lenient) {"
      },
      {
        "txt": "this.lenient = lenient; } public final boolean isLenient() { return lenient; } public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); }"
      },
      {
        "txt": "if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void endArray() throws IOException {"
      },
      {
        "txt": "int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT);"
      },
      {
        "txt": "peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek();"
      },
      {
        "txt": "} if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected! pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); }"
      },
      {
        "txt": "} public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonToken peek() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY;"
      },
      {
        "txt": "case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL:"
      },
      {
        "txt": "return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF:"
      },
      {
        "txt": "return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } int doPeek() throws IOException { int peekStack = stack[stackSize - 1]; if (peekStack == JsonScope.EMPTY_ARRAY) { stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY; } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {"
      },
      {
        "txt": "int c = nextNonWhitespace(true); switch (c) { case ']': return peeked = PEEKED_END_ARRAY; case ';': checkLenient(); // fall-through case ',': break; default: throw syntaxError(\"Unterminated array\");"
      },
      {
        "txt": "} } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) { stack[stackSize - 1] = JsonScope.DANGLING_NAME; if (peekStack == JsonScope.NONEMPTY_OBJECT) { int c = nextNonWhitespace(true); switch (c) { case '}': return peeked = PEEKED_END_OBJECT; case ';': checkLenient(); // fall-through"
      },
      {
        "txt": "case ',': break; default: throw syntaxError(\"Unterminated object\"); } } int c = nextNonWhitespace(true); switch (c) { case '\"': return peeked = PEEKED_DOUBLE_QUOTED_NAME;"
      },
      {
        "txt": "case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED_NAME; case '}': if (peekStack != JsonScope.NONEMPTY_OBJECT) { return peeked = PEEKED_END_OBJECT; } else { throw syntaxError(\"Expected name\"); } default:"
      },
      {
        "txt": "checkLenient(); pos--; // Don't consume the first character in an unquoted string. if (isLiteral((char) c)) { return peeked = PEEKED_UNQUOTED_NAME; } else { throw syntaxError(\"Expected name\"); } } } else if (peekStack == JsonScope.DANGLING_NAME) { stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;"
      },
      {
        "txt": "int c = nextNonWhitespace(true); switch (c) { case ':': break; case '=': checkLenient(); if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { pos++; } break;"
      },
      {
        "txt": "default: throw syntaxError(\"Expected ':'\"); } } else if (peekStack == JsonScope.EMPTY_DOCUMENT) { if (lenient) { consumeNonExecutePrefix(); } stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT; } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) { int c = nextNonWhitespace(false);"
      },
      {
        "txt": "if (c == -1) { return peeked = PEEKED_EOF; } else { checkLenient(); pos--; } } else if (peekStack == JsonScope.CLOSED) { throw new IllegalStateException(\"JsonReader is closed\"); } int c = nextNonWhitespace(true);"
      },
      {
        "txt": "switch (c) { case ']': if (peekStack == JsonScope.EMPTY_ARRAY) { return peeked = PEEKED_END_ARRAY; } case ';': case ',': if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) { checkLenient(); pos--;"
      },
      {
        "txt": "return peeked = PEEKED_NULL; } else { throw syntaxError(\"Unexpected value\"); } case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case '\"': return peeked = PEEKED_DOUBLE_QUOTED; case '[':"
      },
      {
        "txt": "return peeked = PEEKED_BEGIN_ARRAY; case '{': return peeked = PEEKED_BEGIN_OBJECT; default: pos--; // Don't consume the first character in a literal value. } int result = peekKeyword(); if (result != PEEKED_NONE) { return result; }"
      },
      {
        "txt": "result = peekNumber(); if (result != PEEKED_NONE) { return result; } if (!isLiteral(buffer[pos])) { throw syntaxError(\"Expected value\"); } checkLenient(); return peeked = PEEKED_UNQUOTED; }"
      },
      {
        "txt": "private int peekKeyword() throws IOException { char c = buffer[pos]; String keyword; String keywordUpper; int peeking; if (c == 't' || c == 'T') { keyword = \"true\"; keywordUpper = \"TRUE\"; peeking = PEEKED_TRUE; } else if (c == 'f' || c == 'F') {"
      },
      {
        "txt": "keyword = \"false\"; keywordUpper = \"FALSE\"; peeking = PEEKED_FALSE; } else if (c == 'n' || c == 'N') { keyword = \"null\"; keywordUpper = \"NULL\"; peeking = PEEKED_NULL; } else { return PEEKED_NONE; }"
      },
      {
        "txt": "int length = keyword.length(); for (int i = 1; i < length; i++) { if (pos + i >= limit && !fillBuffer(i + 1)) { return PEEKED_NONE; } c = buffer[pos + i]; if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) { return PEEKED_NONE; } }"
      },
      {
        "txt": "if ((pos + length < limit || fillBuffer(length + 1)) && isLiteral(buffer[pos + length])) { return PEEKED_NONE; // Don't match trues, falsey or nullsoft! } pos += length; return peeked = peeking; } private int peekNumber() throws IOException { char[] buffer = this.buffer; int p = pos;"
      },
      {
        "txt": "int l = limit; long value = 0; // Negative to accommodate Long.MIN_VALUE more easily. boolean negative = false; boolean fitsInLong = true; int last = NUMBER_CHAR_NONE; int i = 0; charactersOfNumber: for (; true; i++) { if (p + i == l) { if (i == buffer.length) {"
      },
      {
        "txt": "return PEEKED_NONE; } if (!fillBuffer(i + 1)) { break; } p = pos; l = limit; } char c = buffer[p + i]; switch (c) {"
      },
      {
        "txt": "case '-': if (last == NUMBER_CHAR_NONE) { negative = true; last = NUMBER_CHAR_SIGN; continue; } else if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE;"
      },
      {
        "txt": "case '+': if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE; case 'e': case 'E': if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) { last = NUMBER_CHAR_EXP_E;"
      },
      {
        "txt": "continue; } return PEEKED_NONE; case '.': if (last == NUMBER_CHAR_DIGIT) { last = NUMBER_CHAR_DECIMAL; continue; } return PEEKED_NONE; default:"
      },
      {
        "txt": "if (c < '0' || c > '9') { if (!isLiteral(c)) { break charactersOfNumber; } return PEEKED_NONE; } if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) { value = -(c - '0'); last = NUMBER_CHAR_DIGIT; } else if (last == NUMBER_CHAR_DIGIT) {"
      },
      {
        "txt": "if (value == 0) { return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal). } long newValue = value * 10 - (c - '0'); fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value); value = newValue; } else if (last == NUMBER_CHAR_DECIMAL) { last = NUMBER_CHAR_FRACTION_DIGIT; } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {"
      },
      {
        "txt": "last = NUMBER_CHAR_EXP_DIGIT; } } } if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG; } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {"
      },
      {
        "txt": "peekedNumberLength = i; return peeked = PEEKED_NUMBER; } else { return PEEKED_NONE; } } private boolean isLiteral(char c) throws IOException { switch (c) { case '/': case '\\\\':"
      },
      {
        "txt": "case ';': case '#': case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']': case ':': case ',':"
      },
      {
        "txt": "case ' ': case '\\t': case '\\f': case '\\r': case '\\n': return false; default: return true; } }"
      },
      {
        "txt": "public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\\'');"
      },
      {
        "txt": "} else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('\"'); } else { throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; }"
      },
      {
        "txt": "public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\\'');"
      },
      {
        "txt": "} else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('\"'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength;"
      },
      {
        "txt": "} else { throw new IllegalStateException(\"Expected a string but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public boolean nextBoolean() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "return false; } throw new IllegalStateException(\"Expected a boolean but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); }"
      },
      {
        "txt": "if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(\"Expected null but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public double nextDouble() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength);"
      },
      {
        "txt": "pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(\"Expected a double but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED;"
      },
      {
        "txt": "double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException. if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
      },
      {
        "txt": "public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; }"
      },
      {
        "txt": "if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result;"
      },
      {
        "txt": "} catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\"Expected a long but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException. long result = (long) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'long'."
      },
      {
        "txt": "throw new NumberFormatException(\"Expected a long but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } private String nextQuotedValue(char quote) throws IOException { char[] buffer = this.buffer;"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(); while (true) { int p = pos; int l = limit; int start = p; while (p < l) { int c = buffer[p++]; if (c == quote) { pos = p; builder.append(buffer, start, p - start - 1);"
      },
      {
        "txt": "return builder.toString(); } else if (c == '\\\\') { pos = p; builder.append(buffer, start, p - start - 1); builder.append(readEscapeCharacter()); p = pos; l = limit; start = p; } else if (c == '\\n') { lineNumber++;"
      },
      {
        "txt": "lineStart = p; } } builder.append(buffer, start, p - start); pos = p; if (!fillBuffer(1)) { throw syntaxError(\"Unterminated string\"); } } }"
      },
      {
        "txt": "@SuppressWarnings(\"fallthrough\") private String nextUnquotedValue() throws IOException { StringBuilder builder = null; int i = 0; findNonLiteralCharacter: while (true) { for (; pos + i < limit; i++) { switch (buffer[pos + i]) { case '/': case '\\\\':"
      },
      {
        "txt": "case ';': case '#': case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']': case ':': case ',':"
      },
      {
        "txt": "case ' ': case '\\t': case '\\f': case '\\r': case '\\n': break findNonLiteralCharacter; } } if (i < buffer.length) { if (fillBuffer(i + 1)) {"
      },
      {
        "txt": "continue; } else { break; } } if (builder == null) { builder = new StringBuilder(); } builder.append(buffer, pos, i); pos += i;"
      },
      {
        "txt": "i = 0; if (!fillBuffer(1)) { break; } } String result; if (builder == null) { result = new String(buffer, pos, i); } else { builder.append(buffer, pos, i);"
      },
      {
        "txt": "result = builder.toString(); } pos += i; return result; } private void skipQuotedValue(char quote) throws IOException { char[] buffer = this.buffer; do { int p = pos; int l = limit;"
      },
      {
        "txt": "while (p < l) { int c = buffer[p++]; if (c == quote) { pos = p; return; } else if (c == '\\\\') { pos = p; readEscapeCharacter(); p = pos; l = limit;"
      },
      {
        "txt": "} else if (c == '\\n') { lineNumber++; lineStart = p; } } pos = p; } while (fillBuffer(1)); throw syntaxError(\"Unterminated string\"); } private void skipUnquotedValue() throws IOException {"
      },
      {
        "txt": "do { int i = 0; for (; pos + i < limit; i++) { switch (buffer[pos + i]) { case '/': case '\\\\': case ';': case '#': case '=': checkLenient(); // fall-through"
      },
      {
        "txt": "case '{': case '}': case '[': case ']': case ':': case ',': case ' ': case '\\t': case '\\f': case '\\r':"
      },
      {
        "txt": "case '\\n': pos += i; return; } } pos += i; } while (fillBuffer(1)); } public int nextInt() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { // Make sure no precision was lost casting to 'int'. throw new NumberFormatException(\"Expected an int but was \" + peekedLong + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); }"
      },
      {
        "txt": "pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; <extra_id_0> peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result;"
      },
      {
        "txt": "pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\"Expected an int but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException."
      },
      {
        "txt": "result = (int) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'int'. throw new NumberFormatException(\"Expected an int but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
      },
      {
        "txt": "public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public void skipValue() throws IOException { int count = 0; do { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) {"
      },
      {
        "txt": "stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {"
      },
      {
        "txt": "skipQuotedValue('\"'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = \"null\"; } private void push(int newTop) {"
      },
      {
        "txt": "if (stackSize == stack.length) { int[] newStack = new int[stackSize * 2]; int[] newPathIndices = new int[stackSize * 2]; String[] newPathNames = new String[stackSize * 2]; System.arraycopy(stack, 0, newStack, 0, stackSize); System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize); System.arraycopy(pathNames, 0, newPathNames, 0, stackSize); stack = newStack; pathIndices = newPathIndices; pathNames = newPathNames;"
      },
      {
        "txt": "} stack[stackSize++] = newTop; } private boolean fillBuffer(int minimum) throws IOException { char[] buffer = this.buffer; lineStart -= pos; if (limit != pos) { limit -= pos; System.arraycopy(buffer, pos, buffer, 0, limit); } else {"
      },
      {
        "txt": "limit = 0; } pos = 0; int total; while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { limit += total; if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') { pos++; lineStart++; minimum++;"
      },
      {
        "txt": "} if (limit >= minimum) { return true; } } return false; } int getLineNumber() { return lineNumber + 1; }"
      },
      {
        "txt": "int getColumnNumber() { return pos - lineStart + 1; } private int nextNonWhitespace(boolean throwOnEof) throws IOException { char[] buffer = this.buffer; int p = pos; int l = limit; while (true) { if (p == l) { pos = p;"
      },
      {
        "txt": "if (!fillBuffer(1)) { break; } p = pos; l = limit; } int c = buffer[p++]; if (c == '\\n') { lineNumber++; lineStart = p;"
      },
      {
        "txt": "continue; } else if (c == ' ' || c == '\\r' || c == '\\t') { continue; } if (c == '/') { pos = p; if (p == l) { pos--; // push back '/' so it's still in the buffer when this method returns boolean charsLoaded = fillBuffer(2); pos++; // consume the '/' again"
      },
      {
        "txt": "if (!charsLoaded) { return c; } } checkLenient(); char peek = buffer[pos]; switch (peek) { case '*': pos++; if (!skipTo(\"*/\")) {"
      },
      {
        "txt": "throw syntaxError(\"Unterminated comment\"); } p = pos + 2; l = limit; continue; case '/': pos++; skipToEndOfLine(); p = pos; l = limit;"
      },
      {
        "txt": "continue; default: return c; } } else if (c == '#') { pos = p; checkLenient(); skipToEndOfLine(); p = pos; l = limit;"
      },
      {
        "txt": "} else { pos = p; return c; } } if (throwOnEof) { throw new EOFException(\"End of input\" + \" at line \" + getLineNumber() + \" column \" + getColumnNumber()); } else { return -1;"
      },
      {
        "txt": "} } private void checkLenient() throws IOException { if (!lenient) { throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\"); } } private void skipToEndOfLine() throws IOException { while (pos < limit || fillBuffer(1)) { char c = buffer[pos++];"
      },
      {
        "txt": "if (c == '\\n') { lineNumber++; lineStart = pos; break; } else if (c == '\\r') { break; } } } private boolean skipTo(String toFind) throws IOException {"
      },
      {
        "txt": "outer: for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) { if (buffer[pos] == '\\n') { lineNumber++; lineStart = pos + 1; continue; } for (int c = 0; c < toFind.length(); c++) { if (buffer[pos + c] != toFind.charAt(c)) { continue outer;"
      },
      {
        "txt": "} } return true; } return false; } @Override public String toString() { return getClass().getSimpleName() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber(); }"
      },
      {
        "txt": "public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME:"
      },
      {
        "txt": "case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break;"
      },
      {
        "txt": "} } return result.toString(); } private char readEscapeCharacter() throws IOException { if (pos == limit && !fillBuffer(1)) { throw syntaxError(\"Unterminated escape sequence\"); } char escaped = buffer[pos++]; switch (escaped) {"
      },
      {
        "txt": "case 'u': if (pos + 4 > limit && !fillBuffer(4)) { throw syntaxError(\"Unterminated escape sequence\"); } char result = 0; for (int i = pos, end = i + 4; i < end; i++) { char c = buffer[i]; result <<= 4; if (c >= '0' && c <= '9') { result += (c - '0');"
      },
      {
        "txt": "} else if (c >= 'a' && c <= 'f') { result += (c - 'a' + 10); } else if (c >= 'A' && c <= 'F') { result += (c - 'A' + 10); } else { throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4)); } } pos += 4; return result;"
      },
      {
        "txt": "case 't': return '\\t'; case 'b': return '\\b'; case 'n': return '\\n'; case 'r': return '\\r'; case 'f': return '\\f';"
      },
      {
        "txt": "case '\\n': lineNumber++; lineStart = pos; case '\\'': case '\"': case '\\\\': default: return escaped; } }"
      },
      {
        "txt": "private IOException syntaxError(String message) throws IOException { throw new MalformedJsonException(message + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } private void consumeNonExecutePrefix() throws IOException { nextNonWhitespace(true); pos--; if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { return; }"
      },
      {
        "txt": "for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { return; // not a security token! } } pos += NON_EXECUTE_PREFIX.length; } static { JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() { @Override public void promoteNameToValue(JsonReader reader) throws IOException {"
      },
      {
        "txt": "if (reader instanceof JsonTreeReader) { ((JsonTreeReader)reader).promoteNameToValue(); return; } int p = reader.peeked; if (p == PEEKED_NONE) { p = reader.doPeek(); } if (p == PEEKED_DOUBLE_QUOTED_NAME) { reader.peeked = PEEKED_DOUBLE_QUOTED;"
      },
      {
        "txt": "} else if (p == PEEKED_SINGLE_QUOTED_NAME) { reader.peeked = PEEKED_SINGLE_QUOTED; } else if (p == PEEKED_UNQUOTED_NAME) { reader.peeked = PEEKED_UNQUOTED; } else { throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \" + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber() + \" path \" + reader.getPath()); } }"
      },
      {
        "txt": "}; }"
      }
    ]
  },
  {
    "id": 1179,
    "file_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
    "start-bug-line": 1184,
    "end-bug-line": 1184,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.gson.stream; import com.google.gson.internal.JsonReaderInternalAccess; import com.google.gson.internal.bind.JsonTreeReader;"
      },
      {
        "txt": "import java.io.Closeable; import java.io.EOFException; import java.io.IOException; import java.io.Reader; public class JsonReader implements Closeable { private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray(); private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10; private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2;"
      },
      {
        "txt": "private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12;"
      },
      {
        "txt": "private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; private static final int NUMBER_CHAR_NONE = 0; private static final int NUMBER_CHAR_SIGN = 1; private static final int NUMBER_CHAR_DIGIT = 2; private static final int NUMBER_CHAR_DECIMAL = 3; private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;"
      },
      {
        "txt": "private static final int NUMBER_CHAR_EXP_E = 5; private static final int NUMBER_CHAR_EXP_SIGN = 6; private static final int NUMBER_CHAR_EXP_DIGIT = 7; private final Reader in; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private int limit = 0; private int lineNumber = 0; private int lineStart = 0;"
      },
      {
        "txt": "int peeked = PEEKED_NONE; private long peekedLong; private int peekedNumberLength; private String peekedString; private int[] stack = new int[32]; private int stackSize = 0; { stack[stackSize++] = JsonScope.EMPTY_DOCUMENT; } private String[] pathNames = new String[32];"
      },
      {
        "txt": "private int[] pathIndices = new int[32]; public JsonReader(Reader in) { if (in == null) { throw new NullPointerException(\"in == null\"); } this.in = in; } public final void setLenient(boolean lenient) { this.lenient = lenient; }"
      },
      {
        "txt": "public final boolean isLenient() { return lenient; } public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY);"
      },
      {
        "txt": "pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) {"
      },
      {
        "txt": "p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); }"
      },
      {
        "txt": "} public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else {"
      },
      {
        "txt": "throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) {"
      },
      {
        "txt": "stackSize--; pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected! pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public boolean hasNext() throws IOException {"
      },
      {
        "txt": "int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek();"
      },
      {
        "txt": "} switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY;"
      },
      {
        "txt": "case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED:"
      },
      {
        "txt": "case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default:"
      },
      {
        "txt": "throw new AssertionError(); } } int doPeek() throws IOException { int peekStack = stack[stackSize - 1]; if (peekStack == JsonScope.EMPTY_ARRAY) { stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY; } else if (peekStack == JsonScope.NONEMPTY_ARRAY) { int c = nextNonWhitespace(true); switch (c) {"
      },
      {
        "txt": "case ']': return peeked = PEEKED_END_ARRAY; case ';': checkLenient(); // fall-through case ',': break; default: throw syntaxError(\"Unterminated array\"); } } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {"
      },
      {
        "txt": "stack[stackSize - 1] = JsonScope.DANGLING_NAME; if (peekStack == JsonScope.NONEMPTY_OBJECT) { int c = nextNonWhitespace(true); switch (c) { case '}': return peeked = PEEKED_END_OBJECT; case ';': checkLenient(); // fall-through case ',': break;"
      },
      {
        "txt": "default: throw syntaxError(\"Unterminated object\"); } } int c = nextNonWhitespace(true); switch (c) { case '\"': return peeked = PEEKED_DOUBLE_QUOTED_NAME; case '\\'': checkLenient();"
      },
      {
        "txt": "return peeked = PEEKED_SINGLE_QUOTED_NAME; case '}': if (peekStack != JsonScope.NONEMPTY_OBJECT) { return peeked = PEEKED_END_OBJECT; } else { throw syntaxError(\"Expected name\"); } default: checkLenient(); pos--; // Don't consume the first character in an unquoted string."
      },
      {
        "txt": "if (isLiteral((char) c)) { return peeked = PEEKED_UNQUOTED_NAME; } else { throw syntaxError(\"Expected name\"); } } } else if (peekStack == JsonScope.DANGLING_NAME) { stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT; int c = nextNonWhitespace(true); switch (c) {"
      },
      {
        "txt": "case ':': break; case '=': checkLenient(); if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { pos++; } break; default: throw syntaxError(\"Expected ':'\");"
      },
      {
        "txt": "} } else if (peekStack == JsonScope.EMPTY_DOCUMENT) { if (lenient) { consumeNonExecutePrefix(); } stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT; } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) { int c = nextNonWhitespace(false); if (c == -1) { return peeked = PEEKED_EOF;"
      },
      {
        "txt": "} else { checkLenient(); pos--; } } else if (peekStack == JsonScope.CLOSED) { throw new IllegalStateException(\"JsonReader is closed\"); } int c = nextNonWhitespace(true); switch (c) { case ']':"
      },
      {
        "txt": "if (peekStack == JsonScope.EMPTY_ARRAY) { return peeked = PEEKED_END_ARRAY; } case ';': case ',': if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) { checkLenient(); pos--; return peeked = PEEKED_NULL; } else {"
      },
      {
        "txt": "throw syntaxError(\"Unexpected value\"); } case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case '\"': return peeked = PEEKED_DOUBLE_QUOTED; case '[': return peeked = PEEKED_BEGIN_ARRAY; case '{':"
      },
      {
        "txt": "return peeked = PEEKED_BEGIN_OBJECT; default: pos--; // Don't consume the first character in a literal value. } int result = peekKeyword(); if (result != PEEKED_NONE) { return result; } result = peekNumber(); if (result != PEEKED_NONE) {"
      },
      {
        "txt": "return result; } if (!isLiteral(buffer[pos])) { throw syntaxError(\"Expected value\"); } checkLenient(); return peeked = PEEKED_UNQUOTED; } private int peekKeyword() throws IOException { char c = buffer[pos];"
      },
      {
        "txt": "String keyword; String keywordUpper; int peeking; if (c == 't' || c == 'T') { keyword = \"true\"; keywordUpper = \"TRUE\"; peeking = PEEKED_TRUE; } else if (c == 'f' || c == 'F') { keyword = \"false\"; keywordUpper = \"FALSE\";"
      },
      {
        "txt": "peeking = PEEKED_FALSE; } else if (c == 'n' || c == 'N') { keyword = \"null\"; keywordUpper = \"NULL\"; peeking = PEEKED_NULL; } else { return PEEKED_NONE; } int length = keyword.length(); for (int i = 1; i < length; i++) {"
      },
      {
        "txt": "if (pos + i >= limit && !fillBuffer(i + 1)) { return PEEKED_NONE; } c = buffer[pos + i]; if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) { return PEEKED_NONE; } } if ((pos + length < limit || fillBuffer(length + 1)) && isLiteral(buffer[pos + length])) {"
      },
      {
        "txt": "return PEEKED_NONE; // Don't match trues, falsey or nullsoft! } pos += length; return peeked = peeking; } private int peekNumber() throws IOException { char[] buffer = this.buffer; int p = pos; int l = limit; long value = 0; // Negative to accommodate Long.MIN_VALUE more easily."
      },
      {
        "txt": "boolean negative = false; boolean fitsInLong = true; int last = NUMBER_CHAR_NONE; int i = 0; charactersOfNumber: for (; true; i++) { if (p + i == l) { if (i == buffer.length) { return PEEKED_NONE; }"
      },
      {
        "txt": "if (!fillBuffer(i + 1)) { break; } p = pos; l = limit; } char c = buffer[p + i]; switch (c) { case '-': if (last == NUMBER_CHAR_NONE) {"
      },
      {
        "txt": "negative = true; last = NUMBER_CHAR_SIGN; continue; } else if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE; case '+': if (last == NUMBER_CHAR_EXP_E) {"
      },
      {
        "txt": "last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE; case 'e': case 'E': if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) { last = NUMBER_CHAR_EXP_E; continue; }"
      },
      {
        "txt": "return PEEKED_NONE; case '.': if (last == NUMBER_CHAR_DIGIT) { last = NUMBER_CHAR_DECIMAL; continue; } return PEEKED_NONE; default: if (c < '0' || c > '9') { if (!isLiteral(c)) {"
      },
      {
        "txt": "break charactersOfNumber; } return PEEKED_NONE; } if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) { value = -(c - '0'); last = NUMBER_CHAR_DIGIT; } else if (last == NUMBER_CHAR_DIGIT) { if (value == 0) { return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal)."
      },
      {
        "txt": "} long newValue = value * 10 - (c - '0'); fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value); value = newValue; } else if (last == NUMBER_CHAR_DECIMAL) { last = NUMBER_CHAR_FRACTION_DIGIT; } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) { last = NUMBER_CHAR_EXP_DIGIT; }"
      },
      {
        "txt": "} } if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG; } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) { peekedNumberLength = i; return peeked = PEEKED_NUMBER;"
      },
      {
        "txt": "} else { return PEEKED_NONE; } } private boolean isLiteral(char c) throws IOException { switch (c) { case '/': case '\\\\': case ';': case '#':"
      },
      {
        "txt": "case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']': case ':': case ',': case ' ': case '\\t':"
      },
      {
        "txt": "case '\\f': case '\\r': case '\\n': return false; default: return true; } } public String nextName() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('\"');"
      },
      {
        "txt": "} else { throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public String nextString() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('\"');"
      },
      {
        "txt": "} else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(\"Expected a string but was \" + peek()"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek();"
      },
      {
        "txt": "} if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; }"
      },
      {
        "txt": "throw new IllegalStateException(\"Expected a boolean but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE;"
      },
      {
        "txt": "pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(\"Expected null but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } } public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek();"
      },
      {
        "txt": "} if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {"
      },
      {
        "txt": "peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(\"Expected a double but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException. if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {"
      },
      {
        "txt": "throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public long nextLong() throws IOException { int p = peeked;"
      },
      {
        "txt": "if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength);"
      },
      {
        "txt": "pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { }"
      },
      {
        "txt": "} else { throw new IllegalStateException(\"Expected a long but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException. long result = (long) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'long'. throw new NumberFormatException(\"Expected a long but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());"
      },
      {
        "txt": "} peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } private String nextQuotedValue(char quote) throws IOException { char[] buffer = this.buffer; StringBuilder builder = new StringBuilder(); while (true) {"
      },
      {
        "txt": "int p = pos; int l = limit; int start = p; while (p < l) { int c = buffer[p++]; if (c == quote) { pos = p; builder.append(buffer, start, p - start - 1); return builder.toString(); } else if (c == '\\\\') {"
      },
      {
        "txt": "pos = p; builder.append(buffer, start, p - start - 1); builder.append(readEscapeCharacter()); p = pos; l = limit; start = p; } else if (c == '\\n') { lineNumber++; lineStart = p; }"
      },
      {
        "txt": "} builder.append(buffer, start, p - start); pos = p; if (!fillBuffer(1)) { throw syntaxError(\"Unterminated string\"); } } } @SuppressWarnings(\"fallthrough\") private String nextUnquotedValue() throws IOException {"
      },
      {
        "txt": "StringBuilder builder = null; int i = 0; findNonLiteralCharacter: while (true) { for (; pos + i < limit; i++) { switch (buffer[pos + i]) { case '/': case '\\\\': case ';': case '#':"
      },
      {
        "txt": "case '=': checkLenient(); // fall-through case '{': case '}': case '[': case ']': case ':': case ',': case ' ': case '\\t':"
      },
      {
        "txt": "case '\\f': case '\\r': case '\\n': break findNonLiteralCharacter; } } if (i < buffer.length) { if (fillBuffer(i + 1)) { continue; } else {"
      },
      {
        "txt": "break; } } if (builder == null) { builder = new StringBuilder(); } builder.append(buffer, pos, i); pos += i; i = 0; if (!fillBuffer(1)) {"
      },
      {
        "txt": "break; } } String result; if (builder == null) { result = new String(buffer, pos, i); } else { builder.append(buffer, pos, i); result = builder.toString(); }"
      },
      {
        "txt": "pos += i; return result; } private void skipQuotedValue(char quote) throws IOException { char[] buffer = this.buffer; do { int p = pos; int l = limit; while (p < l) { int c = buffer[p++];"
      },
      {
        "txt": "if (c == quote) { pos = p; return; } else if (c == '\\\\') { pos = p; readEscapeCharacter(); p = pos; l = limit; } else if (c == '\\n') { lineNumber++;"
      },
      {
        "txt": "lineStart = p; } } pos = p; } while (fillBuffer(1)); throw syntaxError(\"Unterminated string\"); } private void skipUnquotedValue() throws IOException { do { int i = 0;"
      },
      {
        "txt": "for (; pos + i < limit; i++) { switch (buffer[pos + i]) { case '/': case '\\\\': case ';': case '#': case '=': checkLenient(); // fall-through case '{': case '}':"
      },
      {
        "txt": "case '[': case ']': case ':': case ',': case ' ': case '\\t': case '\\f': case '\\r': case '\\n': pos += i;"
      },
      {
        "txt": "return; } } pos += i; } while (fillBuffer(1)); } public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek();"
      },
      {
        "txt": "} int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { // Make sure no precision was lost casting to 'int'. throw new NumberFormatException(\"Expected an int but was \" + peekedLong + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++;"
      },
      {
        "txt": "} if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); <extra_id_0> result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { }"
      },
      {
        "txt": "} catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\"Expected an int but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException. result = (int) asDouble; if (result != asDouble) { // Make sure no precision was lost casting to 'int'."
      },
      {
        "txt": "throw new NumberFormatException(\"Expected an int but was \" + peekedString + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public void close() throws IOException { peeked = PEEKED_NONE;"
      },
      {
        "txt": "stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek();"
      },
      {
        "txt": "} if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--;"
      },
      {
        "txt": "} else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('\"'); } else if (p == PEEKED_NUMBER) {"
      },
      {
        "txt": "pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = \"null\"; } private void push(int newTop) { if (stackSize == stack.length) { int[] newStack = new int[stackSize * 2];"
      },
      {
        "txt": "int[] newPathIndices = new int[stackSize * 2]; String[] newPathNames = new String[stackSize * 2]; System.arraycopy(stack, 0, newStack, 0, stackSize); System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize); System.arraycopy(pathNames, 0, newPathNames, 0, stackSize); stack = newStack; pathIndices = newPathIndices; pathNames = newPathNames; } stack[stackSize++] = newTop;"
      },
      {
        "txt": "} private boolean fillBuffer(int minimum) throws IOException { char[] buffer = this.buffer; lineStart -= pos; if (limit != pos) { limit -= pos; System.arraycopy(buffer, pos, buffer, 0, limit); } else { limit = 0; }"
      },
      {
        "txt": "pos = 0; int total; while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { limit += total; if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') { pos++; lineStart++; minimum++; } if (limit >= minimum) {"
      },
      {
        "txt": "return true; } } return false; } int getLineNumber() { return lineNumber + 1; } int getColumnNumber() { return pos - lineStart + 1;"
      },
      {
        "txt": "} private int nextNonWhitespace(boolean throwOnEof) throws IOException { char[] buffer = this.buffer; int p = pos; int l = limit; while (true) { if (p == l) { pos = p; if (!fillBuffer(1)) { break;"
      },
      {
        "txt": "} p = pos; l = limit; } int c = buffer[p++]; if (c == '\\n') { lineNumber++; lineStart = p; continue; } else if (c == ' ' || c == '\\r' || c == '\\t') {"
      },
      {
        "txt": "continue; } if (c == '/') { pos = p; if (p == l) { pos--; // push back '/' so it's still in the buffer when this method returns boolean charsLoaded = fillBuffer(2); pos++; // consume the '/' again if (!charsLoaded) { return c;"
      },
      {
        "txt": "} } checkLenient(); char peek = buffer[pos]; switch (peek) { case '*': pos++; if (!skipTo(\"*/\")) { throw syntaxError(\"Unterminated comment\"); }"
      },
      {
        "txt": "p = pos + 2; l = limit; continue; case '/': pos++; skipToEndOfLine(); p = pos; l = limit; continue; default:"
      },
      {
        "txt": "return c; } } else if (c == '#') { pos = p; checkLenient(); skipToEndOfLine(); p = pos; l = limit; } else { pos = p;"
      },
      {
        "txt": "return c; } } if (throwOnEof) { throw new EOFException(\"End of input\" + \" at line \" + getLineNumber() + \" column \" + getColumnNumber()); } else { return -1; } }"
      },
      {
        "txt": "private void checkLenient() throws IOException { if (!lenient) { throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\"); } } private void skipToEndOfLine() throws IOException { while (pos < limit || fillBuffer(1)) { char c = buffer[pos++]; if (c == '\\n') { lineNumber++;"
      },
      {
        "txt": "lineStart = pos; break; } else if (c == '\\r') { break; } } } private boolean skipTo(String toFind) throws IOException { outer: for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {"
      },
      {
        "txt": "if (buffer[pos] == '\\n') { lineNumber++; lineStart = pos + 1; continue; } for (int c = 0; c < toFind.length(); c++) { if (buffer[pos + c] != toFind.charAt(c)) { continue outer; } }"
      },
      {
        "txt": "return true; } return false; } @Override public String toString() { return getClass().getSimpleName() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber(); } public String getPath() { StringBuilder result = new StringBuilder().append('$');"
      },
      {
        "txt": "for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.');"
      },
      {
        "txt": "if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } }"
      },
      {
        "txt": "return result.toString(); } private char readEscapeCharacter() throws IOException { if (pos == limit && !fillBuffer(1)) { throw syntaxError(\"Unterminated escape sequence\"); } char escaped = buffer[pos++]; switch (escaped) { case 'u': if (pos + 4 > limit && !fillBuffer(4)) {"
      },
      {
        "txt": "throw syntaxError(\"Unterminated escape sequence\"); } char result = 0; for (int i = pos, end = i + 4; i < end; i++) { char c = buffer[i]; result <<= 4; if (c >= '0' && c <= '9') { result += (c - '0'); } else if (c >= 'a' && c <= 'f') { result += (c - 'a' + 10);"
      },
      {
        "txt": "} else if (c >= 'A' && c <= 'F') { result += (c - 'A' + 10); } else { throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4)); } } pos += 4; return result; case 't': return '\\t';"
      },
      {
        "txt": "case 'b': return '\\b'; case 'n': return '\\n'; case 'r': return '\\r'; case 'f': return '\\f'; case '\\n': lineNumber++;"
      },
      {
        "txt": "lineStart = pos; case '\\'': case '\"': case '\\\\': default: return escaped; } } private IOException syntaxError(String message) throws IOException { throw new MalformedJsonException(message"
      },
      {
        "txt": "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath()); } private void consumeNonExecutePrefix() throws IOException { nextNonWhitespace(true); pos--; if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { return; } for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {"
      },
      {
        "txt": "return; // not a security token! } } pos += NON_EXECUTE_PREFIX.length; } static { JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() { @Override public void promoteNameToValue(JsonReader reader) throws IOException { if (reader instanceof JsonTreeReader) { ((JsonTreeReader)reader).promoteNameToValue();"
      },
      {
        "txt": "return; } int p = reader.peeked; if (p == PEEKED_NONE) { p = reader.doPeek(); } if (p == PEEKED_DOUBLE_QUOTED_NAME) { reader.peeked = PEEKED_DOUBLE_QUOTED; } else if (p == PEEKED_SINGLE_QUOTED_NAME) { reader.peeked = PEEKED_SINGLE_QUOTED;"
      },
      {
        "txt": "} else if (p == PEEKED_UNQUOTED_NAME) { reader.peeked = PEEKED_UNQUOTED; } else { throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \" + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber() + \" path \" + reader.getPath()); } } }; }"
      }
    ]
  }
]