[
  {
    "id": 1185,
    "file_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
    "start-bug-line": 162,
    "end-bug-line": 162,
    "bug": "",
    "fix": "@Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.gson.internal.bind; import com.google.gson.JsonArray; import com.google.gson.JsonElement; import com.google.gson.JsonNull; import com.google.gson.JsonObject; import com.google.gson.JsonPrimitive; import com.google.gson.stream.JsonWriter; import java.io.IOException; import java.io.Writer; import java.util.ArrayList;"
      },
      {
        "txt": "import java.util.List; public final class JsonTreeWriter extends JsonWriter { private static final Writer UNWRITABLE_WRITER = new Writer() { @Override public void write(char[] buffer, int offset, int counter) { throw new AssertionError(); } @Override public void flush() throws IOException { throw new AssertionError(); } @Override public void close() throws IOException {"
      },
      {
        "txt": "throw new AssertionError(); } }; private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive(\"closed\"); private final List<JsonElement> stack = new ArrayList<JsonElement>(); private String pendingName; private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?; public JsonTreeWriter() { super(UNWRITABLE_WRITER); }"
      },
      {
        "txt": "public JsonElement get() { if (!stack.isEmpty()) { throw new IllegalStateException(\"Expected one JSON element but was \" + stack); } return product; } private JsonElement peek() { return stack.get(stack.size() - 1); } private void put(JsonElement value) {"
      },
      {
        "txt": "if (pendingName != null) { if (!value.isJsonNull() || getSerializeNulls()) { JsonObject object = (JsonObject) peek(); object.add(pendingName, value); } pendingName = null; } else if (stack.isEmpty()) { product = value; } else { JsonElement element = peek();"
      },
      {
        "txt": "if (element instanceof JsonArray) { ((JsonArray) element).add(value); } else { throw new IllegalStateException(); } } } @Override public JsonWriter beginArray() throws IOException { JsonArray array = new JsonArray(); put(array);"
      },
      {
        "txt": "stack.add(array); return this; } @Override public JsonWriter endArray() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonArray) { stack.remove(stack.size() - 1);"
      },
      {
        "txt": "return this; } throw new IllegalStateException(); } @Override public JsonWriter beginObject() throws IOException { JsonObject object = new JsonObject(); put(object); stack.add(object); return this; }"
      },
      {
        "txt": "@Override public JsonWriter endObject() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException();"
      },
      {
        "txt": "} @Override public JsonWriter name(String name) throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { pendingName = name; return this; }"
      },
      {
        "txt": "throw new IllegalStateException(); } @Override public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } @Override public JsonWriter nullValue() throws IOException {"
      },
      {
        "txt": "return this; } @Override public JsonWriter value(boolean value) throws IOException { put(new JsonPrimitive(value)); return this; } <extra_id_0> @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value); } put(new JsonPrimitive(value)); return this;"
      },
      {
        "txt": "put(new JsonPrimitive(value)); return this; } @Override public JsonWriter value(long value) throws IOException { put(new JsonPrimitive(value)); return this; } @Override public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue();"
      },
      {
        "txt": "} if (!isLenient()) { double d = value.doubleValue(); if (Double.isNaN(d) || Double.isInfinite(d)) { throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value); } } put(new JsonPrimitive(value)); return this; }"
      },
      {
        "txt": "@Override public void flush() throws IOException { } @Override public void close() throws IOException { if (!stack.isEmpty()) { throw new IOException(\"Incomplete document\"); } stack.add(SENTINEL_CLOSED); }"
      }
    ]
  },
  {
    "id": 1186,
    "file_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
    "start-bug-line": 165,
    "end-bug-line": 168,
    "bug": "if (value == null) { out.nullValue(); return; }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.gson.internal.bind; import java.io.IOException; import java.math.BigDecimal; import java.math.BigInteger; import java.net.InetAddress; import java.net.URI; import java.net.URISyntaxException;"
      },
      {
        "txt": "import java.net.URL; import java.sql.Timestamp; import java.util.ArrayList; import java.util.BitSet; import java.util.Calendar; import java.util.Currency; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashMap; import java.util.List;"
      },
      {
        "txt": "import java.util.Locale; import java.util.Map; import java.util.StringTokenizer; import java.util.UUID; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicIntegerArray; import com.google.gson.Gson; import com.google.gson.JsonArray; import com.google.gson.JsonElement;"
      },
      {
        "txt": "import com.google.gson.JsonIOException; import com.google.gson.JsonNull; import com.google.gson.JsonObject; import com.google.gson.JsonPrimitive; import com.google.gson.JsonSyntaxException; import com.google.gson.TypeAdapter; import com.google.gson.TypeAdapterFactory; import com.google.gson.annotations.SerializedName; import com.google.gson.internal.LazilyParsedNumber; import com.google.gson.reflect.TypeToken;"
      },
      {
        "txt": "import com.google.gson.stream.JsonReader; import com.google.gson.stream.JsonToken; import com.google.gson.stream.JsonWriter; public final class TypeAdapters { private TypeAdapters() { throw new UnsupportedOperationException(); } @SuppressWarnings(\"rawtypes\") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override"
      },
      {
        "txt": "public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \" + value.getName() + \". Forgot to register a type adapter?\"); } } @Override public Class read(JsonReader in) throws IOException {"
      },
      {
        "txt": "if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\"); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);"
      },
      {
        "txt": "public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek();"
      },
      {
        "txt": "while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING:"
      },
      {
        "txt": "String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue); } break; default: throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);"
      },
      {
        "txt": "} if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; }"
      },
      {
        "txt": "@Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); }"
      },
      {
        "txt": "out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;"
      },
      {
        "txt": "return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { <extra_id_0> out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) {"
      },
      {
        "txt": "@Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? \"null\" : value.toString()); }"
      },
      {
        "txt": "}; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; }"
      },
      {
        "txt": "try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value);"
      },
      {
        "txt": "} }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;"
      },
      {
        "txt": "} try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value);"
      },
      {
        "txt": "} }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;"
      },
      {
        "txt": "} try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value);"
      },
      {
        "txt": "} }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e);"
      },
      {
        "txt": "} } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException {"
      },
      {
        "txt": "return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException {"
      },
      {
        "txt": "List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } }"
      },
      {
        "txt": "in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray();"
      },
      {
        "txt": "for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override"
      },
      {
        "txt": "public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); }"
      },
      {
        "txt": "} @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) {"
      },
      {
        "txt": "in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } };"
      },
      {
        "txt": "public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override"
      },
      {
        "txt": "public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL:"
      },
      {
        "txt": "in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException {"
      },
      {
        "txt": "out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;"
      },
      {
        "txt": "} String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(\"Expecting character, got: \" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value));"
      },
      {
        "txt": "} }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull();"
      },
      {
        "txt": "return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value);"
      },
      {
        "txt": "} }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString());"
      },
      {
        "txt": "} catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException {"
      },
      {
        "txt": "if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } }"
      },
      {
        "txt": "@Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull();"
      },
      {
        "txt": "return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY ="
      },
      {
        "txt": "newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); }"
      },
      {
        "txt": "@Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException {"
      },
      {
        "txt": "if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return \"null\".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm());"
      },
      {
        "txt": "} }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; }"
      },
      {
        "txt": "try { String nextString = in.nextString(); return \"null\".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString());"
      },
      {
        "txt": "} }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; }"
      },
      {
        "txt": "return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {"
      },
      {
        "txt": "@Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException {"
      },
      {
        "txt": "out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override"
      },
      {
        "txt": "public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null;"
      },
      {
        "txt": "} final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); }"
      },
      {
        "txt": "}; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = \"year\"; private static final String MONTH = \"month\"; private static final String DAY_OF_MONTH = \"dayOfMonth\"; private static final String HOUR_OF_DAY = \"hourOfDay\"; private static final String MINUTE = \"minute\"; private static final String SECOND = \"second\";"
      },
      {
        "txt": "@Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0;"
      },
      {
        "txt": "int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value;"
      },
      {
        "txt": "} else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } }"
      },
      {
        "txt": "in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject();"
      },
      {
        "txt": "out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE));"
      },
      {
        "txt": "out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException {"
      },
      {
        "txt": "if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, \"_\"); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) {"
      },
      {
        "txt": "language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language);"
      },
      {
        "txt": "} else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); }"
      },
      {
        "txt": "}; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number));"
      },
      {
        "txt": "case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in));"
      },
      {
        "txt": "} in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject();"
      },
      {
        "txt": "return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException {"
      },
      {
        "txt": "if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString());"
      },
      {
        "txt": "} } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {"
      },
      {
        "txt": "out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(\"Couldn't write \" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY"
      },
      {
        "txt": "= newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> { private final Map<String, T> nameToConstant = new HashMap<String, T>(); private final Map<T, String> constantToName = new HashMap<T, String>(); public EnumTypeAdapter(Class<T> classOfT) { try { for (T constant : classOfT.getEnumConstants()) { String name = constant.name(); SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class); if (annotation != null) {"
      },
      {
        "txt": "name = annotation.value(); for (String alternate : annotation.alternate()) { nameToConstant.put(alternate, constant); } } nameToConstant.put(name, constant); constantToName.put(constant, name); } } catch (NoSuchFieldException e) { throw new AssertionError(\"Missing field in \" + classOfT.getName(), e);"
      },
      {
        "txt": "} } @Override public T read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return nameToConstant.get(in.nextString()); } @Override public void write(JsonWriter out, T value) throws IOException {"
      },
      {
        "txt": "out.value(value == null ? null : constantToName.get(value)); } } public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({\"rawtypes\", \"unchecked\"}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; }"
      },
      {
        "txt": "if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); // handle anonymous subclasses } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal"
      },
      {
        "txt": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {"
      },
      {
        "txt": "return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\"; } }; } public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() {"
      },
      {
        "txt": "@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return \"Factory[type=\" + boxed.getName() + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\"; } };"
      },
      {
        "txt": "} public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() {"
      },
      {
        "txt": "return \"Factory[type=\" + base.getName() + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\"; } }; } public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(\"unchecked\") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {"
      },
      {
        "txt": "final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in);"
      },
      {
        "txt": "if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";"
      },
      {
        "txt": "} }; }"
      }
    ]
  },
  {
    "id": 1187,
    "file_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
    "start-bug-line": 476,
    "end-bug-line": 476,
    "bug": "",
    "fix": "public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? \"true\" : \"false\"); return this; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.gson.stream; import java.io.Closeable;"
      },
      {
        "txt": "import java.io.Flushable; import java.io.IOException; import java.io.Writer; import static com.google.gson.stream.JsonScope.DANGLING_NAME; import static com.google.gson.stream.JsonScope.EMPTY_ARRAY; import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT; import static com.google.gson.stream.JsonScope.EMPTY_OBJECT; import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY; import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT; import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;"
      },
      {
        "txt": "public class JsonWriter implements Closeable, Flushable { private static final String[] REPLACEMENT_CHARS; private static final String[] HTML_SAFE_REPLACEMENT_CHARS; static { REPLACEMENT_CHARS = new String[128]; for (int i = 0; i <= 0x1f; i++) { REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i); } REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\"; REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";"
      },
      {
        "txt": "REPLACEMENT_CHARS['\\t'] = \"\\\\t\"; REPLACEMENT_CHARS['\\b'] = \"\\\\b\"; REPLACEMENT_CHARS['\\n'] = \"\\\\n\"; REPLACEMENT_CHARS['\\r'] = \"\\\\r\"; REPLACEMENT_CHARS['\\f'] = \"\\\\f\"; HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone(); HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\"; HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\"; HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\"; HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";"
      },
      {
        "txt": "HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\"; } private final Writer out; private int[] stack = new int[32]; private int stackSize = 0; { push(EMPTY_DOCUMENT); } private String indent; private String separator = \":\";"
      },
      {
        "txt": "private boolean lenient; private boolean htmlSafe; private String deferredName; private boolean serializeNulls = true; public JsonWriter(Writer out) { if (out == null) { throw new NullPointerException(\"out == null\"); } this.out = out; }"
      },
      {
        "txt": "public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = \":\"; } else { this.indent = indent; this.separator = \": \"; } } public final void setLenient(boolean lenient) {"
      },
      {
        "txt": "this.lenient = lenient; } public boolean isLenient() { return lenient; } public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public final boolean isHtmlSafe() { return htmlSafe;"
      },
      {
        "txt": "} public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, \"[\");"
      },
      {
        "txt": "} public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\"); } public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, \"{\"); } public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");"
      },
      {
        "txt": "} private JsonWriter open(int empty, String openBracket) throws IOException { beforeValue(); push(empty); out.write(openBracket); return this; } private JsonWriter close(int empty, int nonempty, String closeBracket) throws IOException { int context = peek();"
      },
      {
        "txt": "if (context != nonempty && context != empty) { throw new IllegalStateException(\"Nesting problem.\"); } if (deferredName != null) { throw new IllegalStateException(\"Dangling name: \" + deferredName); } stackSize--; if (context == nonempty) { newline(); }"
      },
      {
        "txt": "out.write(closeBracket); return this; } private void push(int newTop) { if (stackSize == stack.length) { int[] newStack = new int[stackSize * 2]; System.arraycopy(stack, 0, newStack, 0, stackSize); stack = newStack; } stack[stackSize++] = newTop;"
      },
      {
        "txt": "} private int peek() { if (stackSize == 0) { throw new IllegalStateException(\"JsonWriter is closed.\"); } return stack[stackSize - 1]; } private void replaceTop(int topOfStack) { stack[stackSize - 1] = topOfStack; }"
      },
      {
        "txt": "public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(\"name == null\"); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(\"JsonWriter is closed.\"); }"
      },
      {
        "txt": "deferredName = name; return this; } private void writeDeferredName() throws IOException { if (deferredName != null) { beforeName(); string(deferredName); deferredName = null; } }"
      },
      {
        "txt": "public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter jsonValue(String value) throws IOException {"
      },
      {
        "txt": "if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter nullValue() throws IOException { if (deferredName != null) {"
      },
      {
        "txt": "if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; // skip the name and the value } } beforeValue(); out.write(\"null\"); return this;"
      },
      {
        "txt": "public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? \"true\" : \"false\"); return this; } <extra_id_0> public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } writeDeferredName(); beforeValue();"
      },
      {
        "txt": "writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this;"
      },
      {
        "txt": "} public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);"
      },
      {
        "txt": "} beforeValue(); out.append(string); return this; } public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(\"JsonWriter is closed.\"); } out.flush();"
      },
      {
        "txt": "} public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(\"Incomplete document\"); } stackSize = 0; } private void string(String value) throws IOException {"
      },
      {
        "txt": "String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS; out.write(\"\\\"\"); int last = 0; int length = value.length(); for (int i = 0; i < length; i++) { char c = value.charAt(i); String replacement; if (c < 128) { replacement = replacements[c]; if (replacement == null) {"
      },
      {
        "txt": "continue; } } else if (c == '\\u2028') { replacement = \"\\\\u2028\"; } else if (c == '\\u2029') { replacement = \"\\\\u2029\"; } else { continue; } if (last < i) {"
      },
      {
        "txt": "out.write(value, last, i - last); } out.write(replacement); last = i + 1; } if (last < length) { out.write(value, last, length - last); } out.write(\"\\\"\"); }"
      },
      {
        "txt": "private void newline() throws IOException { if (indent == null) { return; } out.write(\"\\n\"); for (int i = 1, size = stackSize; i < size; i++) { out.write(indent); } } private void beforeName() throws IOException {"
      },
      {
        "txt": "int context = peek(); if (context == NONEMPTY_OBJECT) { // first in object out.write(','); } else if (context != EMPTY_OBJECT) { // not in an object! throw new IllegalStateException(\"Nesting problem.\"); } newline(); replaceTop(DANGLING_NAME); } @SuppressWarnings(\"fallthrough\")"
      },
      {
        "txt": "private void beforeValue() throws IOException { switch (peek()) { case NONEMPTY_DOCUMENT: if (!lenient) { throw new IllegalStateException( \"JSON must have only one top-level value.\"); } case EMPTY_DOCUMENT: // first in document replaceTop(NONEMPTY_DOCUMENT); break;"
      },
      {
        "txt": "case EMPTY_ARRAY: // first in array replaceTop(NONEMPTY_ARRAY); newline(); break; case NONEMPTY_ARRAY: // another in array out.append(','); newline(); break; case DANGLING_NAME: // value for name out.append(separator);"
      },
      {
        "txt": "replaceTop(NONEMPTY_OBJECT); break; default: throw new IllegalStateException(\"Nesting problem.\"); } }"
      }
    ]
  }
]