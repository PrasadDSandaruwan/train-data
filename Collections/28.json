[
  {
    "id": 981,
    "file_path": "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java",
    "start-bug-line": 2262,
    "end-bug-line": 2262,
    "bug": "",
    "fix": "@Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.collections4.trie; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.AbstractCollection; import java.util.AbstractMap; import java.util.AbstractSet;"
      },
      {
        "txt": "import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set; import java.util.SortedMap; import org.apache.commons.collections4.OrderedMapIterator;"
      },
      {
        "txt": "abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> { private static final long serialVersionUID = 5155253417231339498L; private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1); private transient volatile Set<K> keySet; private transient volatile Collection<V> values; private transient volatile Set<Map.Entry<K,V>> entrySet; private transient int size = 0; protected transient int modCount = 0; protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) { super(keyAnalyzer);"
      },
      {
        "txt": "} protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> map) { super(keyAnalyzer); putAll(map); } @Override public void clear() { root.key = null; root.bitIndex = -1;"
      },
      {
        "txt": "root.value = null; root.parent = null; root.left = root; root.right = null; root.predecessor = root; size = 0; incrementModCount(); } @Override public int size() {"
      },
      {
        "txt": "return size; } void incrementSize() { size++; incrementModCount(); } void decrementSize() { size--; incrementModCount(); }"
      },
      {
        "txt": "private void incrementModCount() { ++modCount; } @Override public V put(final K key, final V value) { if (key == null) { throw new NullPointerException(\"Key cannot be null\"); } final int lengthInBits = lengthInBits(key); if (lengthInBits == 0) {"
      },
      {
        "txt": "if (root.isEmpty()) { incrementSize(); } else { incrementModCount(); } return root.setKeyValue(key, value); } final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits); if (compareKeys(key, found.key)) { if (found.isEmpty()) { // <- must be the root"
      },
      {
        "txt": "incrementSize(); } else { incrementModCount(); } return found.setKeyValue(key, value); } final int bitIndex = bitIndex(key, found.key); if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) { if (KeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);"
      },
      {
        "txt": "addEntry(t, lengthInBits); incrementSize(); return null; } else if (KeyAnalyzer.isNullBitKey(bitIndex)) { if (root.isEmpty()) { incrementSize(); } else { incrementModCount(); } return root.setKeyValue(key, value);"
      },
      {
        "txt": "} else if (KeyAnalyzer.isEqualBitKey(bitIndex)) { if (found != root) { incrementModCount(); return found.setKeyValue(key, value); } } } throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex); } TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {"
      },
      {
        "txt": "TrieEntry<K, V> current = root.left; TrieEntry<K, V> path = root; while(true) { if (current.bitIndex >= entry.bitIndex || current.bitIndex <= path.bitIndex) { entry.predecessor = entry; if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) { entry.left = entry; entry.right = current; } else {"
      },
      {
        "txt": "entry.left = current; entry.right = entry; } entry.parent = path; if (current.bitIndex >= entry.bitIndex) { current.parent = entry; } if (current.bitIndex <= path.bitIndex) { current.predecessor = entry; }"
      },
      {
        "txt": "if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) { path.left = entry; } else { path.right = entry; } return entry; } path = current; if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) { current = current.left;"
      },
      {
        "txt": "} else { current = current.right; } } } @Override public V get(final Object k) { final TrieEntry<K, V> entry = getEntry(k); return entry != null ? entry.getValue() : null; }"
      },
      {
        "txt": "TrieEntry<K,V> getEntry(final Object k) { final K key = castKey(k); if (key == null) { return null; } final int lengthInBits = lengthInBits(key); final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits); return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null; } public Map.Entry<K, V> select(final K key) {"
      },
      {
        "txt": "final int lengthInBits = lengthInBits(key); final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>(); if (!selectR(root.left, -1, key, lengthInBits, reference)) { return reference.get(); } return null; } public K selectKey(final K key) { final Map.Entry<K, V> entry = select(key); if (entry == null) {"
      },
      {
        "txt": "return null; } return entry.getKey(); } public V selectValue(final K key) { final Map.Entry<K, V> entry = select(key); if (entry == null) { return null; } return entry.getValue();"
      },
      {
        "txt": "} private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, final K key, final int lengthInBits, final Reference<Map.Entry<K, V>> reference) { if (h.bitIndex <= bitIndex) { if (!h.isEmpty()) { reference.set(h); return false; } return true;"
      },
      {
        "txt": "} if (!isBitSet(key, h.bitIndex, lengthInBits)) { if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) { return selectR(h.right, h.bitIndex, key, lengthInBits, reference); } } else { if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) { return selectR(h.left, h.bitIndex, key, lengthInBits, reference); } }"
      },
      {
        "txt": "return false; } @Override public boolean containsKey(final Object k) { if (k == null) { return false; } final K key = castKey(k); final int lengthInBits = lengthInBits(key); final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);"
      },
      {
        "txt": "return !entry.isEmpty() && compareKeys(key, entry.key); } @Override public Set<Map.Entry<K,V>> entrySet() { if (entrySet == null) { entrySet = new EntrySet(); } return entrySet; } @Override"
      },
      {
        "txt": "public Set<K> keySet() { if (keySet == null) { keySet = new KeySet(); } return keySet; } @Override public Collection<V> values() { if (values == null) { values = new Values();"
      },
      {
        "txt": "} return values; } @Override public V remove(final Object k) { if (k == null) { return null; } final K key = castKey(k); final int lengthInBits = lengthInBits(key);"
      },
      {
        "txt": "TrieEntry<K, V> current = root.left; TrieEntry<K, V> path = root; while (true) { if (current.bitIndex <= path.bitIndex) { if (!current.isEmpty() && compareKeys(key, current.key)) { return removeEntry(current); } return null; } path = current;"
      },
      {
        "txt": "if (!isBitSet(key, current.bitIndex, lengthInBits)) { current = current.left; } else { current = current.right; } } } TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) { TrieEntry<K, V> current = root.left; TrieEntry<K, V> path = root;"
      },
      {
        "txt": "while(true) { if (current.bitIndex <= path.bitIndex) { return current; } path = current; if (!isBitSet(key, current.bitIndex, lengthInBits)) { current = current.left; } else { current = current.right; }"
      },
      {
        "txt": "} } V removeEntry(final TrieEntry<K, V> h) { if (h != root) { if (h.isInternalNode()) { removeInternalEntry(h); } else { removeExternalEntry(h); } }"
      },
      {
        "txt": "decrementSize(); return h.setKeyValue(null, null); } private void removeExternalEntry(final TrieEntry<K, V> h) { if (h == root) { throw new IllegalArgumentException(\"Cannot delete root Entry!\"); } else if (!h.isExternalNode()) { throw new IllegalArgumentException(h + \" is not an external Entry!\"); } final TrieEntry<K, V> parent = h.parent;"
      },
      {
        "txt": "final TrieEntry<K, V> child = h.left == h ? h.right : h.left; if (parent.left == h) { parent.left = child; } else { parent.right = child; } if (child.bitIndex > parent.bitIndex) { child.parent = parent; } else { child.predecessor = parent;"
      },
      {
        "txt": "} } private void removeInternalEntry(final TrieEntry<K, V> h) { if (h == root) { throw new IllegalArgumentException(\"Cannot delete root Entry!\"); } else if (!h.isInternalNode()) { throw new IllegalArgumentException(h + \" is not an internal Entry!\"); } final TrieEntry<K, V> p = h.predecessor; p.bitIndex = h.bitIndex;"
      },
      {
        "txt": "{ final TrieEntry<K, V> parent = p.parent; final TrieEntry<K, V> child = p.left == h ? p.right : p.left; if (p.predecessor == p && p.parent != h) { p.predecessor = p.parent; } if (parent.left == p) { parent.left = child; } else { parent.right = child;"
      },
      {
        "txt": "} if (child.bitIndex > parent.bitIndex) { child.parent = parent; } } { if (h.left.parent == h) { h.left.parent = p; } if (h.right.parent == h) {"
      },
      {
        "txt": "h.right.parent = p; } if (h.parent.left == h) { h.parent.left = p; } else { h.parent.right = p; } } p.parent = h.parent; p.left = h.left;"
      },
      {
        "txt": "p.right = h.right; if (isValidUplink(p.left, p)) { p.left.predecessor = p; } if (isValidUplink(p.right, p)) { p.right.predecessor = p; } } TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) { if (node == null) {"
      },
      {
        "txt": "return firstEntry(); } return nextEntryImpl(node.predecessor, node, null); } TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) { TrieEntry<K, V> current = start; if (previous == null || start != previous.predecessor) { while (!current.left.isEmpty()) { if (previous == current.left) {"
      },
      {
        "txt": "break; } if (isValidUplink(current.left, current)) { return current.left; } current = current.left; } } if (current.isEmpty()) { return null;"
      },
      {
        "txt": "} if (current.right == null) { return null; } if (previous != current.right) { if (isValidUplink(current.right, current)) { return current.right; } return nextEntryImpl(current.right, previous, tree); }"
      },
      {
        "txt": "while (current == current.parent.right) { if (current == tree) { return null; } current = current.parent; } if (current == tree) { return null; } if (current.parent.right == null) {"
      },
      {
        "txt": "return null; } if (previous != current.parent.right && isValidUplink(current.parent.right, current.parent)) { return current.parent.right; } if (current.parent.right == current.parent) { return null; } return nextEntryImpl(current.parent.right, previous, tree);"
      },
      {
        "txt": "} TrieEntry<K, V> firstEntry() { if (isEmpty()) { return null; } return followLeft(root); } TrieEntry<K, V> followLeft(TrieEntry<K, V> node) { while(true) { TrieEntry<K, V> child = node.left;"
      },
      {
        "txt": "if (child.isEmpty()) { child = node.right; } if (child.bitIndex <= node.bitIndex) { return child; } node = child; } } @Override"
      },
      {
        "txt": "public Comparator<? super K> comparator() { return getKeyAnalyzer(); } @Override public K firstKey() { if (size() == 0) { throw new NoSuchElementException(); } return firstEntry().getKey(); }"
      },
      {
        "txt": "@Override public K lastKey() { final TrieEntry<K, V> entry = lastEntry(); if (entry != null) { return entry.getKey(); } throw new NoSuchElementException(); } @Override public K nextKey(final K key) {"
      },
      {
        "txt": "if (key == null) { throw new NullPointerException(); } final TrieEntry<K, V> entry = getEntry(key); if (entry != null) { final TrieEntry<K, V> nextEntry = nextEntry(entry); return nextEntry != null ? nextEntry.getKey() : null; } return null; }"
      },
      {
        "txt": "@Override public K previousKey(final K key) { if (key == null) { throw new NullPointerException(); } final TrieEntry<K, V> entry = getEntry(key); if (entry != null) { final TrieEntry<K, V> prevEntry = previousEntry(entry); return prevEntry != null ? prevEntry.getKey() : null; }"
      },
      {
        "txt": "return null; } @Override public OrderedMapIterator<K, V> mapIterator() { return new TrieMapIterator(); } @Override public SortedMap<K, V> prefixMap(final K key) { return getPrefixMapByBits(key, 0, lengthInBits(key)); }"
      },
      {
        "txt": "private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) { final int offsetLength = offsetInBits + lengthInBits; if (offsetLength > lengthInBits(key)) { throw new IllegalArgumentException(offsetInBits + \" + \" + lengthInBits + \" > \" + lengthInBits(key)); } if (offsetLength == 0) { return this; } return new PrefixRangeMap(key, offsetInBits, lengthInBits);"
      },
      {
        "txt": "} @Override public SortedMap<K, V> headMap(final K toKey) { return new RangeEntryMap(null, toKey); } @Override public SortedMap<K, V> subMap(final K fromKey, final K toKey) { return new RangeEntryMap(fromKey, toKey); } @Override"
      },
      {
        "txt": "public SortedMap<K, V> tailMap(final K fromKey) { return new RangeEntryMap(fromKey, null); } TrieEntry<K,V> higherEntry(final K key) { final int lengthInBits = lengthInBits(key); if (lengthInBits == 0) { if (!root.isEmpty()) { if (size() > 1) { return nextEntry(root); }"
      },
      {
        "txt": "return null; } return firstEntry(); } final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits); if (compareKeys(key, found.key)) { return nextEntry(found); } final int bitIndex = bitIndex(key, found.key); if (KeyAnalyzer.isValidBitIndex(bitIndex)) {"
      },
      {
        "txt": "final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex); addEntry(added, lengthInBits); incrementSize(); // must increment because remove will decrement final TrieEntry<K, V> ceil = nextEntry(added); removeEntry(added); modCount -= 2; // we didn't really modify it. return ceil; } else if (KeyAnalyzer.isNullBitKey(bitIndex)) { if (!root.isEmpty()) { return firstEntry();"
      },
      {
        "txt": "} else if (size() > 1) { return nextEntry(firstEntry()); } else { return null; } } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) { return nextEntry(found); } throw new IllegalStateException(\"invalid lookup: \" + key); }"
      },
      {
        "txt": "TrieEntry<K,V> ceilingEntry(final K key) { final int lengthInBits = lengthInBits(key); if (lengthInBits == 0) { if (!root.isEmpty()) { return root; } return firstEntry(); } final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits); if (compareKeys(key, found.key)) {"
      },
      {
        "txt": "return found; } final int bitIndex = bitIndex(key, found.key); if (KeyAnalyzer.isValidBitIndex(bitIndex)) { final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex); addEntry(added, lengthInBits); incrementSize(); // must increment because remove will decrement final TrieEntry<K, V> ceil = nextEntry(added); removeEntry(added); modCount -= 2; // we didn't really modify it."
      },
      {
        "txt": "return ceil; } else if (KeyAnalyzer.isNullBitKey(bitIndex)) { if (!root.isEmpty()) { return root; } return firstEntry(); } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) { return found; } throw new IllegalStateException(\"invalid lookup: \" + key);"
      },
      {
        "txt": "} TrieEntry<K,V> lowerEntry(final K key) { final int lengthInBits = lengthInBits(key); if (lengthInBits == 0) { return null; // there can never be anything before root. } final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits); if (compareKeys(key, found.key)) { return previousEntry(found); }"
      },
      {
        "txt": "final int bitIndex = bitIndex(key, found.key); if (KeyAnalyzer.isValidBitIndex(bitIndex)) { final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex); addEntry(added, lengthInBits); incrementSize(); // must increment because remove will decrement final TrieEntry<K, V> prior = previousEntry(added); removeEntry(added); modCount -= 2; // we didn't really modify it. return prior; } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {"
      },
      {
        "txt": "return null; } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) { return previousEntry(found); } throw new IllegalStateException(\"invalid lookup: \" + key); } TrieEntry<K,V> floorEntry(final K key) { final int lengthInBits = lengthInBits(key); if (lengthInBits == 0) { if (!root.isEmpty()) {"
      },
      {
        "txt": "return root; } return null; } final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits); if (compareKeys(key, found.key)) { return found; } final int bitIndex = bitIndex(key, found.key); if (KeyAnalyzer.isValidBitIndex(bitIndex)) {"
      },
      {
        "txt": "final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex); addEntry(added, lengthInBits); incrementSize(); // must increment because remove will decrement final TrieEntry<K, V> floor = previousEntry(added); removeEntry(added); modCount -= 2; // we didn't really modify it. return floor; } else if (KeyAnalyzer.isNullBitKey(bitIndex)) { if (!root.isEmpty()) { return root;"
      },
      {
        "txt": "} return null; } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) { return found; } throw new IllegalStateException(\"invalid lookup: \" + key); } TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) { TrieEntry<K, V> current = root.left; TrieEntry<K, V> path = root;"
      },
      {
        "txt": "while(true) { if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) { break; } path = current; if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) { current = current.left; } else { current = current.right; }"
      },
      {
        "txt": "} final TrieEntry<K, V> entry = current.isEmpty() ? path : current; if (entry.isEmpty()) { return null; } final int endIndexInBits = offsetInBits + lengthInBits; if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) { return null; } if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits)"
      },
      {
        "txt": "!= isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) { return null; } final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits, entry.key, 0, lengthInBits(entry.getKey())); if (bitIndex >= 0 && bitIndex < lengthInBits) { return null; } return entry; }"
      },
      {
        "txt": "TrieEntry<K, V> lastEntry() { return followRight(root.left); } TrieEntry<K, V> followRight(TrieEntry<K, V> node) { if (node.right == null) { return null; } while (node.right.bitIndex > node.bitIndex) { node = node.right; }"
      },
      {
        "txt": "return node.right; } TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) { if (start.predecessor == null) { throw new IllegalArgumentException(\"must have come from somewhere!\"); } if (start.predecessor.right == start) { if (isValidUplink(start.predecessor.left, start.predecessor)) { return start.predecessor.left; }"
      },
      {
        "txt": "return followRight(start.predecessor.left); } TrieEntry<K, V> node = start.predecessor; while (node.parent != null && node == node.parent.left) { node = node.parent; } if (node.parent == null) { // can be null if we're looking up root. return null; } if (isValidUplink(node.parent.left, node.parent)) {"
      },
      {
        "txt": "if (node.parent.left == root) { if (root.isEmpty()) { return null; } return root; } return node.parent.left; } return followRight(node.parent.left); }"
      },
      {
        "txt": "TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, final TrieEntry<K, V> parentOfSubtree) { if (node == null) { return firstEntry(); } return nextEntryImpl(node.predecessor, node, parentOfSubtree); } static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) { return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty(); }"
      },
      {
        "txt": "private static class Reference<E> { private E item; public void set(final E item) { this.item = item; } public E get() { return item; } } protected static class TrieEntry<K,V> extends BasicEntry<K, V> {"
      },
      {
        "txt": "private static final long serialVersionUID = 4596023148184140013L; protected int bitIndex; protected TrieEntry<K,V> parent; protected TrieEntry<K,V> left; protected TrieEntry<K,V> right; protected TrieEntry<K,V> predecessor; public TrieEntry(final K key, final V value, final int bitIndex) { super(key, value); this.bitIndex = bitIndex; this.parent = null;"
      },
      {
        "txt": "this.left = this; this.right = null; this.predecessor = this; } public boolean isEmpty() { return key == null; } public boolean isInternalNode() { return left != this && right != this; }"
      },
      {
        "txt": "public boolean isExternalNode() { return !isInternalNode(); } @Override public String toString() { final StringBuilder buffer = new StringBuilder(); if (bitIndex == -1) { buffer.append(\"RootEntry(\"); } else { buffer.append(\"Entry(\");"
      },
      {
        "txt": "} buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \"); buffer.append(\"value=\").append(getValue()).append(\", \"); if (parent != null) { if (parent.bitIndex == -1) { buffer.append(\"parent=\").append(\"ROOT\"); } else { buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\"); } } else {"
      },
      {
        "txt": "buffer.append(\"parent=\").append(\"null\"); } buffer.append(\", \"); if (left != null) { if (left.bitIndex == -1) { buffer.append(\"left=\").append(\"ROOT\"); } else { buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\"); } } else {"
      },
      {
        "txt": "buffer.append(\"left=\").append(\"null\"); } buffer.append(\", \"); if (right != null) { if (right.bitIndex == -1) { buffer.append(\"right=\").append(\"ROOT\"); } else { buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\"); } } else {"
      },
      {
        "txt": "buffer.append(\"right=\").append(\"null\"); } buffer.append(\", \"); if (predecessor != null) { if(predecessor.bitIndex == -1) { buffer.append(\"predecessor=\").append(\"ROOT\"); } else { buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\"). append(predecessor.bitIndex).append(\"]\"); }"
      },
      {
        "txt": "} buffer.append(\")\"); return buffer.toString(); } } private class EntrySet extends AbstractSet<Map.Entry<K,V>> { @Override public Iterator<Map.Entry<K,V>> iterator() { return new EntryIterator(); }"
      },
      {
        "txt": "@Override public boolean contains(final Object o) { if (!(o instanceof Map.Entry)) { return false; } final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey()); return candidate != null && candidate.equals(o); } @Override public boolean remove(final Object obj) {"
      },
      {
        "txt": "if (obj instanceof Map.Entry == false) { return false; } if (contains(obj) == false) { return false; } final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj; AbstractPatriciaTrie.this.remove(entry.getKey()); return true; }"
      },
      {
        "txt": "@Override public int size() { return AbstractPatriciaTrie.this.size(); } @Override public void clear() { AbstractPatriciaTrie.this.clear(); } private class EntryIterator extends TrieIterator<Map.Entry<K,V>> { @Override"
      },
      {
        "txt": "public Map.Entry<K,V> next() { return nextEntry(); } } } private class KeySet extends AbstractSet<K> { @Override public Iterator<K> iterator() { return new KeyIterator(); }"
      },
      {
        "txt": "@Override public int size() { return AbstractPatriciaTrie.this.size(); } @Override public boolean contains(final Object o) { return containsKey(o); } @Override public boolean remove(final Object o) {"
      },
      {
        "txt": "final int size = size(); AbstractPatriciaTrie.this.remove(o); return size != size(); } @Override public void clear() { AbstractPatriciaTrie.this.clear(); } private class KeyIterator extends TrieIterator<K> { @Override"
      },
      {
        "txt": "public K next() { return nextEntry().getKey(); } } } private class Values extends AbstractCollection<V> { @Override public Iterator<V> iterator() { return new ValueIterator(); }"
      },
      {
        "txt": "@Override public int size() { return AbstractPatriciaTrie.this.size(); } @Override public boolean contains(final Object o) { return containsValue(o); } @Override public void clear() {"
      },
      {
        "txt": "AbstractPatriciaTrie.this.clear(); } @Override public boolean remove(final Object o) { for (final Iterator<V> it = iterator(); it.hasNext(); ) { final V value = it.next(); if (compare(value, o)) { it.remove(); return true; }"
      },
      {
        "txt": "} return false; } private class ValueIterator extends TrieIterator<V> { @Override public V next() { return nextEntry().getValue(); } } }"
      },
      {
        "txt": "abstract class TrieIterator<E> implements Iterator<E> { protected int expectedModCount = AbstractPatriciaTrie.this.modCount; protected TrieEntry<K, V> next; // the next node to return protected TrieEntry<K, V> current; // the current entry we're on protected TrieIterator() { next = AbstractPatriciaTrie.this.nextEntry(null); } protected TrieIterator(final TrieEntry<K, V> firstEntry) { next = firstEntry; }"
      },
      {
        "txt": "protected TrieEntry<K,V> nextEntry() { if (expectedModCount != AbstractPatriciaTrie.this.modCount) { throw new ConcurrentModificationException(); } final TrieEntry<K,V> e = next; if (e == null) { throw new NoSuchElementException(); } next = findNext(e); current = e;"
      },
      {
        "txt": "return e; } protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) { return AbstractPatriciaTrie.this.nextEntry(prior); } @Override public boolean hasNext() { return next != null; } @Override"
      },
      {
        "txt": "public void remove() { if (current == null) { throw new IllegalStateException(); } if (expectedModCount != AbstractPatriciaTrie.this.modCount) { throw new ConcurrentModificationException(); } final TrieEntry<K, V> node = current; current = null; AbstractPatriciaTrie.this.removeEntry(node);"
      },
      {
        "txt": "expectedModCount = AbstractPatriciaTrie.this.modCount; } } private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> { protected TrieEntry<K, V> previous; // the previous node to return @Override public K next() { return nextEntry().getKey(); } @Override"
      },
      {
        "txt": "public K getKey() { if (current == null) { throw new IllegalStateException(); } return current.getKey(); } @Override public V getValue() { if (current == null) { throw new IllegalStateException();"
      },
      {
        "txt": "} return current.getValue(); } @Override public V setValue(final V value) { if (current == null) { throw new IllegalStateException(); } return current.setValue(value); }"
      },
      {
        "txt": "@Override public boolean hasPrevious() { return previous != null; } @Override public K previous() { return previousEntry().getKey(); } @Override protected TrieEntry<K, V> nextEntry() {"
      },
      {
        "txt": "final TrieEntry<K, V> nextEntry = super.nextEntry(); previous = nextEntry; return nextEntry; } protected TrieEntry<K,V> previousEntry() { if (expectedModCount != AbstractPatriciaTrie.this.modCount) { throw new ConcurrentModificationException(); } final TrieEntry<K,V> e = previous; if (e == null) {"
      },
      {
        "txt": "throw new NoSuchElementException(); } previous = AbstractPatriciaTrie.this.previousEntry(e); next = current; current = e; return current; } } private abstract class RangeMap extends AbstractMap<K, V> implements SortedMap<K, V> {"
      },
      {
        "txt": "private transient volatile Set<Map.Entry<K, V>> entrySet; protected abstract Set<Map.Entry<K, V>> createEntrySet(); protected abstract K getFromKey(); protected abstract boolean isFromInclusive(); protected abstract K getToKey(); protected abstract boolean isToInclusive(); @Override public Comparator<? super K> comparator() { return AbstractPatriciaTrie.this.comparator(); }"
      },
      {
        "txt": "@Override public boolean containsKey(final Object key) { if (!inRange(castKey(key))) { return false; } return AbstractPatriciaTrie.this.containsKey(key); } @Override public V remove(final Object key) { if (!inRange(castKey(key))) {"
      },
      {
        "txt": "return null; } return AbstractPatriciaTrie.this.remove(key); } @Override public V get(final Object key) { if (!inRange(castKey(key))) { return null; } return AbstractPatriciaTrie.this.get(key);"
      },
      {
        "txt": "} @Override public V put(final K key, final V value) { if (!inRange(key)) { throw new IllegalArgumentException(\"Key is out of range: \" + key); } return AbstractPatriciaTrie.this.put(key, value); } @Override public Set<Map.Entry<K, V>> entrySet() {"
      },
      {
        "txt": "if (entrySet == null) { entrySet = createEntrySet(); } return entrySet; } @Override public SortedMap<K, V> subMap(final K fromKey, final K toKey) { if (!inRange2(fromKey)) { throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey); }"
      },
      {
        "txt": "if (!inRange2(toKey)) { throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey); } return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive()); } @Override public SortedMap<K, V> headMap(final K toKey) { if (!inRange2(toKey)) { throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey); }"
      },
      {
        "txt": "return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive()); } @Override public SortedMap<K, V> tailMap(final K fromKey) { if (!inRange2(fromKey)) { throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey); } return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive()); } protected boolean inRange(final K key) {"
      },
      {
        "txt": "final K fromKey = getFromKey(); final K toKey = getToKey(); return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false)); } protected boolean inRange2(final K key) { final K fromKey = getFromKey(); final K toKey = getToKey(); return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true)); } protected boolean inFromRange(final K key, final boolean forceInclusive) {"
      },
      {
        "txt": "final K fromKey = getFromKey(); final boolean fromInclusive = isFromInclusive(); final int ret = getKeyAnalyzer().compare(key, fromKey); if (fromInclusive || forceInclusive) { return ret >= 0; } return ret > 0; } protected boolean inToRange(final K key, final boolean forceInclusive) { final K toKey = getToKey();"
      },
      {
        "txt": "final boolean toInclusive = isToInclusive(); final int ret = getKeyAnalyzer().compare(key, toKey); if (toInclusive || forceInclusive) { return ret <= 0; } return ret < 0; } protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); }"
      },
      {
        "txt": "private class RangeEntryMap extends RangeMap { private final K fromKey; private final K toKey; private final boolean fromInclusive; private final boolean toInclusive; protected RangeEntryMap(final K fromKey, final K toKey) { this(fromKey, true, toKey, false); } protected RangeEntryMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {"
      },
      {
        "txt": "if (fromKey == null && toKey == null) { throw new IllegalArgumentException(\"must have a from or to!\"); } if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) { throw new IllegalArgumentException(\"fromKey > toKey\"); } this.fromKey = fromKey; this.fromInclusive = fromInclusive; this.toKey = toKey; this.toInclusive = toInclusive;"
      },
      {
        "txt": "} @Override public K firstKey() { Map.Entry<K,V> e = null; if (fromKey == null) { e = firstEntry(); } else { if (fromInclusive) { e = ceilingEntry(fromKey); } else {"
      },
      {
        "txt": "e = higherEntry(fromKey); } } final K first = e != null ? e.getKey() : null; if (e == null || toKey != null && !inToRange(first, false)) { throw new NoSuchElementException(); } return first; } @Override"
      },
      {
        "txt": "public K lastKey() { Map.Entry<K,V> e; if (toKey == null) { e = lastEntry(); } else { if (toInclusive) { e = floorEntry(toKey); } else { e = lowerEntry(toKey); }"
      },
      {
        "txt": "} final K last = e != null ? e.getKey() : null; if (e == null || fromKey != null && !inFromRange(last, false)) { throw new NoSuchElementException(); } return last; } @Override protected Set<Entry<K, V>> createEntrySet() { return new RangeEntrySet(this);"
      },
      {
        "txt": "} @Override public K getFromKey() { return fromKey; } @Override public K getToKey() { return toKey; } @Override"
      },
      {
        "txt": "public boolean isFromInclusive() { return fromInclusive; } @Override public boolean isToInclusive() { return toInclusive; } @Override protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) {"
      },
      {
        "txt": "return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } } private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> { private final RangeMap delegate; private transient int size = -1; private transient int expectedModCount; public RangeEntrySet(final RangeMap delegate) { if (delegate == null) { throw new NullPointerException(\"delegate\");"
      },
      {
        "txt": "} this.delegate = delegate; } @Override public Iterator<Map.Entry<K, V>> iterator() { final K fromKey = delegate.getFromKey(); final K toKey = delegate.getToKey(); TrieEntry<K, V> first = null; if (fromKey == null) { first = firstEntry();"
      },
      {
        "txt": "} else { first = ceilingEntry(fromKey); } TrieEntry<K, V> last = null; if (toKey != null) { last = ceilingEntry(toKey); } return new EntryIterator(first, last); } @Override"
      },
      {
        "txt": "public int size() { if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) { size = 0; for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) { ++size; } expectedModCount = AbstractPatriciaTrie.this.modCount; } return size; }"
      },
      {
        "txt": "@Override public boolean isEmpty() { return !iterator().hasNext(); } @SuppressWarnings(\"unchecked\") @Override public boolean contains(final Object o) { if (!(o instanceof Map.Entry)) { return false; }"
      },
      {
        "txt": "final Map.Entry<K, V> entry = (Map.Entry<K, V>) o; final K key = entry.getKey(); if (!delegate.inRange(key)) { return false; } final TrieEntry<K, V> node = getEntry(key); return node != null && compare(node.getValue(), entry.getValue()); } @SuppressWarnings(\"unchecked\") @Override"
      },
      {
        "txt": "public boolean remove(final Object o) { if (!(o instanceof Map.Entry)) { return false; } final Map.Entry<K, V> entry = (Map.Entry<K, V>) o; final K key = entry.getKey(); if (!delegate.inRange(key)) { return false; } final TrieEntry<K, V> node = getEntry(key);"
      },
      {
        "txt": "if (node != null && compare(node.getValue(), entry.getValue())) { removeEntry(node); return true; } return false; } private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> { private final K excludedKey; private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) { super(first);"
      },
      {
        "txt": "this.excludedKey = last != null ? last.getKey() : null; } @Override public boolean hasNext() { return next != null && !compare(next.key, excludedKey); } @Override public Map.Entry<K,V> next() { if (next == null || compare(next.key, excludedKey)) { throw new NoSuchElementException();"
      },
      {
        "txt": "} return nextEntry(); } } } private class PrefixRangeMap extends RangeMap { private final K prefix; private final int offsetInBits; private final int lengthInBits; private K fromKey = null;"
      },
      {
        "txt": "private K toKey = null; private transient int expectedModCount = 0; private int size = -1; private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) { this.prefix = prefix; this.offsetInBits = offsetInBits; this.lengthInBits = lengthInBits; } private int fixup() { if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {"
      },
      {
        "txt": "final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator(); size = 0; Map.Entry<K, V> entry = null; if (it.hasNext()) { entry = it.next(); size = 1; } fromKey = entry == null ? null : entry.getKey(); if (fromKey != null) { final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);"
      },
      {
        "txt": "fromKey = prior == null ? null : prior.getKey(); } toKey = fromKey; while (it.hasNext()) { ++size; entry = it.next(); } toKey = entry == null ? null : entry.getKey(); if (toKey != null) { entry = nextEntry((TrieEntry<K, V>)entry);"
      },
      {
        "txt": "toKey = entry == null ? null : entry.getKey(); } expectedModCount = AbstractPatriciaTrie.this.modCount; } return size; } @Override public K firstKey() { fixup(); Map.Entry<K,V> e = null;"
      },
      {
        "txt": "if (fromKey == null) { e = firstEntry(); } else { e = higherEntry(fromKey); } final K first = e != null ? e.getKey() : null; if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) { throw new NoSuchElementException(); } return first;"
      },
      {
        "txt": "} @Override public K lastKey() { fixup(); Map.Entry<K,V> e = null; if (toKey == null) { e = lastEntry(); } else { e = lowerEntry(toKey); }"
      },
      {
        "txt": "final K last = e != null ? e.getKey() : null; if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) { throw new NoSuchElementException(); } return last; } @Override protected boolean inRange(final K key) { return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key); }"
      },
      {
        "txt": "@Override protected boolean inRange2(final K key) { return inRange(key); } @Override protected boolean inFromRange(final K key, final boolean forceInclusive) { return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key); } @Override protected boolean inToRange(final K key, final boolean forceInclusive) {"
      },
      {
        "txt": "return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key); } @Override protected Set<Map.Entry<K, V>> createEntrySet() { return new PrefixRangeEntrySet(this); } @Override public K getFromKey() { return fromKey; }"
      },
      {
        "txt": "@Override public K getToKey() { return toKey; } @Override public boolean isFromInclusive() { return false; } @Override public boolean isToInclusive() {"
      },
      {
        "txt": "} @Override protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) { return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } <extra_id_0> private final class PrefixRangeEntrySet extends RangeEntrySet { private final PrefixRangeMap delegate; private TrieEntry<K, V> prefixStart; private int expectedModCount = 0; public PrefixRangeEntrySet(final PrefixRangeMap delegate) { super(delegate);"
      },
      {
        "txt": "public PrefixRangeEntrySet(final PrefixRangeMap delegate) { super(delegate); this.delegate = delegate; } @Override public int size() { return delegate.fixup(); } @Override public Iterator<Map.Entry<K,V>> iterator() {"
      },
      {
        "txt": "if (AbstractPatriciaTrie.this.modCount != expectedModCount) { prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits); expectedModCount = AbstractPatriciaTrie.this.modCount; } if (prefixStart == null) { final Set<Map.Entry<K,V>> empty = Collections.emptySet(); return empty.iterator(); } else if (delegate.lengthInBits > prefixStart.bitIndex) { return new SingletonIterator(prefixStart); } else {"
      },
      {
        "txt": "return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits); } } private final class SingletonIterator implements Iterator<Map.Entry<K, V>> { private final TrieEntry<K, V> entry; private int hit = 0; public SingletonIterator(final TrieEntry<K, V> entry) { this.entry = entry; } @Override"
      },
      {
        "txt": "public boolean hasNext() { return hit == 0; } @Override public Map.Entry<K, V> next() { if (hit != 0) { throw new NoSuchElementException(); } ++hit; return entry;"
      },
      {
        "txt": "} @Override public void remove() { if (hit != 1) { throw new IllegalStateException(); } ++hit; AbstractPatriciaTrie.this.removeEntry(entry); } }"
      },
      {
        "txt": "private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> { private final K prefix; private final int offset; private final int lengthInBits; private boolean lastOne; private TrieEntry<K, V> subtree; // the subtree to search within EntryIterator(final TrieEntry<K, V> startScan, final K prefix, final int offset, final int lengthInBits) { subtree = startScan; next = AbstractPatriciaTrie.this.followLeft(startScan);"
      },
      {
        "txt": "this.prefix = prefix; this.offset = offset; this.lengthInBits = lengthInBits; } @Override public Map.Entry<K,V> next() { final Map.Entry<K, V> entry = nextEntry(); if (lastOne) { next = null; }"
      },
      {
        "txt": "return entry; } @Override protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) { return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree); } @Override public void remove() { boolean needsFixing = false; final int bitIdx = subtree.bitIndex;"
      },
      {
        "txt": "if (current == subtree) { needsFixing = true; } super.remove(); if (bitIdx != subtree.bitIndex || needsFixing) { subtree = subtree(prefix, offset, lengthInBits); } if (lengthInBits >= subtree.bitIndex) { lastOne = true; }"
      },
      {
        "txt": "} } } @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException{ stream.defaultReadObject(); root = new TrieEntry<K, V>(null, null, -1); int size = stream.readInt(); for(int i = 0; i < size; i++){ K k = (K) stream.readObject();"
      },
      {
        "txt": "V v = (V) stream.readObject(); put(k, v); } } private void writeObject(final ObjectOutputStream stream) throws IOException{ stream.defaultWriteObject(); stream.writeInt(this.size()); for (final Entry<K, V> entry : entrySet()) { stream.writeObject(entry.getKey()); stream.writeObject(entry.getValue());"
      },
      {
        "txt": "} }"
      }
    ]
  }
]