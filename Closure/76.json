[
  {
    "id": 367,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 300,
    "end-bug-line": 300,
    "bug": "",
    "fix": "if (n.getNext() != null) { state = isVariableReadBeforeKill( n.getNext(), variable); if (state == VariableLiveness.KILL) { state = VariableLiveness.MAYBE_LIVE; } } break;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) &&"
      },
      {
        "txt": "n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs);"
      },
      {
        "txt": "Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild();"
      },
      {
        "txt": "if (NodeUtil.containsFunction(fnBlock)) { return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze();"
      },
      {
        "txt": "tryRemoveDeadAssignments(t, cfg); } @Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) {"
      },
      {
        "txt": "Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF:"
      },
      {
        "txt": "case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue;"
      },
      {
        "txt": "case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); }"
      },
      {
        "txt": "} private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) {"
      },
      {
        "txt": "Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. }"
      },
      {
        "txt": "String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) &&"
      },
      {
        "txt": "rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. }"
      },
      {
        "txt": "if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs);"
      },
      {
        "txt": "Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) {"
      },
      {
        "txt": "parent.replaceChild(n, new Node(Token.EMPTY)); } else { return; } } else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else {"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } }"
      },
      {
        "txt": "Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND: <extra_id_0> case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable);"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } }"
      },
      {
        "txt": "n = n.getParent(); } return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill("
      },
      {
        "txt": "Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL;"
      },
      {
        "txt": "} else { return VariableLiveness.READ; } } switch (n.getType()) { case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);"
      },
      {
        "txt": "default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } }"
      },
      {
        "txt": "} return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) {"
      },
      {
        "txt": "return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  },
  {
    "id": 368,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 305,
    "end-bug-line": 305,
    "bug": "",
    "fix": "if (n.getNext() != null && n.getNext().getNext() != null) { state = checkHookBranchReadBeforeKill( n.getNext(), n.getNext().getNext(), variable); } break;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) ||"
      },
      {
        "txt": "n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root);"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) {"
      },
      {
        "txt": "return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();"
      },
      {
        "txt": "for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE:"
      },
      {
        "txt": "case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH:"
      },
      {
        "txt": "case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); } }"
      },
      {
        "txt": "private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild();"
      },
      {
        "txt": "Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString();"
      },
      {
        "txt": "if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) &&"
      },
      {
        "txt": "NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) &&"
      },
      {
        "txt": "isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);"
      },
      {
        "txt": "parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY));"
      },
      {
        "txt": "} else { return; } } else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) {"
      },
      {
        "txt": "Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } } private boolean isVariableStillLiveWithinExpression("
      },
      {
        "txt": "while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: <extra_id_0> default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) {"
      },
      {
        "txt": "state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent();"
      },
      {
        "txt": "} return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) {"
      },
      {
        "txt": "if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else {"
      },
      {
        "txt": "return VariableLiveness.READ; } } switch (n.getType()) { case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default:"
      },
      {
        "txt": "for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } }"
      },
      {
        "txt": "return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ;"
      },
      {
        "txt": "} else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  },
  {
    "id": 369,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 309,
    "end-bug-line": 309,
    "bug": "if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;"
      },
      {
        "txt": "import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler;"
      },
      {
        "txt": "private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC; } };"
      },
      {
        "txt": "public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this); } @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) { return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns,"
      },
      {
        "txt": "Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();"
      },
      {
        "txt": "Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue;"
      },
      {
        "txt": "case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) {"
      },
      {
        "txt": "tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); } } private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state);"
      },
      {
        "txt": "} private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state);"
      },
      {
        "txt": "rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; }"
      },
      {
        "txt": "Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs);"
      },
      {
        "txt": "compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; }"
      },
      {
        "txt": "if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) {"
      },
      {
        "txt": "parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY)); } else { return; }"
      },
      {
        "txt": "} else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state);"
      },
      {
        "txt": "} c = next; } return; } } private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE;"
      },
      {
        "txt": "case Token.OR: case Token.AND: case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { <extra_id_0> state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; }"
      },
      {
        "txt": "return false; } } } } n = n.getParent(); } return false; } private enum VariableLiveness {"
      },
      {
        "txt": "MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext();"
      },
      {
        "txt": "VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ; } } switch (n.getType()) {"
      },
      {
        "txt": "case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable);"
      },
      {
        "txt": "if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) {"
      },
      {
        "txt": "VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 370,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 311,
    "end-bug-line": 311,
    "bug": "",
    "fix": "if (state != VariableLiveness.MAYBE_LIVE) { break; } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns ="
      },
      {
        "txt": "new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope();"
      },
      {
        "txt": "if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) { return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return;"
      },
      {
        "txt": "} ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) {"
      },
      {
        "txt": "continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) {"
      },
      {
        "txt": "tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); }"
      },
      {
        "txt": "continue; } tryRemoveAssignment(t, n, state); } } private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot,"
      },
      {
        "txt": "FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); }"
      },
      {
        "txt": "Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) {"
      },
      {
        "txt": "return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return;"
      },
      {
        "txt": "} if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs);"
      },
      {
        "txt": "n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n)));"
      },
      {
        "txt": "} else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY)); } else { return; } } else { Preconditions.checkState(false, \"Unknown statement\");"
      },
      {
        "txt": "} compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next;"
      },
      {
        "txt": "} return; } } private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR:"
      },
      {
        "txt": "case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); <extra_id_0> if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } }"
      },
      {
        "txt": "} } } } n = n.getParent(); } return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree."
      },
      {
        "txt": "READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable);"
      },
      {
        "txt": "if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ; } } switch (n.getType()) { case Token.OR:"
      },
      {
        "txt": "case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) {"
      },
      {
        "txt": "return state; } } } } return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill("
      },
      {
        "txt": "trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE; }"
      }
    ]
  },
  {
    "id": 371,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 317,
    "end-bug-line": 319,
    "bug": "} } }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) &&"
      },
      {
        "txt": "n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs);"
      },
      {
        "txt": "Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild();"
      },
      {
        "txt": "if (NodeUtil.containsFunction(fnBlock)) { return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze();"
      },
      {
        "txt": "tryRemoveDeadAssignments(t, cfg); } @Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) {"
      },
      {
        "txt": "Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF:"
      },
      {
        "txt": "case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue;"
      },
      {
        "txt": "case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); }"
      },
      {
        "txt": "} private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) {"
      },
      {
        "txt": "Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. }"
      },
      {
        "txt": "String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) &&"
      },
      {
        "txt": "rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. }"
      },
      {
        "txt": "if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs);"
      },
      {
        "txt": "Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) {"
      },
      {
        "txt": "parent.replaceChild(n, new Node(Token.EMPTY)); } else { return; } } else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else {"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } }"
      },
      {
        "txt": "private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null;"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; <extra_id_0> } n = n.getParent(); } return false; } private enum VariableLiveness {"
      },
      {
        "txt": "} private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {"
      },
      {
        "txt": "Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ; }"
      },
      {
        "txt": "} switch (n.getType()) { case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE; }"
      },
      {
        "txt": "private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL;"
      },
      {
        "txt": "} else { return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  },
  {
    "id": 372,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 340,
    "end-bug-line": 340,
    "bug": "",
    "fix": "if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION return VariableLiveness.MAYBE_LIVE; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness;"
      },
      {
        "txt": "private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) {"
      },
      {
        "txt": "this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) { return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) {"
      },
      {
        "txt": "return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } @Override public void exitScope(NodeTraversal t) { }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue();"
      },
      {
        "txt": "if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR:"
      },
      {
        "txt": "if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state);"
      },
      {
        "txt": "} continue; } tryRemoveAssignment(t, n, state); } } private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); }"
      },
      {
        "txt": "private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext();"
      },
      {
        "txt": "} Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name);"
      },
      {
        "txt": "if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange();"
      },
      {
        "txt": "return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) {"
      },
      {
        "txt": "n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n,"
      },
      {
        "txt": "new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY)); } else { return; } } else {"
      },
      {
        "txt": "Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); }"
      },
      {
        "txt": "c = next; } return; } } private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) {"
      },
      {
        "txt": "case Token.OR: case Token.AND: case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true;"
      },
      {
        "txt": "} else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent(); } return false; }"
      },
      {
        "txt": "MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { <extra_id_0> if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) {"
      },
      {
        "txt": "VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ; } } switch (n.getType()) {"
      },
      {
        "txt": "case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable);"
      },
      {
        "txt": "if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) {"
      },
      {
        "txt": "VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 373,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 362,
    "end-bug-line": 362,
    "bug": "",
    "fix": "VariableLiveness v1 = isVariableReadBeforeKill( n.getFirstChild(), variable); VariableLiveness v2 = isVariableReadBeforeKill( n.getLastChild(), variable);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) ||"
      },
      {
        "txt": "n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root);"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) {"
      },
      {
        "txt": "return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();"
      },
      {
        "txt": "for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE:"
      },
      {
        "txt": "case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH:"
      },
      {
        "txt": "case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); } }"
      },
      {
        "txt": "private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild();"
      },
      {
        "txt": "Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString();"
      },
      {
        "txt": "if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) &&"
      },
      {
        "txt": "NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) &&"
      },
      {
        "txt": "isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);"
      },
      {
        "txt": "parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY));"
      },
      {
        "txt": "} else { return; } } else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) {"
      },
      {
        "txt": "Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } } private boolean isVariableStillLiveWithinExpression("
      },
      {
        "txt": "Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } }"
      },
      {
        "txt": "n = n.getParent(); } return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill("
      },
      {
        "txt": "Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL;"
      },
      {
        "txt": "return VariableLiveness.READ; } } switch (n.getType()) { case Token.OR: case Token.AND: <extra_id_0> case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {"
      },
      {
        "txt": "for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } }"
      },
      {
        "txt": "return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ;"
      },
      {
        "txt": "} else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  },
  {
    "id": 374,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 364,
    "end-bug-line": 364,
    "bug": "",
    "fix": "if (v1 != VariableLiveness.MAYBE_LIVE) { return v1; } else if (v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else { return VariableLiveness.MAYBE_LIVE; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) ||"
      },
      {
        "txt": "n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root);"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) {"
      },
      {
        "txt": "return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();"
      },
      {
        "txt": "for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE:"
      },
      {
        "txt": "case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH:"
      },
      {
        "txt": "case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); } }"
      },
      {
        "txt": "private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild();"
      },
      {
        "txt": "Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString();"
      },
      {
        "txt": "if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) &&"
      },
      {
        "txt": "NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) &&"
      },
      {
        "txt": "isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);"
      },
      {
        "txt": "parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY));"
      },
      {
        "txt": "} else { return; } } else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) {"
      },
      {
        "txt": "Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } } private boolean isVariableStillLiveWithinExpression("
      },
      {
        "txt": "Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } }"
      },
      {
        "txt": "n = n.getParent(); } return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill("
      },
      {
        "txt": "Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL;"
      },
      {
        "txt": "return VariableLiveness.READ; } } switch (n.getType()) { case Token.OR: case Token.AND: <extra_id_0> return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION"
      },
      {
        "txt": "child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE;"
      },
      {
        "txt": "} private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) {"
      },
      {
        "txt": "return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  },
  {
    "id": 375,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 365,
    "end-bug-line": 365,
    "bug": "",
    "fix": "VariableLiveness first = isVariableReadBeforeKill( n.getFirstChild(), variable); if (first != VariableLiveness.MAYBE_LIVE) { return first; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates;"
      },
      {
        "txt": "import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements"
      },
      {
        "txt": "CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC;"
      },
      {
        "txt": "} }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this);"
      },
      {
        "txt": "} @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) { return;"
      },
      {
        "txt": "} if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) {"
      },
      {
        "txt": "FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO:"
      },
      {
        "txt": "tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE:"
      },
      {
        "txt": "case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); } } private void tryRemoveAssignment(NodeTraversal t, Node n,"
      },
      {
        "txt": "FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext();"
      },
      {
        "txt": "if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) {"
      },
      {
        "txt": "return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) {"
      },
      {
        "txt": "n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {"
      },
      {
        "txt": "return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op);"
      },
      {
        "txt": "} else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY)); } else {"
      },
      {
        "txt": "return; } } else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext();"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } } private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) {"
      },
      {
        "txt": "while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {"
      },
      {
        "txt": "state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent();"
      },
      {
        "txt": "} return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) {"
      },
      {
        "txt": "if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else {"
      },
      {
        "txt": "} } switch (n.getType()) { case Token.OR: case Token.AND: case Token.HOOK: <extra_id_0> n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable);"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE; }"
      },
      {
        "txt": "private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL;"
      },
      {
        "txt": "} else { return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  },
  {
    "id": 376,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 372,
    "end-bug-line": 372,
    "bug": "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() {"
      },
      {
        "txt": "@Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC; } }; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) {"
      },
      {
        "txt": "return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) { return; } if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }"
      },
      {
        "txt": "ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } @Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "} private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue;"
      },
      {
        "txt": "} switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment("
      },
      {
        "txt": "t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;"
      },
      {
        "txt": "} tryRemoveAssignment(t, n, state); } } private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) {"
      },
      {
        "txt": "Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope();"
      },
      {
        "txt": "if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures."
      },
      {
        "txt": "} if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; }"
      },
      {
        "txt": "if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs);"
      },
      {
        "txt": "} else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) {"
      },
      {
        "txt": "parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY)); } else { return; } } else { Preconditions.checkState(false, \"Unknown statement\"); }"
      },
      {
        "txt": "compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; }"
      },
      {
        "txt": "return; } } private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND:"
      },
      {
        "txt": "case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false;"
      },
      {
        "txt": "} } } } n = n.getParent(); } return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree."
      },
      {
        "txt": "READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable);"
      },
      {
        "txt": "if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ; } } switch (n.getType()) { case Token.OR:"
      },
      {
        "txt": "case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { <extra_id_0> VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } }"
      },
      {
        "txt": "} } } return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill("
      },
      {
        "txt": "falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else { return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  },
  {
    "id": 377,
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
    "start-bug-line": 378,
    "end-bug-line": 378,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.ControlFlowGraph.Branch;"
      },
      {
        "txt": "import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; class DeadAssignmentsElimination extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private LiveVariablesAnalysis liveness; private static final Predicate<Node> matchRemovableAssigns = new Predicate<Node>() { @Override public boolean apply(Node n) { return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().getType() == Token.NAME) || n.getType() == Token.INC || n.getType() == Token.DEC; }"
      },
      {
        "txt": "}; public DeadAssignmentsElimination(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); NodeTraversal.traverse(compiler, root, this); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } Node fnBlock = t.getScopeRoot().getLastChild(); if (NodeUtil.containsFunction(fnBlock)) { return; }"
      },
      {
        "txt": "if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state ="
      },
      {
        "txt": "cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state);"
      },
      {
        "txt": "continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN:"
      },
      {
        "txt": "if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue; } tryRemoveAssignment(t, n, state); } } private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) {"
      },
      {
        "txt": "tryRemoveAssignment(t, n, n, state); } private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) {"
      },
      {
        "txt": "tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return;"
      },
      {
        "txt": "} Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs);"
      },
      {
        "txt": "n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return;"
      },
      {
        "txt": "} if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) {"
      },
      {
        "txt": "if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY)); } else { return;"
      },
      {
        "txt": "} } else { Preconditions.checkState(false, \"Unknown statement\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {"
      },
      {
        "txt": "tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } } private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) {"
      },
      {
        "txt": "VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch (n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable);"
      },
      {
        "txt": "if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent(); }"
      },
      {
        "txt": "return false; } private enum VariableLiveness { MAYBE_LIVE, // May be still live in the current expression tree. READ, // Known there is a read left of it. KILL, // Known there is a write before any read. } private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) {"
      },
      {
        "txt": "if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ;"
      },
      {
        "txt": "} } switch (n.getType()) { case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild();"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } <extra_id_0> } return VariableLiveness.MAYBE_LIVE; } private VariableLiveness checkHookBranchReadBeforeKill( Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill("
      },
      {
        "txt": "Node trueCase, Node falseCase, String variable) { VariableLiveness v1 = isVariableReadBeforeKill( trueCase, variable); VariableLiveness v2 = isVariableReadBeforeKill( falseCase, variable); if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { return VariableLiveness.KILL; } else {"
      },
      {
        "txt": "return VariableLiveness.MAYBE_LIVE; } }"
      }
    ]
  }
]