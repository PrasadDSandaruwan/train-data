[
  {
    "id": 411,
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
    "start-bug-line": 899,
    "end-bug-line": 899,
    "bug": "",
    "fix": "if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP; import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT; import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CodingConvention.DelegateRelationship; import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.CodingConvention.SubclassType; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionParamBuilder;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import javax.annotation.Nullable; final class TypedScopeCreator implements ScopeCreator { static final String DELEGATE_PROXY_SUFFIX = \"(Proxy)\";"
      },
      {
        "txt": "static final DiagnosticType MALFORMED_TYPEDEF = DiagnosticType.warning( \"JSC_MALFORMED_TYPEDEF\", \"Typedef for {0} does not have any type information\"); static final DiagnosticType ENUM_INITIALIZER = DiagnosticType.warning( \"JSC_ENUM_INITIALIZER_NOT_ENUM\", \"enum initializer must be an object literal or an enum\"); static final DiagnosticType CONSTRUCTOR_EXPECTED = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_REFLECT_CONSTRUCTOR_EXPECTED\", \"Constructor expected as first argument\"); private final AbstractCompiler compiler; private final ErrorReporter typeParsingErrorReporter; private final TypeValidator validator; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList(); private class DeferredSetType { final Node node;"
      },
      {
        "txt": "final JSType type; DeferredSetType(Node node, JSType type) { Preconditions.checkNotNull(node); Preconditions.checkNotNull(type); this.node = node; this.type = type; node.setJSType(type); } void resolve(Scope scope) { node.setJSType(type.resolve(typeParsingErrorReporter, scope));"
      },
      {
        "txt": "} } TypedScopeCreator(AbstractCompiler compiler) { this(compiler, compiler.getCodingConvention()); } TypedScopeCreator(AbstractCompiler compiler, CodingConvention codingConvention) { this.compiler = compiler; this.validator = compiler.getTypeValidator(); this.codingConvention = codingConvention;"
      },
      {
        "txt": "this.typeRegistry = compiler.getTypeRegistry(); this.typeParsingErrorReporter = typeRegistry.getErrorReporter(); } public Scope createScope(Node root, Scope parent) { Scope newScope = null; AbstractScopeBuilder scopeBuilder = null; if (parent == null) { newScope = createInitialScope(root); GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope); scopeBuilder = globalScopeBuilder;"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, scopeBuilder); } else { newScope = new Scope(parent, root); LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope); scopeBuilder = localScopeBuilder; localScopeBuilder.build(); } scopeBuilder.resolveStubDeclarations(); scopeBuilder.resolveTypes(); for (Node functionNode : scopeBuilder.nonExternFunctions) {"
      },
      {
        "txt": "JSType type = functionNode.getJSType(); if (type != null && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; ObjectType fnThisType = fnType.getTypeOfThis(); if (!fnThisType.isUnknownType()) { NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType)); } } }"
      },
      {
        "txt": "if (parent == null) { codingConvention.defineDelegateProxyPrototypeProperties( typeRegistry, newScope, delegateProxyPrototypes); } return newScope; } @VisibleForTesting Scope createInitialScope(Node root) { NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry)); Scope s = new Scope(root, compiler);"
      },
      {
        "txt": "declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE); declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, DATE_FUNCTION_TYPE); declareNativeFunctionType(s, ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE); declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE); declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE); declareNativeValueType(s, \"undefined\", VOID_TYPE); declareNativeValueType(s, \"goog.typedef\", NO_TYPE); declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE); return s; }"
      },
      {
        "txt": "private void declareNativeFunctionType(Scope scope, JSTypeNative tId) { FunctionType t = typeRegistry.getNativeFunctionType(tId); declareNativeType(scope, t.getInstanceType().getReferenceName(), t); declareNativeType( scope, t.getPrototype().getReferenceName(), t.getPrototype()); } private void declareNativeValueType(Scope scope, String name, JSTypeNative tId) { declareNativeType(scope, name, typeRegistry.getNativeType(tId)); }"
      },
      {
        "txt": "private void declareNativeType(Scope scope, String name, JSType t) { scope.declare(name, null, t, null, false); } private static class DiscoverEnums extends AbstractShallowStatementCallback { private final JSTypeRegistry registry; DiscoverEnums(JSTypeRegistry registry) { this.registry = registry; } @Override public void visit(NodeTraversal t, Node node, Node parent) {"
      },
      {
        "txt": "Node nameNode = null; switch (node.getType()) { case Token.VAR: for (Node child = node.getFirstChild(); child != null; child = child.getNext()) { identifyEnumInNameNode( child, NodeUtil.getInfoForNameNode(child)); } break; case Token.EXPR_RESULT:"
      },
      {
        "txt": "Node maybeAssign = node.getFirstChild(); if (maybeAssign.getType() == Token.ASSIGN) { identifyEnumInNameNode( maybeAssign.getFirstChild(), maybeAssign.getJSDocInfo()); } break; } } private void identifyEnumInNameNode(Node nameNode, JSDocInfo info) { if (info != null && info.hasEnumParameterType()) {"
      },
      {
        "txt": "registry.identifyEnumName(nameNode.getQualifiedName()); } } } private static Node getPrototypePropertyOwner(Node n) { if (n.getType() == Token.GETPROP) { Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.getLastChild().getString().equals(\"prototype\")) { Node maybeOwner = firstChild.getFirstChild();"
      },
      {
        "txt": "if (maybeOwner.isQualifiedName()) { return maybeOwner; } } } return null; } private void attachLiteralTypes(Node n) { switch (n.getType()) { case Token.NULL:"
      },
      {
        "txt": "n.setJSType(getNativeType(NULL_TYPE)); break; case Token.VOID: n.setJSType(getNativeType(VOID_TYPE)); break; case Token.STRING: n.setJSType(getNativeType(STRING_TYPE)); break; case Token.NUMBER: n.setJSType(getNativeType(NUMBER_TYPE));"
      },
      {
        "txt": "break; case Token.TRUE: case Token.FALSE: n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.REGEXP: n.setJSType(getNativeType(REGEXP_TYPE)); break; case Token.REF_SPECIAL: n.setJSType(getNativeType(UNKNOWN_TYPE));"
      },
      {
        "txt": "break; case Token.OBJECTLIT: if (n.getJSType() == null) { n.setJSType(typeRegistry.createAnonymousObjectType()); } break; } } private JSType getNativeType(JSTypeNative nativeType) { return typeRegistry.getNativeType(nativeType);"
      },
      {
        "txt": "} private abstract class AbstractScopeBuilder implements NodeTraversal.Callback { final Scope scope; private final List<DeferredSetType> deferredSetTypes = Lists.newArrayList(); private final List<Node> nonExternFunctions = Lists.newArrayList(); private final List<StubDeclaration> stubDeclarations = Lists.newArrayList(); private String sourceName = null;"
      },
      {
        "txt": "private AbstractScopeBuilder(Scope scope) { this.scope = scope; } void setDeferredType(Node node, JSType type) { deferredSetTypes.add(new DeferredSetType(node, type)); } void resolveTypes() { for (DeferredSetType deferred : deferredSetTypes) { deferred.resolve(scope); }"
      },
      {
        "txt": "Iterator<Var> vars = scope.getVars(); while (vars.hasNext()) { vars.next().resolveType(typeParsingErrorReporter); } typeRegistry.resolveTypesInScope(scope); } @Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (n.getType() == Token.FUNCTION ||"
      },
      {
        "txt": "n.getType() == Token.SCRIPT) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); } return parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild() || parent == scope.getRootNode(); } @Override public void visit(NodeTraversal t, Node n, Node parent) { attachLiteralTypes(n); switch (n.getType()) {"
      },
      {
        "txt": "case Token.CALL: checkForClassDefiningCalls(t, n, parent); break; case Token.FUNCTION: if (t.getInput() == null || !t.getInput().isExtern()) { nonExternFunctions.add(n); } if (parent.getType() != Token.ASSIGN && parent.getType() != Token.NAME) { defineDeclaredFunction(n, parent);"
      },
      {
        "txt": "} break; case Token.ASSIGN: defineNamedTypeAssign(n, parent); Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext()); }"
      },
      {
        "txt": "break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; case Token.GETPROP: if (parent.getType() == Token.EXPR_RESULT && n.isQualifiedName()) {"
      },
      {
        "txt": "maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); } break; } } JSType getDeclaredTypeInAnnotation( NodeTraversal t, Node node, JSDocInfo info) { return getDeclaredTypeInAnnotation(t.getSourceName(), node, info); } JSType getDeclaredTypeInAnnotation(String sourceName,"
      },
      {
        "txt": "Node node, JSDocInfo info) { JSType jsType = null; Node objNode = node.getType() == Token.GETPROP ? node.getFirstChild() : null; if (info != null) { if (info.hasType()) { jsType = info.getType().evaluate(scope, typeRegistry); } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { String fnName = node.getQualifiedName(); if (info.isConstructor() && typeRegistry.getType(fnName) != null) {"
      },
      {
        "txt": "return null; } FunctionTypeBuilder builder = new FunctionTypeBuilder( fnName, compiler, node, sourceName, scope) .inferTemplateTypeName(info) .inferReturnType(info) .inferParameterTypes(info) .inferInheritance(info); boolean searchedForThisType = false;"
      },
      {
        "txt": "if (objNode != null) { if (objNode.getType() == Token.GETPROP && objNode.getLastChild().getString().equals(\"prototype\")) { builder.inferThisType(info, objNode.getFirstChild()); searchedForThisType = true; } else if (objNode.getType() == Token.THIS) { builder.inferThisType(info, objNode.getJSType()); searchedForThisType = true; } }"
      },
      {
        "txt": "if (!searchedForThisType) { builder.inferThisType(info, (Node) null); } jsType = builder.buildAndRegister(); } } return jsType; } void assertDefinitionNode(Node n, int type) { Preconditions.checkState(sourceName != null);"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == type); } void defineCatch(Node n, Node parent) { assertDefinitionNode(n, Token.CATCH); Node catchName = n.getFirstChild(); defineSlot(catchName, n, null); } void defineVar(Node n, Node parent) { assertDefinitionNode(n, Token.VAR); JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (n.hasMoreThanOneChild()) { if (info != null) { compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF)); } for (Node name : n.children()) { defineName(name, n, parent, name.getJSDocInfo()); } } else { Node name = n.getFirstChild(); defineName(name, n, parent,"
      },
      {
        "txt": "(info != null) ? info : name.getJSDocInfo()); } } void defineDeclaredFunction(Node n, Node parent) { assertDefinitionNode(n, Token.FUNCTION); JSDocInfo info = n.getJSDocInfo(); int parentType = parent.getType(); Preconditions.checkState( (scope.isLocal() || parentType != Token.ASSIGN) && parentType != Token.NAME,"
      },
      {
        "txt": "\"function defined as standalone function when it is being \" + \"assigned\"); String functionName = n.getFirstChild().getString(); FunctionType functionType = getFunctionType(functionName, n, info, null); if (NodeUtil.isFunctionDeclaration(n)) { defineSlot(n.getFirstChild(), n, functionType); } } void defineNamedTypeAssign(Node n, Node parent) {"
      },
      {
        "txt": "assertDefinitionNode(n, Token.ASSIGN); JSDocInfo info = n.getJSDocInfo(); Node rvalue = n.getLastChild(); Node lvalue = n.getFirstChild(); info = (info != null) ? info : rvalue.getJSDocInfo(); if (rvalue.getType() == Token.FUNCTION || info != null && info.isConstructor()) { getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue); } else if (info != null && info.hasEnumParameterType()) {"
      },
      {
        "txt": "JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry)); if (type != null) { setDeferredType(lvalue, type); } } } private void defineName(Node name, Node var, Node parent, JSDocInfo info) { Node value = name.getFirstChild(); if (value != null && value.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "String functionName = name.getString(); FunctionType functionType = getFunctionType(functionName, value, info, null); if (functionType.isReturnTypeInferred() && scope.isLocal()) { defineSlot(name, var, null); } else { defineSlot(name, var, functionType); } } else {"
      },
      {
        "txt": "JSType type = null; if (info == null) { CompilerInput input = compiler.getInput(sourceName); Preconditions.checkNotNull(input, sourceName); type = input.isExtern() ? getNativeType(UNKNOWN_TYPE) : null; } else if (info.hasEnumParameterType()) { type = getEnumType(name.getString(), var, value, info.getEnumParameterType().evaluate(scope, typeRegistry)); } else if (info.isConstructor()) {"
      },
      {
        "txt": "type = getFunctionType(name.getString(), value, info, name); } else { type = getDeclaredTypeInAnnotation(sourceName, name, info); } defineSlot(name, var, type); } } private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) { FunctionType functionType = null;"
      },
      {
        "txt": "if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) { Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() instanceof FunctionType) { functionType = (FunctionType) var.getType(); if (functionType != null && functionType.isConstructor()) { typeRegistry.declareType(name, functionType.getInstanceType()); } } return functionType; }"
      },
      {
        "txt": "Node owner = null; if (lvalueNode != null) { owner = getPrototypePropertyOwner(lvalueNode); } Node errorRoot = rValue == null ? lvalueNode : rValue; boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION; Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;"
      },
      {
        "txt": "Node fnBlock = isFnLiteral ? parametersNode.getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry); type = type.restrictByNotNullOrUndefined(); if (type.isFunctionType()) { functionType = (FunctionType) type; functionType.setJSDocInfo(info); } } if (functionType == null) {"
      },
      {
        "txt": "FunctionType overriddenPropType = null; if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) { Var var = scope.getVar( lvalueNode.getFirstChild().getQualifiedName()); if (var != null) { ObjectType ownerType = ObjectType.cast(var.getType()); if (ownerType != null) { String propName = lvalueNode.getLastChild().getString(); overriddenPropType = findOverriddenFunction(ownerType, propName);"
      },
      {
        "txt": "} } } functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferFromOverriddenFunction(overriddenPropType, parametersNode) .inferTemplateTypeName(info) .inferReturnType(info)"
      },
      {
        "txt": ".inferInheritance(info) .inferThisType(info, owner) .inferParameterTypes(parametersNode, info) .inferReturnStatementsAsLastResort(fnBlock) .buildAndRegister(); } if (rValue != null) { setDeferredType(rValue, functionType); } return functionType;"
      },
      {
        "txt": "} private FunctionType findOverriddenFunction( ObjectType ownerType, String propName) { JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName);"
      },
      {
        "txt": "if (propType instanceof FunctionType) { return (FunctionType) propType; } } } return null; } private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) { EnumType enumType = null;"
      },
      {
        "txt": "if (value != null) { if (value.getType() == Token.OBJECTLIT) { enumType = typeRegistry.createEnumType(name, elementsType); Node key = value.getFirstChild(); while (key != null) { String keyName = NodeUtil.getStringValue(key); if (enumType.hasOwnProperty(keyName)) { compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName)); } else if (!codingConvention.isValidEnumKey(keyName)) { compiler.report("
      },
      {
        "txt": "JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else { enumType.defineElement(keyName); } key = key.getNext(); key = (key == null) ? null : key.getNext(); } } else if (value.isQualifiedName()) { Var var = scope.getVar(value.getQualifiedName()); if (var != null && var.getType() instanceof EnumType) {"
      },
      {
        "txt": "enumType = (EnumType) var.getType(); } } } if (enumType == null) { compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER)); } else if (scope.isGlobal()) { if (name != null && !name.isEmpty()) { typeRegistry.declareType(name, enumType.getElementsType()); }"
      },
      {
        "txt": "} return enumType; } private void defineSlot(Node name, Node parent, JSType type) { defineSlot(name, parent, type, type == null); } void defineSlot(Node n, Node parent, JSType type, boolean inferred) { Preconditions.checkArgument(inferred || type != null); boolean shouldDeclareOnGlobalThis = false; if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "Preconditions.checkArgument( parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH); shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION); } else { Preconditions.checkArgument("
      },
      {
        "txt": "(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT)); } String variableName = n.getQualifiedName(); Preconditions.checkArgument(!variableName.isEmpty()); Scope scopeToDeclareIn = scope; <extra_id_0> if (scopeToDeclareIn.isDeclared(variableName, false)) { Var oldVar = scopeToDeclareIn.getVar(variableName); validator.expectUndeclaredVariable( sourceName, n, parent, oldVar, variableName, type); } else { if (!inferred) {"
      },
      {
        "txt": "} else { if (!inferred) { setDeferredType(n, type); } CompilerInput input = compiler.getInput(sourceName); scopeToDeclareIn.declare(variableName, n, type, input, inferred); if (shouldDeclareOnGlobalThis) { ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS); boolean isExtern = input.isExtern();"
      },
      {
        "txt": "if (inferred) { globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern); } else { globalThis.defineDeclaredProperty(variableName, type, isExtern); } }"
      },
      {
        "txt": "if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; if (fnType.isConstructor() || fnType.isInterface()) { FunctionType superClassCtor = fnType.getSuperClassConstructor(); scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null || superClassCtor.getInstanceType().equals( getNativeType(OBJECT_TYPE))); }"
      },
      {
        "txt": "} } } private boolean isQnameRootedInGlobalScope(Node n) { Node root = NodeUtil.getRootOfQualifiedName(n); if (root.getType() == Token.NAME) { Var var = scope.getVar(root.getString()); if (var != null) { return var.isGlobal(); }"
      },
      {
        "txt": "} return false; } private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, Node rhsValue) { if (info != null && info.hasType()) { return getDeclaredTypeInAnnotation(t, n, info); } else if (info != null && info.hasEnumParameterType()) { return n.getJSType(); } else if (rhsValue != null &&"
      },
      {
        "txt": "rhsValue.getType() == Token.FUNCTION) { return rhsValue.getJSType(); } else { return getDeclaredTypeInAnnotation(t, n, info); } } private void checkForClassDefiningCalls( NodeTraversal t, Node n, Node parent) { SubclassRelationship relationship = codingConvention.getClassesDefinedByCall(n);"
      },
      {
        "txt": "if (relationship != null) { ObjectType superClass = ObjectType.cast( typeRegistry.getType(relationship.superclassName)); ObjectType subClass = ObjectType.cast( typeRegistry.getType(relationship.subclassName)); if (superClass != null && subClass != null) { FunctionType superCtor = superClass.getConstructor(); FunctionType subCtor = subClass.getConstructor(); if (relationship.type == SubclassType.INHERITS) { validator.expectSuperType(t, n, superClass, subClass);"
      },
      {
        "txt": "} if (superCtor != null && subCtor != null) { codingConvention.applySubclassRelationship( superCtor, subCtor, relationship.type); } } } String singletonGetterClassName = codingConvention.getSingletonGetterClassName(n); if (singletonGetterClassName != null) {"
      },
      {
        "txt": "ObjectType objectType = ObjectType.cast( typeRegistry.getType(singletonGetterClassName)); if (objectType != null) { FunctionType functionType = objectType.getConstructor(); if (functionType != null) { FunctionType getterType = typeRegistry.createFunctionType(objectType); codingConvention.applySingletonGetter(functionType, getterType, objectType); }"
      },
      {
        "txt": "} } DelegateRelationship delegateRelationship = codingConvention.getDelegateRelationship(n); if (delegateRelationship != null) { applyDelegateRelationship(delegateRelationship); } ObjectLiteralCast objectLiteralCast = codingConvention.getObjectLiteralCast(t, n); if (objectLiteralCast != null) {"
      },
      {
        "txt": "ObjectType type = ObjectType.cast( typeRegistry.getType(objectLiteralCast.typeName)); if (type != null && type.getConstructor() != null) { setDeferredType(objectLiteralCast.objectNode, type); } else { compiler.report(JSError.make(t.getSourceName(), n, CONSTRUCTOR_EXPECTED)); } } }"
      },
      {
        "txt": "private void applyDelegateRelationship( DelegateRelationship delegateRelationship) { ObjectType delegatorObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegator)); ObjectType delegateBaseObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegateBase)); ObjectType delegateSuperObject = ObjectType.cast( typeRegistry.getType(codingConvention.getDelegateSuperclassName())); if (delegatorObject != null && delegateBaseObject != null &&"
      },
      {
        "txt": "delegateSuperObject != null) { FunctionType delegatorCtor = delegatorObject.getConstructor(); FunctionType delegateBaseCtor = delegateBaseObject.getConstructor(); FunctionType delegateSuperCtor = delegateSuperObject.getConstructor(); if (delegatorCtor != null && delegateBaseCtor != null && delegateSuperCtor != null) { FunctionParamBuilder functionParamBuilder = new FunctionParamBuilder(typeRegistry); functionParamBuilder.addRequiredParams( getNativeType(U2U_CONSTRUCTOR_TYPE));"
      },
      {
        "txt": "FunctionType findDelegate = typeRegistry.createFunctionType( typeRegistry.createDefaultObjectUnion(delegateBaseObject), functionParamBuilder.build()); FunctionType delegateProxy = typeRegistry.createConstructorType( delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX, null, null, null); delegateProxy.setPrototypeBasedOn(delegateBaseObject); codingConvention.applyDelegateRelationship( delegateSuperObject, delegateBaseObject, delegatorObject, delegateProxy, findDelegate);"
      },
      {
        "txt": "delegateProxyPrototypes.add(delegateProxy.getPrototype()); } } } void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString();"
      },
      {
        "txt": "Preconditions.checkArgument(qName != null && ownerName != null); if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { if (!qVar.isTypeInferred()) { return; } scope.undeclare(qVar); } }"
      },
      {
        "txt": "JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue); if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (valueType == null) { if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration( n, t.getInput() != null && t.getInput().isExtern(), ownerName));"
      },
      {
        "txt": "} return; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { inferred = !(rhsValue != null &&"
      },
      {
        "txt": "rhsValue.getType() == Token.FUNCTION && !scope.isDeclared(qName, false)); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput() != null && t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) ||"
      },
      {
        "txt": "!ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, isExtern); } } defineSlot(n, parent, valueType, inferred); } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType instanceof FunctionType) { JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();"
      },
      {
        "txt": "String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); } } }"
      },
      {
        "txt": "} private ObjectType getObjectSlot(String slotName) { Var ownerVar = scope.getVar(slotName); if (ownerVar != null) { JSType ownerVarType = ownerVar.getType(); return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()); } return null; }"
      },
      {
        "txt": "void resolveStubDeclarations() { for (StubDeclaration stub : stubDeclarations) { Node n = stub.node; Node parent = n.getParent(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); String ownerName = stub.ownerName; boolean isExtern = stub.isExtern; if (scope.isDeclared(qName, false)) { continue;"
      },
      {
        "txt": "} ObjectType ownerType = getObjectSlot(ownerName); ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE); defineSlot(n, parent, unknownType, true); if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) { ownerType.defineInferredProperty( propName, unknownType, isExtern); } else { typeRegistry.registerPropertyOnType("
      },
      {
        "txt": "propName, ownerType == null ? unknownType : ownerType); } } } private final class CollectProperties extends AbstractShallowStatementCallback { private final ObjectType thisType; CollectProperties(ObjectType thisType) { this.thisType = thisType; }"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.EXPR_RESULT) { Node child = n.getFirstChild(); switch (child.getType()) { case Token.ASSIGN: maybeCollectMember(t, child.getFirstChild(), child); break; case Token.GETPROP: maybeCollectMember(t, child, child); break;"
      },
      {
        "txt": "} } } private void maybeCollectMember(NodeTraversal t, Node member, Node nodeWithJsDocInfo) { JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo(); if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) { return;"
      },
      {
        "txt": "} member.getFirstChild().setJSType(thisType); JSType jsType = getDeclaredTypeInAnnotation(t, member, info); Node name = member.getLastChild(); if (jsType != null && (name.getType() == Token.NAME || name.getType() == Token.STRING)) { thisType.defineDeclaredProperty( name.getString(), jsType, false /* functions with implementations are not in externs */);"
      },
      {
        "txt": "} } } // end CollectProperties } private static final class StubDeclaration { private final Node node; private final boolean isExtern; private final String ownerName; private StubDeclaration(Node node, boolean isExtern, String ownerName) { this.node = node;"
      },
      {
        "txt": "this.isExtern = isExtern; this.ownerName = ownerName; } } private final class GlobalScopeBuilder extends AbstractScopeBuilder { private GlobalScopeBuilder(Scope scope) { super(scope); } @Override public void visit(NodeTraversal t, Node n, Node parent) { super.visit(t, n, parent);"
      },
      {
        "txt": "switch (n.getType()) { case Token.ASSIGN: checkForOldStyleTypedef(t, n); break; case Token.VAR: if (n.hasOneChild()) { checkForOldStyleTypedef(t, n); checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo()); } break;"
      },
      {
        "txt": "} } @Override void maybeDeclareQualifiedName( NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { checkForTypedef(t, n, info); super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue); } private void checkForTypedef("
      },
      {
        "txt": "NodeTraversal t, Node candidate, JSDocInfo info) { if (info == null || !info.hasTypedefType()) { return; } String typedef = candidate.getQualifiedName(); if (typedef == null) { return; } typeRegistry.forwardDeclareType(typedef); JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);"
      },
      {
        "txt": "if (realType == null) { compiler.report( JSError.make( t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); if (candidate.getType() == Token.GETPROP) { defineSlot(candidate, candidate.getParent(), getNativeType(NO_TYPE), false); }"
      },
      {
        "txt": "} private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) { String typedef = codingConvention.identifyTypeDefAssign(candidate); if (typedef != null) { typeRegistry.forwardDeclareType(typedef); JSDocInfo info = candidate.getJSDocInfo(); JSType realType = null; if (info != null && info.getType() != null) { realType = info.getType().evaluate(scope, typeRegistry); }"
      },
      {
        "txt": "if (realType == null) { compiler.report( JSError.make( t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); } } } // end GlobalScopeBuilder private final class LocalScopeBuilder extends AbstractScopeBuilder {"
      },
      {
        "txt": "private LocalScopeBuilder(Scope scope) { super(scope); } void build() { NodeTraversal.traverse(compiler, scope.getRootNode(), this); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent);"
      },
      {
        "txt": "return; } super.visit(t, n, parent); } private void handleFunctionInputs(Node fnNode) { Node fnNameNode = fnNode.getFirstChild(); String fnName = fnNameNode.getString(); if (!fnName.isEmpty()) { Scope.Var fnVar = scope.getVar(fnName); if (fnVar == null ||"
      },
      {
        "txt": "(fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false); } } declareArguments(fnNode); } private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext();"
      },
      {
        "txt": "FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext();"
      },
      {
        "txt": "} else { defineSlot(astParameter, functionNode, null, true); } } } } } // end declareArguments } // end LocalScopeBuilder"
      }
    ]
  },
  {
    "id": 412,
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
    "start-bug-line": 902,
    "end-bug-line": 902,
    "bug": "",
    "fix": "if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP; import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT; import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CodingConvention.DelegateRelationship; import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.CodingConvention.SubclassType; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionParamBuilder;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import javax.annotation.Nullable; final class TypedScopeCreator implements ScopeCreator { static final String DELEGATE_PROXY_SUFFIX = \"(Proxy)\";"
      },
      {
        "txt": "static final DiagnosticType MALFORMED_TYPEDEF = DiagnosticType.warning( \"JSC_MALFORMED_TYPEDEF\", \"Typedef for {0} does not have any type information\"); static final DiagnosticType ENUM_INITIALIZER = DiagnosticType.warning( \"JSC_ENUM_INITIALIZER_NOT_ENUM\", \"enum initializer must be an object literal or an enum\"); static final DiagnosticType CONSTRUCTOR_EXPECTED = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_REFLECT_CONSTRUCTOR_EXPECTED\", \"Constructor expected as first argument\"); private final AbstractCompiler compiler; private final ErrorReporter typeParsingErrorReporter; private final TypeValidator validator; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList(); private class DeferredSetType { final Node node;"
      },
      {
        "txt": "final JSType type; DeferredSetType(Node node, JSType type) { Preconditions.checkNotNull(node); Preconditions.checkNotNull(type); this.node = node; this.type = type; node.setJSType(type); } void resolve(Scope scope) { node.setJSType(type.resolve(typeParsingErrorReporter, scope));"
      },
      {
        "txt": "} } TypedScopeCreator(AbstractCompiler compiler) { this(compiler, compiler.getCodingConvention()); } TypedScopeCreator(AbstractCompiler compiler, CodingConvention codingConvention) { this.compiler = compiler; this.validator = compiler.getTypeValidator(); this.codingConvention = codingConvention;"
      },
      {
        "txt": "this.typeRegistry = compiler.getTypeRegistry(); this.typeParsingErrorReporter = typeRegistry.getErrorReporter(); } public Scope createScope(Node root, Scope parent) { Scope newScope = null; AbstractScopeBuilder scopeBuilder = null; if (parent == null) { newScope = createInitialScope(root); GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope); scopeBuilder = globalScopeBuilder;"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, scopeBuilder); } else { newScope = new Scope(parent, root); LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope); scopeBuilder = localScopeBuilder; localScopeBuilder.build(); } scopeBuilder.resolveStubDeclarations(); scopeBuilder.resolveTypes(); for (Node functionNode : scopeBuilder.nonExternFunctions) {"
      },
      {
        "txt": "JSType type = functionNode.getJSType(); if (type != null && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; ObjectType fnThisType = fnType.getTypeOfThis(); if (!fnThisType.isUnknownType()) { NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType)); } } }"
      },
      {
        "txt": "if (parent == null) { codingConvention.defineDelegateProxyPrototypeProperties( typeRegistry, newScope, delegateProxyPrototypes); } return newScope; } @VisibleForTesting Scope createInitialScope(Node root) { NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry)); Scope s = new Scope(root, compiler);"
      },
      {
        "txt": "declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE); declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, DATE_FUNCTION_TYPE); declareNativeFunctionType(s, ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE); declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE); declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE); declareNativeValueType(s, \"undefined\", VOID_TYPE); declareNativeValueType(s, \"goog.typedef\", NO_TYPE); declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE); return s; }"
      },
      {
        "txt": "private void declareNativeFunctionType(Scope scope, JSTypeNative tId) { FunctionType t = typeRegistry.getNativeFunctionType(tId); declareNativeType(scope, t.getInstanceType().getReferenceName(), t); declareNativeType( scope, t.getPrototype().getReferenceName(), t.getPrototype()); } private void declareNativeValueType(Scope scope, String name, JSTypeNative tId) { declareNativeType(scope, name, typeRegistry.getNativeType(tId)); }"
      },
      {
        "txt": "private void declareNativeType(Scope scope, String name, JSType t) { scope.declare(name, null, t, null, false); } private static class DiscoverEnums extends AbstractShallowStatementCallback { private final JSTypeRegistry registry; DiscoverEnums(JSTypeRegistry registry) { this.registry = registry; } @Override public void visit(NodeTraversal t, Node node, Node parent) {"
      },
      {
        "txt": "Node nameNode = null; switch (node.getType()) { case Token.VAR: for (Node child = node.getFirstChild(); child != null; child = child.getNext()) { identifyEnumInNameNode( child, NodeUtil.getInfoForNameNode(child)); } break; case Token.EXPR_RESULT:"
      },
      {
        "txt": "Node maybeAssign = node.getFirstChild(); if (maybeAssign.getType() == Token.ASSIGN) { identifyEnumInNameNode( maybeAssign.getFirstChild(), maybeAssign.getJSDocInfo()); } break; } } private void identifyEnumInNameNode(Node nameNode, JSDocInfo info) { if (info != null && info.hasEnumParameterType()) {"
      },
      {
        "txt": "registry.identifyEnumName(nameNode.getQualifiedName()); } } } private static Node getPrototypePropertyOwner(Node n) { if (n.getType() == Token.GETPROP) { Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.getLastChild().getString().equals(\"prototype\")) { Node maybeOwner = firstChild.getFirstChild();"
      },
      {
        "txt": "if (maybeOwner.isQualifiedName()) { return maybeOwner; } } } return null; } private void attachLiteralTypes(Node n) { switch (n.getType()) { case Token.NULL:"
      },
      {
        "txt": "n.setJSType(getNativeType(NULL_TYPE)); break; case Token.VOID: n.setJSType(getNativeType(VOID_TYPE)); break; case Token.STRING: n.setJSType(getNativeType(STRING_TYPE)); break; case Token.NUMBER: n.setJSType(getNativeType(NUMBER_TYPE));"
      },
      {
        "txt": "break; case Token.TRUE: case Token.FALSE: n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.REGEXP: n.setJSType(getNativeType(REGEXP_TYPE)); break; case Token.REF_SPECIAL: n.setJSType(getNativeType(UNKNOWN_TYPE));"
      },
      {
        "txt": "break; case Token.OBJECTLIT: if (n.getJSType() == null) { n.setJSType(typeRegistry.createAnonymousObjectType()); } break; } } private JSType getNativeType(JSTypeNative nativeType) { return typeRegistry.getNativeType(nativeType);"
      },
      {
        "txt": "} private abstract class AbstractScopeBuilder implements NodeTraversal.Callback { final Scope scope; private final List<DeferredSetType> deferredSetTypes = Lists.newArrayList(); private final List<Node> nonExternFunctions = Lists.newArrayList(); private final List<StubDeclaration> stubDeclarations = Lists.newArrayList(); private String sourceName = null;"
      },
      {
        "txt": "private AbstractScopeBuilder(Scope scope) { this.scope = scope; } void setDeferredType(Node node, JSType type) { deferredSetTypes.add(new DeferredSetType(node, type)); } void resolveTypes() { for (DeferredSetType deferred : deferredSetTypes) { deferred.resolve(scope); }"
      },
      {
        "txt": "Iterator<Var> vars = scope.getVars(); while (vars.hasNext()) { vars.next().resolveType(typeParsingErrorReporter); } typeRegistry.resolveTypesInScope(scope); } @Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (n.getType() == Token.FUNCTION ||"
      },
      {
        "txt": "n.getType() == Token.SCRIPT) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); } return parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild() || parent == scope.getRootNode(); } @Override public void visit(NodeTraversal t, Node n, Node parent) { attachLiteralTypes(n); switch (n.getType()) {"
      },
      {
        "txt": "case Token.CALL: checkForClassDefiningCalls(t, n, parent); break; case Token.FUNCTION: if (t.getInput() == null || !t.getInput().isExtern()) { nonExternFunctions.add(n); } if (parent.getType() != Token.ASSIGN && parent.getType() != Token.NAME) { defineDeclaredFunction(n, parent);"
      },
      {
        "txt": "} break; case Token.ASSIGN: defineNamedTypeAssign(n, parent); Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext()); }"
      },
      {
        "txt": "break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; case Token.GETPROP: if (parent.getType() == Token.EXPR_RESULT && n.isQualifiedName()) {"
      },
      {
        "txt": "maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); } break; } } JSType getDeclaredTypeInAnnotation( NodeTraversal t, Node node, JSDocInfo info) { return getDeclaredTypeInAnnotation(t.getSourceName(), node, info); } JSType getDeclaredTypeInAnnotation(String sourceName,"
      },
      {
        "txt": "Node node, JSDocInfo info) { JSType jsType = null; Node objNode = node.getType() == Token.GETPROP ? node.getFirstChild() : null; if (info != null) { if (info.hasType()) { jsType = info.getType().evaluate(scope, typeRegistry); } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { String fnName = node.getQualifiedName(); if (info.isConstructor() && typeRegistry.getType(fnName) != null) {"
      },
      {
        "txt": "return null; } FunctionTypeBuilder builder = new FunctionTypeBuilder( fnName, compiler, node, sourceName, scope) .inferTemplateTypeName(info) .inferReturnType(info) .inferParameterTypes(info) .inferInheritance(info); boolean searchedForThisType = false;"
      },
      {
        "txt": "if (objNode != null) { if (objNode.getType() == Token.GETPROP && objNode.getLastChild().getString().equals(\"prototype\")) { builder.inferThisType(info, objNode.getFirstChild()); searchedForThisType = true; } else if (objNode.getType() == Token.THIS) { builder.inferThisType(info, objNode.getJSType()); searchedForThisType = true; } }"
      },
      {
        "txt": "if (!searchedForThisType) { builder.inferThisType(info, (Node) null); } jsType = builder.buildAndRegister(); } } return jsType; } void assertDefinitionNode(Node n, int type) { Preconditions.checkState(sourceName != null);"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == type); } void defineCatch(Node n, Node parent) { assertDefinitionNode(n, Token.CATCH); Node catchName = n.getFirstChild(); defineSlot(catchName, n, null); } void defineVar(Node n, Node parent) { assertDefinitionNode(n, Token.VAR); JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (n.hasMoreThanOneChild()) { if (info != null) { compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF)); } for (Node name : n.children()) { defineName(name, n, parent, name.getJSDocInfo()); } } else { Node name = n.getFirstChild(); defineName(name, n, parent,"
      },
      {
        "txt": "(info != null) ? info : name.getJSDocInfo()); } } void defineDeclaredFunction(Node n, Node parent) { assertDefinitionNode(n, Token.FUNCTION); JSDocInfo info = n.getJSDocInfo(); int parentType = parent.getType(); Preconditions.checkState( (scope.isLocal() || parentType != Token.ASSIGN) && parentType != Token.NAME,"
      },
      {
        "txt": "\"function defined as standalone function when it is being \" + \"assigned\"); String functionName = n.getFirstChild().getString(); FunctionType functionType = getFunctionType(functionName, n, info, null); if (NodeUtil.isFunctionDeclaration(n)) { defineSlot(n.getFirstChild(), n, functionType); } } void defineNamedTypeAssign(Node n, Node parent) {"
      },
      {
        "txt": "assertDefinitionNode(n, Token.ASSIGN); JSDocInfo info = n.getJSDocInfo(); Node rvalue = n.getLastChild(); Node lvalue = n.getFirstChild(); info = (info != null) ? info : rvalue.getJSDocInfo(); if (rvalue.getType() == Token.FUNCTION || info != null && info.isConstructor()) { getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue); } else if (info != null && info.hasEnumParameterType()) {"
      },
      {
        "txt": "JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry)); if (type != null) { setDeferredType(lvalue, type); } } } private void defineName(Node name, Node var, Node parent, JSDocInfo info) { Node value = name.getFirstChild(); if (value != null && value.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "String functionName = name.getString(); FunctionType functionType = getFunctionType(functionName, value, info, null); if (functionType.isReturnTypeInferred() && scope.isLocal()) { defineSlot(name, var, null); } else { defineSlot(name, var, functionType); } } else {"
      },
      {
        "txt": "JSType type = null; if (info == null) { CompilerInput input = compiler.getInput(sourceName); Preconditions.checkNotNull(input, sourceName); type = input.isExtern() ? getNativeType(UNKNOWN_TYPE) : null; } else if (info.hasEnumParameterType()) { type = getEnumType(name.getString(), var, value, info.getEnumParameterType().evaluate(scope, typeRegistry)); } else if (info.isConstructor()) {"
      },
      {
        "txt": "type = getFunctionType(name.getString(), value, info, name); } else { type = getDeclaredTypeInAnnotation(sourceName, name, info); } defineSlot(name, var, type); } } private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) { FunctionType functionType = null;"
      },
      {
        "txt": "if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) { Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() instanceof FunctionType) { functionType = (FunctionType) var.getType(); if (functionType != null && functionType.isConstructor()) { typeRegistry.declareType(name, functionType.getInstanceType()); } } return functionType; }"
      },
      {
        "txt": "Node owner = null; if (lvalueNode != null) { owner = getPrototypePropertyOwner(lvalueNode); } Node errorRoot = rValue == null ? lvalueNode : rValue; boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION; Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;"
      },
      {
        "txt": "Node fnBlock = isFnLiteral ? parametersNode.getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry); type = type.restrictByNotNullOrUndefined(); if (type.isFunctionType()) { functionType = (FunctionType) type; functionType.setJSDocInfo(info); } } if (functionType == null) {"
      },
      {
        "txt": "FunctionType overriddenPropType = null; if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) { Var var = scope.getVar( lvalueNode.getFirstChild().getQualifiedName()); if (var != null) { ObjectType ownerType = ObjectType.cast(var.getType()); if (ownerType != null) { String propName = lvalueNode.getLastChild().getString(); overriddenPropType = findOverriddenFunction(ownerType, propName);"
      },
      {
        "txt": "} } } functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferFromOverriddenFunction(overriddenPropType, parametersNode) .inferTemplateTypeName(info) .inferReturnType(info)"
      },
      {
        "txt": ".inferInheritance(info) .inferThisType(info, owner) .inferParameterTypes(parametersNode, info) .inferReturnStatementsAsLastResort(fnBlock) .buildAndRegister(); } if (rValue != null) { setDeferredType(rValue, functionType); } return functionType;"
      },
      {
        "txt": "} private FunctionType findOverriddenFunction( ObjectType ownerType, String propName) { JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName);"
      },
      {
        "txt": "if (propType instanceof FunctionType) { return (FunctionType) propType; } } } return null; } private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) { EnumType enumType = null;"
      },
      {
        "txt": "if (value != null) { if (value.getType() == Token.OBJECTLIT) { enumType = typeRegistry.createEnumType(name, elementsType); Node key = value.getFirstChild(); while (key != null) { String keyName = NodeUtil.getStringValue(key); if (enumType.hasOwnProperty(keyName)) { compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName)); } else if (!codingConvention.isValidEnumKey(keyName)) { compiler.report("
      },
      {
        "txt": "JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else { enumType.defineElement(keyName); } key = key.getNext(); key = (key == null) ? null : key.getNext(); } } else if (value.isQualifiedName()) { Var var = scope.getVar(value.getQualifiedName()); if (var != null && var.getType() instanceof EnumType) {"
      },
      {
        "txt": "enumType = (EnumType) var.getType(); } } } if (enumType == null) { compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER)); } else if (scope.isGlobal()) { if (name != null && !name.isEmpty()) { typeRegistry.declareType(name, enumType.getElementsType()); }"
      },
      {
        "txt": "} return enumType; } private void defineSlot(Node name, Node parent, JSType type) { defineSlot(name, parent, type, type == null); } void defineSlot(Node n, Node parent, JSType type, boolean inferred) { Preconditions.checkArgument(inferred || type != null); boolean shouldDeclareOnGlobalThis = false; if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "Preconditions.checkArgument( parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH); shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION); } else { Preconditions.checkArgument("
      },
      {
        "txt": "(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT)); } String variableName = n.getQualifiedName(); Preconditions.checkArgument(!variableName.isEmpty()); Scope scopeToDeclareIn = scope; <extra_id_0> if (scopeToDeclareIn.isDeclared(variableName, false)) { Var oldVar = scopeToDeclareIn.getVar(variableName); validator.expectUndeclaredVariable( sourceName, n, parent, oldVar, variableName, type); } else { if (!inferred) {"
      },
      {
        "txt": "} else { if (!inferred) { setDeferredType(n, type); } CompilerInput input = compiler.getInput(sourceName); scopeToDeclareIn.declare(variableName, n, type, input, inferred); if (shouldDeclareOnGlobalThis) { ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS); boolean isExtern = input.isExtern();"
      },
      {
        "txt": "if (inferred) { globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern); } else { globalThis.defineDeclaredProperty(variableName, type, isExtern); } }"
      },
      {
        "txt": "if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; if (fnType.isConstructor() || fnType.isInterface()) { FunctionType superClassCtor = fnType.getSuperClassConstructor(); scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null || superClassCtor.getInstanceType().equals( getNativeType(OBJECT_TYPE))); }"
      },
      {
        "txt": "} } } private boolean isQnameRootedInGlobalScope(Node n) { Node root = NodeUtil.getRootOfQualifiedName(n); if (root.getType() == Token.NAME) { Var var = scope.getVar(root.getString()); if (var != null) { return var.isGlobal(); }"
      },
      {
        "txt": "} return false; } private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, Node rhsValue) { if (info != null && info.hasType()) { return getDeclaredTypeInAnnotation(t, n, info); } else if (info != null && info.hasEnumParameterType()) { return n.getJSType(); } else if (rhsValue != null &&"
      },
      {
        "txt": "rhsValue.getType() == Token.FUNCTION) { return rhsValue.getJSType(); } else { return getDeclaredTypeInAnnotation(t, n, info); } } private void checkForClassDefiningCalls( NodeTraversal t, Node n, Node parent) { SubclassRelationship relationship = codingConvention.getClassesDefinedByCall(n);"
      },
      {
        "txt": "if (relationship != null) { ObjectType superClass = ObjectType.cast( typeRegistry.getType(relationship.superclassName)); ObjectType subClass = ObjectType.cast( typeRegistry.getType(relationship.subclassName)); if (superClass != null && subClass != null) { FunctionType superCtor = superClass.getConstructor(); FunctionType subCtor = subClass.getConstructor(); if (relationship.type == SubclassType.INHERITS) { validator.expectSuperType(t, n, superClass, subClass);"
      },
      {
        "txt": "} if (superCtor != null && subCtor != null) { codingConvention.applySubclassRelationship( superCtor, subCtor, relationship.type); } } } String singletonGetterClassName = codingConvention.getSingletonGetterClassName(n); if (singletonGetterClassName != null) {"
      },
      {
        "txt": "ObjectType objectType = ObjectType.cast( typeRegistry.getType(singletonGetterClassName)); if (objectType != null) { FunctionType functionType = objectType.getConstructor(); if (functionType != null) { FunctionType getterType = typeRegistry.createFunctionType(objectType); codingConvention.applySingletonGetter(functionType, getterType, objectType); }"
      },
      {
        "txt": "} } DelegateRelationship delegateRelationship = codingConvention.getDelegateRelationship(n); if (delegateRelationship != null) { applyDelegateRelationship(delegateRelationship); } ObjectLiteralCast objectLiteralCast = codingConvention.getObjectLiteralCast(t, n); if (objectLiteralCast != null) {"
      },
      {
        "txt": "ObjectType type = ObjectType.cast( typeRegistry.getType(objectLiteralCast.typeName)); if (type != null && type.getConstructor() != null) { setDeferredType(objectLiteralCast.objectNode, type); } else { compiler.report(JSError.make(t.getSourceName(), n, CONSTRUCTOR_EXPECTED)); } } }"
      },
      {
        "txt": "private void applyDelegateRelationship( DelegateRelationship delegateRelationship) { ObjectType delegatorObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegator)); ObjectType delegateBaseObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegateBase)); ObjectType delegateSuperObject = ObjectType.cast( typeRegistry.getType(codingConvention.getDelegateSuperclassName())); if (delegatorObject != null && delegateBaseObject != null &&"
      },
      {
        "txt": "delegateSuperObject != null) { FunctionType delegatorCtor = delegatorObject.getConstructor(); FunctionType delegateBaseCtor = delegateBaseObject.getConstructor(); FunctionType delegateSuperCtor = delegateSuperObject.getConstructor(); if (delegatorCtor != null && delegateBaseCtor != null && delegateSuperCtor != null) { FunctionParamBuilder functionParamBuilder = new FunctionParamBuilder(typeRegistry); functionParamBuilder.addRequiredParams( getNativeType(U2U_CONSTRUCTOR_TYPE));"
      },
      {
        "txt": "FunctionType findDelegate = typeRegistry.createFunctionType( typeRegistry.createDefaultObjectUnion(delegateBaseObject), functionParamBuilder.build()); FunctionType delegateProxy = typeRegistry.createConstructorType( delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX, null, null, null); delegateProxy.setPrototypeBasedOn(delegateBaseObject); codingConvention.applyDelegateRelationship( delegateSuperObject, delegateBaseObject, delegatorObject, delegateProxy, findDelegate);"
      },
      {
        "txt": "delegateProxyPrototypes.add(delegateProxy.getPrototype()); } } } void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString();"
      },
      {
        "txt": "Preconditions.checkArgument(qName != null && ownerName != null); if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { if (!qVar.isTypeInferred()) { return; } scope.undeclare(qVar); } }"
      },
      {
        "txt": "JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue); if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (valueType == null) { if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration( n, t.getInput() != null && t.getInput().isExtern(), ownerName));"
      },
      {
        "txt": "} return; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { inferred = !(rhsValue != null &&"
      },
      {
        "txt": "rhsValue.getType() == Token.FUNCTION && !scope.isDeclared(qName, false)); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput() != null && t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) ||"
      },
      {
        "txt": "!ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, isExtern); } } defineSlot(n, parent, valueType, inferred); } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType instanceof FunctionType) { JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();"
      },
      {
        "txt": "String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); } } }"
      },
      {
        "txt": "} private ObjectType getObjectSlot(String slotName) { Var ownerVar = scope.getVar(slotName); if (ownerVar != null) { JSType ownerVarType = ownerVar.getType(); return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()); } return null; }"
      },
      {
        "txt": "void resolveStubDeclarations() { for (StubDeclaration stub : stubDeclarations) { Node n = stub.node; Node parent = n.getParent(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); String ownerName = stub.ownerName; boolean isExtern = stub.isExtern; if (scope.isDeclared(qName, false)) { continue;"
      },
      {
        "txt": "} ObjectType ownerType = getObjectSlot(ownerName); ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE); defineSlot(n, parent, unknownType, true); if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) { ownerType.defineInferredProperty( propName, unknownType, isExtern); } else { typeRegistry.registerPropertyOnType("
      },
      {
        "txt": "propName, ownerType == null ? unknownType : ownerType); } } } private final class CollectProperties extends AbstractShallowStatementCallback { private final ObjectType thisType; CollectProperties(ObjectType thisType) { this.thisType = thisType; }"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.EXPR_RESULT) { Node child = n.getFirstChild(); switch (child.getType()) { case Token.ASSIGN: maybeCollectMember(t, child.getFirstChild(), child); break; case Token.GETPROP: maybeCollectMember(t, child, child); break;"
      },
      {
        "txt": "} } } private void maybeCollectMember(NodeTraversal t, Node member, Node nodeWithJsDocInfo) { JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo(); if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) { return;"
      },
      {
        "txt": "} member.getFirstChild().setJSType(thisType); JSType jsType = getDeclaredTypeInAnnotation(t, member, info); Node name = member.getLastChild(); if (jsType != null && (name.getType() == Token.NAME || name.getType() == Token.STRING)) { thisType.defineDeclaredProperty( name.getString(), jsType, false /* functions with implementations are not in externs */);"
      },
      {
        "txt": "} } } // end CollectProperties } private static final class StubDeclaration { private final Node node; private final boolean isExtern; private final String ownerName; private StubDeclaration(Node node, boolean isExtern, String ownerName) { this.node = node;"
      },
      {
        "txt": "this.isExtern = isExtern; this.ownerName = ownerName; } } private final class GlobalScopeBuilder extends AbstractScopeBuilder { private GlobalScopeBuilder(Scope scope) { super(scope); } @Override public void visit(NodeTraversal t, Node n, Node parent) { super.visit(t, n, parent);"
      },
      {
        "txt": "switch (n.getType()) { case Token.ASSIGN: checkForOldStyleTypedef(t, n); break; case Token.VAR: if (n.hasOneChild()) { checkForOldStyleTypedef(t, n); checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo()); } break;"
      },
      {
        "txt": "} } @Override void maybeDeclareQualifiedName( NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { checkForTypedef(t, n, info); super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue); } private void checkForTypedef("
      },
      {
        "txt": "NodeTraversal t, Node candidate, JSDocInfo info) { if (info == null || !info.hasTypedefType()) { return; } String typedef = candidate.getQualifiedName(); if (typedef == null) { return; } typeRegistry.forwardDeclareType(typedef); JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);"
      },
      {
        "txt": "if (realType == null) { compiler.report( JSError.make( t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); if (candidate.getType() == Token.GETPROP) { defineSlot(candidate, candidate.getParent(), getNativeType(NO_TYPE), false); }"
      },
      {
        "txt": "} private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) { String typedef = codingConvention.identifyTypeDefAssign(candidate); if (typedef != null) { typeRegistry.forwardDeclareType(typedef); JSDocInfo info = candidate.getJSDocInfo(); JSType realType = null; if (info != null && info.getType() != null) { realType = info.getType().evaluate(scope, typeRegistry); }"
      },
      {
        "txt": "if (realType == null) { compiler.report( JSError.make( t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); } } } // end GlobalScopeBuilder private final class LocalScopeBuilder extends AbstractScopeBuilder {"
      },
      {
        "txt": "private LocalScopeBuilder(Scope scope) { super(scope); } void build() { NodeTraversal.traverse(compiler, scope.getRootNode(), this); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent);"
      },
      {
        "txt": "return; } super.visit(t, n, parent); } private void handleFunctionInputs(Node fnNode) { Node fnNameNode = fnNode.getFirstChild(); String fnName = fnNameNode.getString(); if (!fnName.isEmpty()) { Scope.Var fnVar = scope.getVar(fnName); if (fnVar == null ||"
      },
      {
        "txt": "(fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false); } } declareArguments(fnNode); } private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext();"
      },
      {
        "txt": "FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext();"
      },
      {
        "txt": "} else { defineSlot(astParameter, functionNode, null, true); } } } } } // end declareArguments } // end LocalScopeBuilder"
      }
    ]
  }
]