[
  {
    "id": 776,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 201,
    "end-bug-line": 203,
    "bug": "private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule;"
      },
      {
        "txt": "private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler,"
      },
      {
        "txt": "JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null;"
      },
      {
        "txt": "} globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else {"
      },
      {
        "txt": "for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot,"
      },
      {
        "txt": "new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values());"
      },
      {
        "txt": "result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name);"
      },
      {
        "txt": "symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); <extra_id_0> @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t,"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty("
      },
      {
        "txt": "key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); }"
      },
      {
        "txt": "} } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {"
      },
      {
        "txt": "return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove();"
      },
      {
        "txt": "JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {"
      },
      {
        "txt": "Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {"
      },
      {
        "txt": "NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol {"
      },
      {
        "txt": "Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value;"
      },
      {
        "txt": "this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name;"
      },
      {
        "txt": "private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced;"
      },
      {
        "txt": "} boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; }"
      },
      {
        "txt": "if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) {"
      },
      {
        "txt": "hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 777,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 206,
    "end-bug-line": 206,
    "bug": "symbolStack.peek().scope = t.getScope();",
    "fix": "Node n = t.getCurrentNode(); if (n.isFunction()) { String propName = getPrototypePropertyNameFromRValue(n); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), t.getScope())); } else if (isGlobalFunctionDeclaration(t, n)) { Node parent = n.getParent(); String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push( new NameContext(getNameInfoForName(name, VAR), t.getScope())); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR;"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\");"
      },
      {
        "txt": "private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns;"
      },
      {
        "txt": "this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode);"
      },
      {
        "txt": "for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } }"
      },
      {
        "txt": "} @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences());"
      },
      {
        "txt": "t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ?"
      },
      {
        "txt": "propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } }"
      },
      {
        "txt": "private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { <extra_id_0> } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));"
      },
      {
        "txt": "} else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) {"
      },
      {
        "txt": "processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals("
      },
      {
        "txt": "\"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name);"
      },
      {
        "txt": "if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else {"
      },
      {
        "txt": "addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true;"
      },
      {
        "txt": "} } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } }"
      },
      {
        "txt": "private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) {"
      },
      {
        "txt": "symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) {"
      },
      {
        "txt": "Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) {"
      },
      {
        "txt": "return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION."
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); }"
      },
      {
        "txt": "return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent();"
      },
      {
        "txt": "if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break;"
      },
      {
        "txt": "case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } }"
      },
      {
        "txt": "private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences"
      },
      {
        "txt": "implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge);"
      },
      {
        "txt": "} } return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType {"
      },
      {
        "txt": "PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent));"
      },
      {
        "txt": "this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar());"
      },
      {
        "txt": "parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) {"
      },
      {
        "txt": "return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); }"
      },
      {
        "txt": "static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() {"
      },
      {
        "txt": "return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value;"
      },
      {
        "txt": "private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name;"
      },
      {
        "txt": "Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null;"
      },
      {
        "txt": "private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables;"
      },
      {
        "txt": "} boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) {"
      },
      {
        "txt": "deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } }"
      },
      {
        "txt": "return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 778,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 212,
    "end-bug-line": 212,
    "bug": "",
    "fix": "symbolStack.push(new NameContext(anonymousNode, t.getScope())); } } else { Preconditions.checkState(t.inGlobalScope()); symbolStack.push(new NameContext(globalNode, t.getScope())); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\");"
      },
      {
        "txt": "private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars;"
      },
      {
        "txt": "if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) {"
      },
      {
        "txt": "NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } }"
      },
      {
        "txt": "@Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph,"
      },
      {
        "txt": "Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo;"
      },
      {
        "txt": "if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); <extra_id_0> @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) {"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent);"
      },
      {
        "txt": "} else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {"
      },
      {
        "txt": "for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) {"
      },
      {
        "txt": "if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN:"
      },
      {
        "txt": "Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "} break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> {"
      },
      {
        "txt": "@Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); }"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY,"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild();"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map;"
      },
      {
        "txt": "private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope;"
      },
      {
        "txt": "NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false;"
      },
      {
        "txt": "NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; }"
      },
      {
        "txt": "boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module;"
      },
      {
        "txt": "} else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged;"
      },
      {
        "txt": "} JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 779,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 216,
    "end-bug-line": 216,
    "bug": "",
    "fix": "symbolStack.pop();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph;"
      },
      {
        "txt": "private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else {"
      },
      {
        "txt": "firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo);"
      },
      {
        "txt": "} else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() {"
      },
      {
        "txt": "List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else {"
      },
      {
        "txt": "NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode));"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { <extra_id_0> @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) {"
      },
      {
        "txt": "n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else {"
      },
      {
        "txt": "addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) {"
      },
      {
        "txt": "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {"
      },
      {
        "txt": "if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){"
      },
      {
        "txt": "for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } }"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {"
      },
      {
        "txt": "return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {"
      },
      {
        "txt": "boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } }"
      },
      {
        "txt": "return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString();"
      },
      {
        "txt": "getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; }"
      },
      {
        "txt": "private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString();"
      },
      {
        "txt": "Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild();"
      },
      {
        "txt": "key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; }"
      },
      {
        "txt": "} private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) {"
      },
      {
        "txt": "JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; }"
      },
      {
        "txt": "} interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol {"
      },
      {
        "txt": "private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); }"
      },
      {
        "txt": "} } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) {"
      },
      {
        "txt": "this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign,"
      },
      {
        "txt": "JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; }"
      },
      {
        "txt": "} class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; }"
      },
      {
        "txt": "@Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) {"
      },
      {
        "txt": "referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive("
      },
      {
        "txt": "deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef;"
      },
      {
        "txt": "} Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 780,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 221,
    "end-bug-line": 230,
    "bug": "if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode));",
    "fix": "String propName = processNonFunctionPrototypeAssign(n, parent); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), null));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack;"
      },
      {
        "txt": "class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\");"
      },
      {
        "txt": "private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) {"
      },
      {
        "txt": "this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null);"
      },
      {
        "txt": "externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo);"
      },
      {
        "txt": "} } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); }"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result;"
      },
      {
        "txt": "} private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo);"
      },
      {
        "txt": "return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { <extra_id_0> } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent,"
      },
      {
        "txt": "parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i);"
      },
      {
        "txt": "if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) ||"
      },
      {
        "txt": "n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) {"
      },
      {
        "txt": "break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) ||"
      },
      {
        "txt": "n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp();"
      },
      {
        "txt": "if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; }"
      },
      {
        "txt": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule()));"
      },
      {
        "txt": "if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString();"
      },
      {
        "txt": "Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module,"
      },
      {
        "txt": "SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY));"
      },
      {
        "txt": "} } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null &&"
      },
      {
        "txt": "moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol {"
      },
      {
        "txt": "void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module;"
      },
      {
        "txt": "GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } }"
      },
      {
        "txt": "interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key;"
      },
      {
        "txt": "this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo {"
      },
      {
        "txt": "final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() {"
      },
      {
        "txt": "return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true;"
      },
      {
        "txt": "} if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); }"
      },
      {
        "txt": "if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() {"
      },
      {
        "txt": "return declarations; } }"
      }
    ]
  },
  {
    "id": 781,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 240,
    "end-bug-line": 240,
    "bug": "",
    "fix": "if (n.isQualifiedName()) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph;"
      },
      {
        "txt": "private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else {"
      },
      {
        "txt": "firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo);"
      },
      {
        "txt": "} else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() {"
      },
      {
        "txt": "List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else {"
      },
      {
        "txt": "NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode));"
      },
      {
        "txt": "} @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode));"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); <extra_id_0> processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); }"
      },
      {
        "txt": "addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) {"
      },
      {
        "txt": "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {"
      },
      {
        "txt": "if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){"
      },
      {
        "txt": "for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } }"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {"
      },
      {
        "txt": "return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {"
      },
      {
        "txt": "boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } }"
      },
      {
        "txt": "return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString();"
      },
      {
        "txt": "getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; }"
      },
      {
        "txt": "private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString();"
      },
      {
        "txt": "Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild();"
      },
      {
        "txt": "key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; }"
      },
      {
        "txt": "} private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) {"
      },
      {
        "txt": "JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; }"
      },
      {
        "txt": "} interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol {"
      },
      {
        "txt": "private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); }"
      },
      {
        "txt": "} } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) {"
      },
      {
        "txt": "this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign,"
      },
      {
        "txt": "JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; }"
      },
      {
        "txt": "} class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; }"
      },
      {
        "txt": "@Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) {"
      },
      {
        "txt": "referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive("
      },
      {
        "txt": "deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef;"
      },
      {
        "txt": "} Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 782,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 241,
    "end-bug-line": 241,
    "bug": "processPrototypeParent(t, parent);",
    "fix": "if (processPrototypeRef(t, n)) { return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule;"
      },
      {
        "txt": "private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler,"
      },
      {
        "txt": "JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null;"
      },
      {
        "txt": "} globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else {"
      },
      {
        "txt": "for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot,"
      },
      {
        "txt": "new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values());"
      },
      {
        "txt": "result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name);"
      },
      {
        "txt": "map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); }"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { <extra_id_0> } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "} } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) {"
      },
      {
        "txt": "if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) ||"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name;"
      },
      {
        "txt": "if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() &&"
      },
      {
        "txt": "(NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty ="
      },
      {
        "txt": "n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false;"
      },
      {
        "txt": "} private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add("
      },
      {
        "txt": "new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty("
      },
      {
        "txt": "grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {"
      },
      {
        "txt": "String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } }"
      },
      {
        "txt": "private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule,"
      },
      {
        "txt": "getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef();"
      },
      {
        "txt": "if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } }"
      },
      {
        "txt": "interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode;"
      },
      {
        "txt": "private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } }"
      },
      {
        "txt": "} interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) {"
      },
      {
        "txt": "this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } }"
      },
      {
        "txt": "class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; }"
      },
      {
        "txt": "boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true;"
      },
      {
        "txt": "hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module);"
      },
      {
        "txt": "} if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; }"
      },
      {
        "txt": "Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 783,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 244,
    "end-bug-line": 244,
    "bug": "",
    "fix": "return;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass {"
      },
      {
        "txt": "private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph ="
      },
      {
        "txt": "LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler;"
      },
      {
        "txt": "this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null);"
      },
      {
        "txt": "symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); }"
      },
      {
        "txt": "} } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties());"
      },
      {
        "txt": "FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; }"
      },
      {
        "txt": "private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo;"
      },
      {
        "txt": "} } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope();"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) {"
      },
      {
        "txt": "String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); <extra_id_0> addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals("
      },
      {
        "txt": "parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) {"
      },
      {
        "txt": "String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break;"
      },
      {
        "txt": "} context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop();"
      },
      {
        "txt": "} } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; }"
      },
      {
        "txt": "} if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());"
      },
      {
        "txt": "} private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext();"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {"
      },
      {
        "txt": "Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext();"
      },
      {
        "txt": "Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));"
      },
      {
        "txt": "} } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } }"
      },
      {
        "txt": "} private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule);"
      },
      {
        "txt": "} else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule();"
      },
      {
        "txt": "} private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState("
      },
      {
        "txt": "parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent);"
      },
      {
        "txt": "} else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype();"
      },
      {
        "txt": "Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild();"
      },
      {
        "txt": "} private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property {"
      },
      {
        "txt": "private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map;"
      },
      {
        "txt": "this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false;"
      },
      {
        "txt": "private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; }"
      },
      {
        "txt": "boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) {"
      },
      {
        "txt": "JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true;"
      },
      {
        "txt": "} } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; }"
      }
    ]
  },
  {
    "id": 784,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 246,
    "end-bug-line": 246,
    "bug": "addSymbolUse(propName, t.getModule(), PROPERTY);",
    "fix": "if (n.getParent().isAssign() && n.getNext() != null) { String rValueName = getPrototypePropertyNameFromRValue(n); if (rValueName != null) { return; } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { <extra_id_0> } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {"
      },
      {
        "txt": "parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString();"
      },
      {
        "txt": "Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); }"
      },
      {
        "txt": "} else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; }"
      },
      {
        "txt": "context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); }"
      },
      {
        "txt": "} private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } }"
      },
      {
        "txt": "if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); }"
      },
      {
        "txt": "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() &&"
      },
      {
        "txt": "child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild();"
      },
      {
        "txt": "if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent();"
      },
      {
        "txt": "Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); }"
      },
      {
        "txt": "} private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } }"
      },
      {
        "txt": "private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else {"
      },
      {
        "txt": "return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule(); }"
      },
      {
        "txt": "private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() ||"
      },
      {
        "txt": "NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else {"
      },
      {
        "txt": "Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue();"
      },
      {
        "txt": "} static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); }"
      },
      {
        "txt": "private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key;"
      },
      {
        "txt": "private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext {"
      },
      {
        "txt": "final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>();"
      },
      {
        "txt": "private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() {"
      },
      {
        "txt": "return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef;"
      },
      {
        "txt": "if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; }"
      },
      {
        "txt": "} return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 785,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 249,
    "end-bug-line": 249,
    "bug": "} else if (n.isObjectLit() &&",
    "fix": "addSymbolUse(propName, t.getModule(), PROPERTY); } else if (n.isObjectLit()) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\");"
      },
      {
        "txt": "private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars;"
      },
      {
        "txt": "if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) {"
      },
      {
        "txt": "NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } }"
      },
      {
        "txt": "@Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph,"
      },
      {
        "txt": "Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo;"
      },
      {
        "txt": "if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "} @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */;"
      },
      {
        "txt": "symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString();"
      },
      {
        "txt": "processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } <extra_id_0> !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {"
      },
      {
        "txt": "for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) {"
      },
      {
        "txt": "if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN:"
      },
      {
        "txt": "Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "} break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> {"
      },
      {
        "txt": "@Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); }"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY,"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild();"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map;"
      },
      {
        "txt": "private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope;"
      },
      {
        "txt": "NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false;"
      },
      {
        "txt": "NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; }"
      },
      {
        "txt": "boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module;"
      },
      {
        "txt": "} else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged;"
      },
      {
        "txt": "} JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 786,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 253,
    "end-bug-line": 256,
    "bug": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {",
    "fix": "String lValueName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); if (lValueName != null && lValueName.endsWith(\".prototype\")) { return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns;"
      },
      {
        "txt": "private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\");"
      },
      {
        "txt": "private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) {"
      },
      {
        "txt": "firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY);"
      },
      {
        "txt": "if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override"
      },
      {
        "txt": "public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode));"
      },
      {
        "txt": "} public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) {"
      },
      {
        "txt": "return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>();"
      },
      {
        "txt": "private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { }"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));"
      },
      {
        "txt": "} else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) {"
      },
      {
        "txt": "} else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && <extra_id_0> for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) {"
      },
      {
        "txt": "if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) ||"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name;"
      },
      {
        "txt": "if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() &&"
      },
      {
        "txt": "(NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty ="
      },
      {
        "txt": "n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false;"
      },
      {
        "txt": "} private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add("
      },
      {
        "txt": "new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty("
      },
      {
        "txt": "grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {"
      },
      {
        "txt": "String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } }"
      },
      {
        "txt": "private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule,"
      },
      {
        "txt": "getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef();"
      },
      {
        "txt": "if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } }"
      },
      {
        "txt": "interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode;"
      },
      {
        "txt": "private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } }"
      },
      {
        "txt": "} interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) {"
      },
      {
        "txt": "this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } }"
      },
      {
        "txt": "class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; }"
      },
      {
        "txt": "boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true;"
      },
      {
        "txt": "hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module);"
      },
      {
        "txt": "} if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; }"
      },
      {
        "txt": "Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 787,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 277,
    "end-bug-line": 278,
    "bug": "if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {",
    "fix": "if (!processGlobalFunctionDeclaration(t, n, var)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR;"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\");"
      },
      {
        "txt": "private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns;"
      },
      {
        "txt": "this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode);"
      },
      {
        "txt": "for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } }"
      },
      {
        "txt": "} @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences());"
      },
      {
        "txt": "t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ?"
      },
      {
        "txt": "propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } }"
      },
      {
        "txt": "private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ :"
      },
      {
        "txt": "n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() &&"
      },
      {
        "txt": "parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) {"
      },
      {
        "txt": "Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { <extra_id_0> addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } }"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN:"
      },
      {
        "txt": "Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "} break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> {"
      },
      {
        "txt": "@Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); }"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY,"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild();"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map;"
      },
      {
        "txt": "private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope;"
      },
      {
        "txt": "NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false;"
      },
      {
        "txt": "NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; }"
      },
      {
        "txt": "boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module;"
      },
      {
        "txt": "} else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged;"
      },
      {
        "txt": "} JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 788,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 303,
    "end-bug-line": 305,
    "bug": "if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {",
    "fix": "if (processNonFunctionPrototypeAssign(n, parent) != null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "} context.name.readClosureVariables = true; } } } } <extra_id_0> symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null;"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN:"
      },
      {
        "txt": "Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "} break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> {"
      },
      {
        "txt": "@Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); }"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY,"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild();"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map;"
      },
      {
        "txt": "private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope;"
      },
      {
        "txt": "NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false;"
      },
      {
        "txt": "NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; }"
      },
      {
        "txt": "boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module;"
      },
      {
        "txt": "} else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged;"
      },
      {
        "txt": "} JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 789,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 329,
    "end-bug-line": 329,
    "bug": "",
    "fix": "private String processNonFunctionPrototypeAssign(Node n, Node parent) { if (isAssignRValue(n, parent) && !n.isFunction()) { return getPrototypePropertyNameFromRValue(n); } return null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass {"
      },
      {
        "txt": "private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph ="
      },
      {
        "txt": "LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler;"
      },
      {
        "txt": "this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null);"
      },
      {
        "txt": "symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); }"
      },
      {
        "txt": "} } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties());"
      },
      {
        "txt": "FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; }"
      },
      {
        "txt": "private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo;"
      },
      {
        "txt": "} } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope();"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) {"
      },
      {
        "txt": "String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent,"
      },
      {
        "txt": "parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i);"
      },
      {
        "txt": "if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) ||"
      },
      {
        "txt": "n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) {"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } <extra_id_0> private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); }"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t,"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty("
      },
      {
        "txt": "key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); }"
      },
      {
        "txt": "} } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {"
      },
      {
        "txt": "return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove();"
      },
      {
        "txt": "JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {"
      },
      {
        "txt": "Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {"
      },
      {
        "txt": "NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol {"
      },
      {
        "txt": "Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value;"
      },
      {
        "txt": "this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name;"
      },
      {
        "txt": "private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced;"
      },
      {
        "txt": "} boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; }"
      },
      {
        "txt": "if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) {"
      },
      {
        "txt": "hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 790,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 337,
    "end-bug-line": 337,
    "bug": "",
    "fix": "Scope s = t.getScope(); if (!(s.isGlobal() || s.getDepth() == 1 && s.getRootNode() == n)) { return false; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { <extra_id_0> return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) {"
      },
      {
        "txt": "} private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext();"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {"
      },
      {
        "txt": "Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext();"
      },
      {
        "txt": "Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));"
      },
      {
        "txt": "} } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } }"
      },
      {
        "txt": "} private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule);"
      },
      {
        "txt": "} else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule();"
      },
      {
        "txt": "} private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState("
      },
      {
        "txt": "parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent);"
      },
      {
        "txt": "} else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype();"
      },
      {
        "txt": "Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild();"
      },
      {
        "txt": "} private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property {"
      },
      {
        "txt": "private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map;"
      },
      {
        "txt": "this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false;"
      },
      {
        "txt": "private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; }"
      },
      {
        "txt": "boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) {"
      },
      {
        "txt": "JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true;"
      },
      {
        "txt": "} } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; }"
      }
    ]
  },
  {
    "id": 791,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 338,
    "end-bug-line": 341,
    "bug": "return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());",
    "fix": "return NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { <extra_id_0> } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {"
      },
      {
        "txt": "&& n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; }"
      },
      {
        "txt": "} } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null &&"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; }"
      },
      {
        "txt": "return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) &&"
      },
      {
        "txt": "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext();"
      },
      {
        "txt": "if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } }"
      },
      {
        "txt": "break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override"
      },
      {
        "txt": "public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } }"
      },
      {
        "txt": "return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR;"
      },
      {
        "txt": "} class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); }"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else {"
      },
      {
        "txt": "return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode;"
      },
      {
        "txt": "private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign;"
      },
      {
        "txt": "private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value;"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) {"
      },
      {
        "txt": "this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) {"
      },
      {
        "txt": "this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) {"
      },
      {
        "txt": "boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else {"
      },
      {
        "txt": "deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; }"
      },
      {
        "txt": "JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 792,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 347,
    "end-bug-line": 353,
    "bug": "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp();",
    "fix": "private boolean isAssignRValue(Node n, Node parent) { return parent != null && parent.isAssign() && parent.getFirstChild() != n; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph;"
      },
      {
        "txt": "private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else {"
      },
      {
        "txt": "firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo);"
      },
      {
        "txt": "} else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() {"
      },
      {
        "txt": "List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else {"
      },
      {
        "txt": "NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode));"
      },
      {
        "txt": "} @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode));"
      },
      {
        "txt": "} return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null;"
      },
      {
        "txt": "propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) {"
      },
      {
        "txt": "if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); }"
      },
      {
        "txt": "} } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } }"
      },
      {
        "txt": "} } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type);"
      },
      {
        "txt": "NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); }"
      },
      {
        "txt": "private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } <extra_id_0> if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; }"
      },
      {
        "txt": "return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION."
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); }"
      },
      {
        "txt": "return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent();"
      },
      {
        "txt": "if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break;"
      },
      {
        "txt": "case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } }"
      },
      {
        "txt": "private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences"
      },
      {
        "txt": "implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge);"
      },
      {
        "txt": "} } return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType {"
      },
      {
        "txt": "PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent));"
      },
      {
        "txt": "this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar());"
      },
      {
        "txt": "parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) {"
      },
      {
        "txt": "return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); }"
      },
      {
        "txt": "static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() {"
      },
      {
        "txt": "return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value;"
      },
      {
        "txt": "private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name;"
      },
      {
        "txt": "Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null;"
      },
      {
        "txt": "private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables;"
      },
      {
        "txt": "} boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) {"
      },
      {
        "txt": "deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } }"
      },
      {
        "txt": "return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 793,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 362,
    "end-bug-line": 363,
    "bug": "if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext();",
    "fix": "private String getPrototypePropertyNameFromRValue(Node rValue) { Node lValue = NodeUtil.getBestLValue(rValue); if (lValue == null || lValue.getParent() == null || lValue.getParent().getParent() == null || !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) || NodeUtil.isExprAssign(lValue.getParent().getParent()))) { return null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\");"
      },
      {
        "txt": "private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars;"
      },
      {
        "txt": "if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) {"
      },
      {
        "txt": "NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } }"
      },
      {
        "txt": "@Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph,"
      },
      {
        "txt": "Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo;"
      },
      {
        "txt": "if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "} @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */;"
      },
      {
        "txt": "symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString();"
      },
      {
        "txt": "if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() &&"
      },
      {
        "txt": "parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString();"
      },
      {
        "txt": "Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); }"
      },
      {
        "txt": "} else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; }"
      },
      {
        "txt": "context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); }"
      },
      {
        "txt": "} private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } }"
      },
      {
        "txt": "if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); }"
      },
      {
        "txt": "Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); <extra_id_0> if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } }"
      },
      {
        "txt": "} } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null &&"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; }"
      },
      {
        "txt": "return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) &&"
      },
      {
        "txt": "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext();"
      },
      {
        "txt": "if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } }"
      },
      {
        "txt": "break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override"
      },
      {
        "txt": "public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } }"
      },
      {
        "txt": "return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR;"
      },
      {
        "txt": "} class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); }"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else {"
      },
      {
        "txt": "return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode;"
      },
      {
        "txt": "private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign;"
      },
      {
        "txt": "private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value;"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) {"
      },
      {
        "txt": "this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) {"
      },
      {
        "txt": "this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) {"
      },
      {
        "txt": "boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else {"
      },
      {
        "txt": "deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; }"
      },
      {
        "txt": "JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 794,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 365,
    "end-bug-line": 369,
    "bug": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } }",
    "fix": "String lValueName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue)); if (lValueName == null) { return null; } int lastDot = lValueName.lastIndexOf('.'); if (lastDot == -1) { return null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars;"
      },
      {
        "txt": "private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule();"
      },
      {
        "txt": "} else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) {"
      },
      {
        "txt": "if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); }"
      },
      {
        "txt": "public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name);"
      },
      {
        "txt": "} else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() {"
      },
      {
        "txt": "symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent);"
      },
      {
        "txt": "} else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {"
      },
      {
        "txt": "for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) {"
      },
      {
        "txt": "if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "&& n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); <extra_id_0> } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild();"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty("
      },
      {
        "txt": "key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); }"
      },
      {
        "txt": "} } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {"
      },
      {
        "txt": "return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove();"
      },
      {
        "txt": "JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {"
      },
      {
        "txt": "Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {"
      },
      {
        "txt": "NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol {"
      },
      {
        "txt": "Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value;"
      },
      {
        "txt": "this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name;"
      },
      {
        "txt": "private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced;"
      },
      {
        "txt": "} boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; }"
      },
      {
        "txt": "if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) {"
      },
      {
        "txt": "hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 795,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 372,
    "end-bug-line": 372,
    "bug": "",
    "fix": "String firstPart = lValueName.substring(0, lastDot); if (!firstPart.endsWith(\".prototype\")) { return null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } <extra_id_0> return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION."
      },
      {
        "txt": "Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext();"
      },
      {
        "txt": "Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));"
      },
      {
        "txt": "} } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } }"
      },
      {
        "txt": "} private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule);"
      },
      {
        "txt": "} else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule();"
      },
      {
        "txt": "} private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState("
      },
      {
        "txt": "parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent);"
      },
      {
        "txt": "} else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype();"
      },
      {
        "txt": "Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild();"
      },
      {
        "txt": "} private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property {"
      },
      {
        "txt": "private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map;"
      },
      {
        "txt": "this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false;"
      },
      {
        "txt": "private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; }"
      },
      {
        "txt": "boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) {"
      },
      {
        "txt": "JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true;"
      },
      {
        "txt": "} } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; }"
      }
    ]
  },
  {
    "id": 796,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 373,
    "end-bug-line": 373,
    "bug": "return false;",
    "fix": "return lValueName.substring(lastDot + 1);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } <extra_id_0> } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent();"
      },
      {
        "txt": "Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); }"
      },
      {
        "txt": "} private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } }"
      },
      {
        "txt": "private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else {"
      },
      {
        "txt": "return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule(); }"
      },
      {
        "txt": "private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() ||"
      },
      {
        "txt": "NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else {"
      },
      {
        "txt": "Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue();"
      },
      {
        "txt": "} static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); }"
      },
      {
        "txt": "private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key;"
      },
      {
        "txt": "private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext {"
      },
      {
        "txt": "final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>();"
      },
      {
        "txt": "private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() {"
      },
      {
        "txt": "return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef;"
      },
      {
        "txt": "if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; }"
      },
      {
        "txt": "} return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 797,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 381,
    "end-bug-line": 381,
    "bug": "Node nameNode, Node parent, Node gramps) {",
    "fix": "Node nameNode, Var v) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns;"
      },
      {
        "txt": "private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\");"
      },
      {
        "txt": "private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) {"
      },
      {
        "txt": "firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY);"
      },
      {
        "txt": "if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override"
      },
      {
        "txt": "public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode));"
      },
      {
        "txt": "} public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) {"
      },
      {
        "txt": "return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>();"
      },
      {
        "txt": "private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { }"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));"
      },
      {
        "txt": "} else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) {"
      },
      {
        "txt": "processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals("
      },
      {
        "txt": "\"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name);"
      },
      {
        "txt": "if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else {"
      },
      {
        "txt": "addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true;"
      },
      {
        "txt": "} } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } }"
      },
      {
        "txt": "private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) {"
      },
      {
        "txt": "symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) {"
      },
      {
        "txt": "Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) {"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, <extra_id_0> Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString();"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; }"
      },
      {
        "txt": "return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) &&"
      },
      {
        "txt": "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext();"
      },
      {
        "txt": "if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } }"
      },
      {
        "txt": "break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override"
      },
      {
        "txt": "public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } }"
      },
      {
        "txt": "return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR;"
      },
      {
        "txt": "} class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); }"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else {"
      },
      {
        "txt": "return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode;"
      },
      {
        "txt": "private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign;"
      },
      {
        "txt": "private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value;"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) {"
      },
      {
        "txt": "this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) {"
      },
      {
        "txt": "this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) {"
      },
      {
        "txt": "boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else {"
      },
      {
        "txt": "deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; }"
      },
      {
        "txt": "JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 798,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 383,
    "end-bug-line": 383,
    "bug": "",
    "fix": "Node parent = nameNode.getParent();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph;"
      },
      {
        "txt": "private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else {"
      },
      {
        "txt": "firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo);"
      },
      {
        "txt": "} else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() {"
      },
      {
        "txt": "List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else {"
      },
      {
        "txt": "NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode));"
      },
      {
        "txt": "} @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode));"
      },
      {
        "txt": "} return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null;"
      },
      {
        "txt": "propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) {"
      },
      {
        "txt": "if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); }"
      },
      {
        "txt": "} } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } }"
      },
      {
        "txt": "} } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type);"
      },
      {
        "txt": "NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); }"
      },
      {
        "txt": "} private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)"
      },
      {
        "txt": "&& n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; }"
      },
      {
        "txt": "} return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); <extra_id_0> if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add("
      },
      {
        "txt": "String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false;"
      },
      {
        "txt": "} private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {"
      },
      {
        "txt": "String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) {"
      },
      {
        "txt": "for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break;"
      },
      {
        "txt": "} } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {"
      },
      {
        "txt": "if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false;"
      },
      {
        "txt": "} } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; }"
      },
      {
        "txt": "class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1);"
      },
      {
        "txt": "} } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module;"
      },
      {
        "txt": "AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module;"
      },
      {
        "txt": "LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name;"
      },
      {
        "txt": "} } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name;"
      },
      {
        "txt": "} @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false;"
      },
      {
        "txt": "if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef ="
      },
      {
        "txt": "moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() {"
      },
      {
        "txt": "return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 799,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 391,
    "end-bug-line": 391,
    "bug": "new GlobalFunction(nameNode, parent, gramps, t.getModule()));",
    "fix": "new GlobalFunction(nameNode, v, t.getModule()));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR;"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\");"
      },
      {
        "txt": "private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns;"
      },
      {
        "txt": "this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode);"
      },
      {
        "txt": "for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } }"
      },
      {
        "txt": "} @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences());"
      },
      {
        "txt": "t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ?"
      },
      {
        "txt": "propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } }"
      },
      {
        "txt": "private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ :"
      },
      {
        "txt": "n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() &&"
      },
      {
        "txt": "parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) {"
      },
      {
        "txt": "String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break;"
      },
      {
        "txt": "} context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop();"
      },
      {
        "txt": "} } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; }"
      },
      {
        "txt": "} if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());"
      },
      {
        "txt": "} private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext();"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {"
      },
      {
        "txt": "if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( <extra_id_0> if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; }"
      },
      {
        "txt": "return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent();"
      },
      {
        "txt": "if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break;"
      },
      {
        "txt": "case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } }"
      },
      {
        "txt": "private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences"
      },
      {
        "txt": "implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge);"
      },
      {
        "txt": "} } return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType {"
      },
      {
        "txt": "PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent));"
      },
      {
        "txt": "this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar());"
      },
      {
        "txt": "parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) {"
      },
      {
        "txt": "return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); }"
      },
      {
        "txt": "static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() {"
      },
      {
        "txt": "return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value;"
      },
      {
        "txt": "private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name;"
      },
      {
        "txt": "Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null;"
      },
      {
        "txt": "private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables;"
      },
      {
        "txt": "} boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) {"
      },
      {
        "txt": "deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } }"
      },
      {
        "txt": "return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 800,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 411,
    "end-bug-line": 411,
    "bug": "private void processPrototypeParent(NodeTraversal t, Node n) {",
    "fix": "private boolean processPrototypeRef(NodeTraversal t, Node ref) { Node root = NodeUtil.getRootOfQualifiedName(ref);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t,"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } <extra_id_0> switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); }"
      },
      {
        "txt": "} private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } }"
      },
      {
        "txt": "private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else {"
      },
      {
        "txt": "return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule(); }"
      },
      {
        "txt": "private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() ||"
      },
      {
        "txt": "NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else {"
      },
      {
        "txt": "Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue();"
      },
      {
        "txt": "} static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); }"
      },
      {
        "txt": "private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key;"
      },
      {
        "txt": "private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext {"
      },
      {
        "txt": "final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>();"
      },
      {
        "txt": "private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() {"
      },
      {
        "txt": "return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef;"
      },
      {
        "txt": "if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; }"
      },
      {
        "txt": "} return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 801,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 413,
    "end-bug-line": 413,
    "bug": "",
    "fix": "Node n = ref.getParent();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR;"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\");"
      },
      {
        "txt": "private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns;"
      },
      {
        "txt": "this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode);"
      },
      {
        "txt": "for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } }"
      },
      {
        "txt": "} @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences());"
      },
      {
        "txt": "t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ?"
      },
      {
        "txt": "propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } }"
      },
      {
        "txt": "private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ :"
      },
      {
        "txt": "n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() &&"
      },
      {
        "txt": "parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) {"
      },
      {
        "txt": "String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break;"
      },
      {
        "txt": "} context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop();"
      },
      {
        "txt": "} } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; }"
      },
      {
        "txt": "} if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());"
      },
      {
        "txt": "} private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext();"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {"
      },
      {
        "txt": "Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {"
      },
      {
        "txt": "} return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { <extra_id_0> case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) &&"
      },
      {
        "txt": "if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break;"
      },
      {
        "txt": "case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } }"
      },
      {
        "txt": "private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences"
      },
      {
        "txt": "implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge);"
      },
      {
        "txt": "} } return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType {"
      },
      {
        "txt": "PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent));"
      },
      {
        "txt": "this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar());"
      },
      {
        "txt": "parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) {"
      },
      {
        "txt": "return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); }"
      },
      {
        "txt": "static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() {"
      },
      {
        "txt": "return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value;"
      },
      {
        "txt": "private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name;"
      },
      {
        "txt": "Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null;"
      },
      {
        "txt": "private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables;"
      },
      {
        "txt": "} boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) {"
      },
      {
        "txt": "deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } }"
      },
      {
        "txt": "return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 802,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 426,
    "end-bug-line": 426,
    "bug": "",
    "fix": "t.getScope().getVar(root.getString()),",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\");"
      },
      {
        "txt": "private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars;"
      },
      {
        "txt": "if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) {"
      },
      {
        "txt": "NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } }"
      },
      {
        "txt": "@Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph,"
      },
      {
        "txt": "Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo;"
      },
      {
        "txt": "if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "} @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */;"
      },
      {
        "txt": "symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString();"
      },
      {
        "txt": "if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() &&"
      },
      {
        "txt": "parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString();"
      },
      {
        "txt": "Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); }"
      },
      {
        "txt": "} else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; }"
      },
      {
        "txt": "context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); }"
      },
      {
        "txt": "} private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } }"
      },
      {
        "txt": "if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); }"
      },
      {
        "txt": "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() &&"
      },
      {
        "txt": "child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild();"
      },
      {
        "txt": "if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent();"
      },
      {
        "txt": "if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, <extra_id_0> getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) {"
      },
      {
        "txt": "Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "} break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> {"
      },
      {
        "txt": "@Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); }"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY,"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild();"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map;"
      },
      {
        "txt": "private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope;"
      },
      {
        "txt": "NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false;"
      },
      {
        "txt": "NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; }"
      },
      {
        "txt": "boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module;"
      },
      {
        "txt": "} else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged;"
      },
      {
        "txt": "} JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 803,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 428,
    "end-bug-line": 428,
    "bug": "",
    "fix": "return true;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars;"
      },
      {
        "txt": "private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule();"
      },
      {
        "txt": "} else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) {"
      },
      {
        "txt": "if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); }"
      },
      {
        "txt": "public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name);"
      },
      {
        "txt": "} else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() {"
      },
      {
        "txt": "symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent);"
      },
      {
        "txt": "} else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {"
      },
      {
        "txt": "for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) {"
      },
      {
        "txt": "if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); <extra_id_0> break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {"
      },
      {
        "txt": "for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break;"
      },
      {
        "txt": "} } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {"
      },
      {
        "txt": "if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false;"
      },
      {
        "txt": "} } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; }"
      },
      {
        "txt": "class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1);"
      },
      {
        "txt": "} } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module;"
      },
      {
        "txt": "AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module;"
      },
      {
        "txt": "LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name;"
      },
      {
        "txt": "} } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name;"
      },
      {
        "txt": "} @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false;"
      },
      {
        "txt": "if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef ="
      },
      {
        "txt": "moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() {"
      },
      {
        "txt": "return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 804,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 441,
    "end-bug-line": 441,
    "bug": "",
    "fix": "t.getScope().getVar(root.getString()),",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars;"
      },
      {
        "txt": "private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule();"
      },
      {
        "txt": "} else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) {"
      },
      {
        "txt": "if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); }"
      },
      {
        "txt": "public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name);"
      },
      {
        "txt": "} else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() {"
      },
      {
        "txt": "symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent);"
      },
      {
        "txt": "} else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {"
      },
      {
        "txt": "for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) {"
      },
      {
        "txt": "if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN:"
      },
      {
        "txt": "if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, <extra_id_0> getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } }"
      },
      {
        "txt": "} } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {"
      },
      {
        "txt": "if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false;"
      },
      {
        "txt": "} } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; }"
      },
      {
        "txt": "class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1);"
      },
      {
        "txt": "} } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module;"
      },
      {
        "txt": "AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module;"
      },
      {
        "txt": "LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name;"
      },
      {
        "txt": "} } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name;"
      },
      {
        "txt": "} @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false;"
      },
      {
        "txt": "if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef ="
      },
      {
        "txt": "moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() {"
      },
      {
        "txt": "return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 805,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 444,
    "end-bug-line": 444,
    "bug": "",
    "fix": "return true;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES ="
      },
      {
        "txt": "ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns,"
      },
      {
        "txt": "boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; }"
      },
      {
        "txt": "globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties());"
      },
      {
        "txt": "} NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values());"
      },
      {
        "txt": "return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo);"
      },
      {
        "txt": "symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName("
      },
      {
        "txt": "n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else {"
      },
      {
        "txt": "addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) {"
      },
      {
        "txt": "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {"
      },
      {
        "txt": "if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){"
      },
      {
        "txt": "for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } }"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {"
      },
      {
        "txt": "return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {"
      },
      {
        "txt": "boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } }"
      },
      {
        "txt": "return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString();"
      },
      {
        "txt": "getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; }"
      },
      {
        "txt": "private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString();"
      },
      {
        "txt": "Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild();"
      },
      {
        "txt": "String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } <extra_id_0> break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));"
      },
      {
        "txt": "SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY));"
      },
      {
        "txt": "} } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null &&"
      },
      {
        "txt": "moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol {"
      },
      {
        "txt": "void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module;"
      },
      {
        "txt": "GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } }"
      },
      {
        "txt": "interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key;"
      },
      {
        "txt": "this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo {"
      },
      {
        "txt": "final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() {"
      },
      {
        "txt": "return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true;"
      },
      {
        "txt": "} if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); }"
      },
      {
        "txt": "if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() {"
      },
      {
        "txt": "return declarations; } }"
      }
    ]
  },
  {
    "id": 806,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 447,
    "end-bug-line": 447,
    "bug": "",
    "fix": "return false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t,"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty("
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } <extra_id_0> private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "} private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } }"
      },
      {
        "txt": "private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else {"
      },
      {
        "txt": "return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule(); }"
      },
      {
        "txt": "private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() ||"
      },
      {
        "txt": "NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else {"
      },
      {
        "txt": "Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue();"
      },
      {
        "txt": "} static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); }"
      },
      {
        "txt": "private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key;"
      },
      {
        "txt": "private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext {"
      },
      {
        "txt": "final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>();"
      },
      {
        "txt": "private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() {"
      },
      {
        "txt": "return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef;"
      },
      {
        "txt": "if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; }"
      },
      {
        "txt": "} return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 807,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 498,
    "end-bug-line": 498,
    "bug": "",
    "fix": "Var getRootVar();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns;"
      },
      {
        "txt": "private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\");"
      },
      {
        "txt": "private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) {"
      },
      {
        "txt": "firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY);"
      },
      {
        "txt": "if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override"
      },
      {
        "txt": "public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode));"
      },
      {
        "txt": "} public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) {"
      },
      {
        "txt": "return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>();"
      },
      {
        "txt": "private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { }"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));"
      },
      {
        "txt": "} else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) {"
      },
      {
        "txt": "processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals("
      },
      {
        "txt": "\"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name);"
      },
      {
        "txt": "if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else {"
      },
      {
        "txt": "addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true;"
      },
      {
        "txt": "} } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } }"
      },
      {
        "txt": "private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) {"
      },
      {
        "txt": "symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) {"
      },
      {
        "txt": "Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) {"
      },
      {
        "txt": "return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION."
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); }"
      },
      {
        "txt": "return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent();"
      },
      {
        "txt": "if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break;"
      },
      {
        "txt": "case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } }"
      },
      {
        "txt": "private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences"
      },
      {
        "txt": "implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge);"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); <extra_id_0> JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; }"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild();"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map;"
      },
      {
        "txt": "private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope;"
      },
      {
        "txt": "NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false;"
      },
      {
        "txt": "NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; }"
      },
      {
        "txt": "boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module;"
      },
      {
        "txt": "} else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged;"
      },
      {
        "txt": "} JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 808,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 515,
    "end-bug-line": 515,
    "bug": "",
    "fix": "private final Var var;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR;"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\");"
      },
      {
        "txt": "private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns;"
      },
      {
        "txt": "this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode);"
      },
      {
        "txt": "for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } }"
      },
      {
        "txt": "} @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences());"
      },
      {
        "txt": "t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ?"
      },
      {
        "txt": "propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } }"
      },
      {
        "txt": "private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ :"
      },
      {
        "txt": "n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() &&"
      },
      {
        "txt": "parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) {"
      },
      {
        "txt": "String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break;"
      },
      {
        "txt": "} context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop();"
      },
      {
        "txt": "} } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; }"
      },
      {
        "txt": "} if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());"
      },
      {
        "txt": "} private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext();"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {"
      },
      {
        "txt": "Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext();"
      },
      {
        "txt": "Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));"
      },
      {
        "txt": "} } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } }"
      },
      {
        "txt": "} private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule);"
      },
      {
        "txt": "} else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule();"
      },
      {
        "txt": "private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; <extra_id_0> GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module;"
      },
      {
        "txt": "this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar());"
      },
      {
        "txt": "parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) {"
      },
      {
        "txt": "return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); }"
      },
      {
        "txt": "static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() {"
      },
      {
        "txt": "return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value;"
      },
      {
        "txt": "private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name;"
      },
      {
        "txt": "Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null;"
      },
      {
        "txt": "private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables;"
      },
      {
        "txt": "} boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) {"
      },
      {
        "txt": "deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } }"
      },
      {
        "txt": "return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 809,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 517,
    "end-bug-line": 517,
    "bug": "GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {",
    "fix": "GlobalFunction(Node nameNode, Var var, JSModule module) { Node parent = nameNode.getParent();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\");"
      },
      {
        "txt": "private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars;"
      },
      {
        "txt": "if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) {"
      },
      {
        "txt": "NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } }"
      },
      {
        "txt": "@Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph,"
      },
      {
        "txt": "Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo;"
      },
      {
        "txt": "if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "} @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */;"
      },
      {
        "txt": "symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString();"
      },
      {
        "txt": "if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() &&"
      },
      {
        "txt": "parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString();"
      },
      {
        "txt": "Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); }"
      },
      {
        "txt": "} else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; }"
      },
      {
        "txt": "context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); }"
      },
      {
        "txt": "} private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } }"
      },
      {
        "txt": "if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); }"
      },
      {
        "txt": "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() &&"
      },
      {
        "txt": "child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild();"
      },
      {
        "txt": "if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent();"
      },
      {
        "txt": "Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); }"
      },
      {
        "txt": "} private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } }"
      },
      {
        "txt": "private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else {"
      },
      {
        "txt": "return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule(); }"
      },
      {
        "txt": "PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; <extra_id_0> Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; }"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }"
      },
      {
        "txt": "@Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild();"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map;"
      },
      {
        "txt": "private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope;"
      },
      {
        "txt": "NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false;"
      },
      {
        "txt": "NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; }"
      },
      {
        "txt": "boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module;"
      },
      {
        "txt": "} else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged;"
      },
      {
        "txt": "} JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 810,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 522,
    "end-bug-line": 522,
    "bug": "",
    "fix": "this.var = var;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES ="
      },
      {
        "txt": "ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns,"
      },
      {
        "txt": "boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; }"
      },
      {
        "txt": "globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties());"
      },
      {
        "txt": "} NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values());"
      },
      {
        "txt": "return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo);"
      },
      {
        "txt": "symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName("
      },
      {
        "txt": "n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else {"
      },
      {
        "txt": "addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) {"
      },
      {
        "txt": "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {"
      },
      {
        "txt": "if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){"
      },
      {
        "txt": "for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } }"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {"
      },
      {
        "txt": "return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {"
      },
      {
        "txt": "boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } }"
      },
      {
        "txt": "return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString();"
      },
      {
        "txt": "getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; }"
      },
      {
        "txt": "private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString();"
      },
      {
        "txt": "Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild();"
      },
      {
        "txt": "key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; }"
      },
      {
        "txt": "} private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) {"
      },
      {
        "txt": "JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; }"
      },
      {
        "txt": "} interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol {"
      },
      {
        "txt": "private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; <extra_id_0> } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent);"
      },
      {
        "txt": "if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } }"
      },
      {
        "txt": "interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key;"
      },
      {
        "txt": "this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo {"
      },
      {
        "txt": "final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() {"
      },
      {
        "txt": "return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true;"
      },
      {
        "txt": "} if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); }"
      },
      {
        "txt": "if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() {"
      },
      {
        "txt": "return declarations; } }"
      }
    ]
  },
  {
    "id": 811,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 526,
    "end-bug-line": 526,
    "bug": "",
    "fix": "public Var getRootVar() { return var; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t,"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty("
      },
      {
        "txt": "key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); }"
      },
      {
        "txt": "} } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {"
      },
      {
        "txt": "return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove();"
      },
      {
        "txt": "JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {"
      },
      {
        "txt": "parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override <extra_id_0> public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar());"
      },
      {
        "txt": "} else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype();"
      },
      {
        "txt": "Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild();"
      },
      {
        "txt": "} private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property {"
      },
      {
        "txt": "private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map;"
      },
      {
        "txt": "this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false;"
      },
      {
        "txt": "private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; }"
      },
      {
        "txt": "boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) {"
      },
      {
        "txt": "JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true;"
      },
      {
        "txt": "} } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; }"
      }
    ]
  },
  {
    "id": 812,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 527,
    "end-bug-line": 527,
    "bug": "",
    "fix": "@Override",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t,"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty("
      },
      {
        "txt": "key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); }"
      },
      {
        "txt": "} } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {"
      },
      {
        "txt": "return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove();"
      },
      {
        "txt": "JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {"
      },
      {
        "txt": "parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override <extra_id_0> Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue();"
      },
      {
        "txt": "} static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); }"
      },
      {
        "txt": "private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key;"
      },
      {
        "txt": "private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext {"
      },
      {
        "txt": "final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>();"
      },
      {
        "txt": "private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() {"
      },
      {
        "txt": "return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef;"
      },
      {
        "txt": "if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; }"
      },
      {
        "txt": "} return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 813,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 575,
    "end-bug-line": 575,
    "bug": "",
    "fix": "private final Var rootVar;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack;"
      },
      {
        "txt": "class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\");"
      },
      {
        "txt": "private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) {"
      },
      {
        "txt": "this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null);"
      },
      {
        "txt": "externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo);"
      },
      {
        "txt": "} } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); }"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result;"
      },
      {
        "txt": "} private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo);"
      },
      {
        "txt": "return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY)));"
      },
      {
        "txt": "} else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) {"
      },
      {
        "txt": "if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) ||"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name;"
      },
      {
        "txt": "if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() &&"
      },
      {
        "txt": "(NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty ="
      },
      {
        "txt": "n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false;"
      },
      {
        "txt": "} private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add("
      },
      {
        "txt": "new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty("
      },
      {
        "txt": "grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {"
      },
      {
        "txt": "String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } }"
      },
      {
        "txt": "private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule,"
      },
      {
        "txt": "getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef();"
      },
      {
        "txt": "if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } }"
      },
      {
        "txt": "interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode;"
      },
      {
        "txt": "private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } }"
      },
      {
        "txt": "interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; <extra_id_0> AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "@Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value;"
      },
      {
        "txt": "this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name;"
      },
      {
        "txt": "private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced;"
      },
      {
        "txt": "} boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; }"
      },
      {
        "txt": "if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) {"
      },
      {
        "txt": "hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 814,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 580,
    "end-bug-line": 580,
    "bug": "AssignmentProperty(Node node, JSModule module) {",
    "fix": "AssignmentProperty(Node node, Var rootVar, JSModule module) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass {"
      },
      {
        "txt": "private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph ="
      },
      {
        "txt": "LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler;"
      },
      {
        "txt": "this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null);"
      },
      {
        "txt": "symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); }"
      },
      {
        "txt": "} } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties());"
      },
      {
        "txt": "FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; }"
      },
      {
        "txt": "private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo;"
      },
      {
        "txt": "} } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope();"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) {"
      },
      {
        "txt": "String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent,"
      },
      {
        "txt": "parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i);"
      },
      {
        "txt": "if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) ||"
      },
      {
        "txt": "n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) {"
      },
      {
        "txt": "break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) ||"
      },
      {
        "txt": "n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp();"
      },
      {
        "txt": "if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; }"
      },
      {
        "txt": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule()));"
      },
      {
        "txt": "if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString();"
      },
      {
        "txt": "Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module,"
      },
      {
        "txt": "SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY));"
      },
      {
        "txt": "} } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null &&"
      },
      {
        "txt": "moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol {"
      },
      {
        "txt": "void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module;"
      },
      {
        "txt": "GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } }"
      },
      {
        "txt": "Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; <extra_id_0> this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode);"
      },
      {
        "txt": "public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild();"
      },
      {
        "txt": "} private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property {"
      },
      {
        "txt": "private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map;"
      },
      {
        "txt": "this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false;"
      },
      {
        "txt": "private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; }"
      },
      {
        "txt": "boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) {"
      },
      {
        "txt": "JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true;"
      },
      {
        "txt": "} } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; }"
      }
    ]
  },
  {
    "id": 815,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 582,
    "end-bug-line": 582,
    "bug": "",
    "fix": "this.rootVar = rootVar;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR;"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\");"
      },
      {
        "txt": "private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns;"
      },
      {
        "txt": "this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode);"
      },
      {
        "txt": "for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } }"
      },
      {
        "txt": "} @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences());"
      },
      {
        "txt": "t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ?"
      },
      {
        "txt": "propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } }"
      },
      {
        "txt": "private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ :"
      },
      {
        "txt": "n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() &&"
      },
      {
        "txt": "parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) {"
      },
      {
        "txt": "String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break;"
      },
      {
        "txt": "} context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop();"
      },
      {
        "txt": "} } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; }"
      },
      {
        "txt": "} if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());"
      },
      {
        "txt": "} private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext();"
      },
      {
        "txt": "if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {"
      },
      {
        "txt": "Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext();"
      },
      {
        "txt": "Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);"
      },
      {
        "txt": "} break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));"
      },
      {
        "txt": "} } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } }"
      },
      {
        "txt": "} private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule);"
      },
      {
        "txt": "} else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove(); JSModule getModule();"
      },
      {
        "txt": "} private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState("
      },
      {
        "txt": "parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent);"
      },
      {
        "txt": "} else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; } public Node getFunctionNode() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype();"
      },
      {
        "txt": "} static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; <extra_id_0> } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override"
      },
      {
        "txt": "} @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() {"
      },
      {
        "txt": "return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value;"
      },
      {
        "txt": "private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name;"
      },
      {
        "txt": "Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null;"
      },
      {
        "txt": "private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables;"
      },
      {
        "txt": "} boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) {"
      },
      {
        "txt": "deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } }"
      },
      {
        "txt": "return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 816,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 586,
    "end-bug-line": 586,
    "bug": "",
    "fix": "public Var getRootVar() { return rootVar; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars;"
      },
      {
        "txt": "private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule();"
      },
      {
        "txt": "} else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) {"
      },
      {
        "txt": "if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); }"
      },
      {
        "txt": "public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name);"
      },
      {
        "txt": "} else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() {"
      },
      {
        "txt": "symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent);"
      },
      {
        "txt": "} else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {"
      },
      {
        "txt": "for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) {"
      },
      {
        "txt": "if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN:"
      },
      {
        "txt": "Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "} break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> {"
      },
      {
        "txt": "@Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); }"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY,"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override <extra_id_0> public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild();"
      },
      {
        "txt": "public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign;"
      },
      {
        "txt": "private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value;"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) {"
      },
      {
        "txt": "this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) {"
      },
      {
        "txt": "this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) {"
      },
      {
        "txt": "boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else {"
      },
      {
        "txt": "deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; }"
      },
      {
        "txt": "JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 817,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 587,
    "end-bug-line": 587,
    "bug": "",
    "fix": "@Override",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars;"
      },
      {
        "txt": "private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule();"
      },
      {
        "txt": "} else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) {"
      },
      {
        "txt": "if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); }"
      },
      {
        "txt": "public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name);"
      },
      {
        "txt": "} else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() {"
      },
      {
        "txt": "symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent);"
      },
      {
        "txt": "} else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) {"
      },
      {
        "txt": "for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) {"
      },
      {
        "txt": "if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR);"
      },
      {
        "txt": "} } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; }"
      },
      {
        "txt": "} } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info);"
      },
      {
        "txt": "} } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild();"
      },
      {
        "txt": "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true;"
      },
      {
        "txt": "} } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||"
      },
      {
        "txt": "firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true;"
      },
      {
        "txt": "} return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() &&"
      },
      {
        "txt": "NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN:"
      },
      {
        "txt": "Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); }"
      },
      {
        "txt": "} break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback {"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> {"
      },
      {
        "txt": "@Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); }"
      },
      {
        "txt": "} return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY,"
      },
      {
        "txt": "VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode);"
      },
      {
        "txt": "} } @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent;"
      },
      {
        "txt": "} else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property {"
      },
      {
        "txt": "private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override <extra_id_0> NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); }"
      },
      {
        "txt": "return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module;"
      },
      {
        "txt": "LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name;"
      },
      {
        "txt": "} } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name;"
      },
      {
        "txt": "} @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false;"
      },
      {
        "txt": "if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef ="
      },
      {
        "txt": "moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() {"
      },
      {
        "txt": "return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 818,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 622,
    "end-bug-line": 622,
    "bug": "",
    "fix": "private final Var rootVar;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack;"
      },
      {
        "txt": "class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\");"
      },
      {
        "txt": "private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) {"
      },
      {
        "txt": "this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null);"
      },
      {
        "txt": "externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo);"
      },
      {
        "txt": "} } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); }"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result;"
      },
      {
        "txt": "} private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo);"
      },
      {
        "txt": "return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY)));"
      },
      {
        "txt": "} else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) {"
      },
      {
        "txt": "if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) ||"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name;"
      },
      {
        "txt": "if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() &&"
      },
      {
        "txt": "(NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty ="
      },
      {
        "txt": "n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false;"
      },
      {
        "txt": "} private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add("
      },
      {
        "txt": "new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty("
      },
      {
        "txt": "grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {"
      },
      {
        "txt": "String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } }"
      },
      {
        "txt": "private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule,"
      },
      {
        "txt": "getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef();"
      },
      {
        "txt": "if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } }"
      },
      {
        "txt": "interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode;"
      },
      {
        "txt": "private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } }"
      },
      {
        "txt": "} interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; <extra_id_0> LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign;"
      },
      {
        "txt": "this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name;"
      },
      {
        "txt": "private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced;"
      },
      {
        "txt": "} boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; }"
      },
      {
        "txt": "if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) {"
      },
      {
        "txt": "hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 819,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 625,
    "end-bug-line": 625,
    "bug": "JSModule module) {",
    "fix": "Var rootVar, JSModule module) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY;"
      },
      {
        "txt": "private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations();"
      },
      {
        "txt": "private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph;"
      },
      {
        "txt": "this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode);"
      },
      {
        "txt": "symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } }"
      },
      {
        "txt": "} } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t ="
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) {"
      },
      {
        "txt": "Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; }"
      },
      {
        "txt": "} private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ?"
      },
      {
        "txt": "parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() &&"
      },
      {
        "txt": "!(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } }"
      },
      {
        "txt": "} else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) {"
      },
      {
        "txt": "break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {"
      },
      {
        "txt": "symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break;"
      },
      {
        "txt": "} } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() &&"
      },
      {
        "txt": "n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) {"
      },
      {
        "txt": "Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t,"
      },
      {
        "txt": "Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) ||"
      },
      {
        "txt": "anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule());"
      },
      {
        "txt": "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty("
      },
      {
        "txt": "key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) {"
      },
      {
        "txt": "symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); }"
      },
      {
        "txt": "} } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {"
      },
      {
        "txt": "return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol { void remove();"
      },
      {
        "txt": "JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {"
      },
      {
        "txt": "Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {"
      },
      {
        "txt": "NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol {"
      },
      {
        "txt": "Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() {"
      },
      {
        "txt": "return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; } }"
      },
      {
        "txt": "private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, <extra_id_0> this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; }"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; } } private class NameContext {"
      },
      {
        "txt": "final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>();"
      },
      {
        "txt": "private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() {"
      },
      {
        "txt": "return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef;"
      },
      {
        "txt": "if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; }"
      },
      {
        "txt": "} return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 820,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 630,
    "end-bug-line": 630,
    "bug": "",
    "fix": "this.rootVar = rootVar;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph;"
      },
      {
        "txt": "private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();"
      },
      {
        "txt": "AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else {"
      },
      {
        "txt": "firstModule = null; } globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo);"
      },
      {
        "txt": "} else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() {"
      },
      {
        "txt": "List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else {"
      },
      {
        "txt": "NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode));"
      },
      {
        "txt": "} @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode));"
      },
      {
        "txt": "} return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) {"
      },
      {
        "txt": "addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null;"
      },
      {
        "txt": "propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) {"
      },
      {
        "txt": "if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); }"
      },
      {
        "txt": "} } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } }"
      },
      {
        "txt": "} } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type);"
      },
      {
        "txt": "NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); }"
      },
      {
        "txt": "} private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)"
      },
      {
        "txt": "&& n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; }"
      },
      {
        "txt": "} } return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null &&"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; }"
      },
      {
        "txt": "return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) &&"
      },
      {
        "txt": "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext();"
      },
      {
        "txt": "if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } }"
      },
      {
        "txt": "break; } } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override"
      },
      {
        "txt": "public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } }"
      },
      {
        "txt": "return false; } } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR;"
      },
      {
        "txt": "} class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); }"
      },
      {
        "txt": "} @Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else {"
      },
      {
        "txt": "return nameNode.getChildAtIndex(1); } } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode;"
      },
      {
        "txt": "private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign;"
      },
      {
        "txt": "LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; <extra_id_0> } @Override public void remove() { map.removeChild(key); } @Override"
      },
      {
        "txt": "} @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; }"
      },
      {
        "txt": "} class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; }"
      },
      {
        "txt": "@Override public String toString() { return name; } boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) {"
      },
      {
        "txt": "referenced = true; hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive("
      },
      {
        "txt": "deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef;"
      },
      {
        "txt": "} Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 821,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 634,
    "end-bug-line": 634,
    "bug": "",
    "fix": "public Var getRootVar() { return rootVar; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack;"
      },
      {
        "txt": "class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\");"
      },
      {
        "txt": "private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) {"
      },
      {
        "txt": "this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null);"
      },
      {
        "txt": "externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo);"
      },
      {
        "txt": "} } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); }"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result;"
      },
      {
        "txt": "} private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo);"
      },
      {
        "txt": "return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY)));"
      },
      {
        "txt": "} else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) {"
      },
      {
        "txt": "if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) ||"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name;"
      },
      {
        "txt": "if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() &&"
      },
      {
        "txt": "(NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty ="
      },
      {
        "txt": "n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false;"
      },
      {
        "txt": "} private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add("
      },
      {
        "txt": "new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty("
      },
      {
        "txt": "grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {"
      },
      {
        "txt": "String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } }"
      },
      {
        "txt": "private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule,"
      },
      {
        "txt": "getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef();"
      },
      {
        "txt": "if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } }"
      },
      {
        "txt": "interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode;"
      },
      {
        "txt": "private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } }"
      },
      {
        "txt": "} interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) {"
      },
      {
        "txt": "this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override <extra_id_0> public void remove() { map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild();"
      },
      {
        "txt": "public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo {"
      },
      {
        "txt": "final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() {"
      },
      {
        "txt": "return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true;"
      },
      {
        "txt": "} if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); }"
      },
      {
        "txt": "if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() {"
      },
      {
        "txt": "return declarations; } }"
      }
    ]
  },
  {
    "id": 822,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 635,
    "end-bug-line": 635,
    "bug": "",
    "fix": "@Override",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack;"
      },
      {
        "txt": "class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\");"
      },
      {
        "txt": "private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) {"
      },
      {
        "txt": "this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null);"
      },
      {
        "txt": "externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo);"
      },
      {
        "txt": "} } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); }"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result;"
      },
      {
        "txt": "} private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo);"
      },
      {
        "txt": "return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY)));"
      },
      {
        "txt": "} else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);"
      },
      {
        "txt": "} } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) {"
      },
      {
        "txt": "if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) ||"
      },
      {
        "txt": "isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name;"
      },
      {
        "txt": "if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() &&"
      },
      {
        "txt": "(NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty ="
      },
      {
        "txt": "n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false;"
      },
      {
        "txt": "} private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add("
      },
      {
        "txt": "new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty("
      },
      {
        "txt": "grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {"
      },
      {
        "txt": "String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } }"
      },
      {
        "txt": "private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule,"
      },
      {
        "txt": "getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef();"
      },
      {
        "txt": "if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } }"
      },
      {
        "txt": "interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode;"
      },
      {
        "txt": "private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } }"
      },
      {
        "txt": "} interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node;"
      },
      {
        "txt": "this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); }"
      },
      {
        "txt": "@Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) {"
      },
      {
        "txt": "this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override <extra_id_0> map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); }"
      },
      {
        "txt": "return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name;"
      },
      {
        "txt": "private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced;"
      },
      {
        "txt": "} boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; }"
      },
      {
        "txt": "if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) {"
      },
      {
        "txt": "hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 823,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 664,
    "end-bug-line": 664,
    "bug": "Scope scope;",
    "fix": "final Scope scope;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule;"
      },
      {
        "txt": "private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler,"
      },
      {
        "txt": "JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null;"
      },
      {
        "txt": "} globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else {"
      },
      {
        "txt": "for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot,"
      },
      {
        "txt": "new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values());"
      },
      {
        "txt": "result.addAll(varNameInfo.values()); return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name);"
      },
      {
        "txt": "map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) {"
      },
      {
        "txt": "symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);"
      },
      {
        "txt": "} else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {"
      },
      {
        "txt": "if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null &&"
      },
      {
        "txt": "var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } }"
      },
      {
        "txt": "} else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } }"
      },
      {
        "txt": "} if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null;"
      },
      {
        "txt": "for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } }"
      },
      {
        "txt": "private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp()"
      },
      {
        "txt": "&& assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } }"
      },
      {
        "txt": "} return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {"
      },
      {
        "txt": "String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false;"
      },
      {
        "txt": "} private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {"
      },
      {
        "txt": "String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) {"
      },
      {
        "txt": "for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break;"
      },
      {
        "txt": "} } private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {"
      },
      {
        "txt": "if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false;"
      },
      {
        "txt": "} } interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; }"
      },
      {
        "txt": "class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; }"
      },
      {
        "txt": "@Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } }"
      },
      {
        "txt": "@Override public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1);"
      },
      {
        "txt": "} } } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module;"
      },
      {
        "txt": "AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() {"
      },
      {
        "txt": "return getAssignNode().getFirstChild().getFirstChild(); } @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module;"
      },
      {
        "txt": "LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() {"
      },
      {
        "txt": "map.removeChild(key); } @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; }"
      },
      {
        "txt": "public JSModule getModule() { return module; } } private class NameContext { final NameInfo name; <extra_id_0> NameContext(NameInfo name) { this.name = name; } } class NameInfo { final String name;"
      },
      {
        "txt": "class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; }"
      },
      {
        "txt": "boolean isReferenced() { return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true;"
      },
      {
        "txt": "hasChanged = true; } if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module);"
      },
      {
        "txt": "} if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; }"
      },
      {
        "txt": "Deque<Symbol> getDeclarations() { return declarations; } }"
      }
    ]
  },
  {
    "id": 824,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 666,
    "end-bug-line": 666,
    "bug": "NameContext(NameInfo name) {",
    "fix": "NameContext(NameInfo name, Scope scope) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass { private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES ="
      },
      {
        "txt": "ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph = LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns,"
      },
      {
        "txt": "boolean anchorUnusedVars) { this.compiler = compiler; this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; }"
      },
      {
        "txt": "globalNode.markReference(null); externNode.markReference(null); symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, module, nameInfo); } } } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties());"
      },
      {
        "txt": "} NodeTraversal.traverse(compiler, root, new ProcessProperties()); FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values());"
      },
      {
        "txt": "return result; } private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo);"
      },
      {
        "txt": "symbolGraph.createNode(nameInfo); return nameInfo; } } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName("
      },
      {
        "txt": "n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else {"
      },
      {
        "txt": "addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) {"
      },
      {
        "txt": "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {"
      },
      {
        "txt": "if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){"
      },
      {
        "txt": "for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } }"
      },
      {
        "txt": "if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) {"
      },
      {
        "txt": "def = symbolStack.get(i).name; if (def != anonymousNode) { break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {"
      },
      {
        "txt": "return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {"
      },
      {
        "txt": "boolean isChainedProperty = n.getFirstChild().isGetProp(); if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } }"
      },
      {
        "txt": "return false; } private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString();"
      },
      {
        "txt": "getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; }"
      },
      {
        "txt": "private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString();"
      },
      {
        "txt": "Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild();"
      },
      {
        "txt": "key != null; key = key.getNext()) { String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; }"
      },
      {
        "txt": "} private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) {"
      },
      {
        "txt": "symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY)); } } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) {"
      },
      {
        "txt": "JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null && moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; }"
      },
      {
        "txt": "} interface Symbol { void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol {"
      },
      {
        "txt": "private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override"
      },
      {
        "txt": "public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override"
      },
      {
        "txt": "public JSModule getModule() { return module; } public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); }"
      },
      {
        "txt": "} } interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) {"
      },
      {
        "txt": "this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild();"
      },
      {
        "txt": "} @Override public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() {"
      },
      {
        "txt": "return module; } } static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign,"
      },
      {
        "txt": "JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key);"
      },
      {
        "txt": "} @Override public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override"
      },
      {
        "txt": "return module; } } private class NameContext { final NameInfo name; Scope scope; <extra_id_0> this.name = name; } } class NameInfo { final String name; private boolean referenced = false;"
      },
      {
        "txt": "final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() {"
      },
      {
        "txt": "return referenced; } boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true;"
      },
      {
        "txt": "} if (moduleGraph != null) { JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); }"
      },
      {
        "txt": "if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true; } } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() {"
      },
      {
        "txt": "return declarations; } }"
      }
    ]
  },
  {
    "id": 825,
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
    "start-bug-line": 668,
    "end-bug-line": 668,
    "bug": "",
    "fix": "this.scope = scope;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Collection; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; class AnalyzePrototypeProperties implements CompilerPass {"
      },
      {
        "txt": "private final SymbolType PROPERTY = SymbolType.PROPERTY; private final SymbolType VAR = SymbolType.VAR; private final AbstractCompiler compiler; private final boolean canModifyExterns; private final boolean anchorUnusedVars; private final JSModuleGraph moduleGraph; private final JSModule firstModule; private static final Set<String> IMPLICITLY_USED_PROPERTIES = ImmutableSet.of(\"length\", \"toString\", \"valueOf\"); private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph ="
      },
      {
        "txt": "LinkedDirectedGraph.createWithoutAnnotations(); private final NameInfo globalNode = new NameInfo(\"[global]\"); private final NameInfo externNode = new NameInfo(\"[extern]\"); private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\"); private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap(); private final Map<String, NameInfo> varNameInfo = Maps.newHashMap(); AnalyzePrototypeProperties(AbstractCompiler compiler, JSModuleGraph moduleGraph, boolean canModifyExterns, boolean anchorUnusedVars) { this.compiler = compiler;"
      },
      {
        "txt": "this.moduleGraph = moduleGraph; this.canModifyExterns = canModifyExterns; this.anchorUnusedVars = anchorUnusedVars; if (moduleGraph != null) { firstModule = moduleGraph.getRootModule(); } else { firstModule = null; } globalNode.markReference(null); externNode.markReference(null);"
      },
      {
        "txt": "symbolGraph.createNode(globalNode); symbolGraph.createNode(externNode); for (String property : IMPLICITLY_USED_PROPERTIES) { NameInfo nameInfo = getNameInfoForName(property, PROPERTY); if (moduleGraph == null) { symbolGraph.connect(externNode, null, nameInfo); } else { for (JSModule module : moduleGraph.getAllModules()) { symbolGraph.connect(externNode, module, nameInfo); }"
      },
      {
        "txt": "} } } @Override public void process(Node externRoot, Node root) { if (!canModifyExterns) { NodeTraversal.traverse(compiler, externRoot, new ProcessExternProperties()); } NodeTraversal.traverse(compiler, root, new ProcessProperties());"
      },
      {
        "txt": "FixedPointGraphTraversal<NameInfo, JSModule> t = FixedPointGraphTraversal.newTraversal(new PropagateReferences()); t.computeFixedPoint(symbolGraph, Sets.newHashSet(externNode, globalNode)); } public Collection<NameInfo> getAllNameInfo() { List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values()); result.addAll(varNameInfo.values()); return result; }"
      },
      {
        "txt": "private NameInfo getNameInfoForName(String name, SymbolType type) { Map<String, NameInfo> map = type == PROPERTY ? propertyNameInfo : varNameInfo; if (map.containsKey(name)) { return map.get(name); } else { NameInfo nameInfo = new NameInfo(name); map.put(name, nameInfo); symbolGraph.createNode(nameInfo); return nameInfo;"
      },
      {
        "txt": "} } private class ProcessProperties implements NodeTraversal.ScopedCallback { private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope();"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) {"
      },
      {
        "txt": "String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\"prototype\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( \"prototype\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (!propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); }"
      },
      {
        "txt": "} } else if (n.isName()) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent,"
      },
      {
        "txt": "parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()){ for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i);"
      },
      {
        "txt": "if (context.scope == var.getScope()) { break; } context.name.readClosureVariables = true; } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) ||"
      },
      {
        "txt": "n.isFunction()) { symbolStack.pop(); } } private void addSymbolUse(String name, JSModule module, SymbolType type) { NameInfo info = getNameInfoForName(name, type); NameInfo def = null; for (int i = symbolStack.size() - 1; i >= 0; i--) { def = symbolStack.get(i).name; if (def != anonymousNode) {"
      },
      {
        "txt": "break; } } if (!def.equals(info)) { symbolGraph.connect(def, module, info); } } private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) ||"
      },
      {
        "txt": "n.isFunction() && n.getParent().isName()); } private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp();"
      },
      {
        "txt": "if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals(\"prototype\")) { return true; } } } return false; }"
      },
      {
        "txt": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule()));"
      },
      {
        "txt": "if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } return true; } return false; } private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.GETPROP: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent(); Node grandParent = parent.getParent(); if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { String name = dest.getString(); Property prop = new AssignmentProperty( grandParent,"
      },
      {
        "txt": "t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break; case Token.ASSIGN: Node map = n.getFirstChild().getNext(); if (map.isObjectLit()) { for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { String name = key.getString();"
      },
      {
        "txt": "Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module,"
      },
      {
        "txt": "SymbolType type) { symbolGraph.connect(globalNode, module, getNameInfoForName(name, type)); } } private class ProcessExternProperties extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isGetProp()) { symbolGraph.connect(externNode, firstModule, getNameInfoForName(n.getLastChild().getString(), PROPERTY));"
      },
      {
        "txt": "} } } private class PropagateReferences implements EdgeCallback<NameInfo, JSModule> { @Override public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) { if (start.isReferenced()) { JSModule startModule = start.getDeepestCommonModuleRef(); if (startModule != null &&"
      },
      {
        "txt": "moduleGraph.dependsOn(startModule, edge)) { return dest.markReference(startModule); } else { return dest.markReference(edge); } } return false; } } interface Symbol {"
      },
      {
        "txt": "void remove(); JSModule getModule(); } private enum SymbolType { PROPERTY, VAR; } class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module;"
      },
      {
        "txt": "GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent();"
      },
      {
        "txt": "if (parent.isFunction() || parent.hasOneChild()) { NodeUtil.removeChild(parent.getParent(), parent); } else { Preconditions.checkState(parent.isVar()); parent.removeChild(nameNode); } } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} public Node getFunctionNode() { Node parent = nameNode.getParent(); if (parent.isFunction()) { return parent; } else { return nameNode.getChildAtIndex(1); } } }"
      },
      {
        "txt": "interface Property extends Symbol { Node getPrototype(); Node getValue(); } static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module;"
      },
      {
        "txt": "} @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); } @Override public Node getPrototype() { return getAssignNode().getFirstChild().getFirstChild(); } @Override"
      },
      {
        "txt": "public Node getValue() { return getAssignNode().getLastChild(); } private Node getAssignNode() { return exprNode.getFirstChild(); } @Override public JSModule getModule() { return module; }"
      },
      {
        "txt": "} static class LiteralProperty implements Property { private final Node key; private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key;"
      },
      {
        "txt": "this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); } @Override"
      },
      {
        "txt": "public Node getPrototype() { return assign.getFirstChild(); } @Override public Node getValue() { return value; } @Override public JSModule getModule() { return module;"
      },
      {
        "txt": "} private class NameContext { final NameInfo name; Scope scope; NameContext(NameInfo name) { this.name = name; <extra_id_0> } class NameInfo { final String name; private boolean referenced = false; private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null;"
      },
      {
        "txt": "private final Deque<Symbol> declarations = new ArrayDeque<Symbol>(); private JSModule deepestCommonModuleRef = null; private boolean readClosureVariables = false; NameInfo(String name) { this.name = name; } @Override public String toString() { return name; } boolean isReferenced() { return referenced; }"
      },
      {
        "txt": "boolean readsClosureVariables() { return readClosureVariables; } boolean markReference(JSModule module) { boolean hasChanged = false; if (!referenced) { referenced = true; hasChanged = true; } if (moduleGraph != null) {"
      },
      {
        "txt": "JSModule originalDeepestCommon = deepestCommonModuleRef; if (deepestCommonModuleRef == null) { deepestCommonModuleRef = module; } else { deepestCommonModuleRef = moduleGraph.getDeepestCommonDependencyInclusive( deepestCommonModuleRef, module); } if (originalDeepestCommon != deepestCommonModuleRef) { hasChanged = true;"
      },
      {
        "txt": "} } return hasChanged; } JSModule getDeepestCommonModuleRef() { return deepestCommonModuleRef; } Deque<Symbol> getDeclarations() { return declarations; }"
      }
    ]
  },
  {
    "id": 826,
    "file_path": "src/com/google/javascript/jscomp/CrossModuleMethodMotion.java",
    "start-bug-line": 141,
    "end-bug-line": 141,
    "bug": "",
    "fix": "if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) { continue; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.javascript.jscomp.AnalyzePrototypeProperties.NameInfo; import com.google.javascript.jscomp.AnalyzePrototypeProperties.Property; import com.google.javascript.jscomp.AnalyzePrototypeProperties.Symbol; import com.google.javascript.rhino.IR;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import java.io.Serializable; import java.util.Collection; import java.util.Iterator; import java.util.logging.Logger; class CrossModuleMethodMotion implements CompilerPass { private static final Logger logger = Logger.getLogger(CrossModuleMethodMotion.class.getName()); static final DiagnosticType NULL_COMMON_MODULE_ERROR = DiagnosticType.error( \"JSC_INTERNAL_ERROR_MODULE_DEPEND\","
      },
      {
        "txt": "\"null deepest common module\"); private final AbstractCompiler compiler; private final IdGenerator idGenerator; private final AnalyzePrototypeProperties analyzer; private final JSModuleGraph moduleGraph; static final String STUB_METHOD_NAME = \"JSCompiler_stubMethod\"; static final String UNSTUB_METHOD_NAME = \"JSCompiler_unstubMethod\"; static final String STUB_DECLARATIONS = \"var JSCompiler_stubMap = [];\" + \"function JSCompiler_stubMethod(JSCompiler_stubMethod_id) {\" +"
      },
      {
        "txt": "\" return function() {\" + \" return JSCompiler_stubMap[JSCompiler_stubMethod_id].apply(\" + \" this, arguments);\" + \" };\" + \"}\" + \"function JSCompiler_unstubMethod(\" + \" JSCompiler_unstubMethod_id, JSCompiler_unstubMethod_body) {\" + \" return JSCompiler_stubMap[JSCompiler_unstubMethod_id] = \" + \" JSCompiler_unstubMethod_body;\" + \"}\";"
      },
      {
        "txt": "CrossModuleMethodMotion(AbstractCompiler compiler, IdGenerator idGenerator, boolean canModifyExterns) { this.compiler = compiler; this.idGenerator = idGenerator; this.moduleGraph = compiler.getModuleGraph(); this.analyzer = new AnalyzePrototypeProperties(compiler, moduleGraph, canModifyExterns, false); } @Override public void process(Node externRoot, Node root) {"
      },
      {
        "txt": "if (moduleGraph != null && moduleGraph.getModuleCount() > 1) { analyzer.process(externRoot, root); moveMethods(analyzer.getAllNameInfo()); } } private void moveMethods(Collection<NameInfo> allNameInfo) { boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds(); for (NameInfo nameInfo : allNameInfo) { if (!nameInfo.isReferenced()) { continue;"
      },
      {
        "txt": "} if (nameInfo.readsClosureVariables()) { continue; } JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef(); if (deepestCommonModuleRef == null) { compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR)); continue; } Iterator<Symbol> declarations ="
      },
      {
        "txt": "while (declarations.hasNext()) { Symbol symbol = declarations.next(); if (!(symbol instanceof Property)) { continue; } Property prop = (Property) symbol; <extra_id_0> Node value = prop.getValue(); if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) { Node valueParent = value.getParent(); if (valueParent.isGetterDef() || valueParent.isSetterDef()) {"
      },
      {
        "txt": "if (valueParent.isGetterDef() || valueParent.isSetterDef()) { continue; } Node proto = prop.getPrototype(); int stubId = idGenerator.newId(); Node stubCall = IR.call( IR.name(STUB_METHOD_NAME), IR.number(stubId)) .copyInformationFromForTree(value);"
      },
      {
        "txt": "stubCall.putBooleanProp(Node.FREE_CALL, true); valueParent.replaceChild(value, stubCall); Node unstubParent = compiler.getNodeForCodeInsertion( deepestCommonModuleRef); Node unstubCall = IR.call( IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value); unstubCall.putBooleanProp(Node.FREE_CALL, true); unstubParent.addChildToFront("
      },
      {
        "txt": "IR.exprResult( IR.assign( IR.getprop( proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)) .copyInformationFromForTree(value)); compiler.reportCodeChange(); } }"
      },
      {
        "txt": "} if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) { Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS); compiler.getNodeForCodeInsertion(null).addChildrenToFront( declarations.removeChildren()); } } static class IdGenerator implements Serializable { private static final long serialVersionUID = 0L; private int currentId = 0;"
      },
      {
        "txt": "boolean hasGeneratedAnyIds() { return currentId != 0; } int newId() { return currentId++; } }"
      }
    ]
  }
]