[
  {
    "id": 327,
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
    "start-bug-line": 1413,
    "end-bug-line": 1413,
    "bug": "if (!qVar.isTypeInferred()) {",
    "fix": "ObjectType qVarType = ObjectType.cast(qVar.getType()); if (qVarType != null && rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) { typeRegistry.resetImplicitPrototype( rhsValue.getJSType(), qVarType.getImplicitPrototype()); } else if (!qVar.isTypeInferred()) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP; import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT; import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CodingConvention.DelegateRelationship; import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.CodingConvention.SubclassType;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.InputId; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import java.util.Map; import javax.annotation.Nullable; final class TypedScopeCreator implements ScopeCreator { static final String DELEGATE_PROXY_SUFFIX ="
      },
      {
        "txt": "ObjectType.createDelegateSuffix(\"Proxy\"); static final DiagnosticType MALFORMED_TYPEDEF = DiagnosticType.warning( \"JSC_MALFORMED_TYPEDEF\", \"Typedef for {0} does not have any type information\"); static final DiagnosticType ENUM_INITIALIZER = DiagnosticType.warning( \"JSC_ENUM_INITIALIZER_NOT_ENUM\", \"enum initializer must be an object literal or an enum\"); static final DiagnosticType CTOR_INITIALIZER ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_CTOR_INITIALIZER_NOT_CTOR\", \"Constructor {0} must be initialized at declaration\"); static final DiagnosticType IFACE_INITIALIZER = DiagnosticType.warning( \"JSC_IFACE_INITIALIZER_NOT_IFACE\", \"Interface {0} must be initialized at declaration\"); static final DiagnosticType CONSTRUCTOR_EXPECTED = DiagnosticType.warning( \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\","
      },
      {
        "txt": "\"Constructor expected as first argument\"); static final DiagnosticType UNKNOWN_LENDS = DiagnosticType.warning( \"JSC_UNKNOWN_LENDS\", \"Variable {0} not declared before @lends annotation.\"); static final DiagnosticType LENDS_ON_NON_OBJECT = DiagnosticType.warning( \"JSC_LENDS_ON_NON_OBJECT\", \"May only lend properties to object types. {0} has type {1}.\"); private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final ErrorReporter typeParsingErrorReporter; private final TypeValidator validator; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList(); private final Map<String, String> delegateCallingConventions = Maps.newHashMap(); private class DeferredSetType { final Node node; final JSType type;"
      },
      {
        "txt": "DeferredSetType(Node node, JSType type) { Preconditions.checkNotNull(node); Preconditions.checkNotNull(type); this.node = node; this.type = type; node.setJSType(type); } void resolve(Scope scope) { node.setJSType(type.resolve(typeParsingErrorReporter, scope)); }"
      },
      {
        "txt": "} TypedScopeCreator(AbstractCompiler compiler) { this(compiler, compiler.getCodingConvention()); } TypedScopeCreator(AbstractCompiler compiler, CodingConvention codingConvention) { this.compiler = compiler; this.validator = compiler.getTypeValidator(); this.codingConvention = codingConvention; this.typeRegistry = compiler.getTypeRegistry();"
      },
      {
        "txt": "this.typeParsingErrorReporter = typeRegistry.getErrorReporter(); } @Override public Scope createScope(Node root, Scope parent) { Scope newScope = null; AbstractScopeBuilder scopeBuilder = null; if (parent == null) { newScope = createInitialScope(root); GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope); scopeBuilder = globalScopeBuilder;"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, scopeBuilder); } else { newScope = new Scope(parent, root); LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope); scopeBuilder = localScopeBuilder; localScopeBuilder.build(); } scopeBuilder.resolveStubDeclarations(); scopeBuilder.resolveTypes(); for (Node functionNode : scopeBuilder.nonExternFunctions) {"
      },
      {
        "txt": "JSType type = functionNode.getJSType(); if (type != null && type.isFunctionType()) { FunctionType fnType = type.toMaybeFunctionType(); ObjectType fnThisType = fnType.getTypeOfThis(); if (!fnThisType.isUnknownType()) { NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType)); } } }"
      },
      {
        "txt": "if (parent == null) { codingConvention.defineDelegateProxyPrototypeProperties( typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions); } return newScope; } void patchGlobalScope(Scope globalScope, Node scriptRoot) { Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT); Preconditions.checkNotNull(globalScope);"
      },
      {
        "txt": "Preconditions.checkState(globalScope.isGlobal()); String scriptName = NodeUtil.getSourceName(scriptRoot); Preconditions.checkNotNull(scriptName); Iterator<Var> varIter = globalScope.getVars(); List<Var> varsToRemove = Lists.newArrayList(); while (varIter.hasNext()) { Var oldVar = varIter.next(); if (scriptName.equals(oldVar.getInputName())) { varsToRemove.add(oldVar); }"
      },
      {
        "txt": "} for (Var var : varsToRemove) { globalScope.undeclare(var); } GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(globalScope); NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder); } @VisibleForTesting Scope createInitialScope(Node root) { NodeTraversal.traverse("
      },
      {
        "txt": "compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry)); Scope s = new Scope(root, compiler); declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE); declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, DATE_FUNCTION_TYPE); declareNativeFunctionType(s, ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE); declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE); declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE); declareNativeValueType(s, \"undefined\", VOID_TYPE); declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE); return s;"
      },
      {
        "txt": "} private void declareNativeFunctionType(Scope scope, JSTypeNative tId) { FunctionType t = typeRegistry.getNativeFunctionType(tId); declareNativeType(scope, t.getInstanceType().getReferenceName(), t); declareNativeType( scope, t.getPrototype().getReferenceName(), t.getPrototype()); } private void declareNativeValueType(Scope scope, String name, JSTypeNative tId) { declareNativeType(scope, name, typeRegistry.getNativeType(tId));"
      },
      {
        "txt": "} private void declareNativeType(Scope scope, String name, JSType t) { scope.declare(name, null, t, null, false); } private static class DiscoverEnumsAndTypedefs extends AbstractShallowStatementCallback { private final JSTypeRegistry registry; DiscoverEnumsAndTypedefs(JSTypeRegistry registry) { this.registry = registry; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node node, Node parent) { Node nameNode = null; switch (node.getType()) { case Token.VAR: for (Node child = node.getFirstChild(); child != null; child = child.getNext()) { identifyNameNode( child, child.getFirstChild(), NodeUtil.getInfoForNameNode(child));"
      },
      {
        "txt": "} break; case Token.EXPR_RESULT: Node firstChild = node.getFirstChild(); if (firstChild.getType() == Token.ASSIGN) { identifyNameNode( firstChild.getFirstChild(), firstChild.getLastChild(), firstChild.getJSDocInfo()); } else { identifyNameNode("
      },
      {
        "txt": "firstChild, null, firstChild.getJSDocInfo()); } break; } } private void identifyNameNode( Node nameNode, Node valueNode, JSDocInfo info) { if (nameNode.isQualifiedName()) { if (info != null) { if (info.hasEnumParameterType()) {"
      },
      {
        "txt": "registry.identifyNonNullableName(nameNode.getQualifiedName()); } else if (info.hasTypedefType()) { registry.identifyNonNullableName(nameNode.getQualifiedName()); } } } } } private JSType getNativeType(JSTypeNative nativeType) { return typeRegistry.getNativeType(nativeType);"
      },
      {
        "txt": "} private abstract class AbstractScopeBuilder implements NodeTraversal.Callback { final Scope scope; private final List<DeferredSetType> deferredSetTypes = Lists.newArrayList(); private final List<Node> nonExternFunctions = Lists.newArrayList(); private final List<StubDeclaration> stubDeclarations = Lists.newArrayList(); private String sourceName = null;"
      },
      {
        "txt": "private InputId inputId; private AbstractScopeBuilder(Scope scope) { this.scope = scope; } void setDeferredType(Node node, JSType type) { deferredSetTypes.add(new DeferredSetType(node, type)); } void resolveTypes() { for (DeferredSetType deferred : deferredSetTypes) { deferred.resolve(scope);"
      },
      {
        "txt": "} Iterator<Var> vars = scope.getVars(); while (vars.hasNext()) { vars.next().resolveType(typeParsingErrorReporter); } typeRegistry.resolveTypesInScope(scope); } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "inputId = t.getInputId(); if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) { Preconditions.checkNotNull(inputId); sourceName = NodeUtil.getSourceName(n); } boolean descend = parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild() || parent == scope.getRootNode(); if (descend) { if (NodeUtil.isStatementParent(n)) {"
      },
      {
        "txt": "for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (NodeUtil.isHoistedFunctionDeclaration(child)) { defineFunctionLiteral(child, n); } } } } return descend;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { inputId = t.getInputId(); attachLiteralTypes(t, n); switch (n.getType()) { case Token.CALL: checkForClassDefiningCalls(t, n, parent); checkForCallingConventionDefiningCalls(n, delegateCallingConventions); break;"
      },
      {
        "txt": "case Token.FUNCTION: if (t.getInput() == null || !t.getInput().isExtern()) { nonExternFunctions.add(n); } if (!NodeUtil.isHoistedFunctionDeclaration(n)) { defineFunctionLiteral(n, parent); } break; case Token.ASSIGN: Node firstChild = n.getFirstChild();"
      },
      {
        "txt": "if (firstChild.getType() == Token.GETPROP && firstChild.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext()); } break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR:"
      },
      {
        "txt": "defineVar(n, parent); break; case Token.GETPROP: if (parent.getType() == Token.EXPR_RESULT && n.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); } break; } }"
      },
      {
        "txt": "private void attachLiteralTypes(NodeTraversal t, Node n) { switch (n.getType()) { case Token.NULL: n.setJSType(getNativeType(NULL_TYPE)); break; case Token.VOID: n.setJSType(getNativeType(VOID_TYPE)); break; case Token.STRING: if (!NodeUtil.isObjectLitKey(n, n.getParent())) {"
      },
      {
        "txt": "n.setJSType(getNativeType(STRING_TYPE)); } break; case Token.NUMBER: n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.TRUE: case Token.FALSE: n.setJSType(getNativeType(BOOLEAN_TYPE)); break;"
      },
      {
        "txt": "case Token.REGEXP: n.setJSType(getNativeType(REGEXP_TYPE)); break; case Token.REF_SPECIAL: n.setJSType(getNativeType(UNKNOWN_TYPE)); break; case Token.OBJECTLIT: defineObjectLiteral(t, n); break; }"
      },
      {
        "txt": "} private void defineObjectLiteral(NodeTraversal t, Node objectLit) { JSType type = null; JSDocInfo info = objectLit.getJSDocInfo(); if (info != null && info.getLendsName() != null) { String lendsName = info.getLendsName(); Var lendsVar = scope.getVar(lendsName); if (lendsVar == null) { compiler.report("
      },
      {
        "txt": "JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName)); } else { type = lendsVar.getType(); if (type == null) { type = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) { compiler.report( JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT, lendsName, type.toString()));"
      },
      {
        "txt": "type = null; } else { objectLit.setJSType(type); } } } info = NodeUtil.getBestJSDocInfo(objectLit); Node lValue = NodeUtil.getBestLValue(objectLit); String lValueName = NodeUtil.getBestLValueName(lValue); boolean createdEnumType = false;"
      },
      {
        "txt": "if (info != null && info.hasEnumParameterType()) { type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue); createdEnumType = true; } if (type == null) { type = typeRegistry.createAnonymousObjectType(); } setDeferredType(objectLit, type); if (!createdEnumType) { processObjectLitProperties("
      },
      {
        "txt": "t, objectLit, ObjectType.cast(objectLit.getJSType())); } } void processObjectLitProperties( NodeTraversal t, Node objLit, ObjectType objLitType) { for (Node keyNode = objLit.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) { Node value = keyNode.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(keyNode); JSDocInfo info = keyNode.getJSDocInfo();"
      },
      {
        "txt": "JSType valueType = getDeclaredType( t.getSourceName(), info, keyNode, value); JSType keyType = NodeUtil.getObjectLitKeyTypeFromValueType( keyNode, valueType); if (keyType != null) { String qualifiedName = NodeUtil.getBestLValueName(keyNode); if (qualifiedName != null) { defineSlot(keyNode, objLit, qualifiedName, keyType, false); } else { setDeferredType(keyNode, keyType);"
      },
      {
        "txt": "} if (objLitType != null) { boolean isExtern = t.getInput() != null && t.getInput().isExtern(); objLitType.defineDeclaredProperty( memberName, keyType, keyNode); } } } } private JSType getDeclaredTypeInAnnotation(String sourceName,"
      },
      {
        "txt": "Node node, JSDocInfo info) { JSType jsType = null; Node objNode = node.getType() == Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null; if (info != null) { if (info.hasType()) { jsType = info.getType().evaluate(scope, typeRegistry); } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {"
      },
      {
        "txt": "String fnName = node.getQualifiedName(); jsType = createFunctionTypeFromNodes( null, fnName, info, node); } } return jsType; } void assertDefinitionNode(Node n, int type) { Preconditions.checkState(sourceName != null); Preconditions.checkState(n.getType() == type);"
      },
      {
        "txt": "} void defineCatch(Node n, Node parent) { assertDefinitionNode(n, Token.CATCH); Node catchName = n.getFirstChild(); defineSlot(catchName, n, null); } void defineVar(Node n, Node parent) { assertDefinitionNode(n, Token.VAR); JSDocInfo info = n.getJSDocInfo(); if (n.hasMoreThanOneChild()) {"
      },
      {
        "txt": "if (info != null) { compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF)); } for (Node name : n.children()) { defineName(name, n, parent, name.getJSDocInfo()); } } else { Node name = n.getFirstChild(); defineName(name, n, parent, (info != null) ? info : name.getJSDocInfo());"
      },
      {
        "txt": "} } void defineFunctionLiteral(Node n, Node parent) { assertDefinitionNode(n, Token.FUNCTION); Node lValue = NodeUtil.getBestLValue(n); JSDocInfo info = NodeUtil.getBestJSDocInfo(n); String functionName = NodeUtil.getBestLValueName(lValue); FunctionType functionType = createFunctionTypeFromNodes(n, functionName, info, lValue); setDeferredType(n, functionType);"
      },
      {
        "txt": "if (NodeUtil.isFunctionDeclaration(n)) { defineSlot(n.getFirstChild(), n, functionType); } } private void defineName(Node name, Node var, Node parent, JSDocInfo info) { Node value = name.getFirstChild(); JSType type = getDeclaredType(sourceName, info, name, value); if (type == null) { type = name.isFromExterns() ? getNativeType(UNKNOWN_TYPE) : null;"
      },
      {
        "txt": "} defineSlot(name, var, type); } private boolean shouldUseFunctionLiteralType( FunctionType type, JSDocInfo info, Node lValue) { if (info != null) { return true; } if (lValue != null && NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {"
      },
      {
        "txt": "return false; } return scope.isGlobal() || !type.isReturnTypeInferred(); } private FunctionType createFunctionTypeFromNodes( @Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) { FunctionType functionType = null;"
      },
      {
        "txt": "if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) { Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() != null && var.getType().isFunctionType()) { FunctionType aliasedType = var.getType().toMaybeFunctionType(); if ((aliasedType.isConstructor() || aliasedType.isInterface()) && !aliasedType.isNativeObjectType()) { functionType = aliasedType; if (name != null && scope.isGlobal()) { typeRegistry.declareType(name, functionType.getInstanceType());"
      },
      {
        "txt": "} } } } if (functionType == null) { Node errorRoot = rValue == null ? lvalueNode : rValue; boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION; Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ?"
      },
      {
        "txt": "rValue.getFirstChild().getNext() : null; Node fnBlock = isFnLiteral ? parametersNode.getNext() : null; if (info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry); type = type.restrictByNotNullOrUndefined(); if (type.isFunctionType()) { functionType = type.toMaybeFunctionType(); functionType.setJSDocInfo(info); } }"
      },
      {
        "txt": "if (functionType == null) { Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode); String ownerName = NodeUtil.getBestLValueName(ownerNode); Var ownerVar = null; String propName = null; ObjectType ownerType = null; if (ownerName != null) { ownerVar = scope.getVar(ownerName); if (ownerVar != null) { ownerType = ObjectType.cast(ownerVar.getType());"
      },
      {
        "txt": "} if (name != null) { propName = name.substring(ownerName.length() + 1); } } FunctionType overriddenPropType = null; if (ownerType != null && propName != null) { overriddenPropType = findOverriddenFunction(ownerType, propName); }"
      },
      {
        "txt": "FunctionTypeBuilder builder = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferFromOverriddenFunction(overriddenPropType, parametersNode) .inferTemplateTypeName(info) .inferReturnType(info) .inferInheritance(info); boolean searchedForThisType = false; if (ownerType != null && ownerType.isFunctionPrototypeType()) {"
      },
      {
        "txt": "builder.inferThisType( info, ownerType.getOwnerFunction().getInstanceType()); searchedForThisType = true; } else if (ownerNode != null && ownerNode.getType() == Token.THIS) { builder.inferThisType(info, ownerNode.getJSType()); searchedForThisType = true; } if (!searchedForThisType) { builder.inferThisType(info); }"
      },
      {
        "txt": "functionType = builder .inferParameterTypes(parametersNode, info) .inferReturnStatementsAsLastResort(fnBlock) .buildAndRegister(); } } return functionType; } private FunctionType findOverriddenFunction( ObjectType ownerType, String propName) {"
      },
      {
        "txt": "JSType propType = ownerType.getPropertyType(propName); if (propType != null && propType.isFunctionType()) { return propType.toMaybeFunctionType(); } else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName); if (propType != null && propType.isFunctionType()) { return propType.toMaybeFunctionType(); }"
      },
      {
        "txt": "} } return null; } private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) { Preconditions.checkNotNull(info); Preconditions.checkState(info.hasEnumParameterType()); EnumType enumType = null; if (rValue != null && rValue.isQualifiedName()) {"
      },
      {
        "txt": "Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() instanceof EnumType) { enumType = (EnumType) var.getType(); } } if (enumType == null) { JSType elementsType = info.getEnumParameterType().evaluate(scope, typeRegistry); enumType = typeRegistry.createEnumType(name, elementsType); if (rValue != null && rValue.getType() == Token.OBJECTLIT) {"
      },
      {
        "txt": "Node key = rValue.getFirstChild(); while (key != null) { String keyName = NodeUtil.getStringValue(key); if (keyName == null) { compiler.report( JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else if (enumType.hasOwnProperty(keyName)) { compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName)); } else if (!codingConvention.isValidEnumKey(keyName)) { compiler.report("
      },
      {
        "txt": "JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else { enumType.defineElement(keyName, key); } key = key.getNext(); } } } if (name != null && scope.isGlobal()) { typeRegistry.declareType(name, enumType.getElementsType());"
      },
      {
        "txt": "} return enumType; } private void defineSlot(Node name, Node parent, JSType type) { defineSlot(name, parent, type, type == null); } void defineSlot(Node n, Node parent, JSType type, boolean inferred) { Preconditions.checkArgument(inferred || type != null); if (n.getType() == Token.NAME) { Preconditions.checkArgument("
      },
      {
        "txt": "parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH); } else { Preconditions.checkArgument( n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT)); }"
      },
      {
        "txt": "defineSlot(n, parent, n.getQualifiedName(), type, inferred); } void defineSlot(Node n, Node parent, String variableName, JSType type, boolean inferred) { Preconditions.checkArgument(!variableName.isEmpty()); boolean isGlobalVar = n.getType() == Token.NAME && scope.isGlobal(); boolean shouldDeclareOnGlobalThis = isGlobalVar && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);"
      },
      {
        "txt": "Scope scopeToDeclareIn = scope; if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } } if (scopeToDeclareIn.isDeclared(variableName, false)) { Var oldVar = scopeToDeclareIn.getVar(variableName);"
      },
      {
        "txt": "validator.expectUndeclaredVariable( sourceName, n, parent, oldVar, variableName, type); } else { if (!inferred) { setDeferredType(n, type); } CompilerInput input = compiler.getInput(inputId); boolean isExtern = n.isFromExterns(); Var newVar = scopeToDeclareIn.declare(variableName, n, type, input, inferred);"
      },
      {
        "txt": "if (type instanceof EnumType) { Node initialValue = newVar.getInitialValue(); boolean isValidValue = initialValue != null && (initialValue.getType() == Token.OBJECTLIT || initialValue.isQualifiedName()); if (!isValidValue) { compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER)); } } FunctionType fnType = JSType.toMaybeFunctionType(type);"
      },
      {
        "txt": "if (fnType != null && !type.isEmptyType()) { if ((fnType.isConstructor() || fnType.isInterface()) && !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) { FunctionType superClassCtor = fnType.getSuperClassConstructor(); scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor == null || superClassCtor.getInstanceType().equals( getNativeType(OBJECT_TYPE)));"
      },
      {
        "txt": "if (newVar.getInitialValue() == null && !isExtern && variableName.equals( fnType.getInstanceType().getReferenceName())) { compiler.report( JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName)); }"
      },
      {
        "txt": "} } } if (shouldDeclareOnGlobalThis) { ObjectType globalThis = typeRegistry.getNativeObjectType(GLOBAL_THIS); if (inferred) { globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) :"
      },
      {
        "txt": "type, n); } else { globalThis.defineDeclaredProperty(variableName, type, n); } } if (isGlobalVar && \"Window\".equals(variableName) && type != null && type.isFunctionType() && type.isConstructor()) {"
      },
      {
        "txt": "FunctionType globalThisCtor = typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor(); globalThisCtor.getInstanceType().clearCachedValues(); globalThisCtor.getPrototype().clearCachedValues(); globalThisCtor .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType()); } } private boolean isQnameRootedInGlobalScope(Node n) { Node root = NodeUtil.getRootOfQualifiedName(n);"
      },
      {
        "txt": "if (root.getType() == Token.NAME) { Var var = scope.getVar(root.getString()); if (var != null) { return var.isGlobal(); } } return false; } private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {"
      },
      {
        "txt": "if (info != null && info.hasType()) { return getDeclaredTypeInAnnotation(sourceName, lValue, info); } else if (rValue != null && rValue.getType() == Token.FUNCTION && shouldUseFunctionLiteralType( JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) { return rValue.getJSType(); } else if (info != null) { if (info.hasEnumParameterType()) { if (rValue != null && rValue.getType() == Token.OBJECTLIT) { return rValue.getJSType();"
      },
      {
        "txt": "} else { return createEnumTypeFromNodes( rValue, lValue.getQualifiedName(), info, lValue); } } else if (info.isConstructor() || info.isInterface()) { return createFunctionTypeFromNodes( rValue, lValue.getQualifiedName(), info, lValue); } else { if (info.isConstant()) { JSType knownType = null;"
      },
      {
        "txt": "if (rValue != null) { if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { return rValue.getJSType(); } else if (rValue.getType() == Token.OR) { Node firstClause = rValue.getFirstChild(); Node secondClause = firstClause.getNext(); boolean namesMatch = firstClause.getType() == Token.NAME && lValue.getType() == Token.NAME && firstClause.getString().equals(lValue.getString());"
      },
      {
        "txt": "if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) { return secondClause.getJSType(); } } } } } } return getDeclaredTypeInAnnotation(sourceName, lValue, info);"
      },
      {
        "txt": "} private FunctionType getFunctionType(@Nullable Var v) { JSType t = v == null ? null : v.getType(); ObjectType o = t == null ? null : t.dereference(); return JSType.toMaybeFunctionType(o); } private void checkForCallingConventionDefiningCalls( Node n, Map<String, String> delegateCallingConventions) { codingConvention.checkForCallingConventionDefiningCalls(n, delegateCallingConventions);"
      },
      {
        "txt": "} private void checkForClassDefiningCalls( NodeTraversal t, Node n, Node parent) { SubclassRelationship relationship = codingConvention.getClassesDefinedByCall(n); if (relationship != null) { FunctionType superCtor = getFunctionType( scope.getVar(relationship.superclassName)); FunctionType subCtor = getFunctionType( scope.getVar(relationship.subclassName));"
      },
      {
        "txt": "if (superCtor != null && superCtor.isConstructor() && subCtor != null && subCtor.isConstructor()) { ObjectType superClass = superCtor.getInstanceType(); ObjectType subClass = subCtor.getInstanceType(); superCtor = superClass.getConstructor(); subCtor = subClass.getConstructor(); if (relationship.type == SubclassType.INHERITS && !superClass.isEmptyType() && !subClass.isEmptyType()) { validator.expectSuperType(t, n, superClass, subClass); }"
      },
      {
        "txt": "if (superCtor != null && subCtor != null) { codingConvention.applySubclassRelationship( superCtor, subCtor, relationship.type); } } } String singletonGetterClassName = codingConvention.getSingletonGetterClassName(n); if (singletonGetterClassName != null) { ObjectType objectType = ObjectType.cast("
      },
      {
        "txt": "typeRegistry.getType(singletonGetterClassName)); if (objectType != null) { FunctionType functionType = objectType.getConstructor(); if (functionType != null) { FunctionType getterType = typeRegistry.createFunctionType(objectType); codingConvention.applySingletonGetter(functionType, getterType, objectType); } }"
      },
      {
        "txt": "} DelegateRelationship delegateRelationship = codingConvention.getDelegateRelationship(n); if (delegateRelationship != null) { applyDelegateRelationship(delegateRelationship); } ObjectLiteralCast objectLiteralCast = codingConvention.getObjectLiteralCast(t, n); if (objectLiteralCast != null) { ObjectType type = ObjectType.cast("
      },
      {
        "txt": "typeRegistry.getType(objectLiteralCast.typeName)); if (type != null && type.getConstructor() != null) { setDeferredType(objectLiteralCast.objectNode, type); } else { compiler.report(JSError.make(t.getSourceName(), n, CONSTRUCTOR_EXPECTED)); } } } private void applyDelegateRelationship("
      },
      {
        "txt": "DelegateRelationship delegateRelationship) { ObjectType delegatorObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegator)); ObjectType delegateBaseObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegateBase)); ObjectType delegateSuperObject = ObjectType.cast( typeRegistry.getType(codingConvention.getDelegateSuperclassName())); if (delegatorObject != null && delegateBaseObject != null && delegateSuperObject != null) {"
      },
      {
        "txt": "FunctionType delegatorCtor = delegatorObject.getConstructor(); FunctionType delegateBaseCtor = delegateBaseObject.getConstructor(); FunctionType delegateSuperCtor = delegateSuperObject.getConstructor(); if (delegatorCtor != null && delegateBaseCtor != null && delegateSuperCtor != null) { FunctionParamBuilder functionParamBuilder = new FunctionParamBuilder(typeRegistry); functionParamBuilder.addRequiredParams( getNativeType(U2U_CONSTRUCTOR_TYPE)); FunctionType findDelegate = typeRegistry.createFunctionType("
      },
      {
        "txt": "typeRegistry.createDefaultObjectUnion(delegateBaseObject), functionParamBuilder.build()); FunctionType delegateProxy = typeRegistry.createConstructorType( delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX, null, null, null); delegateProxy.setPrototypeBasedOn(delegateBaseObject); codingConvention.applyDelegateRelationship( delegateSuperObject, delegateBaseObject, delegatorObject, delegateProxy, findDelegate); delegateProxyPrototypes.add(delegateProxy.getPrototype());"
      },
      {
        "txt": "} } } void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null);"
      },
      {
        "txt": "if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { <extra_id_0> return; } if (qVar.getScope() == scope) { scope.undeclare(qVar); } }"
      },
      {
        "txt": "} } } if (valueType == null) { if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration( n, t.getInput() != null && t.getInput().isExtern(), ownerName)); }"
      },
      {
        "txt": "return; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); }"
      },
      {
        "txt": "if (inferred) { inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false))); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput() != null && t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) ||"
      },
      {
        "txt": "ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, n); } } defineSlot(n, parent, valueType, inferred); } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) { FunctionType ownerType ="
      },
      {
        "txt": "JSType.toMaybeFunctionType(getObjectSlot(ownerName)); if (ownerType != null) { JSType ownerTypeOfThis = ownerType.getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); }"
      },
      {
        "txt": "} } } private ObjectType getObjectSlot(String slotName) { Var ownerVar = scope.getVar(slotName); if (ownerVar != null) { JSType ownerVarType = ownerVar.getType(); return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()); }"
      },
      {
        "txt": "return null; } void resolveStubDeclarations() { for (StubDeclaration stub : stubDeclarations) { Node n = stub.node; Node parent = n.getParent(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); String ownerName = stub.ownerName; boolean isExtern = stub.isExtern;"
      },
      {
        "txt": "if (scope.isDeclared(qName, false)) { continue; } ObjectType ownerType = getObjectSlot(ownerName); ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE); defineSlot(n, parent, unknownType, true); if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) { ownerType.defineInferredProperty( propName, unknownType, n);"
      },
      {
        "txt": "} else { typeRegistry.registerPropertyOnType( propName, ownerType == null ? unknownType : ownerType); } } } private final class CollectProperties extends AbstractShallowStatementCallback { private final ObjectType thisType; CollectProperties(ObjectType thisType) {"
      },
      {
        "txt": "this.thisType = thisType; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.EXPR_RESULT) { Node child = n.getFirstChild(); switch (child.getType()) { case Token.ASSIGN: maybeCollectMember(t, child.getFirstChild(), child, child.getLastChild());"
      },
      {
        "txt": "break; case Token.GETPROP: maybeCollectMember(t, child, child, null); break; } } } private void maybeCollectMember(NodeTraversal t, Node member, Node nodeWithJsDocInfo, @Nullable Node value) { JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();"
      },
      {
        "txt": "if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) { return; } member.getFirstChild().setJSType(thisType); JSType jsType = getDeclaredType(t.getSourceName(), info, member, value); Node name = member.getLastChild(); if (jsType != null && (name.getType() == Token.NAME || name.getType() == Token.STRING)) {"
      },
      {
        "txt": "thisType.defineDeclaredProperty( name.getString(), jsType, member); } } } // end CollectProperties } private static final class StubDeclaration { private final Node node;"
      },
      {
        "txt": "private final boolean isExtern; private final String ownerName; private StubDeclaration(Node node, boolean isExtern, String ownerName) { this.node = node; this.isExtern = isExtern; this.ownerName = ownerName; } } private final class GlobalScopeBuilder extends AbstractScopeBuilder { private GlobalScopeBuilder(Scope scope) {"
      },
      {
        "txt": "super(scope); } @Override public void visit(NodeTraversal t, Node n, Node parent) { super.visit(t, n, parent); switch (n.getType()) { case Token.VAR: if (n.hasOneChild()) { checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo()); } break;"
      },
      {
        "txt": "} } @Override void maybeDeclareQualifiedName( NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { checkForTypedef(t, n, info); super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue); } private void checkForTypedef("
      },
      {
        "txt": "NodeTraversal t, Node candidate, JSDocInfo info) { if (info == null || !info.hasTypedefType()) { return; } String typedef = candidate.getQualifiedName(); if (typedef == null) { return; } typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE)); JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);"
      },
      {
        "txt": "if (realType == null) { compiler.report( JSError.make( t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.overwriteDeclaredType(typedef, realType); if (candidate.getType() == Token.GETPROP) { defineSlot(candidate, candidate.getParent(), getNativeType(NO_TYPE), false); }"
      },
      {
        "txt": "} } // end GlobalScopeBuilder private final class LocalScopeBuilder extends AbstractScopeBuilder { private LocalScopeBuilder(Scope scope) { super(scope); } void build() { NodeTraversal.traverse(compiler, scope.getRootNode(), this); } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } super.visit(t, n, parent); } private void handleFunctionInputs(Node fnNode) { Node fnNameNode = fnNode.getFirstChild(); String fnName = fnNameNode.getString();"
      },
      {
        "txt": "if (!fnName.isEmpty()) { Scope.Var fnVar = scope.getVar(fnName); if (fnVar == null || (fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false); } } declareArguments(fnNode); }"
      },
      {
        "txt": "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = JSType.toMaybeFunctionType(functionNode.getJSType()); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) {"
      },
      {
        "txt": "if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), false); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } }"
      },
      {
        "txt": "} // end declareArguments } // end LocalScopeBuilder"
      }
    ]
  },
  {
    "id": 328,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 341,
    "end-bug-line": 341,
    "bug": "baseType.isUnknownType() ||",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY,"
      },
      {
        "txt": "CONSTRUCTOR, INTERFACE } private ArrowType call; private PrototypeObjectType prototype; private SimpleSlot prototypeSlot; private final Kind kind; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of();"
      },
      {
        "txt": "private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private String templateTypeName; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis, String templateTypeName, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); Preconditions.checkArgument(source == null ||"
      },
      {
        "txt": "Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY; if (isConstructor) { this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.typeOfThis = typeOfThis != null ? typeOfThis :"
      },
      {
        "txt": "registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType; this.templateTypeName = templateTypeName; } private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType());"
      },
      {
        "txt": "Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.LP), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); }"
      },
      {
        "txt": "@Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() {"
      },
      {
        "txt": "return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } @Override public FunctionType toMaybeFunctionType() { return this; }"
      },
      {
        "txt": "@Override public boolean canBeCalled() { return true; } public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){ return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;"
      },
      {
        "txt": "if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false; } public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else {"
      },
      {
        "txt": "return Collections.emptySet(); } } public Node getParametersNode() { return call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) {"
      },
      {
        "txt": "i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) {"
      },
      {
        "txt": "Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType; }"
      },
      {
        "txt": "public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call; } @Override public StaticSlot<JSType> getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype();"
      },
      {
        "txt": "return prototypeSlot; } else { return super.getSlot(name); } } public Set<String> getOwnPropertyNames() { if (prototype == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\");"
      },
      {
        "txt": "names.addAll(super.getOwnPropertyNames()); return names; } } public ObjectType getPrototype() { if (prototype == null) { setPrototype( new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\","
      },
      {
        "txt": "isNativeObjectType())); } return prototype; } public void setPrototypeBasedOn(ObjectType baseType) { if (baseType.hasReferenceName() || <extra_id_0> isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); }"
      },
      {
        "txt": "registry, this.getReferenceName() + \".prototype\", baseType); } setPrototype((PrototypeObjectType) baseType); } public boolean setPrototype(PrototypeObjectType prototype) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false;"
      },
      {
        "txt": "} boolean replacedPrototype = prototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true); this.prototype.setOwnerFunction(this); if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); }"
      },
      {
        "txt": "if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } } } } if (replacedPrototype) { clearCachedValues();"
      },
      {
        "txt": "} return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces; }"
      },
      {
        "txt": "private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; } set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set); }"
      },
      {
        "txt": "} } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces());"
      },
      {
        "txt": "} } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } public Iterable<ObjectType> getAllExtendedInterfaces() { Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet();"
      },
      {
        "txt": "for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { set.add(instance);"
      },
      {
        "txt": "for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces; } public int getExtendedInterfacesCount() { return extendedInterfaces.size();"
      },
      {
        "txt": "} public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException(); } } @Override"
      },
      {
        "txt": "public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { if (\"call\".equals(name)) { Node params = getParametersNode(); if (params == null) { defineDeclaredProperty(name, new FunctionBuilder(registry) .withReturnType(getReturnType()) .build(), source);"
      },
      {
        "txt": "} else { params = params.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(true); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParamsNode(params)"
      },
      {
        "txt": ".withReturnType(getReturnType()) .build(), source); } } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE)));"
      },
      {
        "txt": "defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(), source); } } return super.getPropertyType(name); }"
      },
      {
        "txt": "@Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (objType.isEquivalentTo(prototype)) { return true; } this.setPrototypeBasedOn(objType);"
      },
      {
        "txt": "return true; } else { return false; } } return super.defineProperty(name, type, inferred, propertyNode); } @Override public JSType getLeastSupertype(JSType that) { return supAndInfHelper(that, true);"
      },
      {
        "txt": "} @Override public JSType getGreatestSubtype(JSType that) { return supAndInfHelper(that, false); } private JSType supAndInfHelper(JSType that, boolean leastSuper) { if (isFunctionType() && that.isFunctionType()) { if (isEquivalentTo(that)) { return this; }"
      },
      {
        "txt": "FunctionType other = that.toMaybeFunctionType(); if (other != null && isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !other.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that); boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this; } else if (isSubtypeOfThis && !isSubtypeOfThat) {"
      },
      {
        "txt": "return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(other, leastSuper); if (merged != null) { return merged; } } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.isEquivalentTo(that)) {"
      },
      {
        "txt": "return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn; }"
      },
      {
        "txt": "return leastSuper ? super.getLeastSupertype(that) : super.getGreatestSubtype(that); } private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call)) { newParamsNode = call.parameters; } else {"
      },
      {
        "txt": "return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis; } else { JSType maybeNewTypeOfThis = leastSuper ?"
      },
      {
        "txt": "typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE); } }"
      },
      {
        "txt": "boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType( registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface());"
      },
      {
        "txt": "ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); } public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { ObjectType foundType = null; if (type.hasProperty(propertyName)) {"
      },
      {
        "txt": "foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); } } return foundType; } public ObjectType getTopMostDefiningType(String propertyName) {"
      },
      {
        "txt": "Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getPrototype().hasProperty(propertyName)); FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); } ObjectType topInstanceType = ctor.getInstanceType(); while (true) { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor();"
      },
      {
        "txt": "if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) { break; } } return topInstanceType; } @Override public boolean isEquivalentTo(JSType otherType) { FunctionType that = JSType.toMaybeFunctionType(otherType);"
      },
      {
        "txt": "if (that == null) { return false; } if (this.isConstructor()) { if (that.isConstructor()) { return this == that; } return false; } if (this.isInterface()) {"
      },
      {
        "txt": "if (that.isInterface()) { return this.getReferenceName().equals(that.getReferenceName()); } return false; } if (that.isInterface()) { return false; } return this.typeOfThis.isEquivalentTo(that.typeOfThis) && this.call.isEquivalentTo(that.call);"
      },
      {
        "txt": "} @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) { return this.call.isEquivalentTo(otherType.call); } @Override public String toString() {"
      },
      {
        "txt": "if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { if (isConstructor()) { b.append(\"new:\");"
      },
      {
        "txt": "} else { b.append(\"this:\"); } b.append(typeOfThis.toString()); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild();"
      },
      {
        "txt": "if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); while (p != null) { b.append(\", \"); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType());"
      },
      {
        "txt": "} else { b.append(p.getJSType().toString()); } p = p.getNext(); } } b.append(\"): \"); b.append(call.returnType); return b.toString(); }"
      },
      {
        "txt": "private void appendVarArgsString(StringBuilder builder, JSType paramType) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append(paramType.toString()).append(\"]\"); } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtype(this, that)) {"
      },
      {
        "txt": "return true; } if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true; } if (this.isInterface()) { return false; }"
      },
      {
        "txt": "boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); }"
      },
      {
        "txt": "@Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType;"
      },
      {
        "txt": "} public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis; } public Node getSource() {"
      },
      {
        "txt": "return source; } public void setSource(Node source) { this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType);"
      },
      {
        "txt": "} @Override public void clearCachedValues() { super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) { subType.clearCachedValues(); } } if (!isNativeObjectType()) {"
      },
      {
        "txt": "if (hasInstanceType()) { getInstanceType().clearCachedValues(); } if (prototype != null) { prototype.clearCachedValues(); } } } public List<FunctionType> getSubTypes() { return subTypes;"
      },
      {
        "txt": "} @Override public boolean hasCachedValues() { return prototype != null || super.hasCachedValues(); } public String getTemplateTypeName() { return templateTypeName; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {"
      },
      {
        "txt": "setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (PrototypeObjectType) safeResolve(prototype, t, scope); JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
      },
      {
        "txt": "boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build();"
      },
      {
        "txt": "} if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } } return super.resolveInternal(t, scope); } @Override"
      },
      {
        "txt": "public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\");"
      },
      {
        "txt": "b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); while (p != null) {"
      },
      {
        "txt": "b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString(); }"
      },
      {
        "txt": "private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); } }"
      }
    ]
  },
  {
    "id": 329,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 366,
    "end-bug-line": 366,
    "bug": "boolean replacedPrototype = prototype != null;",
    "fix": "PrototypeObjectType oldPrototype = this.prototype; boolean replacedPrototype = oldPrototype != null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set;"
      },
      {
        "txt": "public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY, CONSTRUCTOR, INTERFACE } private ArrowType call; private PrototypeObjectType prototype; private SimpleSlot prototypeSlot;"
      },
      {
        "txt": "private final Kind kind; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private String templateTypeName; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis, String templateTypeName, boolean isConstructor, boolean nativeType) {"
      },
      {
        "txt": "super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY; if (isConstructor) { this.typeOfThis = typeOfThis != null ?"
      },
      {
        "txt": "typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType; this.templateTypeName = templateTypeName; } private FunctionType(JSTypeRegistry registry, String name, Node source) {"
      },
      {
        "txt": "super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.LP), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); }"
      },
      {
        "txt": "static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); } @Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() {"
      },
      {
        "txt": "return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() { return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; }"
      },
      {
        "txt": "@Override public FunctionType toMaybeFunctionType() { return this; } @Override public boolean canBeCalled() { return true; } public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){"
      },
      {
        "txt": "return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false; } public Iterable<Node> getParameters() {"
      },
      {
        "txt": "Node n = getParametersNode(); if (n != null) { return n.children(); } else { return Collections.emptySet(); } } public Node getParametersNode() { return call.parameters; }"
      },
      {
        "txt": "public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) { i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min;"
      },
      {
        "txt": "} public int getMaxArguments() { Node params = getParametersNode(); if (params != null) { Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE;"
      },
      {
        "txt": "} public JSType getReturnType() { return call.returnType; } public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call; }"
      },
      {
        "txt": "@Override public StaticSlot<JSType> getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype(); return prototypeSlot; } else { return super.getSlot(name); } } public Set<String> getOwnPropertyNames() {"
      },
      {
        "txt": "if (prototype == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\"); names.addAll(super.getOwnPropertyNames()); return names; } } public ObjectType getPrototype() { if (prototype == null) {"
      },
      {
        "txt": "setPrototype( new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType())); } return prototype; } public void setPrototypeBasedOn(ObjectType baseType) {"
      },
      {
        "txt": "if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); } setPrototype((PrototypeObjectType) baseType); }"
      },
      {
        "txt": "if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false; } <extra_id_0> this.prototype = prototype; this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true); this.prototype.setOwnerFunction(this); if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) {"
      },
      {
        "txt": "FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } }"
      },
      {
        "txt": "} } if (replacedPrototype) { clearCachedValues(); } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) {"
      },
      {
        "txt": "addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; }"
      },
      {
        "txt": "set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) {"
      },
      {
        "txt": "return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces()); } } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); }"
      },
      {
        "txt": "this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } public Iterable<ObjectType> getAllExtendedInterfaces() { Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance,"
      },
      {
        "txt": "Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getExtendedInterfaces() {"
      },
      {
        "txt": "return extendedInterfaces; } public int getExtendedInterfacesCount() { return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else {"
      },
      {
        "txt": "throw new UnsupportedOperationException(); } } @Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { if (\"call\".equals(name)) { Node params = getParametersNode(); if (params == null) { defineDeclaredProperty(name,"
      },
      {
        "txt": "new FunctionBuilder(registry) .withReturnType(getReturnType()) .build(), source); } else { params = params.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode);"
      },
      {
        "txt": "thisTypeNode.setOptionalArg(true); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParamsNode(params) .withReturnType(getReturnType()) .build(), source); } } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry);"
      },
      {
        "txt": "builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(), source);"
      },
      {
        "txt": "} } return super.getPropertyType(name); } @Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) {"
      },
      {
        "txt": "if (objType.isEquivalentTo(prototype)) { return true; } this.setPrototypeBasedOn(objType); return true; } else { return false; } } return super.defineProperty(name, type, inferred, propertyNode);"
      },
      {
        "txt": "} @Override public JSType getLeastSupertype(JSType that) { return supAndInfHelper(that, true); } @Override public JSType getGreatestSubtype(JSType that) { return supAndInfHelper(that, false); } private JSType supAndInfHelper(JSType that, boolean leastSuper) {"
      },
      {
        "txt": "if (isFunctionType() && that.isFunctionType()) { if (isEquivalentTo(that)) { return this; } FunctionType other = that.toMaybeFunctionType(); if (other != null && isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !other.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that);"
      },
      {
        "txt": "boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this; } else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(other, leastSuper); if (merged != null) { return merged; }"
      },
      {
        "txt": "} JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);"
      },
      {
        "txt": "FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn; } return leastSuper ? super.getLeastSupertype(that) : super.getGreatestSubtype(that); } private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) {"
      },
      {
        "txt": "Node newParamsNode = null; if (call.hasEqualParameters(other.call)) { newParamsNode = call.parameters; } else { return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null;"
      },
      {
        "txt": "if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis; } else { JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ?"
      },
      {
        "txt": "registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE); } } boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType( registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred),"
      },
      {
        "txt": "newTypeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); }"
      },
      {
        "txt": "public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { ObjectType foundType = null; if (type.hasProperty(propertyName)) { foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); }"
      },
      {
        "txt": "} return foundType; } public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getPrototype().hasProperty(propertyName)); FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); }"
      },
      {
        "txt": "ObjectType topInstanceType = ctor.getInstanceType(); while (true) { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) { break; } } return topInstanceType; }"
      },
      {
        "txt": "@Override public boolean isEquivalentTo(JSType otherType) { FunctionType that = JSType.toMaybeFunctionType(otherType); if (that == null) { return false; } if (this.isConstructor()) { if (that.isConstructor()) { return this == that;"
      },
      {
        "txt": "} return false; } if (this.isInterface()) { if (that.isInterface()) { return this.getReferenceName().equals(that.getReferenceName()); } return false; } if (that.isInterface()) {"
      },
      {
        "txt": "return false; } return this.typeOfThis.isEquivalentTo(that.typeOfThis) && this.call.isEquivalentTo(that.call); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) {"
      },
      {
        "txt": "return this.call.isEquivalentTo(otherType.call); } @Override public String toString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount();"
      },
      {
        "txt": "boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { if (isConstructor()) { b.append(\"new:\"); } else { b.append(\"this:\"); } b.append(typeOfThis.toString()); } if (paramNum > 0) {"
      },
      {
        "txt": "if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext();"
      },
      {
        "txt": "while (p != null) { b.append(\", \"); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); } }"
      },
      {
        "txt": "b.append(\"): \"); b.append(call.returnType); return b.toString(); } private void appendVarArgsString(StringBuilder builder, JSType paramType) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append(paramType.toString()).append(\"]\");"
      },
      {
        "txt": "} @Override public boolean isSubtype(JSType that) { if (JSType.isSubtype(this, that)) { return true; } if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true;"
      },
      {
        "txt": "} if (this.isInterface()) { return false; } boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);"
      },
      {
        "txt": "return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); } @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType());"
      },
      {
        "txt": "return typeOfThis; } void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() {"
      },
      {
        "txt": "return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis; } public Node getSource() { return source; } public void setSource(Node source) { this.source = source; } private void addSubType(FunctionType subType) {"
      },
      {
        "txt": "if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType); } @Override public void clearCachedValues() { super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) {"
      },
      {
        "txt": "subType.clearCachedValues(); } } if (!isNativeObjectType()) { if (hasInstanceType()) { getInstanceType().clearCachedValues(); } if (prototype != null) { prototype.clearCachedValues(); }"
      },
      {
        "txt": "} } public List<FunctionType> getSubTypes() { return subTypes; } @Override public boolean hasCachedValues() { return prototype != null || super.hasCachedValues(); } public String getTemplateTypeName() {"
      },
      {
        "txt": "return templateTypeName; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (PrototypeObjectType) safeResolve(prototype, t, scope); JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "} if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface);"
      },
      {
        "txt": "changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); }"
      },
      {
        "txt": "} return super.resolveInternal(t, scope); } @Override public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\");"
      },
      {
        "txt": "int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\"); b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); }"
      },
      {
        "txt": "Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); while (p != null) { b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\");"
      },
      {
        "txt": "b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString(); } private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); }"
      }
    ]
  },
  {
    "id": 330,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 372,
    "end-bug-line": 372,
    "bug": "",
    "fix": "if (oldPrototype != null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY,"
      },
      {
        "txt": "CONSTRUCTOR, INTERFACE } private ArrowType call; private PrototypeObjectType prototype; private SimpleSlot prototypeSlot; private final Kind kind; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of();"
      },
      {
        "txt": "private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private String templateTypeName; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis, String templateTypeName, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); Preconditions.checkArgument(source == null ||"
      },
      {
        "txt": "Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY; if (isConstructor) { this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.typeOfThis = typeOfThis != null ? typeOfThis :"
      },
      {
        "txt": "registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType; this.templateTypeName = templateTypeName; } private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType());"
      },
      {
        "txt": "Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.LP), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); }"
      },
      {
        "txt": "@Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() {"
      },
      {
        "txt": "return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } @Override public FunctionType toMaybeFunctionType() { return this; }"
      },
      {
        "txt": "@Override public boolean canBeCalled() { return true; } public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){ return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;"
      },
      {
        "txt": "if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false; } public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else {"
      },
      {
        "txt": "return Collections.emptySet(); } } public Node getParametersNode() { return call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) {"
      },
      {
        "txt": "i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) {"
      },
      {
        "txt": "Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType; }"
      },
      {
        "txt": "public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call; } @Override public StaticSlot<JSType> getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype();"
      },
      {
        "txt": "return prototypeSlot; } else { return super.getSlot(name); } } public Set<String> getOwnPropertyNames() { if (prototype == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\");"
      },
      {
        "txt": "names.addAll(super.getOwnPropertyNames()); return names; } } public ObjectType getPrototype() { if (prototype == null) { setPrototype( new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\","
      },
      {
        "txt": "registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType())); } return prototype; } public void setPrototypeBasedOn(ObjectType baseType) { if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() ||"
      },
      {
        "txt": "!(baseType instanceof PrototypeObjectType)) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); } setPrototype((PrototypeObjectType) baseType); } public boolean setPrototype(PrototypeObjectType prototype) { if (prototype == null) { return false; }"
      },
      {
        "txt": "return false; } boolean replacedPrototype = prototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true); this.prototype.setOwnerFunction(this); <extra_id_0> if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) {"
      },
      {
        "txt": "} if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } } } } if (replacedPrototype) {"
      },
      {
        "txt": "clearCachedValues(); } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces;"
      },
      {
        "txt": "} private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; } set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set);"
      },
      {
        "txt": "} } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat("
      },
      {
        "txt": "implementedInterfaces, superCtor.getImplementedInterfaces()); } } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } public Iterable<ObjectType> getAllExtendedInterfaces() {"
      },
      {
        "txt": "Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) {"
      },
      {
        "txt": "set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces; } public int getExtendedInterfacesCount() {"
      },
      {
        "txt": "return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException(); } }"
      },
      {
        "txt": "@Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { if (\"call\".equals(name)) { Node params = getParametersNode(); if (params == null) { defineDeclaredProperty(name, new FunctionBuilder(registry) .withReturnType(getReturnType()) .build(),"
      },
      {
        "txt": "source); } else { params = params.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(true); defineDeclaredProperty(name, new FunctionBuilder(registry)"
      },
      {
        "txt": ".withParamsNode(params) .withReturnType(getReturnType()) .build(), source); } } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType("
      },
      {
        "txt": "registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(), source); } } return super.getPropertyType(name);"
      },
      {
        "txt": "} @Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (objType.isEquivalentTo(prototype)) { return true; }"
      },
      {
        "txt": "this.setPrototypeBasedOn(objType); return true; } else { return false; } } return super.defineProperty(name, type, inferred, propertyNode); } @Override public JSType getLeastSupertype(JSType that) {"
      },
      {
        "txt": "return supAndInfHelper(that, true); } @Override public JSType getGreatestSubtype(JSType that) { return supAndInfHelper(that, false); } private JSType supAndInfHelper(JSType that, boolean leastSuper) { if (isFunctionType() && that.isFunctionType()) { if (isEquivalentTo(that)) { return this;"
      },
      {
        "txt": "} FunctionType other = that.toMaybeFunctionType(); if (other != null && isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !other.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that); boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this;"
      },
      {
        "txt": "} else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(other, leastSuper); if (merged != null) { return merged; } } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE);"
      },
      {
        "txt": "if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn;"
      },
      {
        "txt": "} return leastSuper ? super.getLeastSupertype(that) : super.getGreatestSubtype(that); } private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call)) { newParamsNode = call.parameters;"
      },
      {
        "txt": "} else { return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis; } else {"
      },
      {
        "txt": "JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE); }"
      },
      {
        "txt": "} boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType( registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() {"
      },
      {
        "txt": "Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); } public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { ObjectType foundType = null;"
      },
      {
        "txt": "if (type.hasProperty(propertyName)) { foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); } } return foundType; }"
      },
      {
        "txt": "public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getPrototype().hasProperty(propertyName)); FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); } ObjectType topInstanceType = ctor.getInstanceType(); while (true) { topInstanceType = ctor.getInstanceType();"
      },
      {
        "txt": "ctor = ctor.getSuperClassConstructor(); if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) { break; } } return topInstanceType; } @Override public boolean isEquivalentTo(JSType otherType) { FunctionType that ="
      },
      {
        "txt": "JSType.toMaybeFunctionType(otherType); if (that == null) { return false; } if (this.isConstructor()) { if (that.isConstructor()) { return this == that; } return false; }"
      },
      {
        "txt": "if (this.isInterface()) { if (that.isInterface()) { return this.getReferenceName().equals(that.getReferenceName()); } return false; } if (that.isInterface()) { return false; } return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&"
      },
      {
        "txt": "this.call.isEquivalentTo(that.call); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) { return this.call.isEquivalentTo(otherType.call); } @Override"
      },
      {
        "txt": "public String toString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { if (isConstructor()) {"
      },
      {
        "txt": "b.append(\"new:\"); } else { b.append(\"this:\"); } b.append(typeOfThis.toString()); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); }"
      },
      {
        "txt": "Node p = call.parameters.getFirstChild(); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); while (p != null) { b.append(\", \"); if (p.isVarArgs()) {"
      },
      {
        "txt": "appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); } } b.append(\"): \"); b.append(call.returnType); return b.toString();"
      },
      {
        "txt": "} private void appendVarArgsString(StringBuilder builder, JSType paramType) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append(paramType.toString()).append(\"]\"); } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (JSType.isSubtype(this, that)) { return true; } if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true; } if (this.isInterface()) { return false;"
      },
      {
        "txt": "} boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);"
      },
      {
        "txt": "} @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) {"
      },
      {
        "txt": "typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis; }"
      },
      {
        "txt": "public Node getSource() { return source; } public void setSource(Node source) { this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); }"
      },
      {
        "txt": "subTypes.add(subType); } @Override public void clearCachedValues() { super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) { subType.clearCachedValues(); } }"
      },
      {
        "txt": "if (!isNativeObjectType()) { if (hasInstanceType()) { getInstanceType().clearCachedValues(); } if (prototype != null) { prototype.clearCachedValues(); } } } public List<FunctionType> getSubTypes() {"
      },
      {
        "txt": "return subTypes; } @Override public boolean hasCachedValues() { return prototype != null || super.hasCachedValues(); } public String getTemplateTypeName() { return templateTypeName; } @Override"
      },
      {
        "txt": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (PrototypeObjectType) safeResolve(prototype, t, scope); JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis;"
      },
      {
        "txt": "} boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) {"
      },
      {
        "txt": "implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } } return super.resolveInternal(t, scope); }"
      },
      {
        "txt": "@Override public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) {"
      },
      {
        "txt": "b.append(\"this:\"); b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext();"
      },
      {
        "txt": "while (p != null) { b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString();"
      },
      {
        "txt": "} private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); } }"
      }
    ]
  },
  {
    "id": 331,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 374,
    "end-bug-line": 374,
    "bug": "",
    "fix": "oldPrototype.setOwnerFunction(null); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY,"
      },
      {
        "txt": "CONSTRUCTOR, INTERFACE } private ArrowType call; private PrototypeObjectType prototype; private SimpleSlot prototypeSlot; private final Kind kind; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of();"
      },
      {
        "txt": "private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private String templateTypeName; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis, String templateTypeName, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); Preconditions.checkArgument(source == null ||"
      },
      {
        "txt": "Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY; if (isConstructor) { this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.typeOfThis = typeOfThis != null ? typeOfThis :"
      },
      {
        "txt": "registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType; this.templateTypeName = templateTypeName; } private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType());"
      },
      {
        "txt": "Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.LP), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); }"
      },
      {
        "txt": "@Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() {"
      },
      {
        "txt": "return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } @Override public FunctionType toMaybeFunctionType() { return this; }"
      },
      {
        "txt": "@Override public boolean canBeCalled() { return true; } public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){ return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;"
      },
      {
        "txt": "if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false; } public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else {"
      },
      {
        "txt": "return Collections.emptySet(); } } public Node getParametersNode() { return call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) {"
      },
      {
        "txt": "i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) {"
      },
      {
        "txt": "Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType; }"
      },
      {
        "txt": "public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call; } @Override public StaticSlot<JSType> getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype();"
      },
      {
        "txt": "return prototypeSlot; } else { return super.getSlot(name); } } public Set<String> getOwnPropertyNames() { if (prototype == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\");"
      },
      {
        "txt": "names.addAll(super.getOwnPropertyNames()); return names; } } public ObjectType getPrototype() { if (prototype == null) { setPrototype( new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\","
      },
      {
        "txt": "registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType())); } return prototype; } public void setPrototypeBasedOn(ObjectType baseType) { if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() ||"
      },
      {
        "txt": "!(baseType instanceof PrototypeObjectType)) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); } setPrototype((PrototypeObjectType) baseType); } public boolean setPrototype(PrototypeObjectType prototype) { if (prototype == null) { return false; }"
      },
      {
        "txt": "return false; } boolean replacedPrototype = prototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true); this.prototype.setOwnerFunction(this); <extra_id_0> if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) {"
      },
      {
        "txt": "} if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } } } } if (replacedPrototype) {"
      },
      {
        "txt": "clearCachedValues(); } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces;"
      },
      {
        "txt": "} private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; } set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set);"
      },
      {
        "txt": "} } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat("
      },
      {
        "txt": "implementedInterfaces, superCtor.getImplementedInterfaces()); } } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } public Iterable<ObjectType> getAllExtendedInterfaces() {"
      },
      {
        "txt": "Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) {"
      },
      {
        "txt": "set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces; } public int getExtendedInterfacesCount() {"
      },
      {
        "txt": "return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException(); } }"
      },
      {
        "txt": "@Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { if (\"call\".equals(name)) { Node params = getParametersNode(); if (params == null) { defineDeclaredProperty(name, new FunctionBuilder(registry) .withReturnType(getReturnType()) .build(),"
      },
      {
        "txt": "source); } else { params = params.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(true); defineDeclaredProperty(name, new FunctionBuilder(registry)"
      },
      {
        "txt": ".withParamsNode(params) .withReturnType(getReturnType()) .build(), source); } } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType("
      },
      {
        "txt": "registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(), source); } } return super.getPropertyType(name);"
      },
      {
        "txt": "} @Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (objType.isEquivalentTo(prototype)) { return true; }"
      },
      {
        "txt": "this.setPrototypeBasedOn(objType); return true; } else { return false; } } return super.defineProperty(name, type, inferred, propertyNode); } @Override public JSType getLeastSupertype(JSType that) {"
      },
      {
        "txt": "return supAndInfHelper(that, true); } @Override public JSType getGreatestSubtype(JSType that) { return supAndInfHelper(that, false); } private JSType supAndInfHelper(JSType that, boolean leastSuper) { if (isFunctionType() && that.isFunctionType()) { if (isEquivalentTo(that)) { return this;"
      },
      {
        "txt": "} FunctionType other = that.toMaybeFunctionType(); if (other != null && isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !other.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that); boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this;"
      },
      {
        "txt": "} else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(other, leastSuper); if (merged != null) { return merged; } } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE);"
      },
      {
        "txt": "if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn;"
      },
      {
        "txt": "} return leastSuper ? super.getLeastSupertype(that) : super.getGreatestSubtype(that); } private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call)) { newParamsNode = call.parameters;"
      },
      {
        "txt": "} else { return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis; } else {"
      },
      {
        "txt": "JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE); }"
      },
      {
        "txt": "} boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType( registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() {"
      },
      {
        "txt": "Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); } public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { ObjectType foundType = null;"
      },
      {
        "txt": "if (type.hasProperty(propertyName)) { foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); } } return foundType; }"
      },
      {
        "txt": "public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getPrototype().hasProperty(propertyName)); FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); } ObjectType topInstanceType = ctor.getInstanceType(); while (true) { topInstanceType = ctor.getInstanceType();"
      },
      {
        "txt": "ctor = ctor.getSuperClassConstructor(); if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) { break; } } return topInstanceType; } @Override public boolean isEquivalentTo(JSType otherType) { FunctionType that ="
      },
      {
        "txt": "JSType.toMaybeFunctionType(otherType); if (that == null) { return false; } if (this.isConstructor()) { if (that.isConstructor()) { return this == that; } return false; }"
      },
      {
        "txt": "if (this.isInterface()) { if (that.isInterface()) { return this.getReferenceName().equals(that.getReferenceName()); } return false; } if (that.isInterface()) { return false; } return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&"
      },
      {
        "txt": "this.call.isEquivalentTo(that.call); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) { return this.call.isEquivalentTo(otherType.call); } @Override"
      },
      {
        "txt": "public String toString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { if (isConstructor()) {"
      },
      {
        "txt": "b.append(\"new:\"); } else { b.append(\"this:\"); } b.append(typeOfThis.toString()); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); }"
      },
      {
        "txt": "Node p = call.parameters.getFirstChild(); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); while (p != null) { b.append(\", \"); if (p.isVarArgs()) {"
      },
      {
        "txt": "appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); } } b.append(\"): \"); b.append(call.returnType); return b.toString();"
      },
      {
        "txt": "} private void appendVarArgsString(StringBuilder builder, JSType paramType) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append(paramType.toString()).append(\"]\"); } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (JSType.isSubtype(this, that)) { return true; } if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true; } if (this.isInterface()) { return false;"
      },
      {
        "txt": "} boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);"
      },
      {
        "txt": "} @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) {"
      },
      {
        "txt": "typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis; }"
      },
      {
        "txt": "public Node getSource() { return source; } public void setSource(Node source) { this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); }"
      },
      {
        "txt": "subTypes.add(subType); } @Override public void clearCachedValues() { super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) { subType.clearCachedValues(); } }"
      },
      {
        "txt": "if (!isNativeObjectType()) { if (hasInstanceType()) { getInstanceType().clearCachedValues(); } if (prototype != null) { prototype.clearCachedValues(); } } } public List<FunctionType> getSubTypes() {"
      },
      {
        "txt": "return subTypes; } @Override public boolean hasCachedValues() { return prototype != null || super.hasCachedValues(); } public String getTemplateTypeName() { return templateTypeName; } @Override"
      },
      {
        "txt": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (PrototypeObjectType) safeResolve(prototype, t, scope); JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis;"
      },
      {
        "txt": "} boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) {"
      },
      {
        "txt": "implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } } return super.resolveInternal(t, scope); }"
      },
      {
        "txt": "@Override public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) {"
      },
      {
        "txt": "b.append(\"this:\"); b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext();"
      },
      {
        "txt": "while (p != null) { b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString();"
      },
      {
        "txt": "} private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); } }"
      }
    ]
  }
]