[
  {
    "id": 206,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 366,
    "end-bug-line": 368,
    "bug": "if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST ="
      },
      {
        "txt": "DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" +"
      },
      {
        "txt": "\"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" +"
      },
      {
        "txt": "\"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\"); static final DiagnosticType ILLEGAL_PROPERTY_ACCESS = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST,"
      },
      {
        "txt": "TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); } Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) {"
      },
      {
        "txt": "this.shouldReport = report; } void expectValidTypeofName(NodeTraversal t, Node n, String found) { report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; }"
      },
      {
        "txt": "return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); } } void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE); } } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes); } } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.isGetProp() &&"
      },
      {
        "txt": "!t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; } return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type.isUnionType()) {"
      },
      {
        "txt": "for (JSType alt : type.toMaybeUnionType().getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } } return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) {"
      },
      {
        "txt": "if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType); } } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) {"
      },
      {
        "txt": "Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) { report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\")); } if (objType.isUnknownType()) { expectStringOrNumber(t, indexNode, indexType, \"property access\"); } else { ObjectType dereferenced = objType.dereference();"
      },
      {
        "txt": "if (dereferenced != null && dereferenced.getIndexType() != null) { expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(), \"restricted index type\"); } else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType,"
      },
      {
        "txt": "} } } boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { <extra_id_0> JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true;"
      },
      {
        "txt": "rightType.isFunctionType() && leftType.isFunctionType()) { return true; } } mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); } return false;"
      },
      {
        "txt": "} return true; } boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType);"
      },
      {
        "txt": "} return false; } return true; } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { if (!argType.canAssignTo(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" +"
      },
      {
        "txt": "\"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName,"
      },
      {
        "txt": "ownerType.toString(), hiddenType.toString(), overridingType.toString()))); } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor(); ObjectType implicitProto = subObject.getImplicitPrototype(); ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype();"
      },
      {
        "txt": "if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) { if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { registerMismatch(superObject, declaredSuper, report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper);"
      },
      {
        "txt": "} if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject); } } } void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {"
      },
      {
        "txt": "registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, castType.toString(), type.toString()))); } } Var expectUndeclaredVariable(String sourceName, CompilerInput input, Node n, Node parent, Var var, String variableName, JSType newType) { Var newVar = var; boolean allowDupe = false; if (n.isGetProp() || NodeUtil.isObjectLitKey(n, parent)) {"
      },
      {
        "txt": "JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo(); } allowDupe = info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&"
      },
      {
        "txt": "newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) { Scope s = var.getScope(); s.undeclare(var); newVar = s.declare(variableName, n, varType, input, false); n.setJSType(varType); if (parent.isVar()) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType);"
      },
      {
        "txt": "} } else { Preconditions.checkState(parent.isFunction()); parent.setJSType(varType); } } else { if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,"
      },
      {
        "txt": "variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); } } } return newVar; } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) {"
      },
      {
        "txt": "ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) { expectInterfaceProperty(t, n, instance, implemented, prop); } } } }"
      },
      {
        "txt": "private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { StaticSlot<JSType> propSlot = instance.getSlot(prop); if (propSlot == null) { String sourceName = n.getSourceFileName(); sourceName = sourceName == null ? \"\" : sourceName; registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString())));"
      },
      {
        "txt": "} else { Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode(); propNode = propNode == null ? n : propNode; JSType found = propSlot.getType(); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) {"
      },
      {
        "txt": "FunctionType constructor = implementedInterface.toObjectType().getConstructor(); registerMismatch(found, required, report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()))); } } } private void mismatch(NodeTraversal t, Node n,"
      },
      {
        "txt": "String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { registerMismatch(found, required, report("
      },
      {
        "txt": "JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); } private void registerMismatch(JSType found, JSType required, JSError error) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return; } mismatches.add(new TypeMismatch(found, required, error));"
      },
      {
        "txt": "if (found.isFunctionType() && required.isFunctionType()) { FunctionType fnTypeA = found.toMaybeFunctionType(); FunctionType fnTypeB = required.toMaybeFunctionType(); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error); }"
      },
      {
        "txt": "registerIfMismatch( fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); } } private void registerIfMismatch( JSType found, JSType required, JSError error) { if (found != null && required != null && !found.canAssignTo(required)) { registerMismatch(found, required, error); }"
      },
      {
        "txt": "} private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { if (n.isGetProp()) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString();"
      },
      {
        "txt": "if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { objectType = FunctionType.getTopDefiningInterface( objectType, propName); } else { while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } } if (objectType != null &&"
      },
      {
        "txt": "(objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } } } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) {"
      },
      {
        "txt": "type = dereferenced; } } String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } else if (qualifiedName != null) { return qualifiedName;"
      },
      {
        "txt": "} else if (type.isFunctionType()) { return \"function\"; } else { return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } private JSError report(JSError error) { if (shouldReport) { compiler.report(error);"
      },
      {
        "txt": "} return error; } static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) { this.typeA = a; this.typeB = b;"
      },
      {
        "txt": "this.src = src; } @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB)); }"
      },
      {
        "txt": "return false; } @Override public int hashCode() { return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 207,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 385,
    "end-bug-line": 385,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.UnknownType;"
      },
      {
        "txt": "import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList();"
      },
      {
        "txt": "private static final String FOUND_REQUIRED = \"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" +"
      },
      {
        "txt": "\"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\","
      },
      {
        "txt": "\"property {0} on interface {1} is not implemented by type {2}\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\");"
      },
      {
        "txt": "static final DiagnosticType ILLEGAL_PROPERTY_ACCESS = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED,"
      },
      {
        "txt": "HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE);"
      },
      {
        "txt": "} Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } void expectValidTypeofName(NodeTraversal t, Node n, String found) { report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); }"
      },
      {
        "txt": "boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE);"
      },
      {
        "txt": "} } void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, STRING_TYPE); } } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, allValueTypes); } } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined("
      },
      {
        "txt": "NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false;"
      },
      {
        "txt": "} return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type.isUnionType()) { for (JSType alt : type.toMaybeUnionType().getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } }"
      },
      {
        "txt": "} return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\","
      },
      {
        "txt": "caseType, switchType); } } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) { report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\"));"
      },
      {
        "txt": "} if (objType.isUnknownType()) { expectStringOrNumber(t, indexNode, indexType, \"property access\"); } else { ObjectType dereferenced = objType.dereference(); if (dereferenced != null && dereferenced.getIndexType() != null) { expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(), \"restricted index type\"); } else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \"array access\");"
      },
      {
        "txt": "} else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } } } boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,"
      },
      {
        "txt": "JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {"
      },
      {
        "txt": "} } mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); <extra_id_0> return false; } return true; } boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {"
      },
      {
        "txt": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); } return false; }"
      },
      {
        "txt": "return true; } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { if (!argType.canAssignTo(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType);"
      },
      {
        "txt": "} } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()))); }"
      },
      {
        "txt": "} void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor(); ObjectType implicitProto = subObject.getImplicitPrototype(); ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype(); if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {"
      },
      {
        "txt": "if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { registerMismatch(superObject, declaredSuper, report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject);"
      },
      {
        "txt": "} } } void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) { registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, castType.toString(), type.toString()))); }"
      },
      {
        "txt": "} Var expectUndeclaredVariable(String sourceName, CompilerInput input, Node n, Node parent, Var var, String variableName, JSType newType) { Var newVar = var; boolean allowDupe = false; if (n.isGetProp() || NodeUtil.isObjectLitKey(n, parent)) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo();"
      },
      {
        "txt": "} allowDupe = info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) {"
      },
      {
        "txt": "Scope s = var.getScope(); s.undeclare(var); newVar = s.declare(variableName, n, varType, input, false); n.setJSType(varType); if (parent.isVar()) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.isFunction());"
      },
      {
        "txt": "parent.setJSType(varType); } } else { if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));"
      },
      {
        "txt": "} } } return newVar; } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) {"
      },
      {
        "txt": "for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) { expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { StaticSlot<JSType> propSlot = instance.getSlot(prop);"
      },
      {
        "txt": "if (propSlot == null) { String sourceName = n.getSourceFileName(); sourceName = sourceName == null ? \"\" : sourceName; registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()))); } else { Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode();"
      },
      {
        "txt": "propNode = propNode == null ? n : propNode; JSType found = propSlot.getType(); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); registerMismatch(found, required, report(t.makeError(propNode,"
      },
      {
        "txt": "HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()))); } } } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); }"
      },
      {
        "txt": "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { registerMismatch(found, required, report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); }"
      },
      {
        "txt": "private void registerMismatch(JSType found, JSType required, JSError error) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return; } mismatches.add(new TypeMismatch(found, required, error)); if (found.isFunctionType() && required.isFunctionType()) { FunctionType fnTypeA = found.toMaybeFunctionType();"
      },
      {
        "txt": "FunctionType fnTypeB = required.toMaybeFunctionType(); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error); } registerIfMismatch( fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); }"
      },
      {
        "txt": "} private void registerIfMismatch( JSType found, JSType required, JSError error) { if (found != null && required != null && !found.canAssignTo(required)) { registerMismatch(found, required, error); } } private String formatFoundRequired(String description, JSType found, JSType required) {"
      },
      {
        "txt": "return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { if (n.isGetProp()) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { objectType = FunctionType.getTopDefiningInterface("
      },
      {
        "txt": "objectType, propName); } else { while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } } if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName;"
      },
      {
        "txt": "} } } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } }"
      },
      {
        "txt": "String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } else if (qualifiedName != null) { return qualifiedName; } else if (type.isFunctionType()) { return \"function\"; } else {"
      },
      {
        "txt": "return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; }"
      },
      {
        "txt": "} private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } private JSError report(JSError error) { if (shouldReport) { compiler.report(error); } return error; }"
      },
      {
        "txt": "static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) { this.typeA = a; this.typeB = b; this.src = src; } @Override public boolean equals(Object object) {"
      },
      {
        "txt": "if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB)); } return false; } @Override public int hashCode() {"
      },
      {
        "txt": "return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 208,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 405,
    "end-bug-line": 407,
    "bug": "if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects;"
      },
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true;"
      },
      {
        "txt": "private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" +"
      },
      {
        "txt": "\"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION ="
      },
      {
        "txt": "DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\");"
      },
      {
        "txt": "static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\"); static final DiagnosticType ILLEGAL_PROPERTY_ACCESS = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION,"
      },
      {
        "txt": "HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);"
      },
      {
        "txt": "this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); } Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } void expectValidTypeofName(NodeTraversal t, Node n, String found) {"
      },
      {
        "txt": "report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); } } void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } }"
      },
      {
        "txt": "void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE); } } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } }"
      },
      {
        "txt": "void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes); } } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); }"
      },
      {
        "txt": "} boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) { return true; }"
      },
      {
        "txt": "mismatch(t, n, msg, type, expectedType); return false; } return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type.isUnionType()) { for (JSType alt : type.toMaybeUnionType().getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true;"
      },
      {
        "txt": "} } } return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) {"
      },
      {
        "txt": "mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType); } } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) {"
      },
      {
        "txt": "report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\")); } if (objType.isUnknownType()) { expectStringOrNumber(t, indexNode, indexType, \"property access\"); } else { ObjectType dereferenced = objType.dereference(); if (dereferenced != null && dereferenced.getIndexType() != null) { expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(), \"restricted index type\");"
      },
      {
        "txt": "} else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } }"
      },
      {
        "txt": "} boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();"
      },
      {
        "txt": "if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true; } } mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); }"
      },
      {
        "txt": "} return true; } boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { <extra_id_0> mismatch(t, n, msg, rightType, leftType); } return false; } return true; }"
      },
      {
        "txt": "return true; } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { if (!argType.canAssignTo(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType);"
      },
      {
        "txt": "} } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()))); }"
      },
      {
        "txt": "} void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor(); ObjectType implicitProto = subObject.getImplicitPrototype(); ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype(); if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {"
      },
      {
        "txt": "if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { registerMismatch(superObject, declaredSuper, report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject);"
      },
      {
        "txt": "} } } void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) { registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, castType.toString(), type.toString()))); }"
      },
      {
        "txt": "} Var expectUndeclaredVariable(String sourceName, CompilerInput input, Node n, Node parent, Var var, String variableName, JSType newType) { Var newVar = var; boolean allowDupe = false; if (n.isGetProp() || NodeUtil.isObjectLitKey(n, parent)) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo();"
      },
      {
        "txt": "} allowDupe = info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) {"
      },
      {
        "txt": "Scope s = var.getScope(); s.undeclare(var); newVar = s.declare(variableName, n, varType, input, false); n.setJSType(varType); if (parent.isVar()) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.isFunction());"
      },
      {
        "txt": "parent.setJSType(varType); } } else { if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));"
      },
      {
        "txt": "} } } return newVar; } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) {"
      },
      {
        "txt": "for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) { expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { StaticSlot<JSType> propSlot = instance.getSlot(prop);"
      },
      {
        "txt": "if (propSlot == null) { String sourceName = n.getSourceFileName(); sourceName = sourceName == null ? \"\" : sourceName; registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()))); } else { Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode();"
      },
      {
        "txt": "propNode = propNode == null ? n : propNode; JSType found = propSlot.getType(); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); registerMismatch(found, required, report(t.makeError(propNode,"
      },
      {
        "txt": "HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()))); } } } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); }"
      },
      {
        "txt": "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { registerMismatch(found, required, report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); }"
      },
      {
        "txt": "private void registerMismatch(JSType found, JSType required, JSError error) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return; } mismatches.add(new TypeMismatch(found, required, error)); if (found.isFunctionType() && required.isFunctionType()) { FunctionType fnTypeA = found.toMaybeFunctionType();"
      },
      {
        "txt": "FunctionType fnTypeB = required.toMaybeFunctionType(); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error); } registerIfMismatch( fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); }"
      },
      {
        "txt": "} private void registerIfMismatch( JSType found, JSType required, JSError error) { if (found != null && required != null && !found.canAssignTo(required)) { registerMismatch(found, required, error); } } private String formatFoundRequired(String description, JSType found, JSType required) {"
      },
      {
        "txt": "return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { if (n.isGetProp()) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { objectType = FunctionType.getTopDefiningInterface("
      },
      {
        "txt": "objectType, propName); } else { while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } } if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName;"
      },
      {
        "txt": "} } } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } }"
      },
      {
        "txt": "String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } else if (qualifiedName != null) { return qualifiedName; } else if (type.isFunctionType()) { return \"function\"; } else {"
      },
      {
        "txt": "return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; }"
      },
      {
        "txt": "} private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } private JSError report(JSError error) { if (shouldReport) { compiler.report(error); } return error; }"
      },
      {
        "txt": "static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) { this.typeA = a; this.typeB = b; this.src = src; } @Override public boolean equals(Object object) {"
      },
      {
        "txt": "if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB)); } return false; } @Override public int hashCode() {"
      },
      {
        "txt": "return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 209,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 409,
    "end-bug-line": 409,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \"{0}\\n\" +"
      },
      {
        "txt": "\"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\","
      },
      {
        "txt": "\"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH ="
      },
      {
        "txt": "DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\"); static final DiagnosticType ILLEGAL_PROPERTY_ACCESS = DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\","
      },
      {
        "txt": "\"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_TYPEOF_VALUE,"
      },
      {
        "txt": "ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); } Iterable<TypeMismatch> getMismatches() {"
      },
      {
        "txt": "return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } void expectValidTypeofName(NodeTraversal t, Node n, String found) { report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, OBJECT_TYPE); return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); } }"
      },
      {
        "txt": "void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE); }"
      },
      {
        "txt": "} void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes); }"
      },
      {
        "txt": "} void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() &&"
      },
      {
        "txt": "type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; } return true;"
      },
      {
        "txt": "} private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type.isUnionType()) { for (JSType alt : type.toMaybeUnionType().getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } } return type.isNoResolvedType();"
      },
      {
        "txt": "} void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType); }"
      },
      {
        "txt": "} void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) { report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\")); } if (objType.isUnknownType()) {"
      },
      {
        "txt": "expectStringOrNumber(t, indexNode, indexType, \"property access\"); } else { ObjectType dereferenced = objType.dereference(); if (dereferenced != null && dereferenced.getIndexType() != null) { expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(), \"restricted index type\"); } else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \"property access\");"
      },
      {
        "txt": "} else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } } } boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {"
      },
      {
        "txt": "if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true; }"
      },
      {
        "txt": "} mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); } return false; } return true; }"
      },
      {
        "txt": "JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); <extra_id_0> return false; } return true; } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {"
      },
      {
        "txt": "void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { if (!argType.canAssignTo(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } }"
      },
      {
        "txt": "void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()))); } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject,"
      },
      {
        "txt": "ObjectType subObject) { FunctionType subCtor = subObject.getConstructor(); ObjectType implicitProto = subObject.getImplicitPrototype(); ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype(); if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) { if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { registerMismatch(superObject, declaredSuper, report("
      },
      {
        "txt": "t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject); } }"
      },
      {
        "txt": "} void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) { registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, castType.toString(), type.toString()))); } } Var expectUndeclaredVariable(String sourceName, CompilerInput input,"
      },
      {
        "txt": "Node n, Node parent, Var var, String variableName, JSType newType) { Var newVar = var; boolean allowDupe = false; if (n.isGetProp() || NodeUtil.isObjectLitKey(n, parent)) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo(); } allowDupe ="
      },
      {
        "txt": "info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) { Scope s = var.getScope(); s.undeclare(var);"
      },
      {
        "txt": "newVar = s.declare(variableName, n, varType, input, false); n.setJSType(varType); if (parent.isVar()) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.isFunction()); parent.setJSType(varType); }"
      },
      {
        "txt": "} else { if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); } }"
      },
      {
        "txt": "} return newVar; } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) {"
      },
      {
        "txt": "expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { StaticSlot<JSType> propSlot = instance.getSlot(prop); if (propSlot == null) { String sourceName = n.getSourceFileName();"
      },
      {
        "txt": "sourceName = sourceName == null ? \"\" : sourceName; registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()))); } else { Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode(); propNode = propNode == null ? n : propNode; JSType found = propSlot.getType();"
      },
      {
        "txt": "JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); registerMismatch(found, required, report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(),"
      },
      {
        "txt": "required.toString(), found.toString()))); } } } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) {"
      },
      {
        "txt": "mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { registerMismatch(found, required, report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); } private void registerMismatch(JSType found, JSType required, JSError error) { found = found.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return; } mismatches.add(new TypeMismatch(found, required, error)); if (found.isFunctionType() && required.isFunctionType()) { FunctionType fnTypeA = found.toMaybeFunctionType(); FunctionType fnTypeB = required.toMaybeFunctionType(); Iterator<Node> paramItA = fnTypeA.getParameters().iterator();"
      },
      {
        "txt": "Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error); } registerIfMismatch( fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); } } private void registerIfMismatch("
      },
      {
        "txt": "JSType found, JSType required, JSError error) { if (found != null && required != null && !found.canAssignTo(required)) { registerMismatch(found, required, error); } } private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); }"
      },
      {
        "txt": "String getReadableJSTypeName(Node n, boolean dereference) { if (n.isGetProp()) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { objectType = FunctionType.getTopDefiningInterface( objectType, propName); } else {"
      },
      {
        "txt": "while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } } if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } }"
      },
      {
        "txt": "} JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() ||"
      },
      {
        "txt": "(type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } else if (qualifiedName != null) { return qualifiedName; } else if (type.isFunctionType()) { return \"function\"; } else { return type.toString(); }"
      },
      {
        "txt": "} private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) {"
      },
      {
        "txt": "return typeRegistry.getNativeType(typeId); } private JSError report(JSError error) { if (shouldReport) { compiler.report(error); } return error; } static class TypeMismatch { final JSType typeA;"
      },
      {
        "txt": "final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) { this.typeA = a; this.typeB = b; this.src = src; } @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object;"
      },
      {
        "txt": "return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB)); } return false; } @Override public int hashCode() { return Objects.hashCode(typeA, typeB); }"
      },
      {
        "txt": "@Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  }
]