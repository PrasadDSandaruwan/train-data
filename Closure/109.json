[
  {
    "id": 449,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1908,
    "end-bug-line": 1908,
    "bug": "return parseTypeName(token);",
    "fix": "if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.base.Splitter; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SimpleErrorReporter; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno,"
      },
      {
        "txt": "int charno) { errorReporter.warning( SimpleErrorReporter.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(SimpleErrorReporter.getMessage0(messageId), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno,"
      },
      {
        "txt": "int charno) { errorReporter.warning( \"Bad type annotation. \" + SimpleErrorReporter.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + SimpleErrorReporter.getMessage0(messageId),"
      },
      {
        "txt": "getSourceName(), lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; private static final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private static final Set<String> idGeneratorAnnotationKeywords ="
      },
      {
        "txt": "ImmutableSet.<String>of(\"unique\", \"consistent\", \"stable\", \"mapped\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State {"
      },
      {
        "txt": "SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) { this.stream = stream;"
      },
      {
        "txt": "this.associatedNode = associatedNode; this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); this.jsdocBuilder.recordOriginalCommentPosition(commentNode.getPosition()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames;"
      },
      {
        "txt": "this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } private String getSourceName() { return sourceFile == null ? null : sourceFile.getName(); } public JSDocInfo parseInlineTypeDoc() { skipEOLs(); JsDocToken token = next(); int lineno = stream.getLineno();"
      },
      {
        "txt": "int startCharno = stream.getCharno(); Node typeAst = parseTypeExpression(token); recordTypeNode(lineno, startCharno, typeAst, token == JsDocToken.LC); JSTypeExpression expr = createJSTypeExpression(typeAst); if (expr != null) { jsdocBuilder.recordType(expr); return retrieveAndResetParsedJSDocInfo(); } return null; }"
      },
      {
        "txt": "private void recordTypeNode(int lineno, int startCharno, Node typeAst, boolean matchingLC) { if (typeAst != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode( typeAst, lineno, startCharno, endLineno, endCharno, matchingLC); } } public static Node parseTypeString(String typeString) {"
      },
      {
        "txt": "Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, null,"
      },
      {
        "txt": "config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token);"
      },
      {
        "txt": "token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } }"
      },
      {
        "txt": "return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList()); } private boolean parseHelperLoop(JsDocToken token, List<ExtendedTypeInfo> extendedTypes) { while (true) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; token = parseAnnotation(token, extendedTypes);"
      },
      {
        "txt": "} else { token = next(); } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true;"
      },
      {
        "txt": "case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; }"
      },
      {
        "txt": "token = next(); break; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); } break;"
      },
      {
        "txt": "} } } private JsDocToken parseAnnotation(JsDocToken token, List<ExtendedTypeInfo> extendedTypes) { JSTypeExpression type; int lineno = stream.getLineno(); int charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName);"
      },
      {
        "txt": "if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case NG_INJECT: if (jsdocBuilder.isNgInjectRecorded()) { parser.addParserWarning(\"msg.jsdoc.nginject.extra\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { jsdocBuilder.recordNgInject(true); } return eatUntilEOLIfNotAnnotation(); case JAGGER_INJECT: if (jsdocBuilder.isJaggerInjectRecorded()) { parser.addParserWarning(\"msg.jsdoc.jaggerInject.extra\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.recordJaggerInject(true);"
      },
      {
        "txt": "} return eatUntilEOLIfNotAnnotation(); case JAGGER_MODULE: if (jsdocBuilder.isJaggerModuleRecorded()) { parser.addParserWarning(\"msg.jsdoc.jaggerModule.extra\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.recordJaggerModule(true); } return eatUntilEOLIfNotAnnotation();"
      },
      {
        "txt": "case JAGGER_PROVIDE: if (jsdocBuilder.isJaggerProvideRecorded()) { parser.addParserWarning(\"msg.jsdoc.jaggerProvide.extra\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.recordJaggerProvide(true); } return eatUntilEOLIfNotAnnotation(); case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) {"
      },
      {
        "txt": "ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else {"
      },
      {
        "txt": "token = eatUntilEOLIfNotAnnotation(); } return token; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case STRUCT:"
      },
      {
        "txt": "if (!jsdocBuilder.recordStruct()) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case DICT: if (!jsdocBuilder.recordDict()) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(),"
      },
      {
        "txt": "stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } return eatUntilEOLIfNotAnnotation(); case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; return token; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } return eatUntilEOLIfNotAnnotation(); case DESC: if (jsdocBuilder.isDescriptionRecorded()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); return eatUntilEOLIfNotAnnotation(); } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; return token;"
      },
      {
        "txt": "} case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview)) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } return token; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; return token;"
      },
      {
        "txt": "case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) {"
      },
      {
        "txt": "type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatUntilEOLIfNotAnnotation(token); return token; case EXPORT: if (!jsdocBuilder.recordExport()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation();"
      },
      {
        "txt": "case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} return eatUntilEOLIfNotAnnotation(); case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) {"
      },
      {
        "txt": "token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); type = createJSTypeExpression(typeNode);"
      },
      {
        "txt": "if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); }"
      },
      {
        "txt": "} token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } else { token = next(); } } else if (token != JsDocToken.EOL &&"
      },
      {
        "txt": "token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatUntilEOLIfNotAnnotation(token); return token; case HIDDEN:"
      },
      {
        "txt": "if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next();"
      },
      {
        "txt": "matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } return token; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case NO_TYPE_CHECK:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case NOT_IMPLEMENTED: return eatUntilEOLIfNotAnnotation(); case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case THROWS: { skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null;"
      },
      {
        "txt": "if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { return eatUntilEOLIfNotAnnotation(); } } token = current(); jsdocBuilder.recordThrowType(type); boolean isAnnotationNext = lookAheadForAnnotation();"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatUntilEOLIfNotAnnotation();"
      },
      {
        "txt": "} return token; } case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) {"
      },
      {
        "txt": "type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { return eatUntilEOLIfNotAnnotation(); } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); }"
      },
      {
        "txt": "String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString();"
      },
      {
        "txt": "if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");"
      },
      {
        "txt": "} else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } } } if (name == null) { token = eatUntilEOLIfNotAnnotation(token); return token; }"
      },
      {
        "txt": "jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation() && token != JsDocToken.ANNOTATION) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); }"
      },
      {
        "txt": "token = paramDescriptionInfo.token; } else if (token != JsDocToken.EOC && token != JsDocToken.EOF) { token = eatUntilEOLIfNotAnnotation(); } return token; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "return eatUntilEOLIfNotAnnotation(); case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case MODIFIES: token = parseModifiesTag(next()); return token; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} return eatUntilEOLIfNotAnnotation(); case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatUntilEOLIfNotAnnotation(); } return token; case STABLEIDGENERATOR: if (!jsdocBuilder.recordStableIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.stableidgen\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } return eatUntilEOLIfNotAnnotation(); case SUPPRESS: token = parseSuppressTag(next()); return token; case TEMPLATE: { ExtractionInfo templateInfo = extractSingleLineBlock(); List<String> names = Lists.newArrayList( Splitter.on(',')"
      },
      {
        "txt": ".trimResults() .split(templateInfo.string)); if (names.size() == 0 || names.get(0).length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeNames(names)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token;"
      },
      {
        "txt": "return token; } case IDGENERATOR: token = parseIdGeneratorTag(next()); return token; case WIZACTION: if (!jsdocBuilder.recordWizaction()) { parser.addParserWarning(\"msg.jsdoc.wizaction\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "return eatUntilEOLIfNotAnnotation(); case DISPOSES: { ExtractionInfo templateInfo = extractSingleLineBlock(); List<String> names = Lists.newArrayList( Splitter.on(',') .trimResults() .split(templateInfo.string)); if (names.size() == 0 || names.get(0).length() == 0) { parser.addTypeWarning(\"msg.jsdoc.disposeparameter.missing\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else if (!jsdocBuilder.recordDisposesParameter(names)) { parser.addTypeWarning(\"msg.jsdoc.disposeparameter.error\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; return token; } case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string;"
      },
      {
        "txt": "if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token;"
      },
      {
        "txt": "return token; case CONSTANT: case DEFINE: case RETURN: case PRIVATE: case PROTECTED: case PUBLIC: case THIS: case TYPE: case TYPEDEF:"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; boolean hasType = lookAheadForType(); boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT); boolean canSkipTypeAnnotation ="
      },
      {
        "txt": "(isAlternateTypeAnnotation || annotation == Annotation.RETURN); type = null; if (hasType || !canSkipTypeAnnotation) { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); }"
      },
      {
        "txt": "type = createJSTypeExpression(typeNode); } boolean hasError = type == null && !canSkipTypeAnnotation; if (!hasError) { if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) { if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "} switch (annotation) { case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } break; case DEFINE: if (!jsdocBuilder.recordDefineType(type)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } return recordDescription(token); case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning( \"msg.jsdoc.visibility.private\", lineno, charno); }"
      },
      {
        "txt": "return recordDescription(token); case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning( \"msg.jsdoc.visibility.protected\", lineno, charno); } return recordDescription(token); case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {"
      },
      {
        "txt": "parser.addParserWarning( \"msg.jsdoc.visibility.public\", lineno, charno); } return recordDescription(token); case RETURN: if (type == null) { type = createJSTypeExpression(newNode(Token.QMARK)); } if (!jsdocBuilder.recordReturnType(type)) {"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } boolean isAnnotationNext = lookAheadForAnnotation(); if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription ="
      },
      {
        "txt": "returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else { token = eatUntilEOLIfNotAnnotation(); } return token;"
      },
      {
        "txt": "case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "} break; } } return eatUntilEOLIfNotAnnotation(); } } return next(); } private JsDocToken recordDescription(JsDocToken token) {"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } return token; } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) {"
      },
      {
        "txt": "if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); }"
      },
      {
        "txt": "} } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; }"
      },
      {
        "txt": "if (match(JsDocToken.PIPE, JsDocToken.COMMA)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } private JsDocToken parseModifiesTag(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else {"
      },
      {
        "txt": "break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } } return token; } private JsDocToken parseIdGeneratorTag(JsDocToken token) { String idgenKind = \"unique\"; if (token == JsDocToken.LC) { if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "String name = stream.getString(); if (!idGeneratorAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.idgen.unknown\", name, stream.getLineno(), stream.getCharno()); } idgenKind = name; token = next(); } else { parser.addParserWarning(\"msg.jsdoc.idgen.bad\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); return token; } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.idgen.bad\", stream.getLineno(), stream.getCharno()); } else { token = next(); } }"
      },
      {
        "txt": "if (idgenKind.equals(\"unique\")) { if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\", stream.getLineno(), stream.getCharno()); } } else if (idgenKind.equals(\"consistent\")) { if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} else if (idgenKind.equals(\"stable\")) { if (!jsdocBuilder.recordStableIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\", stream.getLineno(), stream.getCharno()); } } else if (idgenKind.equals(\"mapped\")) { if (!jsdocBuilder.recordMappedIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} return token; } Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);"
      },
      {
        "txt": "} private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); recordTypeNode(lineno, startCharno, typeNode, true); return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno,"
      },
      {
        "txt": "int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } recordTypeNode(lineno, startCharno, typeNode, matchingLC);"
      },
      {
        "txt": "return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\";"
      },
      {
        "txt": "case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC: return \"{\"; case LP: return \"(\";"
      },
      {
        "txt": "case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB: return \"]\"; case RC: return \"}\";"
      },
      {
        "txt": "case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString();"
      },
      {
        "txt": "default: throw new IllegalStateException(token.toString()); } } JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, getSourceName()); } private static class ExtractionInfo { private final String string;"
      },
      {
        "txt": "private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno; final int charno;"
      },
      {
        "txt": "public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1;"
      },
      {
        "txt": "String line = getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); }"
      },
      {
        "txt": "private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {"
      },
      {
        "txt": "return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder();"
      },
      {
        "txt": "builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; int lineStartChar = -1; do { switch (token) { case STAR: if (ignoreStar) { lineStartChar = stream.getCharno() + 1;"
      },
      {
        "txt": "} else { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) {"
      },
      {
        "txt": "builder.append(\"\\n\"); } ignoreStar = true; lineStartChar = 0; token = next(); continue; default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; boolean isEOC = token == JsDocToken.EOC;"
      },
      {
        "txt": "if (!isEOC) { if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { int numSpaces = stream.getCharno() - lineStartChar; for (int i = 0; i < numSpaces; i++) { builder.append(' '); } lineStartChar = -1; } else if (builder.length() > 0) { builder.append(' '); }"
      },
      {
        "txt": "} if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno();"
      },
      {
        "txt": "int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); } builder.append(toString(token)); line = getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "line = trimEnd(line); } builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true;"
      },
      {
        "txt": "do { switch (token) { case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' ');"
      },
      {
        "txt": "} builder.append('*'); } token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue;"
      },
      {
        "txt": "default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next();"
      },
      {
        "txt": "} } while (true); } private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else {"
      },
      {
        "txt": "break; } } if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) {"
      },
      {
        "txt": "skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } }"
      },
      {
        "txt": "return typeNode; } else { return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next();"
      },
      {
        "txt": "if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs();"
      },
      {
        "txt": "if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else {"
      },
      {
        "txt": "next(); } } return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) {"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token);"
      },
      {
        "txt": "} } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); }"
      },
      {
        "txt": "skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) {"
      },
      {
        "txt": "return null; } Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null;"
      },
      {
        "txt": "} typeList.addChildToBack(typeExpr); } return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS ||"
      },
      {
        "txt": "token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE || token == JsDocToken.GT || token == JsDocToken.EOC) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token));"
      },
      {
        "txt": "} else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next();"
      },
      {
        "txt": "} } return basicTypeExpr; } } private Node parseContextTypeExpression(JsDocToken token) { <extra_id_0> } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs();"
      },
      {
        "txt": "} else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) {"
      },
      {
        "txt": "String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } }"
      },
      {
        "txt": "restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); int lineno = stream.getLineno(); int charno = stream.getCharno();"
      },
      {
        "txt": "while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next(); typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) {"
      },
      {
        "txt": "next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next();"
      },
      {
        "txt": "} } return typeNameNode; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION);"
      },
      {
        "txt": "Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) {"
      },
      {
        "txt": "if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseContextTypeExpression(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType);"
      },
      {
        "txt": "} else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else { hasParams = false; }"
      },
      {
        "txt": "} } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } } } if (parameters != null) {"
      },
      {
        "txt": "functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null;"
      },
      {
        "txt": "} else { functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) {"
      },
      {
        "txt": "do { if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS);"
      },
      {
        "txt": "} else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs();"
      },
      {
        "txt": "next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break;"
      },
      {
        "txt": "} } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next());"
      },
      {
        "txt": "} } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); }"
      },
      {
        "txt": "Node expr = null; do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next();"
      },
      {
        "txt": "} skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA));"
      },
      {
        "txt": "if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union; } private Node parseArrayType(JsDocToken token) {"
      },
      {
        "txt": "Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) {"
      },
      {
        "txt": "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) {"
      },
      {
        "txt": "break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; }"
      },
      {
        "txt": "private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); }"
      },
      {
        "txt": "next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null;"
      },
      {
        "txt": "} fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs(); token = next(); } while (true);"
      },
      {
        "txt": "return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName;"
      },
      {
        "txt": "} next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression);"
      },
      {
        "txt": "return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default: return null; }"
      },
      {
        "txt": "} private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newStringNode(String s) { return newStringNode(s, stream.getLineno(), stream.getCharno()); } private Node newStringNode(String s, int lineno, int charno) { Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode); n.setLength(s.length()); return n; } private Node createTemplateNode() { Node templateNode = IR.script();"
      },
      {
        "txt": "templateNode.setStaticSourceFile( this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null); return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; }"
      },
      {
        "txt": "private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatUntilEOLIfNotAnnotation() { return eatUntilEOLIfNotAnnotation(next()); } private JsDocToken eatUntilEOLIfNotAnnotation(JsDocToken token) { if (token == JsDocToken.ANNOTATION) { state = State.SEARCHING_ANNOTATION; return token;"
      },
      {
        "txt": "} return eatTokensUntilEOL(token); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) {"
      },
      {
        "txt": "state = State.SEARCHING_ANNOTATION; return token; } token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token;"
      },
      {
        "txt": "} private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() {"
      },
      {
        "txt": "if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); } } private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t;"
      },
      {
        "txt": "} private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) { next(); } } } private String getRemainingJSDocLine() {"
      },
      {
        "txt": "String result = stream.getRemainingJSDocLine(); unreadToken = NO_UNREAD_TOKEN; return result; } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); }"
      },
      {
        "txt": "JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForType() { return lookAheadFor('{'); } private boolean lookAheadForAnnotation() {"
      },
      {
        "txt": "return lookAheadFor('@'); } private boolean lookAheadFor(char expect) { boolean matched = false; int c; while (true) { c = stream.getChar(); if (c == ' ') { continue; } else if (c == expect) {"
      },
      {
        "txt": "matched = true; break; } else { break; } } stream.ungetChar(c); return matched; }"
      }
    ]
  }
]