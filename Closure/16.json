[
  {
    "id": 224,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 170,
    "end-bug-line": 170,
    "bug": "",
    "fix": "private final Node aliasDefinition;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\";"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" +"
      },
      {
        "txt": "\" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler;"
      },
      {
        "txt": "this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal();"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else {"
      },
      {
        "txt": "aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock);"
      },
      {
        "txt": "NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage {"
      },
      {
        "txt": "public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node typeReference; <extra_id_0> AliasedTypeNode(Node typeReference, String aliasName) { this.typeReference = typeReference; this.aliasName = aliasName; } @Override"
      },
      {
        "txt": "} @Override public void applyAlias() { typeReference.setString(aliasName); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList();"
      },
      {
        "txt": "private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages;"
      },
      {
        "txt": "} List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());"
      },
      {
        "txt": "} @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null;"
      },
      {
        "txt": "hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } }"
      },
      {
        "txt": "return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();"
      },
      {
        "txt": "int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments));"
      },
      {
        "txt": "hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) {"
      },
      {
        "txt": "String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) {"
      },
      {
        "txt": "forbiddenLocals.add(qNameRoot); } } } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } }"
      },
      {
        "txt": "private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; }"
      },
      {
        "txt": "} } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s);"
      },
      {
        "txt": "} MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) {"
      },
      {
        "txt": "aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }"
      },
      {
        "txt": "} } } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); }"
      },
      {
        "txt": "String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child);"
      },
      {
        "txt": "} } }"
      }
    ]
  },
  {
    "id": 225,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 172,
    "end-bug-line": 172,
    "bug": "AliasedTypeNode(Node typeReference,",
    "fix": "AliasedTypeNode(Node typeReference, Node aliasDefinition,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable;"
      },
      {
        "txt": "this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal);"
      },
      {
        "txt": "if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage { public void applyAlias();"
      },
      {
        "txt": "} private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() {"
      },
      {
        "txt": "aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final String aliasName; <extra_id_0> String aliasName) { this.typeReference = typeReference; this.aliasName = aliasName; } @Override public void applyAlias() {"
      },
      {
        "txt": "@Override public void applyAlias() { typeReference.setString(aliasName); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap();"
      },
      {
        "txt": "private final Set<String> forbiddenLocals = Sets.newHashSet(); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; }"
      },
      {
        "txt": "List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false;"
      },
      {
        "txt": "} } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true;"
      },
      {
        "txt": "} private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();"
      },
      {
        "txt": "SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true;"
      },
      {
        "txt": "} private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString();"
      },
      {
        "txt": "Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot);"
      },
      {
        "txt": "} } } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void findNamespaceShadows(NodeTraversal t) {"
      },
      {
        "txt": "if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; } }"
      },
      {
        "txt": "} private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s); }"
      },
      {
        "txt": "MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);"
      },
      {
        "txt": "} else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); }"
      },
      {
        "txt": "if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar;"
      },
      {
        "txt": "} } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); }"
      },
      {
        "txt": "} if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) {"
      },
      {
        "txt": "if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 226,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 175,
    "end-bug-line": 175,
    "bug": "",
    "fix": "this.aliasDefinition = aliasDefinition;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override"
      },
      {
        "txt": "public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias();"
      },
      {
        "txt": "} for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) {"
      },
      {
        "txt": "Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 ||"
      },
      {
        "txt": "traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference;"
      },
      {
        "txt": "private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); }"
      },
      {
        "txt": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final String aliasName; AliasedTypeNode(Node typeReference, String aliasName) { this.typeReference = typeReference; <extra_id_0> } @Override public void applyAlias() { typeReference.setString(aliasName); } }"
      },
      {
        "txt": "} } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(); private boolean hasNamespaceShadows = false; private boolean hasErrors = false;"
      },
      {
        "txt": "private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; }"
      },
      {
        "txt": "boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent();"
      },
      {
        "txt": "if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t);"
      },
      {
        "txt": "} if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override"
      },
      {
        "txt": "public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n;"
      },
      {
        "txt": "Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation("
      },
      {
        "txt": "n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope();"
      },
      {
        "txt": "for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } } else if (v.isBleedingFunction()) {"
      },
      {
        "txt": "} else if (parent.getType() == Token.LP) { } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; }"
      },
      {
        "txt": "Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; } } } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) {"
      },
      {
        "txt": "MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s); } MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier);"
      },
      {
        "txt": "} } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); }"
      },
      {
        "txt": "} } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; }"
      },
      {
        "txt": "int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) {"
      },
      {
        "txt": "if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);"
      },
      {
        "txt": "} else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode));"
      },
      {
        "txt": "} JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) {"
      },
      {
        "txt": "if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 227,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 180,
    "end-bug-line": 180,
    "bug": "typeReference.setString(aliasName);",
    "fix": "String typeName = typeReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable;"
      },
      {
        "txt": "class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) {"
      },
      {
        "txt": "aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild("
      },
      {
        "txt": "expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } }"
      },
      {
        "txt": "} private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition;"
      },
      {
        "txt": "} @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final String aliasName;"
      },
      {
        "txt": "String aliasName) { this.typeReference = typeReference; this.aliasName = aliasName; } @Override public void applyAlias() { <extra_id_0> } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList();"
      },
      {
        "txt": "private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; }"
      },
      {
        "txt": "private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) {"
      },
      {
        "txt": "return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t);"
      },
      {
        "txt": "} } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear();"
      },
      {
        "txt": "forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false;"
      },
      {
        "txt": "} } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext(); testNode = testNode.getParent();"
      },
      {
        "txt": "} int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error,"
      },
      {
        "txt": "String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent();"
      },
      {
        "txt": "if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) {"
      },
      {
        "txt": "String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); }"
      },
      {
        "txt": "} } private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true;"
      },
      {
        "txt": "return; } } } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals);"
      },
      {
        "txt": "for (String s : forbiddenLocals) { renamer.addDeclaredName(s); } MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) {"
      },
      {
        "txt": "preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() ||"
      },
      {
        "txt": "NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString();"
      },
      {
        "txt": "Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return;"
      },
      {
        "txt": "} else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW);"
      },
      {
        "txt": "} } if (t.getScopeDepth() >= 2) { if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) {"
      },
      {
        "txt": "fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) {"
      },
      {
        "txt": "endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null;"
      },
      {
        "txt": "child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 228,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 468,
    "end-bug-line": 468,
    "bug": "aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));",
    "fix": "aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass {"
      },
      {
        "txt": "static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\","
      },
      {
        "txt": "\"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\","
      },
      {
        "txt": "\"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) {"
      },
      {
        "txt": "this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) {"
      },
      {
        "txt": "Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent();"
      },
      {
        "txt": "} else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall,"
      },
      {
        "txt": "scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } }"
      },
      {
        "txt": "private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; }"
      },
      {
        "txt": "@Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final String aliasName; AliasedTypeNode(Node typeReference,"
      },
      {
        "txt": "String aliasName) { this.typeReference = typeReference; this.aliasName = aliasName; } @Override public void applyAlias() { typeReference.setString(aliasName); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType();"
      },
      {
        "txt": "Node parent = n.getParent(); if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\");"
      },
      {
        "txt": "if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());"
      },
      {
        "txt": "} } } private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) {"
      },
      {
        "txt": "hasNamespaceShadows = true; return; } } } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(),"
      },
      {
        "txt": "forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s); } MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1);"
      },
      {
        "txt": "if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) {"
      },
      {
        "txt": "String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n);"
      },
      {
        "txt": "return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) {"
      },
      {
        "txt": "for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.');"
      },
      {
        "txt": "endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); <extra_id_0> } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); }"
      },
      {
        "txt": "fixTypeNode(child); } } }"
      }
    ]
  }
]