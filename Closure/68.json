[
  {
    "id": 352,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 868,
    "end-bug-line": 868,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.parsing.Config.LanguageMode;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.JSDocInfo.Visibility; import java.util.HashSet; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.List; public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final String sourceName; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno,"
      },
      {
        "txt": "int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) {"
      },
      {
        "txt": "errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno);"
      },
      {
        "txt": "} } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder("
      },
      {
        "txt": "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION"
      },
      {
        "txt": "} JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, String sourceName, Config config, ErrorReporter errorReporter) { this.stream = stream; this.sourceName = sourceName; this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) {"
      },
      {
        "txt": "this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(),"
      },
      {
        "txt": "Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, \"typeparsing\", config, NullErrorReporter.forNewRhino());"
      },
      {
        "txt": "return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\");"
      },
      {
        "txt": "} } retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString();"
      },
      {
        "txt": "Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock();"
      },
      {
        "txt": "String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token);"
      },
      {
        "txt": "} continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR:"
      },
      {
        "txt": "if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; }"
      },
      {
        "txt": "case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token);"
      },
      {
        "txt": "} if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry;"
      },
      {
        "txt": "case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) {"
      },
      {
        "txt": "type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS:"
      },
      {
        "txt": "case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; }"
      },
      {
        "txt": "if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode);"
      },
      {
        "txt": "if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); }"
      },
      {
        "txt": "} token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true;"
      },
      {
        "txt": "} if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS:"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); }"
      },
      {
        "txt": "if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) {"
      },
      {
        "txt": "token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) {"
      },
      {
        "txt": "name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } }"
      },
      {
        "txt": "} if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string;"
      },
      {
        "txt": "if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY:"
      },
      {
        "txt": "if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference);"
      },
      {
        "txt": "} token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE:"
      },
      {
        "txt": "ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = templateInfo.token; continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE:"
      },
      {
        "txt": "case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next();"
      },
      {
        "txt": "typeNode = parseAndRecordTypeNode(token, lineno, charno); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) {"
      },
      {
        "txt": "} else { switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) {"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) {"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break;"
      },
      {
        "txt": "if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; } <extra_id_0> token = eatTokensUntilEOL(); } continue retry; } } }"
      },
      {
        "txt": "} } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF:"
      },
      {
        "txt": "jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next();"
      },
      {
        "txt": "continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "} token = next(); } } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno);"
      },
      {
        "txt": "} } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString());"
      },
      {
        "txt": "token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break;"
      },
      {
        "txt": "} } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} } } return token; } private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } }"
      },
      {
        "txt": "return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNode(JsDocToken token, int lineno,"
      },
      {
        "txt": "int startCharno) { return parseAndRecordTypeNode(token, lineno, startCharno, token == JsDocToken.LC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC);"
      },
      {
        "txt": "int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, true); return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno,"
      },
      {
        "txt": "boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);"
      },
      {
        "txt": "} int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, matchingLC); return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString();"
      },
      {
        "txt": "case BANG: return \"!\"; case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\";"
      },
      {
        "txt": "case LC: return \"{\"; case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\";"
      },
      {
        "txt": "case RB: return \"]\"; case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\";"
      },
      {
        "txt": "case EQUALS: return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null :"
      },
      {
        "txt": "new JSTypeExpression(n, sourceName); } private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } }"
      },
      {
        "txt": "private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } }"
      },
      {
        "txt": "private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next());"
      },
      {
        "txt": "} private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\")"
      },
      {
        "txt": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine();"
      },
      {
        "txt": "if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) {"
      },
      {
        "txt": "case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL:"
      },
      {
        "txt": "if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\"); } ignoreStar = true; token = next(); continue; case ANNOTATION: case EOC: case EOF: if (!(option == WhitespaceOption.PRESERVE &&"
      },
      {
        "txt": "token == JsDocToken.ANNOTATION)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);"
      },
      {
        "txt": "} return new ExtractionInfo(multilineText, token); } default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token));"
      },
      {
        "txt": "line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) {"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) { case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) {"
      },
      {
        "txt": "if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n');"
      },
      {
        "txt": "token = next(); continue; default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line);"
      },
      {
        "txt": "builder.append(line); token = next(); } } while (true); } private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) {"
      },
      {
        "txt": "trimCount++; } else { break; } } if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); }"
      },
      {
        "txt": "private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next();"
      },
      {
        "txt": "} } return typeNode; } else { return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs();"
      },
      {
        "txt": "boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY)); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token);"
      },
      {
        "txt": "if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs();"
      },
      {
        "txt": "Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode;"
      },
      {
        "txt": "} else { return parseTypeName(token); } } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "next(); } skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) {"
      },
      {
        "txt": "Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; } Node typeList = new Node(Token.BLOCK); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next());"
      },
      {
        "txt": "if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr); } return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next();"
      },
      {
        "txt": "if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) {"
      },
      {
        "txt": "return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr);"
      },
      {
        "txt": "} } return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs();"
      },
      {
        "txt": "return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) {"
      },
      {
        "txt": "skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } return reportGenericTypeSyntaxWarning(); }"
      },
      {
        "txt": "private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next();"
      },
      {
        "txt": "typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType);"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); } } return typeNameNode; } private Node parseFunctionType(JsDocToken token) {"
      },
      {
        "txt": "if (token != JsDocToken.LP) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) {"
      },
      {
        "txt": "String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseTypeName(next()));"
      },
      {
        "txt": "if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs();"
      },
      {
        "txt": "token = next(); } else { hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null;"
      },
      {
        "txt": "} } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); }"
      },
      {
        "txt": "skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) {"
      },
      {
        "txt": "Node paramsType = newNode(Token.LP); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next(); }"
      },
      {
        "txt": "if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next();"
      },
      {
        "txt": "skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); } isVarArgs = true;"
      },
      {
        "txt": "} else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null;"
      },
      {
        "txt": "} paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); }"
      },
      {
        "txt": "return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) {"
      },
      {
        "txt": "next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {"
      },
      {
        "txt": "Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState("
      },
      {
        "txt": "token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) {"
      },
      {
        "txt": "return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next();"
      },
      {
        "txt": "} return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next();"
      },
      {
        "txt": "skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) {"
      },
      {
        "txt": "return null; } array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");"
      },
      {
        "txt": "} next(); return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); }"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB);"
      },
      {
        "txt": "do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; }"
      },
      {
        "txt": "next(); skipEOLs(); token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null;"
      },
      {
        "txt": "} skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null;"
      },
      {
        "txt": "} Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString();"
      },
      {
        "txt": "return newStringNode(string); default: return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return Node.newString(s, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT);"
      },
      {
        "txt": "templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); }"
      },
      {
        "txt": "private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; }"
      },
      {
        "txt": "token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next();"
      },
      {
        "txt": "return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else {"
      },
      {
        "txt": "return current(); } } private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) {"
      },
      {
        "txt": "next(); if (match(JsDocToken.STAR)) { next(); } } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() {"
      },
      {
        "txt": "return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(sourceName); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false;"
      },
      {
        "txt": "int c; while (true) { c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else { break;"
      },
      {
        "txt": "} } stream.ungetChar(c); return matchedLc; }"
      }
    ]
  },
  {
    "id": 353,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 870,
    "end-bug-line": 870,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.JSDocInfo.Visibility; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.List;"
      },
      {
        "txt": "public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final String sourceName; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) {"
      },
      {
        "txt": "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning("
      },
      {
        "txt": "\"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); }"
      },
      {
        "txt": "} private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {"
      },
      {
        "txt": "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION }"
      },
      {
        "txt": "JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, String sourceName, Config config, ErrorReporter errorReporter) { this.stream = stream; this.sourceName = sourceName; this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());"
      },
      {
        "txt": "} this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(),"
      },
      {
        "txt": "false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, \"typeparsing\", config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next());"
      },
      {
        "txt": "} boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) {"
      },
      {
        "txt": "ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); }"
      },
      {
        "txt": "} retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName);"
      },
      {
        "txt": "if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string;"
      },
      {
        "txt": "if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) {"
      },
      {
        "txt": "if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason);"
      },
      {
        "txt": "} token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW:"
      },
      {
        "txt": "String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token,"
      },
      {
        "txt": "WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM:"
      },
      {
        "txt": "token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\"));"
      },
      {
        "txt": "} if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS:"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) {"
      },
      {
        "txt": "Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) {"
      },
      {
        "txt": "extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } }"
      },
      {
        "txt": "token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; }"
      },
      {
        "txt": "if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string;"
      },
      {
        "txt": "token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs();"
      },
      {
        "txt": "token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "} } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description);"
      },
      {
        "txt": "} token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno();"
      },
      {
        "txt": "charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs();"
      },
      {
        "txt": "token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next();"
      },
      {
        "txt": "} } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null;"
      },
      {
        "txt": "} else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } } }"
      },
      {
        "txt": "if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC:"
      },
      {
        "txt": "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); }"
      },
      {
        "txt": "token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock();"
      },
      {
        "txt": "String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token;"
      },
      {
        "txt": "continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF:"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token, lineno, charno);"
      },
      {
        "txt": "} if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else {"
      },
      {
        "txt": "switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription("
      },
      {
        "txt": "returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF:"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; } token = eatTokensUntilEOL(); <extra_id_0> continue retry; } } } break; case EOC:"
      },
      {
        "txt": "break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default:"
      },
      {
        "txt": "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next();"
      },
      {
        "txt": "} } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else {"
      },
      {
        "txt": "if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>();"
      },
      {
        "txt": "while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } }"
      },
      {
        "txt": "if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "} return token; } private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name)"
      },
      {
        "txt": "&& !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token;"
      },
      {
        "txt": "} if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; }"
      },
      {
        "txt": "private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno) { return parseAndRecordTypeNode(token, lineno, startCharno,"
      },
      {
        "txt": "token == JsDocToken.LC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno();"
      },
      {
        "txt": "Node typeNode = parseParamTypeExpressionAnnotation(token); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, true); return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) {"
      },
      {
        "txt": "Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } int endCharno = stream.getCharno();"
      },
      {
        "txt": "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, matchingLC); return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\";"
      },
      {
        "txt": "case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC: return \"{\";"
      },
      {
        "txt": "case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB: return \"]\";"
      },
      {
        "txt": "case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS: return \"=\";"
      },
      {
        "txt": "case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, sourceName); }"
      },
      {
        "txt": "private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo { final JSTypeExpression type;"
      },
      {
        "txt": "final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() { stream.update();"
      },
      {
        "txt": "int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {"
      },
      {
        "txt": "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {"
      },
      {
        "txt": "if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim();"
      },
      {
        "txt": "} StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) { case STAR: if (!ignoreStar) {"
      },
      {
        "txt": "if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\");"
      },
      {
        "txt": "} ignoreStar = true; token = next(); continue; case ANNOTATION: case EOC: case EOF: if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) { String multilineText = builder.toString();"
      },
      {
        "txt": "if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token);"
      },
      {
        "txt": "} default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "line = trimEnd(line); } builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true;"
      },
      {
        "txt": "do { switch (token) { case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' ');"
      },
      {
        "txt": "} builder.append('*'); } token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue;"
      },
      {
        "txt": "default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next();"
      },
      {
        "txt": "} } while (true); } private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else {"
      },
      {
        "txt": "break; } } if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) {"
      },
      {
        "txt": "skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } }"
      },
      {
        "txt": "return typeNode; } else { return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next();"
      },
      {
        "txt": "if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY)); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs();"
      },
      {
        "txt": "if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else {"
      },
      {
        "txt": "next(); } } return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) {"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token);"
      },
      {
        "txt": "} } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); }"
      },
      {
        "txt": "skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) {"
      },
      {
        "txt": "return null; } Node typeList = new Node(Token.BLOCK); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null;"
      },
      {
        "txt": "} typeList.addChildToBack(typeExpr); } return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS ||"
      },
      {
        "txt": "token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else {"
      },
      {
        "txt": "Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } }"
      },
      {
        "txt": "return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) {"
      },
      {
        "txt": "skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next());"
      },
      {
        "txt": "} else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) {"
      },
      {
        "txt": "return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next(); typeName += stream.getString(); }"
      },
      {
        "txt": "} Node typeNameNode = newStringNode(typeName); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); } } return typeNameNode; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");"
      },
      {
        "txt": "} Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr);"
      },
      {
        "txt": "boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null;"
      },
      {
        "txt": "} functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else {"
      },
      {
        "txt": "hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } }"
      },
      {
        "txt": "} if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next());"
      },
      {
        "txt": "if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.LP); boolean isVarArgs = false;"
      },
      {
        "txt": "Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs();"
      },
      {
        "txt": "if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token);"
      },
      {
        "txt": "if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType);"
      },
      {
        "txt": "if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; }"
      },
      {
        "txt": "private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID);"
      },
      {
        "txt": "} else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) {"
      },
      {
        "txt": "union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE;"
      },
      {
        "txt": "if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; }"
      },
      {
        "txt": "union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union;"
      },
      {
        "txt": "} private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) { return null; }"
      },
      {
        "txt": "array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next();"
      },
      {
        "txt": "return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token);"
      },
      {
        "txt": "if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs();"
      },
      {
        "txt": "token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON);"
      },
      {
        "txt": "fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default:"
      },
      {
        "txt": "return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(),"
      },
      {
        "txt": "stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return Node.newString(s, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode;"
      },
      {
        "txt": "} private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next());"
      },
      {
        "txt": "} private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next(); } while (true);"
      },
      {
        "txt": "} private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; }"
      },
      {
        "txt": "private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); }"
      },
      {
        "txt": "} private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) {"
      },
      {
        "txt": "next(); } } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); }"
      },
      {
        "txt": "JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(sourceName); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c; while (true) {"
      },
      {
        "txt": "c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else { break; } }"
      },
      {
        "txt": "stream.ungetChar(c); return matchedLc; }"
      }
    ]
  },
  {
    "id": 354,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1709,
    "end-bug-line": 1709,
    "bug": "",
    "fix": "restoreLookAhead(token);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfoBuilder;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.JSDocInfo.Visibility; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.List; public final class JsDocInfoParser {"
      },
      {
        "txt": "private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final String sourceName; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),"
      },
      {
        "txt": "sourceName, lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" +"
      },
      {
        "txt": "ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } }"
      },
      {
        "txt": "private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;"
      },
      {
        "txt": "} void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream,"
      },
      {
        "txt": "Comment commentNode, String sourceName, Config config, ErrorReporter errorReporter) { this.stream = stream; this.sourceName = sourceName; this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); }"
      },
      {
        "txt": "this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false,"
      },
      {
        "txt": "LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, \"typeparsing\", config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); }"
      },
      {
        "txt": "boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token);"
      },
      {
        "txt": "token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } }"
      },
      {
        "txt": "retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry;"
      },
      {
        "txt": "case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED:"
      },
      {
        "txt": "if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); }"
      },
      {
        "txt": "token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "} else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \"\";"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) ||"
      },
      {
        "txt": "fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);"
      },
      {
        "txt": "String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); }"
      },
      {
        "txt": "if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs();"
      },
      {
        "txt": "token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode("
      },
      {
        "txt": "token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo("
      },
      {
        "txt": "type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next();"
      },
      {
        "txt": "if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token;"
      },
      {
        "txt": "if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC:"
      },
      {
        "txt": "case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "} token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); }"
      },
      {
        "txt": "token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\","
      },
      {
        "txt": "lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); }"
      },
      {
        "txt": "} if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) {"
      },
      {
        "txt": "if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } } } if (name == null) {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name,"
      },
      {
        "txt": "paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES:"
      },
      {
        "txt": "token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE:"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token;"
      },
      {
        "txt": "} else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string;"
      },
      {
        "txt": "if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry;"
      },
      {
        "txt": "case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno();"
      },
      {
        "txt": "charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token, lineno, charno); }"
      },
      {
        "txt": "if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) {"
      },
      {
        "txt": "case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription);"
      },
      {
        "txt": "} token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "} break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) {"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; } token = eatTokensUntilEOL(); } continue retry; } }"
      },
      {
        "txt": "} break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null);"
      },
      {
        "txt": "parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry;"
      },
      {
        "txt": "default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } }"
      },
      {
        "txt": "token = next(); } } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); }"
      },
      {
        "txt": "} else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) {"
      },
      {
        "txt": "Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next();"
      },
      {
        "txt": "} else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; }"
      },
      {
        "txt": "} if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} } return token; } private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString();"
      },
      {
        "txt": "if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token;"
      },
      {
        "txt": "} private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno) {"
      },
      {
        "txt": "return parseAndRecordTypeNode(token, lineno, startCharno, token == JsDocToken.LC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno();"
      },
      {
        "txt": "int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, true); return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC,"
      },
      {
        "txt": "boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); }"
      },
      {
        "txt": "int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, matchingLC); return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG:"
      },
      {
        "txt": "return \"!\"; case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC:"
      },
      {
        "txt": "return \"{\"; case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB:"
      },
      {
        "txt": "return \"]\"; case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS:"
      },
      {
        "txt": "return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, sourceName);"
      },
      {
        "txt": "} private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo {"
      },
      {
        "txt": "final JSTypeExpression type; final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() {"
      },
      {
        "txt": "stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); }"
      },
      {
        "txt": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,"
      },
      {
        "txt": "WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) { case STAR:"
      },
      {
        "txt": "if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) {"
      },
      {
        "txt": "builder.append(\"\\n\"); } ignoreStar = true; token = next(); continue; case ANNOTATION: case EOC: case EOF: if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) {"
      },
      {
        "txt": "String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); }"
      },
      {
        "txt": "return new ExtractionInfo(multilineText, token); } default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine();"
      },
      {
        "txt": "if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder();"
      },
      {
        "txt": "boolean ignoreStar = true; do { switch (token) { case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next();"
      },
      {
        "txt": "continue; default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line);"
      },
      {
        "txt": "token = next(); } } while (true); } private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++;"
      },
      {
        "txt": "} else { break; } } if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); }"
      },
      {
        "txt": "} return typeNode; } else { return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false;"
      },
      {
        "txt": "token = next(); if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY)); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) {"
      },
      {
        "txt": "skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");"
      },
      {
        "txt": "} else { next(); } } return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next());"
      },
      {
        "txt": "if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else {"
      },
      {
        "txt": "return parseTypeName(token); } } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next();"
      },
      {
        "txt": "} skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token);"
      },
      {
        "txt": "if (typeExpr == null) { return null; } Node typeList = new Node(Token.BLOCK); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) {"
      },
      {
        "txt": "return null; } typeList.addChildToBack(typeExpr); } return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA ||"
      },
      {
        "txt": "token == JsDocToken.EQUALS || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next()));"
      },
      {
        "txt": "} else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); }"
      },
      {
        "txt": "} return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next());"
      },
      {
        "txt": "} else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs();"
      },
      {
        "txt": "} else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } <extra_id_0> } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString();"
      },
      {
        "txt": "} String typeName = stream.getString(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next(); typeName += stream.getString(); } }"
      },
      {
        "txt": "Node typeNameNode = newStringNode(typeName); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");"
      },
      {
        "txt": "} next(); } } return typeNameNode; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); }"
      },
      {
        "txt": "Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr);"
      },
      {
        "txt": "if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; }"
      },
      {
        "txt": "functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else { hasParams = false;"
      },
      {
        "txt": "} } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } } }"
      },
      {
        "txt": "if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) {"
      },
      {
        "txt": "return null; } else { functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.LP); boolean isVarArgs = false; Node paramType = null;"
      },
      {
        "txt": "if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) {"
      },
      {
        "txt": "paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) {"
      },
      {
        "txt": "skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) {"
      },
      {
        "txt": "break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; } private Node parseResultType(JsDocToken token) {"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else {"
      },
      {
        "txt": "return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate);"
      },
      {
        "txt": "} Node expr = null; do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; } union.addChildToBack(expr);"
      },
      {
        "txt": "} while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union; }"
      },
      {
        "txt": "private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next(); }"
      },
      {
        "txt": "if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) { return null; } array.addChildToBack(arg);"
      },
      {
        "txt": "if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array;"
      },
      {
        "txt": "} private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");"
      },
      {
        "txt": "} next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) {"
      },
      {
        "txt": "return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs(); if (!match(JsDocToken.COLON)) {"
      },
      {
        "txt": "return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName);"
      },
      {
        "txt": "fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default: return null;"
      },
      {
        "txt": "} } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode);"
      },
      {
        "txt": "} private Node newStringNode(String s) { return Node.newString(s, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; }"
      },
      {
        "txt": "private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); }"
      },
      {
        "txt": "private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next(); } while (true); }"
      },
      {
        "txt": "private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) {"
      },
      {
        "txt": "unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); } }"
      },
      {
        "txt": "private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) { next();"
      },
      {
        "txt": "} } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() {"
      },
      {
        "txt": "return jsdocBuilder.build(sourceName); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c; while (true) { c = stream.getChar();"
      },
      {
        "txt": "if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else { break; } } stream.ungetChar(c);"
      },
      {
        "txt": "return matchedLc; }"
      }
    ]
  },
  {
    "id": 355,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1761,
    "end-bug-line": 1761,
    "bug": "",
    "fix": "restoreLookAhead(token);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import com.google.javascript.rhino.JSDocInfo.Visibility; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.List; public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final String sourceName;"
      },
      {
        "txt": "private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) {"
      },
      {
        "txt": "errorReporter.warning(ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno); }"
      },
      {
        "txt": "void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames;"
      },
      {
        "txt": "private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;"
      },
      {
        "txt": "} private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, String sourceName, Config config,"
      },
      {
        "txt": "ErrorReporter errorReporter) { this.stream = stream; this.sourceName = sourceName; this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter;"
      },
      {
        "txt": "this.templateNode = this.createTemplateNode(); } public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser("
      },
      {
        "txt": "new JsDocTokenStream(typeString), null, \"typeparsing\", config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno; int charno;"
      },
      {
        "txt": "JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string);"
      },
      {
        "txt": "} } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } } retry: for (;;) { switch (token) { case ANNOTATION:"
      },
      {
        "txt": "if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token,"
      },
      {
        "txt": "WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) {"
      },
      {
        "txt": "fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null;"
      },
      {
        "txt": "if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "} token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState("
      },
      {
        "txt": "annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS:"
      },
      {
        "txt": "skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null;"
      },
      {
        "txt": "if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current(); jsdocBuilder.recordThrowType(type);"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token);"
      },
      {
        "txt": "} continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression("
      },
      {
        "txt": "parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); }"
      },
      {
        "txt": "String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString();"
      },
      {
        "txt": "if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");"
      },
      {
        "txt": "} else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; }"
      },
      {
        "txt": "jsdocBuilder.markName(name, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token;"
      },
      {
        "txt": "} else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST:"
      },
      {
        "txt": "if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string;"
      },
      {
        "txt": "if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string;"
      },
      {
        "txt": "if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token;"
      },
      {
        "txt": "continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() &&"
      },
      {
        "txt": "annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token, lineno, charno); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) {"
      },
      {
        "txt": "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\","
      },
      {
        "txt": "lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) {"
      },
      {
        "txt": "ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "break; } token = eatTokensUntilEOL(); } continue retry; } } } break; case EOC:"
      },
      {
        "txt": "if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes);"
      },
      {
        "txt": "return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next();"
      },
      {
        "txt": "continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } }"
      },
      {
        "txt": "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token;"
      },
      {
        "txt": "} private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,"
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next();"
      },
      {
        "txt": "if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC);"
      },
      {
        "txt": "} private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno) { return parseAndRecordTypeNode(token, lineno, startCharno, token == JsDocToken.LC, false); }"
      },
      {
        "txt": "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); int endCharno = stream.getCharno();"
      },
      {
        "txt": "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, true); return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) {"
      },
      {
        "txt": "typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, matchingLC);"
      },
      {
        "txt": "return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\";"
      },
      {
        "txt": "case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC: return \"{\"; case LP: return \"(\";"
      },
      {
        "txt": "case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB: return \"]\"; case RC: return \"}\";"
      },
      {
        "txt": "case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString();"
      },
      {
        "txt": "default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, sourceName); } private static class ExtractionInfo { private final String string;"
      },
      {
        "txt": "private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno; final int charno;"
      },
      {
        "txt": "public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1;"
      },
      {
        "txt": "String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); }"
      },
      {
        "txt": "private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {"
      },
      {
        "txt": "return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder();"
      },
      {
        "txt": "builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) { case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' ');"
      },
      {
        "txt": "} builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\"); } ignoreStar = true;"
      },
      {
        "txt": "token = next(); continue; case ANNOTATION: case EOC: case EOF: if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim();"
      },
      {
        "txt": "} int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); } default:"
      },
      {
        "txt": "ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); }"
      },
      {
        "txt": "builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) {"
      },
      {
        "txt": "case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*');"
      },
      {
        "txt": "} token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default: if (!ignoreStar && builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); } } while (true);"
      },
      {
        "txt": "} private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break; }"
      },
      {
        "txt": "} if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next());"
      },
      {
        "txt": "if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else {"
      },
      {
        "txt": "return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next();"
      },
      {
        "txt": "if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY)); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode);"
      },
      {
        "txt": "} else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); }"
      },
      {
        "txt": "} return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token); } }"
      },
      {
        "txt": "private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next();"
      },
      {
        "txt": "return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; }"
      },
      {
        "txt": "Node typeList = new Node(Token.BLOCK); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr);"
      },
      {
        "txt": "} return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RC || token == JsDocToken.RP ||"
      },
      {
        "txt": "token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) {"
      },
      {
        "txt": "if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } } return basicTypeExpr; }"
      },
      {
        "txt": "} private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next());"
      },
      {
        "txt": "} else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string);"
      },
      {
        "txt": "} else { return parseTypeName(token); } } return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); }"
      },
      {
        "txt": "String typeName = stream.getString(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next(); typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName);"
      },
      {
        "txt": "if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); }"
      },
      {
        "txt": "} } return typeNameNode; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { <extra_id_0> } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next();"
      },
      {
        "txt": "if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next();"
      },
      {
        "txt": "skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");"
      },
      {
        "txt": "} if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else { hasParams = false; } } }"
      },
      {
        "txt": "if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); }"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType);"
      },
      {
        "txt": "} return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.LP); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) {"
      },
      {
        "txt": "next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); }"
      },
      {
        "txt": "skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType);"
      },
      {
        "txt": "} } if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA));"
      },
      {
        "txt": "} if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY);"
      },
      {
        "txt": "} token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); } }"
      },
      {
        "txt": "private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null; do {"
      },
      {
        "txt": "if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs();"
      },
      {
        "txt": "token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null;"
      },
      {
        "txt": "boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true;"
      },
      {
        "txt": "} else { arg = parseTypeExpression(token); } if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) { break; }"
      },
      {
        "txt": "skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC);"
      },
      {
        "txt": "Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList);"
      },
      {
        "txt": "return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType);"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs(); token = next(); } while (true); return fieldTypeList; }"
      },
      {
        "txt": "private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; } next();"
      },
      {
        "txt": "skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; }"
      },
      {
        "txt": "private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default: return null; } } private Node wrapNode(int type, Node n) {"
      },
      {
        "txt": "return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return Node.newString(s, stream.getLineno(),"
      },
      {
        "txt": "stream.getCharno()).clonePropsFrom(templateNode); } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null;"
      },
      {
        "txt": "} private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC ||"
      },
      {
        "txt": "token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) {"
      },
      {
        "txt": "unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; }"
      },
      {
        "txt": "private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); } } private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN;"
      },
      {
        "txt": "return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) { next(); } } }"
      },
      {
        "txt": "private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(sourceName); } JSDocInfo getFileOverviewJSDocInfo() {"
      },
      {
        "txt": "return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c; while (true) { c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') {"
      },
      {
        "txt": "matchedLc = true; break; } else { break; } } stream.ungetChar(c); return matchedLc; }"
      }
    ]
  }
]