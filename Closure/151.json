[
  {
    "id": 660,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 301,
    "end-bug-line": 301,
    "bug": "",
    "fix": "@Option(name = \"--version\", usage = \"Prints the compiler version to stderr.\") private boolean version = false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef;"
      },
      {
        "txt": "import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set;"
      },
      {
        "txt": "import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { private static class Flags { @Option(name = \"--help\", usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\","
      },
      {
        "txt": "usage = \"Turns on extra sanity checks\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--output_wrapper_marker\", usage = \"Use this token as output marker in the value of\""
      },
      {
        "txt": "+ \" --output_wrapper\") private String output_wrapper_marker = \"%output%\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \""
      },
      {
        "txt": "+ \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\";"
      },
      {
        "txt": "@Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" +"
      },
      {
        "txt": "DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\","
      },
      {
        "txt": "usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\")"
      },
      {
        "txt": "private boolean debug = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--output_manifest\","
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; <extra_id_0> public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler("
      },
      {
        "txt": "Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException { String param = params.getParameter(0); if (param == null) {"
      },
      {
        "txt": "setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { throw new CmdLineException(owner,"
      },
      {
        "txt": "\"Illegal boolean value: \" + lowerParam); } return 1; } } @Override public String getDefaultMetaVariable() { return null; } }"
      },
      {
        "txt": "} private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break;"
      },
      {
        "txt": "case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private boolean isConfigValid = false;"
      },
      {
        "txt": "protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private void initConfigFromFlags(String[] args, PrintStream err) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");"
      },
      {
        "txt": "Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1));"
      },
      {
        "txt": "} else { processedArgs.add(value); } } else { processedArgs.add(arg); } } CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try {"
      },
      {
        "txt": "parser.parseArgument(processedArgs.toArray(new String[] {})); } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig()"
      },
      {
        "txt": ".setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module)"
      },
      {
        "txt": ".setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper)"
      },
      {
        "txt": ".setOutputWrapperMarker(flags.output_wrapper_marker) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)"
      },
      {
        "txt": ".setOutputManifest(flags.output_manifest); } } @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) {"
      },
      {
        "txt": "level.setDebugOptionsForCompilationLevel(options); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; }"
      },
      {
        "txt": "@Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs;"
      },
      {
        "txt": "} else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\","
      },
      {
        "txt": "\"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\","
      },
      {
        "txt": "\"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\","
      },
      {
        "txt": "\"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_range.js\", \"w3c_selectors.js\","
      },
      {
        "txt": "\"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize());"
      },
      {
        "txt": "externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) {"
      },
      {
        "txt": "externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) {"
      },
      {
        "txt": "runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 661,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 367,
    "end-bug-line": 367,
    "bug": "",
    "fix": "private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\";",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter;"
      },
      {
        "txt": "import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern;"
      },
      {
        "txt": "import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { private static class Flags { @Option(name = \"--help\", usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\""
      },
      {
        "txt": "+ \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\", usage = \"Turns on extra sanity checks\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode ="
      },
      {
        "txt": "CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \""
      },
      {
        "txt": "+ \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\","
      },
      {
        "txt": "usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \""
      },
      {
        "txt": "+ \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\")"
      },
      {
        "txt": "private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--output_wrapper_marker\", usage = \"Use this token as output marker in the value of\" + \" --output_wrapper\") private String output_wrapper_marker = \"%output%\"; @Option(name = \"--module_wrapper\","
      },
      {
        "txt": "usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\";"
      },
      {
        "txt": "@Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)"
      },
      {
        "txt": "private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\","
      },
      {
        "txt": "aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\")"
      },
      {
        "txt": "private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT;"
      },
      {
        "txt": "@Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \""
      },
      {
        "txt": "+ \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \""
      },
      {
        "txt": "+ \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler("
      },
      {
        "txt": "CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException { String param = params.getParameter(0); if (param == null) { setter.addValue(true); return 0;"
      },
      {
        "txt": "} else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { throw new CmdLineException(owner, \"Illegal boolean value: \" + lowerParam); }"
      },
      {
        "txt": "return 1; } } @Override public String getDefaultMetaVariable() { return null; } } } private static enum FormattingOption {"
      },
      {
        "txt": "PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); <extra_id_0> private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {"
      },
      {
        "txt": "} protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private void initConfigFromFlags(String[] args, PrintStream err) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) {"
      },
      {
        "txt": "Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); }"
      },
      {
        "txt": "} else { processedArgs.add(arg); } } CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); } catch (CmdLineException e) { err.println(e.getMessage());"
      },
      {
        "txt": "isConfigValid = false; } if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast)"
      },
      {
        "txt": ".setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file)"
      },
      {
        "txt": ".setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setOutputWrapperMarker(flags.output_wrapper_marker) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix)"
      },
      {
        "txt": ".setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setOutputManifest(flags.output_manifest); } }"
      },
      {
        "txt": "@Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } WarningLevel wLevel = flags.warning_level;"
      },
      {
        "txt": "wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; } @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream());"
      },
      {
        "txt": "} @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs);"
      },
      {
        "txt": "return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\","
      },
      {
        "txt": "\"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\","
      },
      {
        "txt": "\"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\","
      },
      {
        "txt": "\"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\");"
      },
      {
        "txt": "public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(),"
      },
      {
        "txt": "entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs;"
      },
      {
        "txt": "} public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1);"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 662,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 418,
    "end-bug-line": 418,
    "bug": "",
    "fix": "if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/p/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option;"
      },
      {
        "txt": "import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.util.List; import java.util.Map; import java.util.ResourceBundle;"
      },
      {
        "txt": "import java.util.Set; import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { private static class Flags { @Option(name = \"--help\","
      },
      {
        "txt": "usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\")"
      },
      {
        "txt": "private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", usage = \"Turns on extra sanity checks\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName();"
      },
      {
        "txt": "@Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\")"
      },
      {
        "txt": "private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\","
      },
      {
        "txt": "usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\")"
      },
      {
        "txt": "private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\","
      },
      {
        "txt": "usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\""
      },
      {
        "txt": "+ \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--output_wrapper_marker\","
      },
      {
        "txt": "usage = \"Use this token as output marker in the value of\" + \" --output_wrapper\") private String output_wrapper_marker = \"%output%\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\","
      },
      {
        "txt": "usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\")"
      },
      {
        "txt": "private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\","
      },
      {
        "txt": "usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\")"
      },
      {
        "txt": "private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS;"
      },
      {
        "txt": "@Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \""
      },
      {
        "txt": "+ \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false;"
      },
      {
        "txt": "@Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES ="
      },
      {
        "txt": "Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException {"
      },
      {
        "txt": "String param = params.getParameter(0); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false);"
      },
      {
        "txt": "} else { throw new CmdLineException(owner, \"Illegal boolean value: \" + lowerParam); } return 1; } } @Override public String getDefaultMetaVariable() { return null;"
      },
      {
        "txt": "} } } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT:"
      },
      {
        "txt": "options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this); } } }"
      },
      {
        "txt": "private final Flags flags = new Flags(); private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); }"
      },
      {
        "txt": "private void initConfigFromFlags(String[] args, PrintStream err) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value);"
      },
      {
        "txt": "if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); } } else { processedArgs.add(arg); } } CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "try { parser.parseArgument(processedArgs.toArray(new String[] {})); } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } <extra_id_0> if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree)"
      },
      {
        "txt": "getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file)"
      },
      {
        "txt": ".setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level)"
      },
      {
        "txt": ".setOutputWrapper(flags.output_wrapper) .setOutputWrapperMarker(flags.output_wrapper_marker) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset)"
      },
      {
        "txt": ".setManageClosureDependencies(flags.manage_closure_dependencies) .setOutputManifest(flags.output_manifest); } } @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options);"
      },
      {
        "txt": "if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_range.js\","
      },
      {
        "txt": "\"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) {"
      },
      {
        "txt": "LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList();"
      },
      {
        "txt": "for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args);"
      },
      {
        "txt": "if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  }
]