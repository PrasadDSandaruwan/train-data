[
  {
    "id": 510,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 26,
    "end-bug-line": 26,
    "bug": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;",
    "fix": "import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; <extra_id_0> import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer;"
      },
      {
        "txt": "MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else {"
      },
      {
        "txt": "renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer);"
      },
      {
        "txt": "} else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); }"
      },
      {
        "txt": "} @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name);"
      },
      {
        "txt": "nameStack.push(renamer); } break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME:"
      },
      {
        "txt": "String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break;"
      },
      {
        "txt": "case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) {"
      },
      {
        "txt": "String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION"
      },
      {
        "txt": "|| n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); }"
      },
      {
        "txt": "} } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name);"
      },
      {
        "txt": "return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index);"
      },
      {
        "txt": "} private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString();"
      },
      {
        "txt": "if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName);"
      },
      {
        "txt": "String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else {"
      },
      {
        "txt": "var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName);"
      },
      {
        "txt": "} } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\";"
      },
      {
        "txt": "ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() {"
      },
      {
        "txt": "return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null;"
      },
      {
        "txt": "if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName);"
      },
      {
        "txt": "} private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); }"
      },
      {
        "txt": "@Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness;"
      },
      {
        "txt": "InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override"
      },
      {
        "txt": "public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) {"
      },
      {
        "txt": "name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); }"
      },
      {
        "txt": "@Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 511,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 48,
    "end-bug-line": 48,
    "bug": "",
    "fix": "public static final String ARGUMENTS = \"arguments\";",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { <extra_id_0> private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer;"
      },
      {
        "txt": "MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer;"
      },
      {
        "txt": "if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); }"
      },
      {
        "txt": "nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer);"
      },
      {
        "txt": "} break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break;"
      },
      {
        "txt": "} return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek();"
      },
      {
        "txt": "if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break;"
      },
      {
        "txt": "case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName;"
      },
      {
        "txt": "} } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString());"
      },
      {
        "txt": "} else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer {"
      },
      {
        "txt": "void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) {"
      },
      {
        "txt": "this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) {"
      },
      {
        "txt": "return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring("
      },
      {
        "txt": "index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName);"
      },
      {
        "txt": "if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false;"
      },
      {
        "txt": "if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION &&"
      },
      {
        "txt": "parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } }"
      },
      {
        "txt": "} } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create();"
      },
      {
        "txt": "} private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override"
      },
      {
        "txt": "public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); }"
      },
      {
        "txt": "declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id;"
      },
      {
        "txt": "} private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false;"
      },
      {
        "txt": "} } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix,"
      },
      {
        "txt": "boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name));"
      },
      {
        "txt": "} } private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); }"
      },
      {
        "txt": "return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness);"
      },
      {
        "txt": "} @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 512,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 235,
    "end-bug-line": 236,
    "bug": "static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass {",
    "fix": "static class ContextualRenameInverter implements ScopedCallback, CompilerPass {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() {"
      },
      {
        "txt": "this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope();"
      },
      {
        "txt": "} if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else {"
      },
      {
        "txt": "findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } }"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name);"
      },
      {
        "txt": "} nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer);"
      },
      {
        "txt": "} break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString());"
      },
      {
        "txt": "if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION:"
      },
      {
        "txt": "nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName);"
      },
      {
        "txt": "if (newName != null) { return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) {"
      },
      {
        "txt": "if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } }"
      },
      {
        "txt": "interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } <extra_id_0> private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) {"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "} private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),"
      },
      {
        "txt": "name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) {"
      },
      {
        "txt": "return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) {"
      },
      {
        "txt": "recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {"
      },
      {
        "txt": "var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } }"
      },
      {
        "txt": "} static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); }"
      },
      {
        "txt": "private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) {"
      },
      {
        "txt": "if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName);"
      },
      {
        "txt": "} } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; }"
      },
      {
        "txt": "private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; }"
      },
      {
        "txt": "} static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) {"
      },
      {
        "txt": "this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); }"
      },
      {
        "txt": "} private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR"
      },
      {
        "txt": "+ idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); }"
      },
      {
        "txt": "@Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 513,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 240,
    "end-bug-line": 240,
    "bug": "",
    "fix": "private Set<String> referencedNames = ImmutableSet.of();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; <extra_id_0> private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this);"
      },
      {
        "txt": "public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); }"
      },
      {
        "txt": "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return;"
      },
      {
        "txt": "} if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true;"
      },
      {
        "txt": "} if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName);"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } }"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 514,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 242,
    "end-bug-line": 242,
    "bug": "",
    "fix": "private Deque<Set<String>> referenceStack = new ArrayDeque<Set<String>>();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; <extra_id_0> private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this);"
      },
      {
        "txt": "public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); }"
      },
      {
        "txt": "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return;"
      },
      {
        "txt": "} if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true;"
      },
      {
        "txt": "} if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName);"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } }"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 515,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 244,
    "end-bug-line": 244,
    "bug": "private Map<Var, String> nameMap = Maps.newHashMap();",
    "fix": "private Map<String, List<Node>> nameMap = Maps.newHashMap();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; <extra_id_0> private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); }"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) {"
      },
      {
        "txt": "return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; }"
      },
      {
        "txt": "if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; }"
      },
      {
        "txt": "if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); }"
      },
      {
        "txt": "node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } } static class ContextualRenamer implements Renamer {"
      },
      {
        "txt": "private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false;"
      },
      {
        "txt": "this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name);"
      },
      {
        "txt": "} else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } }"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1);"
      },
      {
        "txt": "} private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer {"
      },
      {
        "txt": "private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty());"
      },
      {
        "txt": "this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) {"
      },
      {
        "txt": "if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); }"
      },
      {
        "txt": "@Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() {"
      },
      {
        "txt": "return removeConstness; } }"
      }
    ]
  },
  {
    "id": 516,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 266,
    "end-bug-line": 268,
    "bug": "private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() {"
      },
      {
        "txt": "this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope();"
      },
      {
        "txt": "} if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else {"
      },
      {
        "txt": "findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } }"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name);"
      },
      {
        "txt": "} nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer);"
      },
      {
        "txt": "} break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString());"
      },
      {
        "txt": "if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION:"
      },
      {
        "txt": "nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName);"
      },
      {
        "txt": "if (newName != null) { return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) {"
      },
      {
        "txt": "if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } }"
      },
      {
        "txt": "} interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler;"
      },
      {
        "txt": "private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index);"
      },
      {
        "txt": "private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } <extra_id_0> private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return;"
      },
      {
        "txt": "} if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true;"
      },
      {
        "txt": "} if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName);"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } }"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 517,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 273,
    "end-bug-line": 273,
    "bug": "",
    "fix": "public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } <extra_id_0> private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return;"
      },
      {
        "txt": "} if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true;"
      },
      {
        "txt": "} if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName);"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } }"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 518,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 274,
    "end-bug-line": 277,
    "bug": "private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());",
    "fix": "referenceStack.push(referencedNames); referencedNames = Sets.newHashSet();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } <extra_id_0> } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) {"
      },
      {
        "txt": "String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else {"
      },
      {
        "txt": "int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName;"
      },
      {
        "txt": "} else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); }"
      },
      {
        "txt": "nameMap.put(var, newName); } } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global;"
      },
      {
        "txt": "final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override"
      },
      {
        "txt": "public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name);"
      },
      {
        "txt": "String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) {"
      },
      {
        "txt": "return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1);"
      },
      {
        "txt": "} @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix;"
      },
      {
        "txt": "private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; }"
      },
      {
        "txt": "@Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name; }"
      },
      {
        "txt": "if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName);"
      },
      {
        "txt": "} @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 519,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 284,
    "end-bug-line": 291,
    "bug": "@Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) {",
    "fix": "public void exitScope(NodeTraversal t) { if (t.inGlobalScope()) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier;"
      },
      {
        "txt": "import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();"
      },
      {
        "txt": "private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer;"
      },
      {
        "txt": "} else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild();"
      },
      {
        "txt": "findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop();"
      },
      {
        "txt": "} } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null"
      },
      {
        "txt": "&& !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString();"
      },
      {
        "txt": "renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) {"
      },
      {
        "txt": "for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null"
      },
      {
        "txt": "|| parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer);"
      },
      {
        "txt": "} } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) {"
      },
      {
        "txt": "int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) {"
      },
      {
        "txt": "} private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } <extra_id_0> return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName);"
      },
      {
        "txt": "} else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {"
      },
      {
        "txt": "newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange();"
      },
      {
        "txt": "} nameMap.put(var, newName); } } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap();"
      },
      {
        "txt": "private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; }"
      },
      {
        "txt": "@Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) {"
      },
      {
        "txt": "int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override"
      },
      {
        "txt": "public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) {"
      },
      {
        "txt": "return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier;"
      },
      {
        "txt": "private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness;"
      },
      {
        "txt": "} @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name;"
      },
      {
        "txt": "} if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) {"
      },
      {
        "txt": "return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; }"
      }
    ]
  },
  {
    "id": 520,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 295,
    "end-bug-line": 300,
    "bug": "if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index);",
    "fix": "for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); handleScopeVar(v); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier;"
      },
      {
        "txt": "import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();"
      },
      {
        "txt": "private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer;"
      },
      {
        "txt": "} else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild();"
      },
      {
        "txt": "findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop();"
      },
      {
        "txt": "} } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null"
      },
      {
        "txt": "&& !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString();"
      },
      {
        "txt": "renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) {"
      },
      {
        "txt": "for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null"
      },
      {
        "txt": "|| parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer);"
      },
      {
        "txt": "} } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) {"
      },
      {
        "txt": "int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) {"
      },
      {
        "txt": "return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) {"
      },
      {
        "txt": "if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } <extra_id_0> boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {"
      },
      {
        "txt": "if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); }"
      },
      {
        "txt": "node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } } static class ContextualRenamer implements Renamer {"
      },
      {
        "txt": "private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false;"
      },
      {
        "txt": "this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name);"
      },
      {
        "txt": "} else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } }"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1);"
      },
      {
        "txt": "} private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer {"
      },
      {
        "txt": "private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty());"
      },
      {
        "txt": "this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) {"
      },
      {
        "txt": "if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); }"
      },
      {
        "txt": "@Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() {"
      },
      {
        "txt": "return removeConstness; } }"
      }
    ]
  },
  {
    "id": 521,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 304,
    "end-bug-line": 304,
    "bug": "",
    "fix": "Set<String> current = referencedNames; referencedNames = referenceStack.pop();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer;"
      },
      {
        "txt": "} static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState("
      },
      {
        "txt": "declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION:"
      },
      {
        "txt": "{ Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break;"
      },
      {
        "txt": "case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME);"
      },
      {
        "txt": "} n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop();"
      },
      {
        "txt": "break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } }"
      },
      {
        "txt": "return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild();"
      },
      {
        "txt": "renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName);"
      },
      {
        "txt": "boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; }"
      },
      {
        "txt": "public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); }"
      },
      {
        "txt": "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return;"
      },
      {
        "txt": "if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); <extra_id_0> boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {"
      },
      {
        "txt": "if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); }"
      },
      {
        "txt": "node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } } static class ContextualRenamer implements Renamer {"
      },
      {
        "txt": "private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false;"
      },
      {
        "txt": "this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name);"
      },
      {
        "txt": "} else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } }"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1);"
      },
      {
        "txt": "} private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer {"
      },
      {
        "txt": "private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty());"
      },
      {
        "txt": "this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) {"
      },
      {
        "txt": "if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); }"
      },
      {
        "txt": "@Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() {"
      },
      {
        "txt": "return removeConstness; } }"
      }
    ]
  },
  {
    "id": 522,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 307,
    "end-bug-line": 310,
    "bug": "boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; }",
    "fix": "if (!referenceStack.isEmpty()) { referencedNames.addAll(current); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer;"
      },
      {
        "txt": "} static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState("
      },
      {
        "txt": "declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION:"
      },
      {
        "txt": "{ Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break;"
      },
      {
        "txt": "case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME);"
      },
      {
        "txt": "} n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop();"
      },
      {
        "txt": "break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } }"
      },
      {
        "txt": "return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild();"
      },
      {
        "txt": "renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName);"
      },
      {
        "txt": "boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; }"
      },
      {
        "txt": "public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); }"
      },
      {
        "txt": "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return;"
      },
      {
        "txt": "if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); <extra_id_0> if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode();"
      },
      {
        "txt": "var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName);"
      },
      {
        "txt": "} } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\";"
      },
      {
        "txt": "ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() {"
      },
      {
        "txt": "return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null;"
      },
      {
        "txt": "if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName);"
      },
      {
        "txt": "} private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); }"
      },
      {
        "txt": "@Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness;"
      },
      {
        "txt": "InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override"
      },
      {
        "txt": "public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) {"
      },
      {
        "txt": "name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); }"
      },
      {
        "txt": "@Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 523,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 317,
    "end-bug-line": 317,
    "bug": "",
    "fix": "void handleScopeVar(Var v) { String name  = v.getName(); if (containsSeparator(name)) { String newName = getOrginalName(name);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier;"
      },
      {
        "txt": "import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();"
      },
      {
        "txt": "private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer;"
      },
      {
        "txt": "} else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild();"
      },
      {
        "txt": "findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop();"
      },
      {
        "txt": "} } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null"
      },
      {
        "txt": "&& !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString();"
      },
      {
        "txt": "renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) {"
      },
      {
        "txt": "for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null"
      },
      {
        "txt": "|| parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer);"
      },
      {
        "txt": "} } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) {"
      },
      {
        "txt": "int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) {"
      },
      {
        "txt": "return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) {"
      },
      {
        "txt": "String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else {"
      },
      {
        "txt": "String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } <extra_id_0> if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode();"
      },
      {
        "txt": "var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName);"
      },
      {
        "txt": "} } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\";"
      },
      {
        "txt": "ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() {"
      },
      {
        "txt": "return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null;"
      },
      {
        "txt": "if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName);"
      },
      {
        "txt": "} private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); }"
      },
      {
        "txt": "@Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness;"
      },
      {
        "txt": "InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override"
      },
      {
        "txt": "public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) {"
      },
      {
        "txt": "name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); }"
      },
      {
        "txt": "@Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 524,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 318,
    "end-bug-line": 322,
    "bug": "if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null);",
    "fix": "if (TokenStream.isJSIdentifier(newName) && !referencedNames.contains(newName) && !newName.equals(ARGUMENTS)) { referencedNames.remove(name);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier;"
      },
      {
        "txt": "import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();"
      },
      {
        "txt": "private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer;"
      },
      {
        "txt": "} else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild();"
      },
      {
        "txt": "findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop();"
      },
      {
        "txt": "} } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null"
      },
      {
        "txt": "&& !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString();"
      },
      {
        "txt": "renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) {"
      },
      {
        "txt": "for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null"
      },
      {
        "txt": "|| parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer);"
      },
      {
        "txt": "} } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) {"
      },
      {
        "txt": "int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) {"
      },
      {
        "txt": "return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) {"
      },
      {
        "txt": "String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else {"
      },
      {
        "txt": "String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } <extra_id_0> Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName);"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } }"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 525,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 325,
    "end-bug-line": 330,
    "bug": "Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName);",
    "fix": "referencedNames.add(newName); List<Node> references = nameMap.get(name); Preconditions.checkState(references != null); for (Node n : references) { Preconditions.checkState(n.getType() == Token.NAME); n.setString(newName); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "} private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),"
      },
      {
        "txt": "name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) {"
      },
      {
        "txt": "return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) {"
      },
      {
        "txt": "} if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); <extra_id_0> compiler.reportCodeChange(); } nameMap.put(var, newName); } } }"
      },
      {
        "txt": "} } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() {"
      },
      {
        "txt": "this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage);"
      },
      {
        "txt": "} @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) {"
      },
      {
        "txt": "newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); }"
      },
      {
        "txt": "private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer("
      },
      {
        "txt": "Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) {"
      },
      {
        "txt": "if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring("
      },
      {
        "txt": "0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override"
      },
      {
        "txt": "public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 526,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 333,
    "end-bug-line": 333,
    "bug": "",
    "fix": "nameMap.remove(name); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer();"
      },
      {
        "txt": "} MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot();"
      },
      {
        "txt": "Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); }"
      },
      {
        "txt": "if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer);"
      },
      {
        "txt": "} nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); }"
      },
      {
        "txt": "nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); }"
      },
      {
        "txt": "break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) {"
      },
      {
        "txt": "Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop();"
      },
      {
        "txt": "break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) {"
      },
      {
        "txt": "return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) {"
      },
      {
        "txt": "renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } }"
      },
      {
        "txt": "interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap();"
      },
      {
        "txt": "private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); }"
      },
      {
        "txt": "private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) {"
      },
      {
        "txt": "return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope();"
      },
      {
        "txt": "Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index);"
      },
      {
        "txt": "boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode();"
      },
      {
        "txt": "parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } <extra_id_0> nameMap.put(var, newName); } } } } }"
      },
      {
        "txt": "} } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create();"
      },
      {
        "txt": "} private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override"
      },
      {
        "txt": "public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); }"
      },
      {
        "txt": "declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id;"
      },
      {
        "txt": "} private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false;"
      },
      {
        "txt": "} } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix,"
      },
      {
        "txt": "boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name));"
      },
      {
        "txt": "} } private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); }"
      },
      {
        "txt": "return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness);"
      },
      {
        "txt": "} @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 527,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 334,
    "end-bug-line": 334,
    "bug": "nameMap.put(var, newName);",
    "fix": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer();"
      },
      {
        "txt": "} MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot();"
      },
      {
        "txt": "Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); }"
      },
      {
        "txt": "if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer);"
      },
      {
        "txt": "} nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); }"
      },
      {
        "txt": "nameStack.push(renamer); } break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); }"
      },
      {
        "txt": "break; } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) {"
      },
      {
        "txt": "Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop();"
      },
      {
        "txt": "break; case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) {"
      },
      {
        "txt": "return newName; } } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) {"
      },
      {
        "txt": "renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } }"
      },
      {
        "txt": "interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap();"
      },
      {
        "txt": "private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); }"
      },
      {
        "txt": "private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) {"
      },
      {
        "txt": "return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope();"
      },
      {
        "txt": "Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index);"
      },
      {
        "txt": "boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode();"
      },
      {
        "txt": "parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } <extra_id_0> } } } } } static class ContextualRenamer implements Renamer {"
      },
      {
        "txt": "} static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); }"
      },
      {
        "txt": "private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) {"
      },
      {
        "txt": "if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName);"
      },
      {
        "txt": "} } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; }"
      },
      {
        "txt": "private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; }"
      },
      {
        "txt": "} static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) {"
      },
      {
        "txt": "this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); }"
      },
      {
        "txt": "} private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR"
      },
      {
        "txt": "+ idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); }"
      },
      {
        "txt": "@Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 528,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 336,
    "end-bug-line": 336,
    "bug": "",
    "fix": "@Override public void visit(NodeTraversal t, Node node, Node parent) { if (t.inGlobalScope()) { return;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); }"
      },
      {
        "txt": "MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer;"
      },
      {
        "txt": "if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); }"
      },
      {
        "txt": "nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer);"
      },
      {
        "txt": "} break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break;"
      },
      {
        "txt": "} return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek();"
      },
      {
        "txt": "if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break;"
      },
      {
        "txt": "case Token.CATCH: nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName;"
      },
      {
        "txt": "} } return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString());"
      },
      {
        "txt": "} else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer {"
      },
      {
        "txt": "void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) {"
      },
      {
        "txt": "this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) {"
      },
      {
        "txt": "return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring("
      },
      {
        "txt": "index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName);"
      },
      {
        "txt": "if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false;"
      },
      {
        "txt": "if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION &&"
      },
      {
        "txt": "var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); <extra_id_0> } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage;"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 529,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 338,
    "end-bug-line": 338,
    "bug": "",
    "fix": "if (NodeUtil.isReferenceName(node)) { String name = node.getString();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "} private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),"
      },
      {
        "txt": "name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) {"
      },
      {
        "txt": "return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) {"
      },
      {
        "txt": "recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } <extra_id_0> } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage;"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 530,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 340,
    "end-bug-line": 340,
    "bug": "",
    "fix": "referencedNames.add(name);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "} private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),"
      },
      {
        "txt": "name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) {"
      },
      {
        "txt": "return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) {"
      },
      {
        "txt": "recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } <extra_id_0> } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage;"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); }"
      },
      {
        "txt": "} } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) {"
      },
      {
        "txt": "nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } }"
      },
      {
        "txt": "static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier;"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } }"
      },
      {
        "txt": "private String getUniqueName(String name) { if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get();"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override"
      },
      {
        "txt": "public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 531,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 341,
    "end-bug-line": 341,
    "bug": "",
    "fix": "if (containsSeparator(name)) { addCandidateNameReference(name, node);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "} private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),"
      },
      {
        "txt": "name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) {"
      },
      {
        "txt": "return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) {"
      },
      {
        "txt": "recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } <extra_id_0> } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap();"
      },
      {
        "txt": "private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false;"
      },
      {
        "txt": "this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name);"
      },
      {
        "txt": "} else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } }"
      },
      {
        "txt": "} @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1);"
      },
      {
        "txt": "} private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer {"
      },
      {
        "txt": "private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty());"
      },
      {
        "txt": "this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) {"
      },
      {
        "txt": "if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); }"
      },
      {
        "txt": "@Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() {"
      },
      {
        "txt": "return removeConstness; } }"
      }
    ]
  },
  {
    "id": 532,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 345,
    "end-bug-line": 345,
    "bug": "",
    "fix": "private void addCandidateNameReference(String name, Node n) { List<Node> nodes = nameMap.get(name); if (null == nodes) { nodes = Lists.newLinkedList(); nameMap.put(name, nodes); } nodes.add(n); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique"
      },
      {
        "txt": "implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) {"
      },
      {
        "txt": "return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));"
      },
      {
        "txt": "Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name);"
      },
      {
        "txt": "} Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope();"
      },
      {
        "txt": "String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH: {"
      },
      {
        "txt": "Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true; } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; }"
      },
      {
        "txt": "} private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; }"
      },
      {
        "txt": "private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); }"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope();"
      },
      {
        "txt": "} static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this);"
      },
      {
        "txt": "} public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1;"
      },
      {
        "txt": "} private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) {"
      },
      {
        "txt": "node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) ||"
      },
      {
        "txt": "!TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName);"
      },
      {
        "txt": "} nameMap.put(var, newName); } } } } <extra_id_0> static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() {"
      },
      {
        "txt": "final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override"
      },
      {
        "txt": "public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name);"
      },
      {
        "txt": "String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) {"
      },
      {
        "txt": "return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1);"
      },
      {
        "txt": "} @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix;"
      },
      {
        "txt": "private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; }"
      },
      {
        "txt": "@Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name; }"
      },
      {
        "txt": "if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName);"
      },
      {
        "txt": "} @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 533,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 391,
    "end-bug-line": 391,
    "bug": "",
    "fix": "if (!name.equals(ARGUMENTS)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique"
      },
      {
        "txt": "implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) {"
      },
      {
        "txt": "return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));"
      },
      {
        "txt": "Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name);"
      },
      {
        "txt": "} Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope();"
      },
      {
        "txt": "String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH: {"
      },
      {
        "txt": "Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true; } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break; }"
      },
      {
        "txt": "} private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; }"
      },
      {
        "txt": "private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); }"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope();"
      },
      {
        "txt": "} static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this);"
      },
      {
        "txt": "} public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1;"
      },
      {
        "txt": "} private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) {"
      },
      {
        "txt": "node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) ||"
      },
      {
        "txt": "!TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName);"
      },
      {
        "txt": "compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } } static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage;"
      },
      {
        "txt": "private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage;"
      },
      {
        "txt": "@Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { <extra_id_0> reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) {"
      },
      {
        "txt": "String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) {"
      },
      {
        "txt": "return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1);"
      },
      {
        "txt": "} @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix;"
      },
      {
        "txt": "private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; }"
      },
      {
        "txt": "@Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name; }"
      },
      {
        "txt": "if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) { return declarations.get(oldName);"
      },
      {
        "txt": "} @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; } }"
      }
    ]
  },
  {
    "id": 534,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 400,
    "end-bug-line": 400,
    "bug": "",
    "fix": "} declarations.put(name, newName);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer;"
      },
      {
        "txt": "} static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState("
      },
      {
        "txt": "declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION:"
      },
      {
        "txt": "{ Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break;"
      },
      {
        "txt": "case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME);"
      },
      {
        "txt": "} n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop();"
      },
      {
        "txt": "break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } }"
      },
      {
        "txt": "return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild();"
      },
      {
        "txt": "renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName);"
      },
      {
        "txt": "boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; }"
      },
      {
        "txt": "public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); }"
      },
      {
        "txt": "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return;"
      },
      {
        "txt": "} if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true;"
      },
      {
        "txt": "} if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName);"
      },
      {
        "txt": "} node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } }"
      },
      {
        "txt": "static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) {"
      },
      {
        "txt": "this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) {"
      },
      {
        "txt": "} else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); <extra_id_0> declarations.put(name, newName); } } } @Override public String getReplacementName(String oldName) {"
      },
      {
        "txt": "@Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); }"
      },
      {
        "txt": "private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap();"
      },
      {
        "txt": "private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix;"
      },
      {
        "txt": "this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) {"
      },
      {
        "txt": "return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override"
      },
      {
        "txt": "public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 535,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 401,
    "end-bug-line": 401,
    "bug": "declarations.put(name, newName);",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) { this.rootRenamer = renamer; }"
      },
      {
        "txt": "static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) { Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION ||"
      },
      {
        "txt": "!(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext(); for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString();"
      },
      {
        "txt": "renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer); } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.FUNCTION: {"
      },
      {
        "txt": "Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.CATCH:"
      },
      {
        "txt": "{ Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; } return true; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) { n.removeProp(Node.IS_CONSTANT_NAME); }"
      },
      {
        "txt": "n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH: nameStack.pop(); break;"
      },
      {
        "txt": "} } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null;"
      },
      {
        "txt": "} private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString());"
      },
      {
        "txt": "} for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name); String getReplacementName(String oldName); boolean stripConstIfReplaced();"
      },
      {
        "txt": "Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node js) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); } private boolean containsSeparator(String name) {"
      },
      {
        "txt": "return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; }"
      },
      {
        "txt": "if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) { recurseScopes = true; }"
      },
      {
        "txt": "if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); }"
      },
      {
        "txt": "node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } } } static class ContextualRenamer implements Renamer {"
      },
      {
        "txt": "private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); } private ContextualRenamer(Multiset<String> nameUsage) { this.global = false;"
      },
      {
        "txt": "this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) { if (global) { reserveName(name);"
      },
      {
        "txt": "if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } <extra_id_0> } } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName);"
      },
      {
        "txt": "public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; } private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) {"
      },
      {
        "txt": "return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; } } static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier;"
      },
      {
        "txt": "private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) { this.uniqueIdSupplier = uniqueIdSupplier; Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness;"
      },
      {
        "txt": "} @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name;"
      },
      {
        "txt": "} if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); } @Override public String getReplacementName(String oldName) {"
      },
      {
        "txt": "return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() { return removeConstness; }"
      }
    ]
  },
  {
    "id": 536,
    "file_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "start-bug-line": 461,
    "end-bug-line": 461,
    "bug": "",
    "fix": "Preconditions.checkState(!name.equals(ARGUMENTS));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer; MakeDeclaredNamesUnique() { this.rootRenamer = new ContextualRenamer(); } MakeDeclaredNamesUnique(Renamer renamer) {"
      },
      {
        "txt": "this.rootRenamer = renamer; } static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) { return new ContextualRenameInverter(compiler); } @Override public void enterScope(NodeTraversal t) { Node declarationRoot = t.getScopeRoot(); Renamer renamer; if (nameStack.isEmpty()) {"
      },
      {
        "txt": "Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { Node fnParams = declarationRoot.getFirstChild().getNext();"
      },
      {
        "txt": "for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else { findDeclaredNames(declarationRoot, null, renamer); } nameStack.push(renamer);"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (!t.inGlobalScope()) { nameStack.pop(); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) { renamer.addDeclaredName(name); } nameStack.push(renamer); }"
      },
      {
        "txt": "break; case Token.CATCH: { Renamer renamer = nameStack.peek().forChildScope(); String name = n.getFirstChild().getString(); renamer.addDeclaredName(name); nameStack.push(renamer); } break; }"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME: String newName = getReplacementName(n.getString()); if (newName != null) { Renamer renamer = nameStack.peek(); if (renamer.stripConstIfReplaced()) {"
      },
      {
        "txt": "n.removeProp(Node.IS_CONSTANT_NAME); } n.setString(newName); t.getCompiler().reportCodeChange(); } break; case Token.FUNCTION: nameStack.pop(); break; case Token.CATCH:"
      },
      {
        "txt": "nameStack.pop(); break; } } private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; }"
      },
      {
        "txt": "} return null; } private void findDeclaredNames(Node n, Node parent, Renamer renamer) { if (parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild()) { if (NodeUtil.isVarDeclaration(n)) { renamer.addDeclaredName(n.getString()); } else if (NodeUtil.isFunctionDeclaration(n)) {"
      },
      {
        "txt": "Node nameNode = n.getFirstChild(); renamer.addDeclaredName(nameNode.getString()); } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { findDeclaredNames(c, n, renamer); } } } interface Renamer { void addDeclaredName(String name);"
      },
      {
        "txt": "String getReplacementName(String oldName); boolean stripConstIfReplaced(); Renamer forChildScope(); } static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, this); } public static String getOrginalName(String name) { int index = indexOfSeparator(name); return (index == -1) ? name : name.substring(0, index); } private static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);"
      },
      {
        "txt": "} private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),"
      },
      {
        "txt": "name.length()); } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) {"
      },
      {
        "txt": "return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches(\"\\\\d+\")) {"
      },
      {
        "txt": "recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {"
      },
      {
        "txt": "var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } } } }"
      },
      {
        "txt": "} static class ContextualRenamer implements Renamer { private final Multiset<String> nameUsage; private final Map<String, String> declarations = Maps.newHashMap(); private final boolean global; final static String UNIQUE_ID_SEPARATOR = \"$$\"; ContextualRenamer() { this.global = true; nameUsage = HashMultiset.create(); }"
      },
      {
        "txt": "private ContextualRenamer(Multiset<String> nameUsage) { this.global = false; this.nameUsage = nameUsage; } @Override public Renamer forChildScope() { return new ContextualRenamer(nameUsage); } @Override public void addDeclaredName(String name) {"
      },
      {
        "txt": "if (global) { reserveName(name); } else { if (!declarations.containsKey(name)) { int id = incrementNameCount(name); String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName);"
      },
      {
        "txt": "} } } @Override public String getReplacementName(String oldName) { return declarations.get(oldName); } private String getUniqueName(String name, int id) { return name + UNIQUE_ID_SEPARATOR + id; }"
      },
      {
        "txt": "private void reserveName(String name) { nameUsage.setCount(name, 0, 1); } private int incrementNameCount(String name) { return nameUsage.add(name, 1); } @Override public boolean stripConstIfReplaced() { return false; }"
      },
      {
        "txt": "} static class InlineRenamer implements Renamer { private final Map<String, String> declarations = Maps.newHashMap(); private final Supplier<String> uniqueIdSupplier; private final String idPrefix; private final boolean removeConstness; InlineRenamer( Supplier<String> uniqueIdSupplier, String idPrefix, boolean removeConstness) {"
      },
      {
        "txt": "Preconditions.checkArgument(!idPrefix.isEmpty()); this.idPrefix = idPrefix; this.removeConstness = removeConstness; } @Override public void addDeclaredName(String name) { <extra_id_0> declarations.put(name, getUniqueName(name)); } } private String getUniqueName(String name) { if (name.isEmpty()) { return name;"
      },
      {
        "txt": "if (name.isEmpty()) { return name; } if (name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) { name = name.substring( 0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)); } return name + ContextualRenamer.UNIQUE_ID_SEPARATOR + idPrefix + uniqueIdSupplier.get(); }"
      },
      {
        "txt": "@Override public String getReplacementName(String oldName) { return declarations.get(oldName); } @Override public Renamer forChildScope() { return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness); } @Override public boolean stripConstIfReplaced() {"
      },
      {
        "txt": "return removeConstness; } }"
      }
    ]
  },
  {
    "id": 537,
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
    "start-bug-line": 1043,
    "end-bug-line": 1043,
    "bug": "",
    "fix": "static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty() && !isLabelName(n); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.javascript.rhino.FunctionNode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class NodeUtil { private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS ="
      },
      {
        "txt": "new HashSet<String>(Arrays.asList( \"Array\", \"Date\", \"Error\", \"Object\", \"RegExp\", \"XMLHttpRequest\")); public static final String CONSTANT_MARKER = \"$$constant\"; private NodeUtil() {} static boolean getBooleanValue(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.STRING: return n.getString().length() > 0; case Token.NUMBER: return n.getDouble() != 0; case Token.NULL: case Token.FALSE: case Token.VOID: return false; case Token.NAME:"
      },
      {
        "txt": "String name = n.getString(); if (\"undefined\".equals(name) || \"NaN\".equals(name)) { return false; } else if (\"Infinity\".equals(name)) { return true; } break; case Token.TRUE: case Token.ARRAYLIT:"
      },
      {
        "txt": "case Token.OBJECTLIT: case Token.REGEXP: return true; } throw new IllegalArgumentException(\"Non-literal value: \" + n); } static String getStringValue(Node n) { switch (n.getType()) { case Token.NAME: case Token.STRING:"
      },
      {
        "txt": "return n.getString(); case Token.NUMBER: double value = n.getDouble(); long longValue = (long) value; if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(n.getDouble()); } case Token.FALSE:"
      },
      {
        "txt": "case Token.TRUE: case Token.NULL: return Node.tokenToName(n.getType()); case Token.VOID: return \"undefined\"; } return null; } static String getFunctionName(Node n, Node parent) { String name = n.getFirstChild().getString();"
      },
      {
        "txt": "switch (parent.getType()) { case Token.NAME: return parent.getString(); case Token.ASSIGN: return parent.getFirstChild().getQualifiedName(); default: return name != null && name.length() != 0 ? name : null; } } static boolean isImmutableValue(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.STRING: case Token.NUMBER: case Token.NULL: case Token.TRUE: case Token.FALSE: case Token.VOID: return true; case Token.NEG: return isImmutableValue(n.getFirstChild());"
      },
      {
        "txt": "case Token.NAME: String name = n.getString(); return \"undefined\".equals(name) || \"Infinity\".equals(name) || \"NaN\".equals(name); } return false; } static boolean isLiteralValue(Node n) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!isLiteralValue(child)) { return false; } } return true;"
      },
      {
        "txt": "default: return isImmutableValue(n); } } static boolean isValidDefineValue(Node val, Set<String> defines) { switch (val.getType()) { case Token.STRING: case Token.NUMBER: case Token.TRUE: case Token.FALSE:"
      },
      {
        "txt": "return true; case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.NOT: case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines); case Token.NAME: case Token.GETPROP:"
      },
      {
        "txt": "if (val.isQualifiedName()) { return defines.contains(val.getQualifiedName()); } } return false; } static boolean isEmptyBlock(Node block) { if (block.getType() != Token.BLOCK) { return false; }"
      },
      {
        "txt": "for (Node n = block.getFirstChild(); n != null; n = n.getNext()) { if (n.getType() != Token.EMPTY) { return false; } } return true; } static boolean isSimpleOperatorType(int type) { switch (type) { case Token.ADD:"
      },
      {
        "txt": "case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.COMMA: case Token.DIV: case Token.EQ: case Token.GE: case Token.GETELEM: case Token.GETPROP:"
      },
      {
        "txt": "case Token.GT: case Token.INSTANCEOF: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.NOT: case Token.RSH:"
      },
      {
        "txt": "case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.TYPEOF: case Token.VOID: case Token.POS: case Token.NEG: case Token.URSH: return true; default:"
      },
      {
        "txt": "return false; } } public static Node newExpr(Node child) { return new Node(Token.EXPR_RESULT, child); } static boolean mayEffectMutableState(Node n) { return checkForStateChangeHelper(n, true); } static boolean mayHaveSideEffects(Node n) {"
      },
      {
        "txt": "return checkForStateChangeHelper(n, false); } private static boolean checkForStateChangeHelper( Node n, boolean checkForNewObjects) { switch (n.getType()) { case Token.AND: case Token.BLOCK: case Token.EXPR_RESULT: case Token.HOOK: case Token.IF:"
      },
      {
        "txt": "case Token.IN: case Token.LP: case Token.NUMBER: case Token.OR: case Token.THIS: case Token.TRUE: case Token.FALSE: case Token.NULL: case Token.STRING: case Token.SWITCH:"
      },
      {
        "txt": "case Token.TRY: case Token.EMPTY: break; case Token.THROW: return true; case Token.OBJECTLIT: case Token.ARRAYLIT: case Token.REGEXP: if (checkForNewObjects) { return true;"
      },
      {
        "txt": "} break; case Token.VAR: // empty var statement (no declaration) case Token.NAME: // variable by itself if (n.getFirstChild() != null) return true; break; case Token.FUNCTION: return !isFunctionAnonymous(n); case Token.NEW:"
      },
      {
        "txt": "{ if (checkForNewObjects) { return true; } if (n.isNoSideEffectsCall()) { break; } Node constructor = n.getFirstChild(); if (Token.NAME == constructor.getType()) { String className = constructor.getString();"
      },
      {
        "txt": "if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) { break; } } else { } } return true; case Token.CALL: if (n.isNoSideEffectsCall()) { break;"
      },
      {
        "txt": "} return true; default: if (isSimpleOperatorType(n.getType())) break; if (isAssignmentOp(n)) { if (checkForStateChangeHelper( n.getFirstChild(), checkForNewObjects) || checkForStateChangeHelper( n.getLastChild(), checkForNewObjects)) {"
      },
      {
        "txt": "return true; } Node current = n.getFirstChild(); for (; current.getType() == Token.GETPROP || current.getType() == Token.GETELEM; current = current.getFirstChild()) { } return !(isLiteralValue(current) || current.getType() == Token.FUNCTION); }"
      },
      {
        "txt": "return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (checkForStateChangeHelper(c, checkForNewObjects)) { return true; } } return false; } static boolean constructorCallHasSideEffects(Node callNode) {"
      },
      {
        "txt": "Preconditions.checkArgument( callNode.getType() == Token.NEW, \"Expected NEW node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) { return false;"
      },
      {
        "txt": "} return true; } static boolean functionCallHasSideEffects(Node callNode) { Preconditions.checkArgument( callNode.getType() == Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; }"
      },
      {
        "txt": "Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { String name = nameNode.getString(); if (name.equals(\"String\")) { return false; } } if (nameNode.getType() == Token.GETPROP && nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString();"
      },
      {
        "txt": "if (namespaceName.equals(\"Math\")) { return false; } } return true; } static boolean nodeTypeMayHaveSideEffects(Node n) { if (NodeUtil.isAssignmentOp(n)) { return true; }"
      },
      {
        "txt": "switch(n.getType()) { case Token.CALL: case Token.DELPROP: case Token.NEW: case Token.DEC: case Token.INC: case Token.THROW: return true; case Token.NAME: return n.hasChildren();"
      },
      {
        "txt": "default: return false; } } static boolean canBeSideEffected(Node n) { Set<String> emptySet = Collections.emptySet(); return canBeSideEffected(n, emptySet); } static boolean canBeSideEffected(Node n, Set<String> knownConstants) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.CALL: case Token.NEW: return true; case Token.NAME: return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString()); case Token.GETPROP: case Token.GETELEM: return true; }"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (canBeSideEffected(c, knownConstants)) { return true; } } return false; } static int precedence(int type) { switch (type) { case Token.COMMA: return 0;"
      },
      {
        "txt": "case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV:"
      },
      {
        "txt": "case Token.ASSIGN_MOD: case Token.ASSIGN: return 1; case Token.HOOK: return 2; // ?: operator case Token.OR: return 3; case Token.AND: return 4; case Token.BITOR: return 5; case Token.BITXOR: return 6; case Token.BITAND: return 7; case Token.EQ: case Token.NE:"
      },
      {
        "txt": "case Token.SHEQ: case Token.SHNE: return 8; case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.INSTANCEOF: case Token.IN: return 9; case Token.LSH: case Token.RSH:"
      },
      {
        "txt": "case Token.URSH: return 10; case Token.SUB: case Token.ADD: return 11; case Token.MUL: case Token.MOD: case Token.DIV: return 12; case Token.INC: case Token.DEC: case Token.NEW: case Token.DELPROP:"
      },
      {
        "txt": "case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: case Token.NEG: return 13; case Token.ARRAYLIT: case Token.CALL: case Token.EMPTY: case Token.FALSE:"
      },
      {
        "txt": "case Token.FUNCTION: case Token.GETELEM: case Token.GETPROP: case Token.GET_REF: case Token.IF: case Token.LP: case Token.NAME: case Token.NULL: case Token.NUMBER: case Token.OBJECTLIT:"
      },
      {
        "txt": "case Token.REGEXP: case Token.RETURN: case Token.STRING: case Token.THIS: case Token.TRUE: return 15; default: throw new Error(\"Unknown precedence for \" + Node.tokenToName(type) + \" (type \" + type + \")\"); }"
      },
      {
        "txt": "} static boolean isAssociative(int type) { switch (type) { case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITAND: return true; default:"
      },
      {
        "txt": "return false; } } static boolean isAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH:"
      },
      {
        "txt": "case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: return true; } return false;"
      },
      {
        "txt": "} static int getOpFromAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN_BITOR: return Token.BITOR; case Token.ASSIGN_BITXOR: return Token.BITXOR; case Token.ASSIGN_BITAND: return Token.BITAND; case Token.ASSIGN_LSH:"
      },
      {
        "txt": "return Token.LSH; case Token.ASSIGN_RSH: return Token.RSH; case Token.ASSIGN_URSH: return Token.URSH; case Token.ASSIGN_ADD: return Token.ADD; case Token.ASSIGN_SUB: return Token.SUB; case Token.ASSIGN_MUL:"
      },
      {
        "txt": "return Token.MUL; case Token.ASSIGN_DIV: return Token.DIV; case Token.ASSIGN_MOD: return Token.MOD; } throw new IllegalArgumentException(\"Not an assiment op\"); } static boolean isExpressionNode(Node n) { return n.getType() == Token.EXPR_RESULT;"
      },
      {
        "txt": "} static boolean containsFunctionDeclaration(Node n) { return containsType(n, Token.FUNCTION); } static boolean referencesThis(Node n) { return containsType(n, Token.THIS); } static boolean isGet(Node n) { return n.getType() == Token.GETPROP || n.getType() == Token.GETELEM;"
      },
      {
        "txt": "} static boolean isGetProp(Node n) { return n.getType() == Token.GETPROP; } static boolean isName(Node n) { return n.getType() == Token.NAME; } static boolean isNew(Node n) { return n.getType() == Token.NEW; }"
      },
      {
        "txt": "static boolean isVar(Node n) { return n.getType() == Token.VAR; } static boolean isVarDeclaration(Node n) { return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR; } static Node getAssignedValue(Node n) { Preconditions.checkState(isName(n)); Node parent = n.getParent(); if (isVar(parent)) {"
      },
      {
        "txt": "return n.getFirstChild(); } else if (isAssign(parent) && parent.getFirstChild() == n) { return n.getNext(); } else { return null; } } static boolean isString(Node n) { return n.getType() == Token.STRING; }"
      },
      {
        "txt": "static boolean isExprAssign(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.ASSIGN; } static boolean isAssign(Node n) { return n.getType() == Token.ASSIGN; } static boolean isExprCall(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.CALL;"
      },
      {
        "txt": "} static boolean isForIn(Node n) { return n.getType() == Token.FOR && n.getChildCount() == 3; } static boolean isLoopStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE:"
      },
      {
        "txt": "return true; default: return false; } } static Node getLoopCodeBlock(Node n) { switch (n.getType()) { case Token.FOR: case Token.WHILE: return n.getLastChild();"
      },
      {
        "txt": "case Token.DO: return n.getFirstChild(); default: return null; } } static boolean isControlStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO:"
      },
      {
        "txt": "case Token.WHILE: case Token.WITH: case Token.IF: case Token.LABEL: case Token.TRY: case Token.CATCH: case Token.SWITCH: case Token.CASE: case Token.DEFAULT: return true;"
      },
      {
        "txt": "default: return false; } } static boolean isControlStructureCodeBlock(Node parent, Node n) { switch (parent.getType()) { case Token.FOR: case Token.WHILE: case Token.LABEL: case Token.WITH:"
      },
      {
        "txt": "return parent.getLastChild() == n; case Token.DO: return parent.getFirstChild() == n; case Token.IF: return parent.getFirstChild() != n; case Token.TRY: return parent.getFirstChild() == n || parent.getLastChild() == n; case Token.CATCH: return parent.getLastChild() == n; case Token.SWITCH:"
      },
      {
        "txt": "case Token.CASE: return parent.getFirstChild() != n; case Token.DEFAULT: return true; default: Preconditions.checkState(isControlStructure(parent)); return false; } } static Node getConditionExpression(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.IF: case Token.WHILE: return n.getFirstChild(); case Token.DO: return n.getLastChild(); case Token.FOR: switch (n.getChildCount()) { case 3: return null;"
      },
      {
        "txt": "case 4: return n.getFirstChild().getNext(); } throw new IllegalArgumentException(\"malformed 'for' statement \" + n); case Token.CASE: return null; } throw new IllegalArgumentException(n + \" does not have a condition.\"); } static boolean isStatementBlock(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK; } static boolean isStatement(Node n) { Node parent = n.getParent(); Preconditions.checkState(parent != null); switch (parent.getType()) { case Token.SCRIPT: case Token.BLOCK: case Token.LABEL: return true;"
      },
      {
        "txt": "return false; } } static boolean isSwitchCase(Node n) { return n.getType() == Token.CASE || n.getType() == Token.DEFAULT; } <extra_id_0> static boolean isLabelName(Node n) { if (n != null && n.getType() == Token.NAME) { Node parent = n.getParent(); switch (parent.getType()) { case Token.LABEL: case Token.BREAK:"
      },
      {
        "txt": "case Token.LABEL: case Token.BREAK: case Token.CONTINUE: if (n == parent.getFirstChild()) { return true; } } } return false; }"
      },
      {
        "txt": "static boolean isTryFinallyNode(Node parent, Node child) { return parent.getType() == Token.TRY && parent.getChildCount() == 3 && child == parent.getLastChild(); } static void removeChild(Node parent, Node node) { if (isStatementBlock(parent) || isSwitchCase(node) || isTryFinallyNode(parent, node)) { parent.removeChild(node); } else if (parent.getType() == Token.VAR) {"
      },
      {
        "txt": "if (parent.hasMoreThanOneChild()) { parent.removeChild(node); } else { parent.removeChild(node); removeChild(parent.getParent(), parent); } } else if (node.getType() == Token.BLOCK) { node.detachChildren(); } else if (parent.getType() == Token.LABEL && node == parent.getLastChild()) {"
      },
      {
        "txt": "parent.removeChild(node); removeChild(parent.getParent(), parent); } else if (parent.getType() == Token.FOR && parent.getChildCount() == 4) { parent.replaceChild(node, new Node(Token.EMPTY)); } else { throw new IllegalStateException(\"Invalid attempt to remove node: \" + node.toString() + \" of \"+ parent.toString()); } }"
      },
      {
        "txt": "static boolean tryMergeBlock(Node block) { Preconditions.checkState(block.getType() == Token.BLOCK); Node parent = block.getParent(); if (NodeUtil.isStatementBlock(parent)) { Node previous = block; while (block.hasChildren()) { Node child = block.removeFirstChild(); parent.addChildAfter(child, previous); previous = child; }"
      },
      {
        "txt": "parent.removeChild(block); return true; } else if (parent.getType() == Token.LABEL && block.hasOneChild()) { parent.replaceChild(block, block.removeFirstChild()); return true; } else { return false; } } static boolean isCall(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.CALL; } static boolean isFunction(Node n) { return n.getType() == Token.FUNCTION; } static Node getFunctionBody(Node fn) { Preconditions.checkArgument(isFunction(fn)); return fn.getLastChild(); } static boolean isThis(Node node) {"
      },
      {
        "txt": "return node.getType() == Token.THIS; } static boolean containsCall(Node n) { return containsType(n, Token.CALL); } static boolean isFunctionDeclaration(Node n) { return n.getType() == Token.FUNCTION && !isFunctionAnonymous(n); } static boolean isHoistedFunctionDeclaration(Node n) { return NodeUtil.isFunctionDeclaration(n)"
      },
      {
        "txt": "&& (n.getParent().getType() == Token.SCRIPT || n.getParent().getParent().getType() == Token.FUNCTION); } static boolean isAnonymousFunction(Node n) { return n.getType() == Token.FUNCTION && isFunctionAnonymous(n); } static boolean isFunctionAnonymous(Node n) { return !isStatement(n); } static boolean isVarArgsFunction(Node function) {"
      },
      {
        "txt": "Preconditions.checkArgument(isFunction(function)); return NodeUtil.isNameReferenced( function.getLastChild(), \"arguments\", Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } static boolean isObjectCallMethod(Node callNode, String methodName) { if (callNode.getType() == Token.CALL) { Node functionIndentifyingExpression = callNode.getFirstChild(); if (NodeUtil.isGet(functionIndentifyingExpression)) {"
      },
      {
        "txt": "Node last = functionIndentifyingExpression.getLastChild(); if (last != null && last.getType() == Token.STRING) { String propName = last.getString(); return (propName.equals(methodName)); } } } return false; } static boolean isFunctionObjectCall(Node callNode) {"
      },
      {
        "txt": "return isObjectCallMethod(callNode, \"call\"); } static boolean isFunctionObjectApply(Node callNode) { return isObjectCallMethod(callNode, \"apply\"); } static boolean isSimpleFunctionObjectCall(Node callNode) { if (isFunctionObjectCall(callNode)) { if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) { return true; }"
      },
      {
        "txt": "} return false; } static boolean isLhs(Node n, Node parent) { return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) || parent.getType() == Token.VAR; } static boolean isObjectLitKey(Node node, Node parent) { if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) { int index = 0;"
      },
      {
        "txt": "for (Node current = parent.getFirstChild(); current != null; current = current.getNext()) { if (current == node) { return index % 2 == 0; } index++; } } return false;"
      },
      {
        "txt": "} static String opToStr(int operator) { switch (operator) { case Token.BITOR: return \"|\"; case Token.OR: return \"||\"; case Token.BITXOR: return \"^\"; case Token.AND: return \"&&\"; case Token.BITAND: return \"&\"; case Token.SHEQ: return \"===\"; case Token.EQ: return \"==\";"
      },
      {
        "txt": "case Token.NOT: return \"!\"; case Token.NE: return \"!=\"; case Token.SHNE: return \"!==\"; case Token.LSH: return \"<<\"; case Token.IN: return \"in\"; case Token.LE: return \"<=\"; case Token.LT: return \"<\"; case Token.URSH: return \">>>\"; case Token.RSH: return \">>\"; case Token.GE: return \">=\";"
      },
      {
        "txt": "case Token.GT: return \">\"; case Token.MUL: return \"*\"; case Token.DIV: return \"/\"; case Token.MOD: return \"%\"; case Token.BITNOT: return \"~\"; case Token.ADD: return \"+\"; case Token.SUB: return \"-\"; case Token.POS: return \"+\"; case Token.NEG: return \"-\"; case Token.ASSIGN: return \"=\";"
      },
      {
        "txt": "case Token.ASSIGN_BITOR: return \"|=\"; case Token.ASSIGN_BITXOR: return \"^=\"; case Token.ASSIGN_BITAND: return \"&=\"; case Token.ASSIGN_LSH: return \"<<=\"; case Token.ASSIGN_RSH: return \">>=\"; case Token.ASSIGN_URSH: return \">>>=\"; case Token.ASSIGN_ADD: return \"+=\"; case Token.ASSIGN_SUB: return \"-=\"; case Token.ASSIGN_MUL: return \"*=\"; case Token.ASSIGN_DIV: return \"/=\";"
      },
      {
        "txt": "case Token.ASSIGN_MOD: return \"%=\"; case Token.VOID: return \"void\"; case Token.TYPEOF: return \"typeof\"; case Token.INSTANCEOF: return \"instanceof\"; default: return null; } } static String opToStrNoFail(int operator) { String res = opToStr(operator); if (res == null) {"
      },
      {
        "txt": "throw new Error(\"Unknown op \" + operator + \": \" + Token.name(operator)); } return res; } static boolean containsTypeInOuterScope(Node node, int type) { return containsType(node, type, Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } static boolean containsType(Node node,"
      },
      {
        "txt": "int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static boolean containsType(Node node, int type) { return containsType(node, type, Predicates.<Node>alwaysTrue()); } static void redeclareVarsInsideBranch(Node branch) { Collection<Node> vars = getVarsDeclaredInBranch(branch); if (vars.isEmpty()) {"
      },
      {
        "txt": "return; } Node parent = getAddingRoot(branch); for (Node nameNode : vars) { Node var = new Node( Token.VAR, Node.newString(Token.NAME, nameNode.getString())); copyNameAnnotations(nameNode, var.getFirstChild()); parent.addChildToFront(var); } }"
      },
      {
        "txt": "static void copyNameAnnotations(Node source, Node destination) { if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) { destination.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } private static Node getAddingRoot(Node n) { Node addingRoot = null; Node ancestor = n; while (null != (ancestor = ancestor.getParent())) { int type = ancestor.getType();"
      },
      {
        "txt": "if (type == Token.SCRIPT) { addingRoot = ancestor; break; } else if (type == Token.FUNCTION) { addingRoot = ancestor.getLastChild(); break; } } Preconditions.checkState(addingRoot.getType() == Token.BLOCK || addingRoot.getType() == Token.SCRIPT);"
      },
      {
        "txt": "Preconditions.checkState(addingRoot.getFirstChild() == null || addingRoot.getFirstChild().getType() != Token.SCRIPT); return addingRoot; } public static FunctionNode newFunctionNode(String name, List<Node> params, Node body, int lineno, int charno) { Node parameterParen = new Node(Token.LP, lineno, charno); for (Node param : params) { parameterParen.addChildToBack(param); }"
      },
      {
        "txt": "FunctionNode function = new FunctionNode(name, lineno, charno); function.addChildrenToBack( Node.newString(Token.NAME, name, lineno, charno)); function.addChildToBack(parameterParen); function.addChildToBack(body); return function; } public static Node newQualifiedNameNode(String name, int lineno, int charno) { int endPos = name.indexOf('.'); if (endPos == -1) {"
      },
      {
        "txt": "return Node.newString(Token.NAME, name, lineno, charno); } Node node = Node.newString(Token.NAME, name.substring(0, endPos), lineno, charno); int startPos; do { startPos = endPos + 1; endPos = name.indexOf('.', startPos); String part = (endPos == -1 ? name.substring(startPos)"
      },
      {
        "txt": ": name.substring(startPos, endPos)); node = new Node(Token.GETPROP, node, Node.newString(Token.STRING, part, lineno, charno), lineno, charno); } while (endPos != -1); return node; } static Node newQualifiedNameNode(String name, Node basisNode, String originalName) { Node node = newQualifiedNameNode(name, -1, -1);"
      },
      {
        "txt": "setDebugInformation(node, basisNode, originalName); return node; } static void setDebugInformation(Node node, Node basisNode, String originalName) { node.copyInformationFromForTree(basisNode); node.putProp(Node.ORIGINALNAME_PROP, originalName); } static Node newName(String name, Node basisNode) { Node nameNode = Node.newString(Token.NAME, name);"
      },
      {
        "txt": "nameNode.copyInformationFrom(basisNode); return nameNode; } static Node newName(String name, Node basisNode, String originalName) { Node nameNode = newName(name, basisNode); nameNode.putProp(Node.ORIGINALNAME_PROP, originalName); return nameNode; } static boolean isLatin(String s) { char LARGEST_BASIC_LATIN = 0x7f;"
      },
      {
        "txt": "int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c > LARGEST_BASIC_LATIN) { return false; } } return true; } static boolean isValidPropertyName(String name) {"
      },
      {
        "txt": "return TokenStream.isJSIdentifier(name) && !TokenStream.isKeyword(name) && NodeUtil.isLatin(name); } private static class VarCollector implements Visitor { final Map<String, Node> vars = Maps.newLinkedHashMap(); public void visit(Node n) { if (n.getType() == Token.NAME) { Node parent = n.getParent(); if (parent != null && parent.getType() == Token.VAR) {"
      },
      {
        "txt": "String name = n.getString(); if (!vars.containsKey(name)) { vars.put(name, n); } } } } } public static Collection<Node> getVarsDeclaredInBranch(Node root) { VarCollector collector = new VarCollector();"
      },
      {
        "txt": "visitPreOrder( root, collector, Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); return collector.vars.values(); } static boolean isPrototypePropertyDeclaration(Node n) { if (!NodeUtil.isExprAssign(n)) { return false; }"
      },
      {
        "txt": "return isPrototypeProperty(n.getFirstChild().getFirstChild()); } static boolean isPrototypeProperty(Node n) { String lhsString = n.getQualifiedName(); if (lhsString == null) { return false; } int prototypeIdx = lhsString.indexOf(\".prototype.\"); return prototypeIdx != -1; }"
      },
      {
        "txt": "static Node getPrototypeClassName(Node qName) { Node cur = qName; while (isGetProp(cur)) { if (cur.getLastChild().getString().equals(\"prototype\")) { return cur.getFirstChild(); } else { cur = cur.getFirstChild(); } } return null;"
      },
      {
        "txt": "} static String getPrototypePropertyName(Node qName) { String qNameStr = qName.getQualifiedName(); int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\"); int memberIndex = prototypeIdx + \".prototype\".length() + 1; return qNameStr.substring(memberIndex); } static Node newUndefinedNode() { return new Node(Token.VOID, Node.newNumber(0)); }"
      },
      {
        "txt": "static Node newVarNode(String name, Node value) { Node nodeName = Node.newString(Token.NAME, name); if (value != null) { nodeName.addChildrenToBack(value); } Node var = new Node(Token.VAR, nodeName); return var; } private static class MatchNameNode implements Predicate<Node>{ final String name;"
      },
      {
        "txt": "MatchNameNode(String name){ this.name = name; } public boolean apply(Node n) { return n.getType() == Token.NAME && n.getString().equals(name); } } static class MatchNodeType implements Predicate<Node>{ final int type;"
      },
      {
        "txt": "MatchNodeType(int type){ this.type = type; } public boolean apply(Node n) { return n.getType() == type; } } static boolean isNodeTypeReferenced(Node node, int type) { return isNodeTypeReferenced(node, type, Predicates.<Node>alwaysTrue()); }"
      },
      {
        "txt": "static boolean isNodeTypeReferenced( Node node, int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static int getNodeTypeReferenceCount(Node node, int type) { return getCount(node, new MatchNodeType(type)); } static boolean isNameReferenced(Node node, String name, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "return has(node, new MatchNameNode(name), traverseChildrenPred); } static boolean isNameReferenced(Node node, String name) { return isNameReferenced(node, name, Predicates.<Node>alwaysTrue()); } static int getNameReferenceCount(Node node, String name) { return getCount(node, new MatchNameNode(name) ); } static boolean has(Node node, Predicate<Node> pred,"
      },
      {
        "txt": "Predicate<Node> traverseChildrenPred) { if (pred.apply(node)) { return true; } if (!traverseChildrenPred.apply(node)) { return false; } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { if (has(c, pred, traverseChildrenPred)) { return true;"
      },
      {
        "txt": "} } return false; } static int getCount(Node n, Predicate<Node> pred) { int total = 0; if (pred.apply(n)) { total++; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "total += getCount(c, pred); } return total; } static interface Visitor { void visit(Node node); } static void visitPreOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "vistor.visit(node); if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPreOrder(c, vistor, traverseChildrenPred); } } } static void visitPostOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPostOrder(c, vistor, traverseChildrenPred); } } vistor.visit(node); } static boolean hasFinally(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getChildCount() == 3;"
      },
      {
        "txt": "} static Node getCatchBlock(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getFirstChild().getNext(); } static boolean hasCatchHandler(Node n) { Preconditions.checkArgument(n.getType() == Token.BLOCK); return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH; } static Node getFnParameters(Node fnNode) {"
      },
      {
        "txt": "Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } static boolean isConstantName(Node node) { return node.getBooleanProp(Node.IS_CONSTANT_NAME); } static JSDocInfo getInfoForNameNode(Node nameNode) { JSDocInfo info = null; Node parent = null; if (nameNode != null) {"
      },
      {
        "txt": "info = nameNode.getJSDocInfo(); parent = nameNode.getParent(); } if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) || parent.getType() == Token.FUNCTION)) { info = parent.getJSDocInfo(); } return info; }"
      },
      {
        "txt": "static String getSourceName(Node n) { String sourceName = null; while (sourceName == null && n != null) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); n = n.getParent(); } return sourceName; }"
      }
    ]
  },
  {
    "id": 538,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 82,
    "end-bug-line": 82,
    "bug": "removeDuplicateDeclarations(root);",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange;"
      },
      {
        "txt": "private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription);"
      },
      {
        "txt": "compiler.reportCodeChange(); } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); <extra_id_0> if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } new PropogateConstantAnnotations(compiler, assertOnChange)"
      },
      {
        "txt": "} new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations("
      },
      {
        "txt": "AbstractCompiler compiler, boolean forbidChanges) { this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.getType() == Token.NAME) { if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) &&"
      },
      {
        "txt": "!n.getBooleanProp(Node.IS_CONSTANT_NAME)) { n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } }"
      },
      {
        "txt": "} } } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations;"
      },
      {
        "txt": "} @Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap();"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false;"
      },
      {
        "txt": "if (NodeUtil.isConstantName(n) || compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); }"
      },
      {
        "txt": "if (info != null && info.isConstant()) { expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else {"
      },
      {
        "txt": "Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" +"
      },
      {
        "txt": "\"constant.\"); } } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler;"
      },
      {
        "txt": "this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override"
      },
      {
        "txt": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild();"
      },
      {
        "txt": "n.setType(Token.FOR); n.addChildBefore(new Node(Token.EMPTY), expr); n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; } } private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "moveNamedFunctions(n.getLastChild()); } } private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR:"
      },
      {
        "txt": "case Token.WHILE: case Token.DO: return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; }"
      },
      {
        "txt": "} private void extractForInitializer( Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent);"
      },
      {
        "txt": "break; case Token.FOR: if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else {"
      },
      {
        "txt": "newStatement = NodeUtil.newExpr(init); } insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) {"
      },
      {
        "txt": "for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node("
      },
      {
        "txt": "Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c); reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION);"
      },
      {
        "txt": "Node previous = null; Node current = functionBody.getFirstChild(); while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) {"
      },
      {
        "txt": "Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous); insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } }"
      },
      {
        "txt": "private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) { parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) {"
      },
      {
        "txt": "Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator( compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration("
      },
      {
        "txt": "Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild(); n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value);"
      },
      {
        "txt": "gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else { Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY));"
      },
      {
        "txt": "} } reportCodeChange(\"Duplicate VAR declaration\"); } } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 539,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 102,
    "end-bug-line": 102,
    "bug": "",
    "fix": "removeDuplicateDeclarations(root);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; }"
      },
      {
        "txt": "private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root,"
      },
      {
        "txt": "removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } <extra_id_0> .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler;"
      },
      {
        "txt": "implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) { this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) {"
      },
      {
        "txt": "new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString());"
      },
      {
        "txt": "if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) { n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" +"
      },
      {
        "txt": "\" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } } } } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler;"
      },
      {
        "txt": "final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; } @Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs));"
      },
      {
        "txt": "NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return;"
      },
      {
        "txt": "} boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n) || compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null;"
      },
      {
        "txt": "Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) { expectedConst = true; } else { expectedConst = false; } }"
      },
      {
        "txt": "if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) {"
      },
      {
        "txt": "constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\"); } } } } static class NormalizeStatements implements Callback {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription);"
      },
      {
        "txt": "} compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR); n.addChildBefore(new Node(Token.EMPTY), expr); n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break;"
      },
      {
        "txt": "} } private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); }"
      },
      {
        "txt": "if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); } } private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild();"
      },
      {
        "txt": "switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO: return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block);"
      },
      {
        "txt": "block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer( Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before;"
      },
      {
        "txt": "Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR: if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY));"
      },
      {
        "txt": "Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); } insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break;"
      },
      {
        "txt": "} } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); }"
      },
      {
        "txt": "while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c); reportCodeChange(\"VAR with multiple children\"); } } }"
      },
      {
        "txt": "} private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild(); while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); }"
      },
      {
        "txt": "Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous); insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current;"
      },
      {
        "txt": "} current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) { parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); }"
      },
      {
        "txt": "return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator( compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); }"
      },
      {
        "txt": "private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); if (n.hasChildren()) {"
      },
      {
        "txt": "parent.removeChild(n); Node value = n.getFirstChild(); n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n);"
      },
      {
        "txt": "gramps.replaceChild(parent, n); } else { Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } }"
      },
      {
        "txt": "private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  }
]