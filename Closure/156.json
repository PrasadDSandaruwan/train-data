[
  {
    "id": 704,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 455,
    "end-bug-line": 456,
    "bug": "if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias);",
    "fix": "if (n.canCollapse()) { updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\");"
      },
      {
        "txt": "static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) {"
      },
      {
        "txt": "this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; } @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else {"
      },
      {
        "txt": "namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name);"
      },
      {
        "txt": "} for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); } } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) {"
      },
      {
        "txt": "continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); }"
      },
      {
        "txt": "} } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } }"
      },
      {
        "txt": "private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope);"
      },
      {
        "txt": "ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i);"
      },
      {
        "txt": "Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } }"
      },
      {
        "txt": "return false; } private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) {"
      },
      {
        "txt": "if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } }"
      },
      {
        "txt": "} private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName()));"
      },
      {
        "txt": "} private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias);"
      },
      {
        "txt": "} } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName);"
      },
      {
        "txt": "} } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) {"
      },
      {
        "txt": "String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); }"
      },
      {
        "txt": "} } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) {"
      },
      {
        "txt": "int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName);"
      },
      {
        "txt": "} } } private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) {"
      },
      {
        "txt": "} parent.replaceChild(n, ref); compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); <extra_id_0> } if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null &&"
      },
      {
        "txt": "p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } } }"
      },
      {
        "txt": "} private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); }"
      },
      {
        "txt": "Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else {"
      },
      {
        "txt": "Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current);"
      },
      {
        "txt": "parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return;"
      },
      {
        "txt": "} switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n);"
      },
      {
        "txt": "break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2);"
      },
      {
        "txt": "boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); }"
      },
      {
        "txt": "ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode);"
      },
      {
        "txt": "ref.node = nameNode; insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) {"
      },
      {
        "txt": "if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } } });"
      },
      {
        "txt": "} } private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0;"
      },
      {
        "txt": "if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode);"
      },
      {
        "txt": "} numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration;"
      },
      {
        "txt": "String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys();"
      },
      {
        "txt": "for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ?"
      },
      {
        "txt": "key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode)"
      },
      {
        "txt": ".copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName);"
      },
      {
        "txt": "if (p != null) { if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p);"
      },
      {
        "txt": "} } } numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames());"
      },
      {
        "txt": "Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter);"
      },
      {
        "txt": "parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } }"
      },
      {
        "txt": "} return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 705,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 574,
    "end-bug-line": 574,
    "bug": "private void updateObjLitOrFunctionDeclaration(Name n, String alias) {",
    "fix": "private void updateObjLitOrFunctionDeclaration( Name n, String alias, boolean canCollapseChildNames) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\");"
      },
      {
        "txt": "static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) {"
      },
      {
        "txt": "this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; } @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else {"
      },
      {
        "txt": "namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name);"
      },
      {
        "txt": "} for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); } } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) {"
      },
      {
        "txt": "continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); }"
      },
      {
        "txt": "} } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } }"
      },
      {
        "txt": "private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope);"
      },
      {
        "txt": "ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i);"
      },
      {
        "txt": "Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } }"
      },
      {
        "txt": "return false; } private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) {"
      },
      {
        "txt": "if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } }"
      },
      {
        "txt": "} private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName()));"
      },
      {
        "txt": "} private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias);"
      },
      {
        "txt": "} } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName);"
      },
      {
        "txt": "} } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) {"
      },
      {
        "txt": "String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); }"
      },
      {
        "txt": "} } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) {"
      },
      {
        "txt": "int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName);"
      },
      {
        "txt": "} } } private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) {"
      },
      {
        "txt": "ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); }"
      },
      {
        "txt": "if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration);"
      },
      {
        "txt": "} } } } private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent();"
      },
      {
        "txt": "if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue);"
      },
      {
        "txt": "Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {}"
      },
      {
        "txt": ".copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } <extra_id_0> if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return; }"
      },
      {
        "txt": "return; } switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION:"
      },
      {
        "txt": "updateFunctionDeclarationAtFunctionNode(n); break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3);"
      },
      {
        "txt": "Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n);"
      },
      {
        "txt": "} ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue);"
      },
      {
        "txt": "varParent.replaceChild(gramps, varNode); ref.node = nameNode; insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode);"
      },
      {
        "txt": "if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null ||"
      },
      {
        "txt": "(!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } }"
      },
      {
        "txt": "}); } } private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;"
      },
      {
        "txt": "int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) {"
      },
      {
        "txt": "gramps.removeChild(varNode); } numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) {"
      },
      {
        "txt": "Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0;"
      },
      {
        "txt": "boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString());"
      },
      {
        "txt": "String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias);"
      },
      {
        "txt": "if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); }"
      },
      {
        "txt": "Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) {"
      },
      {
        "txt": "Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } } numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) {"
      },
      {
        "txt": "Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode)"
      },
      {
        "txt": ".copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } }"
      },
      {
        "txt": "} } return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 706,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 589,
    "end-bug-line": 589,
    "bug": "updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);",
    "fix": "updateObjLitOrFunctionDeclarationAtAssignNode( n, alias, canCollapseChildNames);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\","
      },
      {
        "txt": "\"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler,"
      },
      {
        "txt": "boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; } @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root);"
      },
      {
        "txt": "} else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) {"
      },
      {
        "txt": "flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); } } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop();"
      },
      {
        "txt": "if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref);"
      },
      {
        "txt": "} } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } }"
      },
      {
        "txt": "} private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar));"
      },
      {
        "txt": "(new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef ="
      },
      {
        "txt": "aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; }"
      },
      {
        "txt": "} return false; } private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL ||"
      },
      {
        "txt": "ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } }"
      },
      {
        "txt": "} } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node,"
      },
      {
        "txt": "NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); }"
      },
      {
        "txt": "flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) {"
      },
      {
        "txt": "flattenNameRef(alias, r.node, rParent, originalName); } } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } }"
      },
      {
        "txt": "private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName);"
      },
      {
        "txt": "} } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth,"
      },
      {
        "txt": "String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) {"
      },
      {
        "txt": "flattenNameRef(alias, n.getFirstChild(), n, originalName); } } } private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType();"
      },
      {
        "txt": "if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias);"
      },
      {
        "txt": "} if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration("
      },
      {
        "txt": "appendPropForAlias(alias, p.name), p, p.declaration); } } } } private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent();"
      },
      {
        "txt": "Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue);"
      },
      {
        "txt": "nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent,"
      },
      {
        "txt": "currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) {"
      },
      {
        "txt": "} if (n.declaration.getTwin() != null) { return; } switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: <extra_id_0> break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n);"
      },
      {
        "txt": "case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR);"
      },
      {
        "txt": "Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode);"
      },
      {
        "txt": "nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode; insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); }"
      },
      {
        "txt": "addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) {"
      },
      {
        "txt": "if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); }"
      },
      {
        "txt": "} }); } } private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent();"
      },
      {
        "txt": "boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node);"
      },
      {
        "txt": "if (!varNode.hasChildren()) { gramps.removeChild(varNode); } numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } }"
      },
      {
        "txt": "private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0;"
      },
      {
        "txt": "int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER &&"
      },
      {
        "txt": "TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else {"
      },
      {
        "txt": "refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);"
      },
      {
        "txt": "} Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar;"
      },
      {
        "txt": "if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode;"
      },
      {
        "txt": "if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } } numVars++; } return numVars; } private int addStubsForUndeclaredProperties("
      },
      {
        "txt": "Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias);"
      },
      {
        "txt": "Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); }"
      },
      {
        "txt": "} } } return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop;"
      }
    ]
  },
  {
    "id": 707,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 592,
    "end-bug-line": 592,
    "bug": "updateObjLitOrFunctionDeclarationAtVarNode(n);",
    "fix": "updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass {"
      },
      {
        "txt": "static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\","
      },
      {
        "txt": "\"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes;"
      },
      {
        "txt": "this.inlineAliases = inlineAliases; } @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else { namespace = new GlobalNamespace(compiler, root); }"
      },
      {
        "txt": "if (inlineAliases) { inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) {"
      },
      {
        "txt": "collapseDeclarationOfNameAndDescendants(n, n.name); } } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; }"
      },
      {
        "txt": "if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } }"
      },
      {
        "txt": "} if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent();"
      },
      {
        "txt": "if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar);"
      },
      {
        "txt": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode);"
      },
      {
        "txt": "newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } } return false; }"
      },
      {
        "txt": "private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref);"
      },
      {
        "txt": "} initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } } } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) {"
      },
      {
        "txt": "compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames("
      },
      {
        "txt": "Name n, String alias) { if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias); } }"
      },
      {
        "txt": "private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName); } }"
      },
      {
        "txt": "} if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null &&"
      },
      {
        "txt": "n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); } } }"
      },
      {
        "txt": "if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP;"
      },
      {
        "txt": "boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName); } }"
      },
      {
        "txt": "} private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) { ref.setJSType(type); }"
      },
      {
        "txt": "parent.replaceChild(n, ref); compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) { for (Name p : n.props) {"
      },
      {
        "txt": "collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } }"
      },
      {
        "txt": "} } private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName);"
      },
      {
        "txt": "} Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode);"
      },
      {
        "txt": "} else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode);"
      },
      {
        "txt": "currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) {"
      },
      {
        "txt": "} switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: <extra_id_0> break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break; } }"
      },
      {
        "txt": "} } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;"
      },
      {
        "txt": "boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue);"
      },
      {
        "txt": "Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode;"
      },
      {
        "txt": "insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) {"
      },
      {
        "txt": "varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(),"
      },
      {
        "txt": "new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } } }); }"
      },
      {
        "txt": "} private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) {"
      },
      {
        "txt": "numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode); }"
      },
      {
        "txt": "numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString();"
      },
      {
        "txt": "addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null;"
      },
      {
        "txt": "key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);"
      },
      {
        "txt": "String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);"
      },
      {
        "txt": "} key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key);"
      },
      {
        "txt": "if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) {"
      },
      {
        "txt": "if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); }"
      },
      {
        "txt": "} } numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));"
      },
      {
        "txt": "Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter);"
      },
      {
        "txt": "addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } } }"
      },
      {
        "txt": "return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 708,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 595,
    "end-bug-line": 595,
    "bug": "updateFunctionDeclarationAtFunctionNode(n);",
    "fix": "updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name;"
      },
      {
        "txt": "import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\","
      },
      {
        "txt": "\"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames;"
      },
      {
        "txt": "private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; } @Override"
      },
      {
        "txt": "public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace); }"
      },
      {
        "txt": "nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); } }"
      },
      {
        "txt": "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs);"
      },
      {
        "txt": "for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) &&"
      },
      {
        "txt": "name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString());"
      },
      {
        "txt": "ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {"
      },
      {
        "txt": "int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL));"
      },
      {
        "txt": "compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } } return false; } private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null &&"
      },
      {
        "txt": "(name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) {"
      },
      {
        "txt": "warnAboutNamespaceAliasing(name, ref); } } } } } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName()));"
      },
      {
        "txt": "} private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return; for (Name p : n.props) {"
      },
      {
        "txt": "String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName();"
      },
      {
        "txt": "for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName); } } } if (n.props != null) { for (Name p : n.props) {"
      },
      {
        "txt": "flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); }"
      },
      {
        "txt": "if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); } } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1);"
      },
      {
        "txt": "} } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) {"
      },
      {
        "txt": "for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName); } } } private void flattenNameRef(String alias, Node n, Node parent, String originalName) {"
      },
      {
        "txt": "Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange(); }"
      },
      {
        "txt": "private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null &&"
      },
      {
        "txt": "p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } } } } private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {"
      },
      {
        "txt": "Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(),"
      },
      {
        "txt": "refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps;"
      },
      {
        "txt": "Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); }"
      },
      {
        "txt": "compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return; } switch (n.declaration.node.getParent().getType()) {"
      },
      {
        "txt": "updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: <extra_id_0> break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration;"
      },
      {
        "txt": "Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode);"
      },
      {
        "txt": "ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName());"
      },
      {
        "txt": "if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode; insertedVarNode = true; } if (isObjLit) {"
      },
      {
        "txt": "declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange();"
      },
      {
        "txt": "} } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) {"
      },
      {
        "txt": "compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } } }); } } private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration;"
      },
      {
        "txt": "String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps);"
      },
      {
        "txt": "} numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode); } numChanges++; ref.node = null; }"
      },
      {
        "txt": "if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); }"
      },
      {
        "txt": "private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext();"
      },
      {
        "txt": "if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null;"
      },
      {
        "txt": "if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode); }"
      },
      {
        "txt": "Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else {"
      },
      {
        "txt": "varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET);"
      },
      {
        "txt": "newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } } numVars++;"
      },
      {
        "txt": "} return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) {"
      },
      {
        "txt": "for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++; compiler.reportCodeChange();"
      },
      {
        "txt": "if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } } } return numStubs; } private static String appendPropForAlias(String root, String prop) {"
      },
      {
        "txt": "if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 709,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 609,
    "end-bug-line": 609,
    "bug": "Name n, String alias) {",
    "fix": "Name n, String alias, boolean canCollapseChildNames) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\");"
      },
      {
        "txt": "static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) {"
      },
      {
        "txt": "this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; } @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else {"
      },
      {
        "txt": "namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name);"
      },
      {
        "txt": "} for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); } } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) {"
      },
      {
        "txt": "continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); }"
      },
      {
        "txt": "} } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } }"
      },
      {
        "txt": "private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope);"
      },
      {
        "txt": "ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i);"
      },
      {
        "txt": "Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } }"
      },
      {
        "txt": "return false; } private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) {"
      },
      {
        "txt": "if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } }"
      },
      {
        "txt": "} private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName()));"
      },
      {
        "txt": "} private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias);"
      },
      {
        "txt": "} } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName);"
      },
      {
        "txt": "} } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) {"
      },
      {
        "txt": "String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); }"
      },
      {
        "txt": "} } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) {"
      },
      {
        "txt": "int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName);"
      },
      {
        "txt": "} } } private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) {"
      },
      {
        "txt": "ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); }"
      },
      {
        "txt": "if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration);"
      },
      {
        "txt": "} } } } private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent();"
      },
      {
        "txt": "if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue);"
      },
      {
        "txt": "Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {}"
      },
      {
        "txt": "Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return;"
      },
      {
        "txt": "} if (n.declaration.getTwin() != null) { return; } switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n);"
      },
      {
        "txt": "case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( <extra_id_0> Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;"
      },
      {
        "txt": "Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n);"
      },
      {
        "txt": "} ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue);"
      },
      {
        "txt": "varParent.replaceChild(gramps, varNode); ref.node = nameNode; insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode);"
      },
      {
        "txt": "if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null ||"
      },
      {
        "txt": "(!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } }"
      },
      {
        "txt": "}); } } private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;"
      },
      {
        "txt": "int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) {"
      },
      {
        "txt": "gramps.removeChild(varNode); } numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) {"
      },
      {
        "txt": "Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0;"
      },
      {
        "txt": "boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString());"
      },
      {
        "txt": "String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias);"
      },
      {
        "txt": "if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); }"
      },
      {
        "txt": "Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) {"
      },
      {
        "txt": "Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } } numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) {"
      },
      {
        "txt": "Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode)"
      },
      {
        "txt": ".copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } }"
      },
      {
        "txt": "} } return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 710,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 653,
    "end-bug-line": 653,
    "bug": "if (isObjLit) {",
    "fix": "if (canCollapseChildNames) { if (isObjLit) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\","
      },
      {
        "txt": "\"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler,"
      },
      {
        "txt": "boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; } @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root);"
      },
      {
        "txt": "} else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) {"
      },
      {
        "txt": "flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); } } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop();"
      },
      {
        "txt": "if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref);"
      },
      {
        "txt": "} } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } }"
      },
      {
        "txt": "} private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar));"
      },
      {
        "txt": "(new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef ="
      },
      {
        "txt": "aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; }"
      },
      {
        "txt": "} return false; } private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL ||"
      },
      {
        "txt": "ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } }"
      },
      {
        "txt": "} } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node,"
      },
      {
        "txt": "NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); }"
      },
      {
        "txt": "flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) {"
      },
      {
        "txt": "flattenNameRef(alias, r.node, rParent, originalName); } } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } }"
      },
      {
        "txt": "private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName);"
      },
      {
        "txt": "} } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth,"
      },
      {
        "txt": "String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) {"
      },
      {
        "txt": "flattenNameRef(alias, n.getFirstChild(), n, originalName); } } } private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType();"
      },
      {
        "txt": "if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias);"
      },
      {
        "txt": "} if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration("
      },
      {
        "txt": "appendPropForAlias(alias, p.name), p, p.declaration); } } } } private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent();"
      },
      {
        "txt": "Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue);"
      },
      {
        "txt": "nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent,"
      },
      {
        "txt": "currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) {"
      },
      {
        "txt": "return; } if (n.declaration.getTwin() != null) { return; } switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR:"
      },
      {
        "txt": "updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration;"
      },
      {
        "txt": "Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true;"
      },
      {
        "txt": "} else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);"
      },
      {
        "txt": "varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode; insertedVarNode = true; } <extra_id_0> declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) {"
      },
      {
        "txt": "addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) {"
      },
      {
        "txt": "if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); }"
      },
      {
        "txt": "} }); } } private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent();"
      },
      {
        "txt": "boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node);"
      },
      {
        "txt": "if (!varNode.hasChildren()) { gramps.removeChild(varNode); } numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } }"
      },
      {
        "txt": "private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0;"
      },
      {
        "txt": "int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER &&"
      },
      {
        "txt": "TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else {"
      },
      {
        "txt": "refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);"
      },
      {
        "txt": "} Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar;"
      },
      {
        "txt": "if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode;"
      },
      {
        "txt": "if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } } numVars++; } return numVars; } private int addStubsForUndeclaredProperties("
      },
      {
        "txt": "Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias);"
      },
      {
        "txt": "Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); }"
      },
      {
        "txt": "} } } return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop;"
      }
    ]
  },
  {
    "id": 711,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 657,
    "end-bug-line": 657,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\");"
      },
      {
        "txt": "private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases;"
      },
      {
        "txt": "} @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) {"
      },
      {
        "txt": "inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name);"
      },
      {
        "txt": "} } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 &&"
      },
      {
        "txt": "name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } }"
      },
      {
        "txt": "if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) {"
      },
      {
        "txt": "Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined()"
      },
      {
        "txt": "&& aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode);"
      },
      {
        "txt": "} aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } } return false; } private void checkNamespaces() {"
      },
      {
        "txt": "for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); }"
      },
      {
        "txt": "initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } } } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report("
      },
      {
        "txt": "JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) {"
      },
      {
        "txt": "if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) {"
      },
      {
        "txt": "if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName); } } }"
      },
      {
        "txt": "if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) {"
      },
      {
        "txt": "flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); } } } if (n.props != null) {"
      },
      {
        "txt": "for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent());"
      },
      {
        "txt": "Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName); } } }"
      },
      {
        "txt": "private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref);"
      },
      {
        "txt": "compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants("
      },
      {
        "txt": "p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } } }"
      },
      {
        "txt": "} private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); }"
      },
      {
        "txt": "Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else {"
      },
      {
        "txt": "Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current);"
      },
      {
        "txt": "parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return;"
      },
      {
        "txt": "} switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n);"
      },
      {
        "txt": "break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2);"
      },
      {
        "txt": "boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); }"
      },
      {
        "txt": "ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode);"
      },
      {
        "txt": "insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); <extra_id_0> } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); }"
      },
      {
        "txt": "varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(),"
      },
      {
        "txt": "new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } } }); }"
      },
      {
        "txt": "} private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) {"
      },
      {
        "txt": "numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode); }"
      },
      {
        "txt": "numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString();"
      },
      {
        "txt": "addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null;"
      },
      {
        "txt": "key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);"
      },
      {
        "txt": "String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);"
      },
      {
        "txt": "} key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key);"
      },
      {
        "txt": "if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) {"
      },
      {
        "txt": "if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); }"
      },
      {
        "txt": "} } numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));"
      },
      {
        "txt": "Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter);"
      },
      {
        "txt": "addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } } }"
      },
      {
        "txt": "return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 712,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 658,
    "end-bug-line": 658,
    "bug": "",
    "fix": "addStubsForUndeclaredProperties(n, alias, varParent, varNode);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\");"
      },
      {
        "txt": "private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases;"
      },
      {
        "txt": "} @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) {"
      },
      {
        "txt": "inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name);"
      },
      {
        "txt": "} } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 &&"
      },
      {
        "txt": "name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } }"
      },
      {
        "txt": "if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) {"
      },
      {
        "txt": "Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined()"
      },
      {
        "txt": "&& aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode);"
      },
      {
        "txt": "} aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } } return false; } private void checkNamespaces() {"
      },
      {
        "txt": "for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); }"
      },
      {
        "txt": "initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } } } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report("
      },
      {
        "txt": "JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) {"
      },
      {
        "txt": "if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) {"
      },
      {
        "txt": "if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName); } } }"
      },
      {
        "txt": "if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) {"
      },
      {
        "txt": "flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); } } } if (n.props != null) {"
      },
      {
        "txt": "for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent());"
      },
      {
        "txt": "Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName); } } }"
      },
      {
        "txt": "private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref);"
      },
      {
        "txt": "compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants("
      },
      {
        "txt": "p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } } }"
      },
      {
        "txt": "} private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); }"
      },
      {
        "txt": "Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else {"
      },
      {
        "txt": "Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current);"
      },
      {
        "txt": "parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return;"
      },
      {
        "txt": "} switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n);"
      },
      {
        "txt": "break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2);"
      },
      {
        "txt": "boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); }"
      },
      {
        "txt": "ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode);"
      },
      {
        "txt": "insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); <extra_id_0> addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange();"
      },
      {
        "txt": "} compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() {"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } } }); } }"
      },
      {
        "txt": "private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues("
      },
      {
        "txt": "n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode); } numChanges++;"
      },
      {
        "txt": "ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties("
      },
      {
        "txt": "n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) {"
      },
      {
        "txt": "Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName);"
      },
      {
        "txt": "String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); }"
      },
      {
        "txt": "key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) {"
      },
      {
        "txt": "varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) {"
      },
      {
        "txt": "Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); } }"
      },
      {
        "txt": "} numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter);"
      },
      {
        "txt": "int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar;"
      },
      {
        "txt": "numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } } } return numStubs;"
      },
      {
        "txt": "} private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 713,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 659,
    "end-bug-line": 659,
    "bug": "addStubsForUndeclaredProperties(n, alias, varParent, varNode);",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler;"
      },
      {
        "txt": "private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace);"
      },
      {
        "txt": "} nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); }"
      },
      {
        "txt": "} private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {"
      },
      {
        "txt": "List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT ||"
      },
      {
        "txt": "name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope;"
      },
      {
        "txt": "Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()"
      },
      {
        "txt": "&& aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); }"
      },
      {
        "txt": "aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } } return false; } private void checkNamespaces() { for (Name name : nameMap.values()) {"
      },
      {
        "txt": "if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true;"
      },
      {
        "txt": "} else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } } } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node,"
      },
      {
        "txt": "UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return;"
      },
      {
        "txt": "for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) {"
      },
      {
        "txt": "String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName); } } } if (n.props != null) {"
      },
      {
        "txt": "for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName);"
      },
      {
        "txt": "} if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); } } } if (n.props != null) { for (Name p : n.props) {"
      },
      {
        "txt": "flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName);"
      },
      {
        "txt": "if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName); } } } private void flattenNameRef(String alias, Node n, Node parent,"
      },
      {
        "txt": "String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange();"
      },
      {
        "txt": "} private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name));"
      },
      {
        "txt": "if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } } } }"
      },
      {
        "txt": "private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName("
      },
      {
        "txt": "compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin());"
      },
      {
        "txt": "Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode);"
      },
      {
        "txt": "} compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return; }"
      },
      {
        "txt": "switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break;"
      },
      {
        "txt": "} } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;"
      },
      {
        "txt": "boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue);"
      },
      {
        "txt": "Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode;"
      },
      {
        "txt": "} if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } <extra_id_0> if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } } }); } } private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {"
      },
      {
        "txt": "Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode),"
      },
      {
        "txt": "gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode); } numChanges++; ref.node = null;"
      },
      {
        "txt": "} if (numChanges > 0) { compiler.reportCodeChange(); } } private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent());"
      },
      {
        "txt": "} private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild();"
      },
      {
        "txt": "nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName;"
      },
      {
        "txt": "Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode);"
      },
      {
        "txt": "} Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter);"
      },
      {
        "txt": "} else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias ="
      },
      {
        "txt": "p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } }"
      },
      {
        "txt": "numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0;"
      },
      {
        "txt": "if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++;"
      },
      {
        "txt": "compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } } } return numStubs; }"
      },
      {
        "txt": "private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 714,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 699,
    "end-bug-line": 699,
    "bug": "private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {",
    "fix": "private void updateObjLitOrFunctionDeclarationAtVarNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning( \"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler; private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases;"
      },
      {
        "txt": "CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; } @Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) {"
      },
      {
        "txt": "namespace = new GlobalNamespace(compiler, externs, root); } else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace); } nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces();"
      },
      {
        "txt": "for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); } } private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) {"
      },
      {
        "txt": "Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) {"
      },
      {
        "txt": "name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); }"
      },
      {
        "txt": "} } private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope; Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,"
      },
      {
        "txt": "Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) {"
      },
      {
        "txt": "ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); } aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true;"
      },
      {
        "txt": "} } return false; } private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) {"
      },
      {
        "txt": "if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } }"
      },
      {
        "txt": "} } } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report("
      },
      {
        "txt": "JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return; for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias);"
      },
      {
        "txt": "} flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) { String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) &&"
      },
      {
        "txt": "(r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName); } } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, 1); } }"
      },
      {
        "txt": "} private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName); } if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) {"
      },
      {
        "txt": "flattenNameRefAtDepth(alias, r.node, depth, originalName); } } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } }"
      },
      {
        "txt": "private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName); if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); }"
      },
      {
        "txt": "if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName); } } } private void flattenNameRef(String alias, Node n, Node parent, String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref);"
      },
      {
        "txt": "JSType type = n.getJSType(); if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange(); } private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) {"
      },
      {
        "txt": "updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name)); if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) {"
      },
      {
        "txt": "updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } } } } private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent();"
      },
      {
        "txt": "Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) {"
      },
      {
        "txt": "parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK;"
      },
      {
        "txt": "current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) {"
      },
      {
        "txt": "if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return; } switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break;"
      },
      {
        "txt": "case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break; } } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) {"
      },
      {
        "txt": "Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null;"
      },
      {
        "txt": "insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode; insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues("
      },
      {
        "txt": "n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "} private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report("
      },
      {
        "txt": "UNSAFE_THIS, name.fullName())); } } }); } } <extra_id_0> Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;"
      },
      {
        "txt": "Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) { numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) {"
      },
      {
        "txt": "varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode); } numChanges++; ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); }"
      },
      {
        "txt": "} private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) {"
      },
      {
        "txt": "int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild(); nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; }"
      },
      {
        "txt": "boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName; Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent();"
      },
      {
        "txt": "} else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode); } Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter); } else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange();"
      },
      {
        "txt": "nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias = p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); }"
      },
      {
        "txt": "p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } } numVars++; } return numVars; }"
      },
      {
        "txt": "private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0; if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name);"
      },
      {
        "txt": "Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++; compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);"
      },
      {
        "txt": "} } } } return numStubs; } private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); }"
      },
      {
        "txt": "return root + '$' + prop; }"
      }
    ]
  },
  {
    "id": 715,
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
    "start-bug-line": 742,
    "end-bug-line": 742,
    "bug": "private void updateFunctionDeclarationAtFunctionNode(Name n) {",
    "fix": "private void updateFunctionDeclarationAtFunctionNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.jscomp.GlobalNamespace.Ref; import com.google.javascript.jscomp.GlobalNamespace.Ref.Type; import com.google.javascript.jscomp.ReferenceCollectingCallback; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.JSType; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class CollapseProperties implements CompilerPass { static final DiagnosticType UNSAFE_NAMESPACE_WARNING = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_UNSAFE_NAMESPACE\", \"incomplete alias created for namespace {0}\"); static final DiagnosticType NAMESPACE_REDEFINED_WARNING = DiagnosticType.warning( \"JSC_NAMESPACE_REDEFINED\", \"namespace {0} should not be redefined\"); static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning( \"JSC_UNSAFE_THIS\", \"dangerous use of 'this' in static method {0}\"); private AbstractCompiler compiler;"
      },
      {
        "txt": "private List<Name> globalNames; private Map<String, Name> nameMap; private final boolean collapsePropertiesOnExternTypes; private final boolean inlineAliases; CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { this.compiler = compiler; this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; this.inlineAliases = inlineAliases; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { GlobalNamespace namespace; if (collapsePropertiesOnExternTypes) { namespace = new GlobalNamespace(compiler, externs, root); } else { namespace = new GlobalNamespace(compiler, root); } if (inlineAliases) { inlineAliases(namespace);"
      },
      {
        "txt": "} nameMap = namespace.getNameIndex(); globalNames = namespace.getNameForest(); checkNamespaces(); for (Name n : globalNames) { flattenReferencesToCollapsibleDescendantNames(n, n.name); } for (Name n : globalNames) { collapseDeclarationOfNameAndDescendants(n, n.name); }"
      },
      {
        "txt": "} private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {"
      },
      {
        "txt": "List<Ref> refs = Lists.newArrayList(name.refs); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT ||"
      },
      {
        "txt": "name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { Node aliasParent = alias.node.getParent(); if (aliasParent.getType() == Token.NAME) { Scope scope = alias.scope;"
      },
      {
        "txt": "Var aliasVar = scope.getVar(aliasParent.getString()); ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); (new NodeTraversal(compiler, collector)).traverseAtScope(scope); ReferenceCollection aliasRefs = collector.getReferenceCollection(aliasVar); if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()"
      },
      {
        "txt": "&& aliasRefs.isAssignedOnceInLifetime()) { int size = aliasRefs.references.size(); Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); for (int i = 1; i < size; i++) { ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); Node newNode = alias.node.cloneTree(); aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode); newNodes.add(newNode); }"
      },
      {
        "txt": "aliasParent.replaceChild(alias.node, new Node(Token.NULL)); compiler.reportCodeChange(); namespace.scanNewNodes(alias.scope, newNodes); return true; } } return false; } private void checkNamespaces() { for (Name name : nameMap.values()) {"
      },
      {
        "txt": "if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true;"
      },
      {
        "txt": "} else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } } } private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node,"
      },
      {
        "txt": "UNSAFE_NAMESPACE_WARNING, nameObj.fullName())); } private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { compiler.report( JSError.make(ref.sourceName, ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.fullName())); } private void flattenReferencesToCollapsibleDescendantNames( Name n, String alias) { if (n.props == null) return;"
      },
      {
        "txt": "for (Name p : n.props) { String propAlias = appendPropForAlias(alias, p.name); if (p.canCollapse()) { flattenReferencesTo(p, propAlias); } flattenReferencesToCollapsibleDescendantNames(p, propAlias); } } private void flattenReferencesTo(Name n, String alias) { if (n.refs != null) {"
      },
      {
        "txt": "String originalName = n.fullName(); for (Ref r : n.refs) { Node rParent = r.node.getParent(); if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { flattenNameRef(alias, r.node, rParent, originalName); } } } if (n.props != null) {"
      },
      {
        "txt": "for (Name p : n.props) { flattenPrefixes(alias, p, 1); } } } private void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.fullName(); if (n.declaration != null && n.declaration.node != null && n.declaration.node.getType() == Token.GETPROP) { flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName);"
      },
      {
        "txt": "} if (n.refs != null) { for (Ref r : n.refs) { if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); } } } if (n.props != null) { for (Name p : n.props) {"
      },
      {
        "txt": "flattenPrefixes(alias, p, depth + 1); } } } private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { int nType = n.getType(); boolean isQName = nType == Token.NAME || nType == Token.GETPROP; boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); Preconditions.checkState(isObjKey || isQName);"
      },
      {
        "txt": "if (isQName) { for (int i = 1; i < depth && n.hasChildren(); i++) { n = n.getFirstChild(); } if (n.hasChildren()) { flattenNameRef(alias, n.getFirstChild(), n, originalName); } } } private void flattenNameRef(String alias, Node n, Node parent,"
      },
      {
        "txt": "String originalName) { Node ref = NodeUtil.newName( compiler.getCodingConvention(), alias, n, originalName); NodeUtil.copyNameAnnotations(n.getLastChild(), ref); JSType type = n.getJSType(); if (type != null) { ref.setJSType(type); } parent.replaceChild(n, ref); compiler.reportCodeChange();"
      },
      {
        "txt": "} private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) { for (Name p : n.props) { collapseDeclarationOfNameAndDescendants( p, appendPropForAlias(alias, p.name));"
      },
      {
        "txt": "if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) { updateSimpleDeclaration( appendPropForAlias(alias, p.name), p, p.declaration); } } } }"
      },
      {
        "txt": "private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } Node nameNode = NodeUtil.newName("
      },
      {
        "txt": "compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin());"
      },
      {
        "txt": "Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {} Node stubVar = new Node(Token.VAR, nameNode.cloneTree()) .copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode);"
      },
      {
        "txt": "} compiler.reportCodeChange(); } private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { return; } if (n.declaration.getTwin() != null) { return; }"
      },
      {
        "txt": "switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break;"
      },
      {
        "txt": "} } private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;"
      },
      {
        "txt": "boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue);"
      },
      {
        "txt": "Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode;"
      },
      {
        "txt": "insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) {"
      },
      {
        "txt": "varParent.removeChild(varNode); } compiler.reportCodeChange(); } } private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { NodeTraversal.traverse(compiler, function.getLastChild(),"
      },
      {
        "txt": "new NodeTraversal.AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.THIS) { compiler.report( JSError.make(name.declaration.sourceName, n, UNSAFE_THIS, name.fullName())); } } }); }"
      },
      {
        "txt": "} private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString(); Node rvalue = ref.node.getFirstChild(); Node varNode = ref.node.getParent(); Node gramps = varNode.getParent(); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; int numChanges = 0; if (isObjLit) {"
      },
      {
        "txt": "numChanges += declareVarsForObjLitValues( n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); } numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); if (isObjLit && n.canEliminate()) { varNode.removeChild(ref.node); if (!varNode.hasChildren()) { gramps.removeChild(varNode); }"
      },
      {
        "txt": "ref.node = null; } if (numChanges > 0) { compiler.reportCodeChange(); } } <extra_id_0> Ref ref = n.declaration; String fnName = ref.node.getString(); addStubsForUndeclaredProperties( n, fnName, ref.node.getAncestor(2), ref.node.getParent()); } private int declareVarsForObjLitValues("
      },
      {
        "txt": "} private int declareVarsForObjLitValues( Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { int numVars = 0; int arbitraryNameCounter = 0; boolean discardKeys = !objlitName.shouldKeepKeys(); for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { Node value = key.getFirstChild();"
      },
      {
        "txt": "nextKey = key.getNext(); if (key.getType() == Token.GET || key.getType() == Token.SET) { continue; } boolean isJsIdentifier = key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString()); String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); String propAlias = appendPropForAlias(alias, propName); String qName = objlitName.fullName() + '.' + propName;"
      },
      {
        "txt": "Node refNode = null; if (discardKeys) { objlit.removeChild(key); value.detachFromParent(); } else { refNode = Node.newString(Token.NAME, propAlias); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } key.replaceChild(value, refNode);"
      },
      {
        "txt": "} Node nameNode = Node.newString(Token.NAME, propAlias); nameNode.addChildToFront(value); if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(key); if (nameToAddAfter != null) { varParent.addChildAfter(newVar, nameToAddAfter);"
      },
      {
        "txt": "} else { varParent.addChildBefore(newVar, varNode); } compiler.reportCodeChange(); nameToAddAfter = newVar; if (isJsIdentifier) { Name p = nameMap.get(qName); if (p != null) { if (!discardKeys) { Ref newAlias ="
      },
      {
        "txt": "p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET); newAlias.node = refNode; p.addRef(newAlias); } p.declaration.node = nameNode; if (value.getType() == Token.FUNCTION) { checkForHosedThisReferences(value, value.getJSDocInfo(), p); } } }"
      },
      {
        "txt": "numVars++; } return numVars; } private int addStubsForUndeclaredProperties( Name n, String alias, Node parent, Node addAfter) { Preconditions.checkState(n.canCollapseUnannotatedChildNames()); Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); Preconditions.checkNotNull(addAfter); int numStubs = 0;"
      },
      {
        "txt": "if (n.props != null) { for (Name p : n.props) { if (p.needsToBeStubbed()) { String propAlias = appendPropForAlias(alias, p.name); Node nameNode = Node.newString(Token.NAME, propAlias); Node newVar = new Node(Token.VAR, nameNode) .copyInformationFromForTree(addAfter); parent.addChildAfter(newVar, addAfter); addAfter = newVar; numStubs++;"
      },
      {
        "txt": "compiler.reportCodeChange(); if (p.refs.get(0).node.getLastChild().getBooleanProp( Node.IS_CONSTANT_NAME)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } } } return numStubs; }"
      },
      {
        "txt": "private static String appendPropForAlias(String root, String prop) { if (prop.indexOf('$') != -1) { prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\"); } return root + '$' + prop; }"
      }
    ]
  }
]