[
  {
    "id": 547,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 281,
    "end-bug-line": 281,
    "bug": "",
    "fix": "case Token.FUNCTION: normalizeFunctionDeclaration(n); break;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true;"
      },
      {
        "txt": "static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); }"
      },
      {
        "txt": "compiler.reportCodeChange(); } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root);"
      },
      {
        "txt": "} removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange;"
      },
      {
        "txt": "public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) { this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); }"
      },
      {
        "txt": "if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) { n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); }"
      },
      {
        "txt": "} } } } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler;"
      },
      {
        "txt": "this.checkUserDeclarations = checkUserDeclarations; } @Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); }"
      },
      {
        "txt": "private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) {"
      },
      {
        "txt": "boolean expectedConst = false; if (NodeUtil.isConstantName(n) || compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo();"
      },
      {
        "txt": "} if (info != null && info.isConstant()) { expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\");"
      },
      {
        "txt": "} else { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst,"
      },
      {
        "txt": "\"The name \" + name + \" is not consistently annotated as \" + \"constant.\"); } } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) {"
      },
      {
        "txt": "n.setType(Token.FOR); n.addChildBefore(new Node(Token.EMPTY), expr); n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; <extra_id_0> } private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); }"
      },
      {
        "txt": "normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild());"
      },
      {
        "txt": "} } private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE:"
      },
      {
        "txt": "case Token.DO: return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } }"
      },
      {
        "txt": "private void extractForInitializer( Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break;"
      },
      {
        "txt": "case Token.FOR: if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init);"
      },
      {
        "txt": "} insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) {"
      },
      {
        "txt": "next = c.getNext(); if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno());"
      },
      {
        "txt": "n.addChildBefore(newVar, c); reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null;"
      },
      {
        "txt": "Node current = functionBody.getFirstChild(); while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous);"
      },
      {
        "txt": "functionBody.removeChildAfter(previous); insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } } private Node addToFront(Node parent, Node newChild, Node after) {"
      },
      {
        "txt": "if (after == null) { parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback();"
      },
      {
        "txt": "ScopeCreator scopeCreator = new SyntacticScopeCreator( compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps,"
      },
      {
        "txt": "Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n);"
      },
      {
        "txt": "Node value = n.getFirstChild(); n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n);"
      },
      {
        "txt": "} else { Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) {"
      },
      {
        "txt": "return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 548,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 292,
    "end-bug-line": 292,
    "bug": "",
    "fix": "private void normalizeFunctionDeclaration(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION); if (!NodeUtil.isFunctionAnonymous(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) { rewriteFunctionDeclaration(n); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);"
      },
      {
        "txt": "new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } }"
      },
      {
        "txt": "} } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n)"
      },
      {
        "txt": "|| compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) {"
      },
      {
        "txt": "expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst,"
      },
      {
        "txt": "\"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\");"
      },
      {
        "txt": "} } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange;"
      },
      {
        "txt": "} private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR);"
      },
      {
        "txt": "n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; } } <extra_id_0> private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {"
      },
      {
        "txt": "} if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); }"
      },
      {
        "txt": "} private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO:"
      },
      {
        "txt": "return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer("
      },
      {
        "txt": "Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR:"
      },
      {
        "txt": "if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); }"
      },
      {
        "txt": "insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext();"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c);"
      },
      {
        "txt": "reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild();"
      },
      {
        "txt": "while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous);"
      },
      {
        "txt": "insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) {"
      },
      {
        "txt": "parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator("
      },
      {
        "txt": "compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild();"
      },
      {
        "txt": "n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else {"
      },
      {
        "txt": "Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 549,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 309,
    "end-bug-line": 309,
    "bug": "",
    "fix": "private void rewriteFunctionDeclaration(Node n) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);"
      },
      {
        "txt": "new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } }"
      },
      {
        "txt": "} } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n)"
      },
      {
        "txt": "|| compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) {"
      },
      {
        "txt": "expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst,"
      },
      {
        "txt": "\"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\");"
      },
      {
        "txt": "} } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange;"
      },
      {
        "txt": "} private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR);"
      },
      {
        "txt": "n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; } } <extra_id_0> private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {"
      },
      {
        "txt": "} if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); }"
      },
      {
        "txt": "} private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO:"
      },
      {
        "txt": "return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer("
      },
      {
        "txt": "Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR:"
      },
      {
        "txt": "if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); }"
      },
      {
        "txt": "insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext();"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c);"
      },
      {
        "txt": "reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild();"
      },
      {
        "txt": "while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous);"
      },
      {
        "txt": "insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) {"
      },
      {
        "txt": "parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator("
      },
      {
        "txt": "compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild();"
      },
      {
        "txt": "n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else {"
      },
      {
        "txt": "Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 550,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 310,
    "end-bug-line": 310,
    "bug": "",
    "fix": "Node oldNameNode = n.getFirstChild(); Node fnNameNode = oldNameNode.cloneNode(); Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno()); var.copyInformationFrom(n);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);"
      },
      {
        "txt": "new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } }"
      },
      {
        "txt": "} } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n)"
      },
      {
        "txt": "|| compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) {"
      },
      {
        "txt": "expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst,"
      },
      {
        "txt": "\"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\");"
      },
      {
        "txt": "} } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange;"
      },
      {
        "txt": "} private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR);"
      },
      {
        "txt": "n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; } } <extra_id_0> private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {"
      },
      {
        "txt": "} if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); }"
      },
      {
        "txt": "} private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO:"
      },
      {
        "txt": "return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer("
      },
      {
        "txt": "Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR:"
      },
      {
        "txt": "if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); }"
      },
      {
        "txt": "insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext();"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c);"
      },
      {
        "txt": "reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild();"
      },
      {
        "txt": "while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous);"
      },
      {
        "txt": "insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) {"
      },
      {
        "txt": "parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator("
      },
      {
        "txt": "compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild();"
      },
      {
        "txt": "n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else {"
      },
      {
        "txt": "Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 551,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 312,
    "end-bug-line": 312,
    "bug": "",
    "fix": "oldNameNode.setString(\"\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);"
      },
      {
        "txt": "new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } }"
      },
      {
        "txt": "} } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n)"
      },
      {
        "txt": "|| compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) {"
      },
      {
        "txt": "expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst,"
      },
      {
        "txt": "\"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\");"
      },
      {
        "txt": "} } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange;"
      },
      {
        "txt": "} private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR);"
      },
      {
        "txt": "n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; } } <extra_id_0> private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {"
      },
      {
        "txt": "} if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); }"
      },
      {
        "txt": "} private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO:"
      },
      {
        "txt": "return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer("
      },
      {
        "txt": "Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR:"
      },
      {
        "txt": "if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); }"
      },
      {
        "txt": "insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext();"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c);"
      },
      {
        "txt": "reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild();"
      },
      {
        "txt": "while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous);"
      },
      {
        "txt": "insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) {"
      },
      {
        "txt": "parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator("
      },
      {
        "txt": "compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild();"
      },
      {
        "txt": "n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else {"
      },
      {
        "txt": "Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 552,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 314,
    "end-bug-line": 314,
    "bug": "",
    "fix": "Node parent = n.getParent(); parent.replaceChild(n, var); fnNameNode.addChildToFront(n);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);"
      },
      {
        "txt": "new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } }"
      },
      {
        "txt": "} } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n)"
      },
      {
        "txt": "|| compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) {"
      },
      {
        "txt": "expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst,"
      },
      {
        "txt": "\"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\");"
      },
      {
        "txt": "} } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange;"
      },
      {
        "txt": "} private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR);"
      },
      {
        "txt": "n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; } } <extra_id_0> private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {"
      },
      {
        "txt": "} if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); }"
      },
      {
        "txt": "} private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO:"
      },
      {
        "txt": "return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer("
      },
      {
        "txt": "Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR:"
      },
      {
        "txt": "if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); }"
      },
      {
        "txt": "insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext();"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c);"
      },
      {
        "txt": "reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild();"
      },
      {
        "txt": "while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous);"
      },
      {
        "txt": "insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) {"
      },
      {
        "txt": "parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator("
      },
      {
        "txt": "compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild();"
      },
      {
        "txt": "n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else {"
      },
      {
        "txt": "Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 553,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 315,
    "end-bug-line": 315,
    "bug": "",
    "fix": "reportCodeChange(\"Function declaration\"); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);"
      },
      {
        "txt": "new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) {"
      },
      {
        "txt": "this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {"
      },
      {
        "txt": "n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } }"
      },
      {
        "txt": "} } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; } boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n)"
      },
      {
        "txt": "|| compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) {"
      },
      {
        "txt": "expectedConst = true; } else { expectedConst = false; } } if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst,"
      },
      {
        "txt": "\"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\");"
      },
      {
        "txt": "} } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange;"
      },
      {
        "txt": "} private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR);"
      },
      {
        "txt": "n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; } } <extra_id_0> private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {"
      },
      {
        "txt": "} if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); }"
      },
      {
        "txt": "} private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO:"
      },
      {
        "txt": "return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer("
      },
      {
        "txt": "Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR:"
      },
      {
        "txt": "if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); }"
      },
      {
        "txt": "insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; } } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext();"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c);"
      },
      {
        "txt": "reportCodeChange(\"VAR with multiple children\"); } } } } private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild();"
      },
      {
        "txt": "while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous);"
      },
      {
        "txt": "insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; } current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) {"
      },
      {
        "txt": "parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator("
      },
      {
        "txt": "compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild();"
      },
      {
        "txt": "n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else {"
      },
      {
        "txt": "Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } } private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true;"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 554,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 521,
    "end-bug-line": 521,
    "bug": "if (parent.getType() == Token.VAR) {",
    "fix": "Var v = s.getVar(name);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) {"
      },
      {
        "txt": "throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) {"
      },
      {
        "txt": "MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) { this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) {"
      },
      {
        "txt": "new NodeTraversal(compiler, this).traverseRoots(externs, root); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString());"
      },
      {
        "txt": "if (var != null) { info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) { n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" +"
      },
      {
        "txt": "\" name: \"+ name + \"\\n\" + \" gramps:\" + n.getParent().getParent().toStringTree()); } } } } } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler;"
      },
      {
        "txt": "final private boolean checkUserDeclarations; VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; } @Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs));"
      },
      {
        "txt": "NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return;"
      },
      {
        "txt": "} boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n) || compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null;"
      },
      {
        "txt": "Var var = t.getScope().getVar(n.getString()); if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) { expectedConst = true; } else { expectedConst = false; } }"
      },
      {
        "txt": "if (expectedConst) { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) {"
      },
      {
        "txt": "constantMap.put(name, isConst); } else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\"); } } } } static class NormalizeStatements implements Callback {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription);"
      },
      {
        "txt": "} compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR); n.addChildBefore(new Node(Token.EMPTY), expr); n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break;"
      },
      {
        "txt": "} } private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); }"
      },
      {
        "txt": "if (NodeUtil.isStatementBlock(n)) { splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); } } private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild();"
      },
      {
        "txt": "switch (last.getType()) { case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO: return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block);"
      },
      {
        "txt": "block.addChildToFront(last); reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer( Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before;"
      },
      {
        "txt": "Node insertBeforeParent = (before == null) ? n : beforeParent; switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR: if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY));"
      },
      {
        "txt": "Node newStatement; if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); } insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break;"
      },
      {
        "txt": "} } } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); }"
      },
      {
        "txt": "while (c.getFirstChild() != c.getLastChild()) { Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c); reportCodeChange(\"VAR with multiple children\"); } } }"
      },
      {
        "txt": "} private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild(); while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); }"
      },
      {
        "txt": "Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous); insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current;"
      },
      {
        "txt": "} current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) { parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); }"
      },
      {
        "txt": "return newChild; } } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator( compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); }"
      },
      {
        "txt": "SyntacticScopeCreator.RedeclarationHandler { @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); <extra_id_0> Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) {"
      },
      {
        "txt": "private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild(); n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent);"
      },
      {
        "txt": "} else if (gramps.getType() == Token.FOR) { parent.removeChild(n); gramps.replaceChild(parent, n); } else { Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); }"
      },
      {
        "txt": "} private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { }"
      },
      {
        "txt": "@Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  },
  {
    "id": 555,
    "file_path": "src/com/google/javascript/jscomp/Normalize.java",
    "start-bug-line": 523,
    "end-bug-line": 523,
    "bug": "",
    "fix": "Preconditions.checkState( v == null || v.getParentNode().getType() != Token.CATCH); if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) { s.undeclare(v); s.declare(name, n, n.getJSType(), v.input); replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent()); } } else if (parent.getType() == Token.VAR) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; class Normalize implements CompilerPass { private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final boolean assertOnChange; private static final boolean CONVERT_WHILE_TO_FOR = true; static final boolean MAKE_LOCAL_NAMES_UNIQUE = true; Normalize(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException("
      },
      {
        "txt": "\"Normalize constraints violated:\\n\" + changeDescription); } compiler.reportCodeChange(); } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();"
      },
      {
        "txt": "NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); } public static class PropogateConstantAnnotations extends AbstractPostOrderCallback implements CompilerPass {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final boolean assertOnChange; public PropogateConstantAnnotations( AbstractCompiler compiler, boolean forbidChanges) { this.compiler = compiler; this.assertOnChange = forbidChanges; } @Override public void process(Node externs, Node root) { new NodeTraversal(compiler, this).traverseRoots(externs, root);"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { if (n.getString().isEmpty()) { return; } JSDocInfo info = null; Var var = t.getScope().getVar(n.getString()); if (var != null) {"
      },
      {
        "txt": "info = var.getJSDocInfo(); } if ((info != null && info.isConstant()) && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) { n.putBooleanProp(Node.IS_CONSTANT_NAME, true); if (assertOnChange) { String name = n.getString(); throw new IllegalStateException( \"Unexpected const change.\\n\" + \" name: \"+ name + \"\\n\" +"
      },
      {
        "txt": "\" gramps:\" + n.getParent().getParent().toStringTree()); } } } } } static class VerifyConstants extends AbstractPostOrderCallback implements CompilerPass { final private AbstractCompiler compiler; final private boolean checkUserDeclarations;"
      },
      {
        "txt": "VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { this.compiler = compiler; this.checkUserDeclarations = checkUserDeclarations; } @Override public void process(Node externs, Node root) { Node externsAndJs = root.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState(externsAndJs.hasChild(externs)); NodeTraversal.traverseRoots("
      },
      {
        "txt": "compiler, Lists.newArrayList(externs, root), this); } private Map<String,Boolean> constantMap = Maps.newHashMap(); @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); if (n.getString().isEmpty()) { return; }"
      },
      {
        "txt": "boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (checkUserDeclarations) { boolean expectedConst = false; if (NodeUtil.isConstantName(n) || compiler.getCodingConvention().isConstant(n.getString())) { expectedConst = true; } else { expectedConst = false; JSDocInfo info = null; Var var = t.getScope().getVar(n.getString());"
      },
      {
        "txt": "if (var != null) { info = var.getJSDocInfo(); } if (info != null && info.isConstant()) { expectedConst = true; } else { expectedConst = false; } } if (expectedConst) {"
      },
      {
        "txt": "Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" is not annotated as constant.\"); } else { Preconditions.checkState(expectedConst == isConst, \"The name \" + name + \" should not be annotated as constant.\"); } } Boolean value = constantMap.get(name); if (value == null) { constantMap.put(name, isConst);"
      },
      {
        "txt": "} else { Preconditions.checkState(value.booleanValue() == isConst, \"The name \" + name + \" is not consistently annotated as \" + \"constant.\"); } } } } static class NormalizeStatements implements Callback { private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final boolean assertOnChange; NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { this.compiler = compiler; this.assertOnChange = assertOnChange; } private void reportCodeChange(String changeDescription) { if (assertOnChange) { throw new IllegalStateException( \"Normalize constraints violated:\\n\" + changeDescription); }"
      },
      {
        "txt": "compiler.reportCodeChange(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { doStatementNormalizations(t, n, parent); return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.WHILE: if (CONVERT_WHILE_TO_FOR) { Node expr = n.getFirstChild(); n.setType(Token.FOR); n.addChildBefore(new Node(Token.EMPTY), expr); n.addChildAfter(new Node(Token.EMPTY), expr); reportCodeChange(\"WHILE node\"); } break; }"
      },
      {
        "txt": "} private void doStatementNormalizations( NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.LABEL) { normalizeLabels(n); } if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) { extractForInitializer(n, null, null); } if (NodeUtil.isStatementBlock(n)) {"
      },
      {
        "txt": "splitVarDeclarations(n); } if (n.getType() == Token.FUNCTION) { moveNamedFunctions(n.getLastChild()); } } private void normalizeLabels(Node n) { Preconditions.checkArgument(n.getType() == Token.LABEL); Node last = n.getLastChild(); switch (last.getType()) {"
      },
      {
        "txt": "case Token.LABEL: case Token.BLOCK: case Token.FOR: case Token.WHILE: case Token.DO: return; default: Node block = new Node(Token.BLOCK); n.replaceChild(last, block); block.addChildToFront(last);"
      },
      {
        "txt": "reportCodeChange(\"LABEL normalization\"); return; } } private void extractForInitializer( Node n, Node before, Node beforeParent) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); Node insertBefore = (before == null) ? c : before; Node insertBeforeParent = (before == null) ? n : beforeParent;"
      },
      {
        "txt": "switch (c.getType()) { case Token.LABEL: extractForInitializer(c, insertBefore, insertBeforeParent); break; case Token.FOR: if (!NodeUtil.isForIn(c) && c.getFirstChild().getType() != Token.EMPTY) { Node init = c.getFirstChild(); c.replaceChild(init, new Node(Token.EMPTY)); Node newStatement;"
      },
      {
        "txt": "if (init.getType() == Token.VAR) { newStatement = init; } else { newStatement = NodeUtil.newExpr(init); } insertBeforeParent.addChildBefore(newStatement, insertBefore); reportCodeChange(\"FOR initializer\"); } break; }"
      },
      {
        "txt": "} } private void splitVarDeclarations(Node n) { for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); if (c.getType() == Token.VAR) { if (assertOnChange && !c.hasChildren()) { throw new IllegalStateException(\"Empty VAR node.\"); } while (c.getFirstChild() != c.getLastChild()) {"
      },
      {
        "txt": "Node name = c.getFirstChild(); c.removeChild(name); Node newVar = new Node( Token.VAR, name, n.getLineno(), n.getCharno()); n.addChildBefore(newVar, c); reportCodeChange(\"VAR with multiple children\"); } } } }"
      },
      {
        "txt": "private void moveNamedFunctions(Node functionBody) { Preconditions.checkState( functionBody.getParent().getType() == Token.FUNCTION); Node previous = null; Node current = functionBody.getFirstChild(); while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous;"
      },
      {
        "txt": "while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous); insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\"Move function declaration not at top of function\"); } else { previous = current; }"
      },
      {
        "txt": "current = next; } } private Node addToFront(Node parent, Node newChild, Node after) { if (after == null) { parent.addChildToFront(newChild); } else { parent.addChildAfter(newChild, after); } return newChild;"
      },
      {
        "txt": "} } private void removeDuplicateDeclarations(Node root) { Callback tickler = new ScopeTicklingCallback(); ScopeCreator scopeCreator = new SyntacticScopeCreator( compiler, new DuplicateDeclarationHandler()); NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); t.traverse(root); } private final class DuplicateDeclarationHandler implements"
      },
      {
        "txt": "@Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { <extra_id_0> replaceVarWithAssignment(n, parent, gramps); } } private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { if (n.hasChildren()) { parent.removeChild(n);"
      },
      {
        "txt": "if (n.hasChildren()) { parent.removeChild(n); Node value = n.getFirstChild(); n.removeChild(value); Node replacement = new Node(Token.ASSIGN, n, value); gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement)); } else { if (NodeUtil.isStatementBlock(gramps)) { gramps.removeChild(parent); } else if (gramps.getType() == Token.FOR) {"
      },
      {
        "txt": "parent.removeChild(n); gramps.replaceChild(parent, n); } else { Preconditions.checkState(gramps.getType() == Token.LABEL); gramps.replaceChild(parent, new Node(Token.EMPTY)); } } reportCodeChange(\"Duplicate VAR declaration\"); } }"
      },
      {
        "txt": "private final class ScopeTicklingCallback implements NodeTraversal.ScopedCallback { @Override public void enterScope(NodeTraversal t) { t.getScope(); } @Override public void exitScope(NodeTraversal t) { } @Override"
      },
      {
        "txt": "public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { } }"
      }
    ]
  }
]