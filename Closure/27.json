[
  {
    "id": 255,
    "file_path": "src/com/google/javascript/rhino/IR.java",
    "start-bug-line": 111,
    "end-bug-line": 111,
    "bug": "",
    "fix": "private static Node blockUnchecked(Node stmt) { return new Node(Token.BLOCK, stmt); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino; import com.google.common.base.Preconditions; import java.util.List; public class IR { private IR() {} public static Node empty() { return new Node(Token.EMPTY);"
      },
      {
        "txt": "} public static Node function(Node name, Node params, Node body) { Preconditions.checkState(name.isName()); Preconditions.checkState(params.isParamList()); Preconditions.checkState(body.isBlock()); return new Node(Token.FUNCTION, name, params, body); } public static Node paramList() { return new Node(Token.PARAM_LIST); }"
      },
      {
        "txt": "public static Node paramList(Node param) { Preconditions.checkState(param.isName()); return new Node(Token.PARAM_LIST, param); } public static Node paramList(Node ... params) { Node paramList = paramList(); for (Node param : params) { Preconditions.checkState(param.isName()); paramList.addChildToBack(param); }"
      },
      {
        "txt": "return paramList; } public static Node paramList(List<Node> params) { Node paramList = paramList(); for (Node param : params) { Preconditions.checkState(param.isName()); paramList.addChildToBack(param); } return paramList; }"
      },
      {
        "txt": "public static Node block() { Node block = new Node(Token.BLOCK); return block; } public static Node block(Node stmt) { Preconditions.checkState(mayBeStatement(stmt)); Node block = new Node(Token.BLOCK, stmt); return block; } public static Node block(Node ... stmts) {"
      },
      {
        "txt": "for (Node stmt : stmts) { Preconditions.checkState(mayBeStatement(stmt)); block.addChildToBack(stmt); } return block; } <extra_id_0> public static Node script(Node ... stmts) { Node block = new Node(Token.SCRIPT); for (Node stmt : stmts) { Preconditions.checkState(mayBeStatement(stmt)); block.addChildToBack(stmt); }"
      },
      {
        "txt": "block.addChildToBack(stmt); } return block; } public static Node var(Node name, Node value) { Preconditions.checkState(name.isName() && !name.hasChildren()); Preconditions.checkState(mayBeExpression(value)); name.addChildToFront(value); return var(name); }"
      },
      {
        "txt": "public static Node var(Node name) { Preconditions.checkState(name.isName()); return new Node(Token.VAR, name); } public static Node returnNode() { return new Node(Token.RETURN); } public static Node returnNode(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.RETURN, expr);"
      },
      {
        "txt": "} public static Node throwNode(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.THROW, expr); } public static Node exprResult(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.EXPR_RESULT, expr); } public static Node ifNode(Node cond, Node then) {"
      },
      {
        "txt": "Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(then.isBlock()); return new Node(Token.IF, cond, then); } public static Node ifNode(Node cond, Node then, Node elseNode) { Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(then.isBlock()); Preconditions.checkState(elseNode.isBlock()); return new Node(Token.IF, cond, then, elseNode); }"
      },
      {
        "txt": "public static Node doNode(Node body, Node cond) { Preconditions.checkState(body.isBlock()); Preconditions.checkState(mayBeExpression(cond)); return new Node(Token.DO, body, cond); } public static Node forIn(Node target, Node cond, Node body) { Preconditions.checkState(target.isVar() || mayBeExpression(target)); Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(body.isBlock()); return new Node(Token.FOR, target, cond, body);"
      },
      {
        "txt": "} public static Node forNode(Node init, Node cond, Node incr, Node body) { Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init)); Preconditions.checkState(mayBeExpressionOrEmpty(cond)); Preconditions.checkState(mayBeExpressionOrEmpty(incr)); Preconditions.checkState(body.isBlock()); return new Node(Token.FOR, init, cond, incr, body); } public static Node switchNode(Node cond, Node ... cases) { Preconditions.checkState(mayBeExpression(cond));"
      },
      {
        "txt": "Node switchNode = new Node(Token.SWITCH, cond); for (Node caseNode : cases) { Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase()); switchNode.addChildToBack(caseNode); } return switchNode; } public static Node caseNode(Node expr, Node body) { Preconditions.checkState(mayBeExpression(expr)); Preconditions.checkState(body.isBlock());"
      },
      {
        "txt": "body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); return new Node(Token.CASE, expr, body); } public static Node defaultCase(Node body) { Preconditions.checkState(body.isBlock()); body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); return new Node(Token.DEFAULT_CASE, body); } public static Node label(Node name, Node stmt) { Preconditions.checkState(name.isLabelName());"
      },
      {
        "txt": "Preconditions.checkState(mayBeStatement(stmt)); Node block = new Node(Token.LABEL, name, stmt); return block; } public static Node labelName(String name) { Preconditions.checkState(!name.isEmpty()); return Node.newString(Token.LABEL_NAME, name); } public static Node tryFinally(Node tryBody, Node finallyBody) { Preconditions.checkState(tryBody.isLabelName());"
      },
      {
        "txt": "Preconditions.checkState(finallyBody.isLabelName()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); } public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); Node catchBody = block(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); }"
      },
      {
        "txt": "public static Node tryCatchFinally( Node tryBody, Node catchNode, Node finallyBody) { Preconditions.checkState(finallyBody.isBlock()); Node tryNode = tryCatch(tryBody, catchNode); tryNode.addChildToBack(finallyBody); return tryNode; } public static Node catchNode(Node expr, Node body) { Preconditions.checkState(expr.isName()); Preconditions.checkState(body.isBlock());"
      },
      {
        "txt": "return new Node(Token.CATCH, expr, body); } public static Node breakNode() { return new Node(Token.BREAK); } public static Node breakNode(Node name) { Preconditions.checkState(name.isLabelName()); return new Node(Token.BREAK, name); } public static Node continueNode() {"
      },
      {
        "txt": "return new Node(Token.CONTINUE); } public static Node continueNode(Node name) { Preconditions.checkState(name.isLabelName()); return new Node(Token.CONTINUE, name); } public static Node call(Node target, Node ... args) { Node call = new Node(Token.CALL, target); for (Node arg : args) { Preconditions.checkState(mayBeExpression(arg));"
      },
      {
        "txt": "call.addChildToBack(arg); } return call; } public static Node newNode(Node target, Node ... args) { Node newcall = new Node(Token.NEW, target); for (Node arg : args) { Preconditions.checkState(mayBeExpression(arg)); newcall.addChildToBack(arg); }"
      },
      {
        "txt": "return newcall; } public static Node name(String name) { return Node.newString(Token.NAME, name); } public static Node getprop(Node target, Node prop) { Preconditions.checkState(mayBeExpression(target)); Preconditions.checkState(prop.isString()); return new Node(Token.GETPROP, target, prop); }"
      },
      {
        "txt": "public static Node getelem(Node target, Node elem) { Preconditions.checkState(mayBeExpression(target)); Preconditions.checkState(mayBeExpression(elem)); return new Node(Token.GETELEM, target, elem); } public static Node assign(Node target, Node expr) { Preconditions.checkState(isAssignmentTarget(target)); Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.ASSIGN, target, expr); }"
      },
      {
        "txt": "public static Node hook(Node cond, Node trueval, Node falseval) { Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(mayBeExpression(trueval)); Preconditions.checkState(mayBeExpression(falseval)); return new Node(Token.HOOK, cond, trueval, falseval); } public static Node comma(Node expr1, Node expr2) { return binaryOp(Token.COMMA, expr1, expr2); } public static Node and(Node expr1, Node expr2) {"
      },
      {
        "txt": "return binaryOp(Token.AND, expr1, expr2); } public static Node or(Node expr1, Node expr2) { return binaryOp(Token.OR, expr1, expr2); } public static Node not(Node expr1) { return unaryOp(Token.NOT, expr1); } public static Node eq(Node expr1, Node expr2) { return binaryOp(Token.EQ, expr1, expr2);"
      },
      {
        "txt": "} public static Node sheq(Node expr1, Node expr2) { return binaryOp(Token.SHEQ, expr1, expr2); } public static Node voidNode(Node expr1) { return unaryOp(Token.VOID, expr1); } public static Node neg(Node expr1) { return unaryOp(Token.NEG, expr1); }"
      },
      {
        "txt": "public static Node pos(Node expr1) { return unaryOp(Token.POS, expr1); } public static Node add(Node expr1, Node expr2) { return binaryOp(Token.ADD, expr1, expr2); } public static Node sub(Node expr1, Node expr2) { return binaryOp(Token.SUB, expr1, expr2); } public static Node objectlit(Node ... propdefs) {"
      },
      {
        "txt": "Node objectlit = new Node(Token.OBJECTLIT); for (Node propdef : propdefs) { Preconditions.checkState( propdef.isStringKey() || propdef.isGetterDef() || propdef.isSetterDef()); Preconditions.checkState(propdef.hasOneChild()); objectlit.addChildToBack(propdef); } return objectlit; }"
      },
      {
        "txt": "public static Node propdef(Node string, Node value) { Preconditions.checkState(string.isStringKey()); Preconditions.checkState(!string.hasChildren()); Preconditions.checkState(mayBeExpression(value)); string.addChildToFront(value); return string; } public static Node arraylit(Node ... exprs) { Node arraylit = new Node(Token.ARRAYLIT); for (Node expr : exprs) {"
      },
      {
        "txt": "Preconditions.checkState(mayBeExpressionOrEmpty(expr)); arraylit.addChildToBack(expr); } return arraylit; } public static Node regexp(Node expr) { Preconditions.checkState(expr.isString()); return new Node(Token.REGEXP, expr); } public static Node regexp(Node expr, Node flags) {"
      },
      {
        "txt": "Preconditions.checkState(expr.isString()); Preconditions.checkState(flags.isString()); return new Node(Token.REGEXP, expr, flags); } public static Node string(String s) { return Node.newString(s); } public static Node stringKey(String s) { return Node.newString(Token.STRING_KEY, s); }"
      },
      {
        "txt": "public static Node number(double d) { return Node.newNumber(d); } public static Node thisNode() { return new Node(Token.THIS); } public static Node trueNode() { return new Node(Token.TRUE); } public static Node falseNode() {"
      },
      {
        "txt": "return new Node(Token.FALSE); } public static Node nullNode() { return new Node(Token.NULL); } private static Node binaryOp(int token, Node expr1, Node expr2) { Preconditions.checkState(mayBeExpression(expr1)); Preconditions.checkState(mayBeExpression(expr2)); return new Node(token, expr1, expr2); }"
      },
      {
        "txt": "private static Node unaryOp(int token, Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(token, expr); } private static boolean mayBeExpressionOrEmpty(Node n) { return n.isEmpty() || mayBeExpression(n); } private static boolean isAssignmentTarget(Node n) { return n.isName() || n.isGetProp() || n.isGetElem(); }"
      },
      {
        "txt": "private static boolean mayBeStatement(Node n) { switch (n.getType()) { case Token.EMPTY: case Token.FUNCTION: return true; case Token.BLOCK: case Token.BREAK: case Token.CONST: case Token.CONTINUE: case Token.DEBUGGER:"
      },
      {
        "txt": "case Token.DO: case Token.EXPR_RESULT: case Token.FOR: case Token.IF: case Token.LABEL: case Token.RETURN: case Token.SWITCH: case Token.THROW: case Token.TRY: case Token.VAR:"
      },
      {
        "txt": "case Token.WHILE: case Token.WITH: return true; default: return false; } } private static boolean mayBeExpression(Node n) { switch (n.getType()) { case Token.FUNCTION:"
      },
      {
        "txt": "return true; case Token.ADD: case Token.AND: case Token.ARRAYLIT: case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH:"
      },
      {
        "txt": "case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.BITAND: case Token.BITOR: case Token.BITNOT: case Token.BITXOR:"
      },
      {
        "txt": "case Token.CALL: case Token.COMMA: case Token.DEC: case Token.DELPROP: case Token.DIV: case Token.EQ: case Token.FALSE: case Token.GE: case Token.GETPROP: case Token.GETELEM:"
      },
      {
        "txt": "case Token.GT: case Token.HOOK: case Token.IN: case Token.INC: case Token.INSTANCEOF: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL:"
      },
      {
        "txt": "case Token.NAME: case Token.NE: case Token.NEG: case Token.NEW: case Token.NOT: case Token.NUMBER: case Token.NULL: case Token.OBJECTLIT: case Token.OR: case Token.POS:"
      },
      {
        "txt": "case Token.REGEXP: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.STRING: case Token.SUB: case Token.THIS: case Token.TYPEOF: case Token.TRUE: case Token.URSH:"
      },
      {
        "txt": "case Token.VOID: return true; default: return false; } }"
      }
    ]
  },
  {
    "id": 256,
    "file_path": "src/com/google/javascript/rhino/IR.java",
    "start-bug-line": 224,
    "end-bug-line": 225,
    "bug": "Preconditions.checkState(tryBody.isLabelName()); Preconditions.checkState(finallyBody.isLabelName());",
    "fix": "Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(finallyBody.isBlock());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino; import com.google.common.base.Preconditions; import java.util.List; public class IR { private IR() {} public static Node empty() { return new Node(Token.EMPTY); } public static Node function(Node name, Node params, Node body) { Preconditions.checkState(name.isName());"
      },
      {
        "txt": "Preconditions.checkState(params.isParamList()); Preconditions.checkState(body.isBlock()); return new Node(Token.FUNCTION, name, params, body); } public static Node paramList() { return new Node(Token.PARAM_LIST); } public static Node paramList(Node param) { Preconditions.checkState(param.isName()); return new Node(Token.PARAM_LIST, param);"
      },
      {
        "txt": "} public static Node paramList(Node ... params) { Node paramList = paramList(); for (Node param : params) { Preconditions.checkState(param.isName()); paramList.addChildToBack(param); } return paramList; } public static Node paramList(List<Node> params) {"
      },
      {
        "txt": "Node paramList = paramList(); for (Node param : params) { Preconditions.checkState(param.isName()); paramList.addChildToBack(param); } return paramList; } public static Node block() { Node block = new Node(Token.BLOCK); return block;"
      },
      {
        "txt": "} public static Node block(Node stmt) { Preconditions.checkState(mayBeStatement(stmt)); Node block = new Node(Token.BLOCK, stmt); return block; } public static Node block(Node ... stmts) { Node block = new Node(Token.BLOCK); for (Node stmt : stmts) { Preconditions.checkState(mayBeStatement(stmt));"
      },
      {
        "txt": "block.addChildToBack(stmt); } return block; } public static Node script(Node ... stmts) { Node block = new Node(Token.SCRIPT); for (Node stmt : stmts) { Preconditions.checkState(mayBeStatement(stmt)); block.addChildToBack(stmt); }"
      },
      {
        "txt": "return block; } public static Node var(Node name, Node value) { Preconditions.checkState(name.isName() && !name.hasChildren()); Preconditions.checkState(mayBeExpression(value)); name.addChildToFront(value); return var(name); } public static Node var(Node name) { Preconditions.checkState(name.isName());"
      },
      {
        "txt": "return new Node(Token.VAR, name); } public static Node returnNode() { return new Node(Token.RETURN); } public static Node returnNode(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.RETURN, expr); } public static Node throwNode(Node expr) {"
      },
      {
        "txt": "Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.THROW, expr); } public static Node exprResult(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.EXPR_RESULT, expr); } public static Node ifNode(Node cond, Node then) { Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(then.isBlock());"
      },
      {
        "txt": "return new Node(Token.IF, cond, then); } public static Node ifNode(Node cond, Node then, Node elseNode) { Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(then.isBlock()); Preconditions.checkState(elseNode.isBlock()); return new Node(Token.IF, cond, then, elseNode); } public static Node doNode(Node body, Node cond) { Preconditions.checkState(body.isBlock());"
      },
      {
        "txt": "Preconditions.checkState(mayBeExpression(cond)); return new Node(Token.DO, body, cond); } public static Node forIn(Node target, Node cond, Node body) { Preconditions.checkState(target.isVar() || mayBeExpression(target)); Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(body.isBlock()); return new Node(Token.FOR, target, cond, body); } public static Node forNode(Node init, Node cond, Node incr, Node body) {"
      },
      {
        "txt": "Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init)); Preconditions.checkState(mayBeExpressionOrEmpty(cond)); Preconditions.checkState(mayBeExpressionOrEmpty(incr)); Preconditions.checkState(body.isBlock()); return new Node(Token.FOR, init, cond, incr, body); } public static Node switchNode(Node cond, Node ... cases) { Preconditions.checkState(mayBeExpression(cond)); Node switchNode = new Node(Token.SWITCH, cond); for (Node caseNode : cases) {"
      },
      {
        "txt": "Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase()); switchNode.addChildToBack(caseNode); } return switchNode; } public static Node caseNode(Node expr, Node body) { Preconditions.checkState(mayBeExpression(expr)); Preconditions.checkState(body.isBlock()); body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); return new Node(Token.CASE, expr, body);"
      },
      {
        "txt": "} public static Node defaultCase(Node body) { Preconditions.checkState(body.isBlock()); body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); return new Node(Token.DEFAULT_CASE, body); } public static Node label(Node name, Node stmt) { Preconditions.checkState(name.isLabelName()); Preconditions.checkState(mayBeStatement(stmt)); Node block = new Node(Token.LABEL, name, stmt);"
      },
      {
        "txt": "} public static Node labelName(String name) { Preconditions.checkState(!name.isEmpty()); return Node.newString(Token.LABEL_NAME, name); } public static Node tryFinally(Node tryBody, Node finallyBody) { <extra_id_0> Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); } public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch());"
      },
      {
        "txt": "Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); Node catchBody = block(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); } public static Node tryCatchFinally( Node tryBody, Node catchNode, Node finallyBody) { Preconditions.checkState(finallyBody.isBlock()); Node tryNode = tryCatch(tryBody, catchNode); tryNode.addChildToBack(finallyBody);"
      },
      {
        "txt": "return tryNode; } public static Node catchNode(Node expr, Node body) { Preconditions.checkState(expr.isName()); Preconditions.checkState(body.isBlock()); return new Node(Token.CATCH, expr, body); } public static Node breakNode() { return new Node(Token.BREAK); }"
      },
      {
        "txt": "public static Node breakNode(Node name) { Preconditions.checkState(name.isLabelName()); return new Node(Token.BREAK, name); } public static Node continueNode() { return new Node(Token.CONTINUE); } public static Node continueNode(Node name) { Preconditions.checkState(name.isLabelName()); return new Node(Token.CONTINUE, name);"
      },
      {
        "txt": "} public static Node call(Node target, Node ... args) { Node call = new Node(Token.CALL, target); for (Node arg : args) { Preconditions.checkState(mayBeExpression(arg)); call.addChildToBack(arg); } return call; } public static Node newNode(Node target, Node ... args) {"
      },
      {
        "txt": "Node newcall = new Node(Token.NEW, target); for (Node arg : args) { Preconditions.checkState(mayBeExpression(arg)); newcall.addChildToBack(arg); } return newcall; } public static Node name(String name) { return Node.newString(Token.NAME, name); }"
      },
      {
        "txt": "public static Node getprop(Node target, Node prop) { Preconditions.checkState(mayBeExpression(target)); Preconditions.checkState(prop.isString()); return new Node(Token.GETPROP, target, prop); } public static Node getelem(Node target, Node elem) { Preconditions.checkState(mayBeExpression(target)); Preconditions.checkState(mayBeExpression(elem)); return new Node(Token.GETELEM, target, elem); }"
      },
      {
        "txt": "public static Node assign(Node target, Node expr) { Preconditions.checkState(isAssignmentTarget(target)); Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.ASSIGN, target, expr); } public static Node hook(Node cond, Node trueval, Node falseval) { Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(mayBeExpression(trueval)); Preconditions.checkState(mayBeExpression(falseval)); return new Node(Token.HOOK, cond, trueval, falseval);"
      },
      {
        "txt": "} public static Node comma(Node expr1, Node expr2) { return binaryOp(Token.COMMA, expr1, expr2); } public static Node and(Node expr1, Node expr2) { return binaryOp(Token.AND, expr1, expr2); } public static Node or(Node expr1, Node expr2) { return binaryOp(Token.OR, expr1, expr2); }"
      },
      {
        "txt": "public static Node not(Node expr1) { return unaryOp(Token.NOT, expr1); } public static Node eq(Node expr1, Node expr2) { return binaryOp(Token.EQ, expr1, expr2); } public static Node sheq(Node expr1, Node expr2) { return binaryOp(Token.SHEQ, expr1, expr2); } public static Node voidNode(Node expr1) {"
      },
      {
        "txt": "return unaryOp(Token.VOID, expr1); } public static Node neg(Node expr1) { return unaryOp(Token.NEG, expr1); } public static Node pos(Node expr1) { return unaryOp(Token.POS, expr1); } public static Node add(Node expr1, Node expr2) { return binaryOp(Token.ADD, expr1, expr2);"
      },
      {
        "txt": "} public static Node sub(Node expr1, Node expr2) { return binaryOp(Token.SUB, expr1, expr2); } public static Node objectlit(Node ... propdefs) { Node objectlit = new Node(Token.OBJECTLIT); for (Node propdef : propdefs) { Preconditions.checkState( propdef.isStringKey() || propdef.isGetterDef() || propdef.isSetterDef());"
      },
      {
        "txt": "Preconditions.checkState(propdef.hasOneChild()); objectlit.addChildToBack(propdef); } return objectlit; } public static Node propdef(Node string, Node value) { Preconditions.checkState(string.isStringKey()); Preconditions.checkState(!string.hasChildren()); Preconditions.checkState(mayBeExpression(value)); string.addChildToFront(value);"
      },
      {
        "txt": "return string; } public static Node arraylit(Node ... exprs) { Node arraylit = new Node(Token.ARRAYLIT); for (Node expr : exprs) { Preconditions.checkState(mayBeExpressionOrEmpty(expr)); arraylit.addChildToBack(expr); } return arraylit; }"
      },
      {
        "txt": "public static Node regexp(Node expr) { Preconditions.checkState(expr.isString()); return new Node(Token.REGEXP, expr); } public static Node regexp(Node expr, Node flags) { Preconditions.checkState(expr.isString()); Preconditions.checkState(flags.isString()); return new Node(Token.REGEXP, expr, flags); } public static Node string(String s) {"
      },
      {
        "txt": "return Node.newString(s); } public static Node stringKey(String s) { return Node.newString(Token.STRING_KEY, s); } public static Node number(double d) { return Node.newNumber(d); } public static Node thisNode() { return new Node(Token.THIS);"
      },
      {
        "txt": "} public static Node trueNode() { return new Node(Token.TRUE); } public static Node falseNode() { return new Node(Token.FALSE); } public static Node nullNode() { return new Node(Token.NULL); }"
      },
      {
        "txt": "private static Node binaryOp(int token, Node expr1, Node expr2) { Preconditions.checkState(mayBeExpression(expr1)); Preconditions.checkState(mayBeExpression(expr2)); return new Node(token, expr1, expr2); } private static Node unaryOp(int token, Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(token, expr); } private static boolean mayBeExpressionOrEmpty(Node n) {"
      },
      {
        "txt": "return n.isEmpty() || mayBeExpression(n); } private static boolean isAssignmentTarget(Node n) { return n.isName() || n.isGetProp() || n.isGetElem(); } private static boolean mayBeStatement(Node n) { switch (n.getType()) { case Token.EMPTY: case Token.FUNCTION: return true;"
      },
      {
        "txt": "case Token.BLOCK: case Token.BREAK: case Token.CONST: case Token.CONTINUE: case Token.DEBUGGER: case Token.DO: case Token.EXPR_RESULT: case Token.FOR: case Token.IF: case Token.LABEL:"
      },
      {
        "txt": "case Token.RETURN: case Token.SWITCH: case Token.THROW: case Token.TRY: case Token.VAR: case Token.WHILE: case Token.WITH: return true; default: return false;"
      },
      {
        "txt": "} } private static boolean mayBeExpression(Node n) { switch (n.getType()) { case Token.FUNCTION: return true; case Token.ADD: case Token.AND: case Token.ARRAYLIT: case Token.ASSIGN:"
      },
      {
        "txt": "case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV:"
      },
      {
        "txt": "case Token.ASSIGN_MOD: case Token.BITAND: case Token.BITOR: case Token.BITNOT: case Token.BITXOR: case Token.CALL: case Token.COMMA: case Token.DEC: case Token.DELPROP: case Token.DIV:"
      },
      {
        "txt": "case Token.EQ: case Token.FALSE: case Token.GE: case Token.GETPROP: case Token.GETELEM: case Token.GT: case Token.HOOK: case Token.IN: case Token.INC: case Token.INSTANCEOF:"
      },
      {
        "txt": "case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NAME: case Token.NE: case Token.NEG: case Token.NEW: case Token.NOT:"
      },
      {
        "txt": "case Token.NUMBER: case Token.NULL: case Token.OBJECTLIT: case Token.OR: case Token.POS: case Token.REGEXP: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.STRING:"
      },
      {
        "txt": "case Token.SUB: case Token.THIS: case Token.TYPEOF: case Token.TRUE: case Token.URSH: case Token.VOID: return true; default: return false; }"
      }
    ]
  },
  {
    "id": 257,
    "file_path": "src/com/google/javascript/rhino/IR.java",
    "start-bug-line": 233,
    "end-bug-line": 233,
    "bug": "Node catchBody = block(catchNode).copyInformationFrom(catchNode);",
    "fix": "Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino; import com.google.common.base.Preconditions; import java.util.List; public class IR { private IR() {} public static Node empty() { return new Node(Token.EMPTY); }"
      },
      {
        "txt": "public static Node function(Node name, Node params, Node body) { Preconditions.checkState(name.isName()); Preconditions.checkState(params.isParamList()); Preconditions.checkState(body.isBlock()); return new Node(Token.FUNCTION, name, params, body); } public static Node paramList() { return new Node(Token.PARAM_LIST); } public static Node paramList(Node param) {"
      },
      {
        "txt": "Preconditions.checkState(param.isName()); return new Node(Token.PARAM_LIST, param); } public static Node paramList(Node ... params) { Node paramList = paramList(); for (Node param : params) { Preconditions.checkState(param.isName()); paramList.addChildToBack(param); } return paramList;"
      },
      {
        "txt": "} public static Node paramList(List<Node> params) { Node paramList = paramList(); for (Node param : params) { Preconditions.checkState(param.isName()); paramList.addChildToBack(param); } return paramList; } public static Node block() {"
      },
      {
        "txt": "Node block = new Node(Token.BLOCK); return block; } public static Node block(Node stmt) { Preconditions.checkState(mayBeStatement(stmt)); Node block = new Node(Token.BLOCK, stmt); return block; } public static Node block(Node ... stmts) { Node block = new Node(Token.BLOCK);"
      },
      {
        "txt": "for (Node stmt : stmts) { Preconditions.checkState(mayBeStatement(stmt)); block.addChildToBack(stmt); } return block; } public static Node script(Node ... stmts) { Node block = new Node(Token.SCRIPT); for (Node stmt : stmts) { Preconditions.checkState(mayBeStatement(stmt));"
      },
      {
        "txt": "block.addChildToBack(stmt); } return block; } public static Node var(Node name, Node value) { Preconditions.checkState(name.isName() && !name.hasChildren()); Preconditions.checkState(mayBeExpression(value)); name.addChildToFront(value); return var(name); }"
      },
      {
        "txt": "public static Node var(Node name) { Preconditions.checkState(name.isName()); return new Node(Token.VAR, name); } public static Node returnNode() { return new Node(Token.RETURN); } public static Node returnNode(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.RETURN, expr);"
      },
      {
        "txt": "} public static Node throwNode(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.THROW, expr); } public static Node exprResult(Node expr) { Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.EXPR_RESULT, expr); } public static Node ifNode(Node cond, Node then) {"
      },
      {
        "txt": "Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(then.isBlock()); return new Node(Token.IF, cond, then); } public static Node ifNode(Node cond, Node then, Node elseNode) { Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(then.isBlock()); Preconditions.checkState(elseNode.isBlock()); return new Node(Token.IF, cond, then, elseNode); }"
      },
      {
        "txt": "public static Node doNode(Node body, Node cond) { Preconditions.checkState(body.isBlock()); Preconditions.checkState(mayBeExpression(cond)); return new Node(Token.DO, body, cond); } public static Node forIn(Node target, Node cond, Node body) { Preconditions.checkState(target.isVar() || mayBeExpression(target)); Preconditions.checkState(mayBeExpression(cond)); Preconditions.checkState(body.isBlock()); return new Node(Token.FOR, target, cond, body);"
      },
      {
        "txt": "} public static Node forNode(Node init, Node cond, Node incr, Node body) { Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init)); Preconditions.checkState(mayBeExpressionOrEmpty(cond)); Preconditions.checkState(mayBeExpressionOrEmpty(incr)); Preconditions.checkState(body.isBlock()); return new Node(Token.FOR, init, cond, incr, body); } public static Node switchNode(Node cond, Node ... cases) { Preconditions.checkState(mayBeExpression(cond));"
      },
      {
        "txt": "Node switchNode = new Node(Token.SWITCH, cond); for (Node caseNode : cases) { Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase()); switchNode.addChildToBack(caseNode); } return switchNode; } public static Node caseNode(Node expr, Node body) { Preconditions.checkState(mayBeExpression(expr)); Preconditions.checkState(body.isBlock());"
      },
      {
        "txt": "body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); return new Node(Token.CASE, expr, body); } public static Node defaultCase(Node body) { Preconditions.checkState(body.isBlock()); body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); return new Node(Token.DEFAULT_CASE, body); } public static Node label(Node name, Node stmt) { Preconditions.checkState(name.isLabelName());"
      },
      {
        "txt": "Preconditions.checkState(mayBeStatement(stmt)); Node block = new Node(Token.LABEL, name, stmt); return block; } public static Node labelName(String name) { Preconditions.checkState(!name.isEmpty()); return Node.newString(Token.LABEL_NAME, name); } public static Node tryFinally(Node tryBody, Node finallyBody) { Preconditions.checkState(tryBody.isLabelName());"
      },
      {
        "txt": "Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); } public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); <extra_id_0> return new Node(Token.TRY, tryBody, catchBody); } public static Node tryCatchFinally( Node tryBody, Node catchNode, Node finallyBody) { Preconditions.checkState(finallyBody.isBlock()); Node tryNode = tryCatch(tryBody, catchNode);"
      },
      {
        "txt": "Preconditions.checkState(finallyBody.isBlock()); Node tryNode = tryCatch(tryBody, catchNode); tryNode.addChildToBack(finallyBody); return tryNode; } public static Node catchNode(Node expr, Node body) { Preconditions.checkState(expr.isName()); Preconditions.checkState(body.isBlock()); return new Node(Token.CATCH, expr, body); }"
      },
      {
        "txt": "public static Node breakNode() { return new Node(Token.BREAK); } public static Node breakNode(Node name) { Preconditions.checkState(name.isLabelName()); return new Node(Token.BREAK, name); } public static Node continueNode() { return new Node(Token.CONTINUE); }"
      },
      {
        "txt": "public static Node continueNode(Node name) { Preconditions.checkState(name.isLabelName()); return new Node(Token.CONTINUE, name); } public static Node call(Node target, Node ... args) { Node call = new Node(Token.CALL, target); for (Node arg : args) { Preconditions.checkState(mayBeExpression(arg)); call.addChildToBack(arg); }"
      },
      {
        "txt": "return call; } public static Node newNode(Node target, Node ... args) { Node newcall = new Node(Token.NEW, target); for (Node arg : args) { Preconditions.checkState(mayBeExpression(arg)); newcall.addChildToBack(arg); } return newcall; }"
      },
      {
        "txt": "public static Node name(String name) { return Node.newString(Token.NAME, name); } public static Node getprop(Node target, Node prop) { Preconditions.checkState(mayBeExpression(target)); Preconditions.checkState(prop.isString()); return new Node(Token.GETPROP, target, prop); } public static Node getelem(Node target, Node elem) { Preconditions.checkState(mayBeExpression(target));"
      },
      {
        "txt": "Preconditions.checkState(mayBeExpression(elem)); return new Node(Token.GETELEM, target, elem); } public static Node assign(Node target, Node expr) { Preconditions.checkState(isAssignmentTarget(target)); Preconditions.checkState(mayBeExpression(expr)); return new Node(Token.ASSIGN, target, expr); } public static Node hook(Node cond, Node trueval, Node falseval) { Preconditions.checkState(mayBeExpression(cond));"
      },
      {
        "txt": "Preconditions.checkState(mayBeExpression(trueval)); Preconditions.checkState(mayBeExpression(falseval)); return new Node(Token.HOOK, cond, trueval, falseval); } public static Node comma(Node expr1, Node expr2) { return binaryOp(Token.COMMA, expr1, expr2); } public static Node and(Node expr1, Node expr2) { return binaryOp(Token.AND, expr1, expr2); }"
      },
      {
        "txt": "public static Node or(Node expr1, Node expr2) { return binaryOp(Token.OR, expr1, expr2); } public static Node not(Node expr1) { return unaryOp(Token.NOT, expr1); } public static Node eq(Node expr1, Node expr2) { return binaryOp(Token.EQ, expr1, expr2); } public static Node sheq(Node expr1, Node expr2) {"
      },
      {
        "txt": "return binaryOp(Token.SHEQ, expr1, expr2); } public static Node voidNode(Node expr1) { return unaryOp(Token.VOID, expr1); } public static Node neg(Node expr1) { return unaryOp(Token.NEG, expr1); } public static Node pos(Node expr1) { return unaryOp(Token.POS, expr1);"
      },
      {
        "txt": "} public static Node add(Node expr1, Node expr2) { return binaryOp(Token.ADD, expr1, expr2); } public static Node sub(Node expr1, Node expr2) { return binaryOp(Token.SUB, expr1, expr2); } public static Node objectlit(Node ... propdefs) { Node objectlit = new Node(Token.OBJECTLIT); for (Node propdef : propdefs) {"
      },
      {
        "txt": "Preconditions.checkState( propdef.isStringKey() || propdef.isGetterDef() || propdef.isSetterDef()); Preconditions.checkState(propdef.hasOneChild()); objectlit.addChildToBack(propdef); } return objectlit; } public static Node propdef(Node string, Node value) { Preconditions.checkState(string.isStringKey());"
      },
      {
        "txt": "Preconditions.checkState(!string.hasChildren()); Preconditions.checkState(mayBeExpression(value)); string.addChildToFront(value); return string; } public static Node arraylit(Node ... exprs) { Node arraylit = new Node(Token.ARRAYLIT); for (Node expr : exprs) { Preconditions.checkState(mayBeExpressionOrEmpty(expr)); arraylit.addChildToBack(expr);"
      },
      {
        "txt": "} return arraylit; } public static Node regexp(Node expr) { Preconditions.checkState(expr.isString()); return new Node(Token.REGEXP, expr); } public static Node regexp(Node expr, Node flags) { Preconditions.checkState(expr.isString()); Preconditions.checkState(flags.isString());"
      },
      {
        "txt": "return new Node(Token.REGEXP, expr, flags); } public static Node string(String s) { return Node.newString(s); } public static Node stringKey(String s) { return Node.newString(Token.STRING_KEY, s); } public static Node number(double d) { return Node.newNumber(d);"
      },
      {
        "txt": "} public static Node thisNode() { return new Node(Token.THIS); } public static Node trueNode() { return new Node(Token.TRUE); } public static Node falseNode() { return new Node(Token.FALSE); }"
      },
      {
        "txt": "public static Node nullNode() { return new Node(Token.NULL); } private static Node binaryOp(int token, Node expr1, Node expr2) { Preconditions.checkState(mayBeExpression(expr1)); Preconditions.checkState(mayBeExpression(expr2)); return new Node(token, expr1, expr2); } private static Node unaryOp(int token, Node expr) { Preconditions.checkState(mayBeExpression(expr));"
      },
      {
        "txt": "return new Node(token, expr); } private static boolean mayBeExpressionOrEmpty(Node n) { return n.isEmpty() || mayBeExpression(n); } private static boolean isAssignmentTarget(Node n) { return n.isName() || n.isGetProp() || n.isGetElem(); } private static boolean mayBeStatement(Node n) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.EMPTY: case Token.FUNCTION: return true; case Token.BLOCK: case Token.BREAK: case Token.CONST: case Token.CONTINUE: case Token.DEBUGGER: case Token.DO: case Token.EXPR_RESULT:"
      },
      {
        "txt": "case Token.FOR: case Token.IF: case Token.LABEL: case Token.RETURN: case Token.SWITCH: case Token.THROW: case Token.TRY: case Token.VAR: case Token.WHILE: case Token.WITH:"
      },
      {
        "txt": "return true; default: return false; } } private static boolean mayBeExpression(Node n) { switch (n.getType()) { case Token.FUNCTION: return true; case Token.ADD:"
      },
      {
        "txt": "case Token.AND: case Token.ARRAYLIT: case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD:"
      },
      {
        "txt": "case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.BITAND: case Token.BITOR: case Token.BITNOT: case Token.BITXOR: case Token.CALL: case Token.COMMA:"
      },
      {
        "txt": "case Token.DEC: case Token.DELPROP: case Token.DIV: case Token.EQ: case Token.FALSE: case Token.GE: case Token.GETPROP: case Token.GETELEM: case Token.GT: case Token.HOOK:"
      },
      {
        "txt": "case Token.IN: case Token.INC: case Token.INSTANCEOF: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NAME: case Token.NE:"
      },
      {
        "txt": "case Token.NEG: case Token.NEW: case Token.NOT: case Token.NUMBER: case Token.NULL: case Token.OBJECTLIT: case Token.OR: case Token.POS: case Token.REGEXP: case Token.RSH:"
      },
      {
        "txt": "case Token.SHEQ: case Token.SHNE: case Token.STRING: case Token.SUB: case Token.THIS: case Token.TYPEOF: case Token.TRUE: case Token.URSH: case Token.VOID: return true;"
      },
      {
        "txt": "default: return false; } }"
      }
    ]
  }
]