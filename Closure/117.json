[
  {
    "id": 470,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 725,
    "end-bug-line": 725,
    "bug": "",
    "fix": "JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED ="
      },
      {
        "txt": "\"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\"); static final DiagnosticType ILLEGAL_PROPERTY_ACCESS ="
      },
      {
        "txt": "DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH,"
      },
      {
        "txt": "UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); }"
      },
      {
        "txt": "Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } void expectValidTypeofName(NodeTraversal t, Node n, String found) { report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); }"
      },
      {
        "txt": "} void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE);"
      },
      {
        "txt": "} } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes);"
      },
      {
        "txt": "} } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {"
      },
      {
        "txt": "if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; }"
      },
      {
        "txt": "return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type.isUnionType()) { for (JSType alt : type.toMaybeUnionType().getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } }"
      },
      {
        "txt": "return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType);"
      },
      {
        "txt": "} } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) { report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\")); }"
      },
      {
        "txt": "if (objType.isUnknownType()) { expectStringOrNumber(t, indexNode, indexType, \"property access\"); } else { ObjectType dereferenced = objType.dereference(); if (dereferenced != null && dereferenced .getTemplateTypeMap() .hasTemplateKey(typeRegistry.getObjectIndexKey())) { expectCanAssignTo(t, indexNode, indexType, dereferenced .getTemplateTypeMap().getTemplateType(typeRegistry.getObjectIndexKey()), \"restricted index type\");"
      },
      {
        "txt": "} else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } }"
      },
      {
        "txt": "} boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.isSubtype(leftType)) { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true;"
      },
      {
        "txt": "} } mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); return false; } return true; }"
      },
      {
        "txt": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.isSubtype(leftType)) { mismatch(t, n, msg, rightType, leftType); return false; } return true; } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {"
      },
      {
        "txt": "if (!argType.isSubtype(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) {"
      },
      {
        "txt": "if (!overridingType.isSubtype(hiddenType)) { registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()))); } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor();"
      },
      {
        "txt": "ObjectType implicitProto = subObject.getImplicitPrototype(); ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype(); if (declaredSuper != null && declaredSuper.isTemplatizedType()) { declaredSuper = declaredSuper.toMaybeTemplatizedType().getReferencedType(); } if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {"
      },
      {
        "txt": "if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { registerMismatch(superObject, declaredSuper, report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject);"
      },
      {
        "txt": "} } } void expectCanCast(NodeTraversal t, Node n, JSType castType, JSType type) { if (!type.canCastTo(castType)) { registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, type.toString(), castType.toString()))); } } Var expectUndeclaredVariable(String sourceName, CompilerInput input,"
      },
      {
        "txt": "Node n, Node parent, Var var, String variableName, JSType newType) { Var newVar = var; boolean allowDupe = false; if (n.isGetProp() || NodeUtil.isObjectLitKey(n)) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo(); } allowDupe ="
      },
      {
        "txt": "info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) { Scope s = var.getScope(); s.undeclare(var);"
      },
      {
        "txt": "newVar = s.declare(variableName, n, varType, input, false); n.setJSType(varType); if (parent.isVar()) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.isFunction()); parent.setJSType(varType); }"
      },
      {
        "txt": "} else { if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); } }"
      },
      {
        "txt": "} return newVar; } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) {"
      },
      {
        "txt": "expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { StaticSlot<JSType> propSlot = instance.getSlot(prop); if (propSlot == null) { String sourceName = n.getSourceFileName();"
      },
      {
        "txt": "sourceName = sourceName == null ? \"\" : sourceName; registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()))); } else { Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode(); propNode = propNode == null ? n : propNode; JSType found = propSlot.getType();"
      },
      {
        "txt": "found = found.restrictByNotNullOrUndefined(); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); TemplateTypeMap typeMap = implementedInterface.getTemplateTypeMap(); if (!typeMap.isEmpty()) { TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( typeRegistry, typeMap); required = required.visit(replacer); } required = required.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (!found.isSubtype(required)) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); registerMismatch(found, required, report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()))); } } }"
      },
      {
        "txt": "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) {"
      },
      {
        "txt": "registerMismatch(found, required, report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); } private void registerMismatch(JSType found, JSType required, JSError error) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.isSubtype(required) || required.isSubtype(found)) { return; }"
      },
      {
        "txt": "mismatches.add(new TypeMismatch(found, required, error)); if (found.isFunctionType() && required.isFunctionType()) { FunctionType fnTypeA = found.toMaybeFunctionType(); FunctionType fnTypeB = required.toMaybeFunctionType(); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error);"
      },
      {
        "txt": "} registerIfMismatch( fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); } } private void registerIfMismatch( JSType found, JSType required, JSError error) { if (found != null && required != null && !found.isSubtype(required)) { registerMismatch(found, required, error);"
      },
      {
        "txt": "} private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { <extra_id_0> if (n.isGetProp()) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {"
      },
      {
        "txt": "if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { objectType = FunctionType.getTopDefiningInterface( objectType, propName); } else { while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } } if (objectType != null &&"
      },
      {
        "txt": "(objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } } } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) {"
      },
      {
        "txt": "type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) {"
      },
      {
        "txt": "return qualifiedName; } else if (type.isFunctionType()) { return \"function\"; } else { return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) {"
      },
      {
        "txt": "return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } private JSError report(JSError error) { if (shouldReport) {"
      },
      {
        "txt": "compiler.report(error); } return error; } static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) { this.typeA = a;"
      },
      {
        "txt": "this.typeB = b; this.src = src; } @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB));"
      },
      {
        "txt": "} return false; } @Override public int hashCode() { return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 471,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 727,
    "end-bug-line": 727,
    "bug": "",
    "fix": "if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED ="
      },
      {
        "txt": "\"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\"); static final DiagnosticType ILLEGAL_PROPERTY_ACCESS ="
      },
      {
        "txt": "DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH,"
      },
      {
        "txt": "UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); }"
      },
      {
        "txt": "Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } void expectValidTypeofName(NodeTraversal t, Node n, String found) { report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); }"
      },
      {
        "txt": "} void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE);"
      },
      {
        "txt": "} } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes);"
      },
      {
        "txt": "} } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {"
      },
      {
        "txt": "if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; }"
      },
      {
        "txt": "return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type.isUnionType()) { for (JSType alt : type.toMaybeUnionType().getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } }"
      },
      {
        "txt": "return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType);"
      },
      {
        "txt": "} } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) { report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\")); }"
      },
      {
        "txt": "if (objType.isUnknownType()) { expectStringOrNumber(t, indexNode, indexType, \"property access\"); } else { ObjectType dereferenced = objType.dereference(); if (dereferenced != null && dereferenced .getTemplateTypeMap() .hasTemplateKey(typeRegistry.getObjectIndexKey())) { expectCanAssignTo(t, indexNode, indexType, dereferenced .getTemplateTypeMap().getTemplateType(typeRegistry.getObjectIndexKey()), \"restricted index type\");"
      },
      {
        "txt": "} else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } }"
      },
      {
        "txt": "} boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.isSubtype(leftType)) { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true;"
      },
      {
        "txt": "} } mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); return false; } return true; }"
      },
      {
        "txt": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.isSubtype(leftType)) { mismatch(t, n, msg, rightType, leftType); return false; } return true; } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {"
      },
      {
        "txt": "if (!argType.isSubtype(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) {"
      },
      {
        "txt": "if (!overridingType.isSubtype(hiddenType)) { registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()))); } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor();"
      },
      {
        "txt": "ObjectType implicitProto = subObject.getImplicitPrototype(); ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype(); if (declaredSuper != null && declaredSuper.isTemplatizedType()) { declaredSuper = declaredSuper.toMaybeTemplatizedType().getReferencedType(); } if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {"
      },
      {
        "txt": "if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { registerMismatch(superObject, declaredSuper, report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject);"
      },
      {
        "txt": "} } } void expectCanCast(NodeTraversal t, Node n, JSType castType, JSType type) { if (!type.canCastTo(castType)) { registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, type.toString(), castType.toString()))); } } Var expectUndeclaredVariable(String sourceName, CompilerInput input,"
      },
      {
        "txt": "Node n, Node parent, Var var, String variableName, JSType newType) { Var newVar = var; boolean allowDupe = false; if (n.isGetProp() || NodeUtil.isObjectLitKey(n)) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo(); } allowDupe ="
      },
      {
        "txt": "info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) { Scope s = var.getScope(); s.undeclare(var);"
      },
      {
        "txt": "newVar = s.declare(variableName, n, varType, input, false); n.setJSType(varType); if (parent.isVar()) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.isFunction()); parent.setJSType(varType); }"
      },
      {
        "txt": "} else { if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); } }"
      },
      {
        "txt": "} return newVar; } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) {"
      },
      {
        "txt": "expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { StaticSlot<JSType> propSlot = instance.getSlot(prop); if (propSlot == null) { String sourceName = n.getSourceFileName();"
      },
      {
        "txt": "sourceName = sourceName == null ? \"\" : sourceName; registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()))); } else { Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode(); propNode = propNode == null ? n : propNode; JSType found = propSlot.getType();"
      },
      {
        "txt": "found = found.restrictByNotNullOrUndefined(); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); TemplateTypeMap typeMap = implementedInterface.getTemplateTypeMap(); if (!typeMap.isEmpty()) { TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( typeRegistry, typeMap); required = required.visit(replacer); } required = required.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (!found.isSubtype(required)) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); registerMismatch(found, required, report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()))); } } }"
      },
      {
        "txt": "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) {"
      },
      {
        "txt": "registerMismatch(found, required, report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); } private void registerMismatch(JSType found, JSType required, JSError error) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.isSubtype(required) || required.isSubtype(found)) { return; }"
      },
      {
        "txt": "mismatches.add(new TypeMismatch(found, required, error)); if (found.isFunctionType() && required.isFunctionType()) { FunctionType fnTypeA = found.toMaybeFunctionType(); FunctionType fnTypeB = required.toMaybeFunctionType(); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error);"
      },
      {
        "txt": "} registerIfMismatch( fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); } } private void registerIfMismatch( JSType found, JSType required, JSError error) { if (found != null && required != null && !found.isSubtype(required)) { registerMismatch(found, required, error);"
      },
      {
        "txt": "} private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { <extra_id_0> if (n.isGetProp()) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {"
      },
      {
        "txt": "if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { objectType = FunctionType.getTopDefiningInterface( objectType, propName); } else { while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } } if (objectType != null &&"
      },
      {
        "txt": "(objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } } } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) {"
      },
      {
        "txt": "type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) {"
      },
      {
        "txt": "return qualifiedName; } else if (type.isFunctionType()) { return \"function\"; } else { return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) {"
      },
      {
        "txt": "return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } private JSError report(JSError error) { if (shouldReport) {"
      },
      {
        "txt": "compiler.report(error); } return error; } static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) { this.typeA = a;"
      },
      {
        "txt": "this.typeB = b; this.src = src; } @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB));"
      },
      {
        "txt": "} return false; } @Override public int hashCode() { return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 472,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 756,
    "end-bug-line": 767,
    "bug": "JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnknownType; import java.text.MessageFormat;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED ="
      },
      {
        "txt": "\"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_TYPEOF_VALUE = DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\"); static final DiagnosticType ILLEGAL_PROPERTY_ACCESS ="
      },
      {
        "txt": "DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\", \"Cannot do {0} access on a {1}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH,"
      },
      {
        "txt": "UNKNOWN_TYPEOF_VALUE, ILLEGAL_PROPERTY_ACCESS); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); }"
      },
      {
        "txt": "Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } void expectValidTypeofName(NodeTraversal t, Node n, String found) { report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); }"
      },
      {
        "txt": "} void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE);"
      },
      {
        "txt": "} } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes);"
      },
      {
        "txt": "} } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {"
      },
      {
        "txt": "if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; }"
      },
      {
        "txt": "return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type.isUnionType()) { for (JSType alt : type.toMaybeUnionType().getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } }"
      },
      {
        "txt": "return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType);"
      },
      {
        "txt": "} } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) { report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\")); }"
      },
      {
        "txt": "if (objType.isUnknownType()) { expectStringOrNumber(t, indexNode, indexType, \"property access\"); } else { ObjectType dereferenced = objType.dereference(); if (dereferenced != null && dereferenced .getTemplateTypeMap() .hasTemplateKey(typeRegistry.getObjectIndexKey())) { expectCanAssignTo(t, indexNode, indexType, dereferenced .getTemplateTypeMap().getTemplateType(typeRegistry.getObjectIndexKey()), \"restricted index type\");"
      },
      {
        "txt": "} else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } }"
      },
      {
        "txt": "} boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.isSubtype(leftType)) { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true;"
      },
      {
        "txt": "} } mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); return false; } return true; }"
      },
      {
        "txt": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.isSubtype(leftType)) { mismatch(t, n, msg, rightType, leftType); return false; } return true; } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {"
      },
      {
        "txt": "if (!argType.isSubtype(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) {"
      },
      {
        "txt": "if (!overridingType.isSubtype(hiddenType)) { registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()))); } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor();"
      },
      {
        "txt": "ObjectType implicitProto = subObject.getImplicitPrototype(); ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype(); if (declaredSuper != null && declaredSuper.isTemplatizedType()) { declaredSuper = declaredSuper.toMaybeTemplatizedType().getReferencedType(); } if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {"
      },
      {
        "txt": "if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { registerMismatch(superObject, declaredSuper, report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject);"
      },
      {
        "txt": "} } } void expectCanCast(NodeTraversal t, Node n, JSType castType, JSType type) { if (!type.canCastTo(castType)) { registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, type.toString(), castType.toString()))); } } Var expectUndeclaredVariable(String sourceName, CompilerInput input,"
      },
      {
        "txt": "Node n, Node parent, Var var, String variableName, JSType newType) { Var newVar = var; boolean allowDupe = false; if (n.isGetProp() || NodeUtil.isObjectLitKey(n)) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo(); } allowDupe ="
      },
      {
        "txt": "info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) { Scope s = var.getScope(); s.undeclare(var);"
      },
      {
        "txt": "newVar = s.declare(variableName, n, varType, input, false); n.setJSType(varType); if (parent.isVar()) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.isFunction()); parent.setJSType(varType); }"
      },
      {
        "txt": "} else { if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); } }"
      },
      {
        "txt": "} return newVar; } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) {"
      },
      {
        "txt": "expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { StaticSlot<JSType> propSlot = instance.getSlot(prop); if (propSlot == null) { String sourceName = n.getSourceFileName();"
      },
      {
        "txt": "sourceName = sourceName == null ? \"\" : sourceName; registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()))); } else { Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode(); propNode = propNode == null ? n : propNode; JSType found = propSlot.getType();"
      },
      {
        "txt": "found = found.restrictByNotNullOrUndefined(); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); TemplateTypeMap typeMap = implementedInterface.getTemplateTypeMap(); if (!typeMap.isEmpty()) { TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( typeRegistry, typeMap); required = required.visit(replacer); } required = required.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (!found.isSubtype(required)) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); registerMismatch(found, required, report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()))); } } }"
      },
      {
        "txt": "private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) {"
      },
      {
        "txt": "registerMismatch(found, required, report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); } private void registerMismatch(JSType found, JSType required, JSError error) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.isSubtype(required) || required.isSubtype(found)) { return; }"
      },
      {
        "txt": "mismatches.add(new TypeMismatch(found, required, error)); if (found.isFunctionType() && required.isFunctionType()) { FunctionType fnTypeA = found.toMaybeFunctionType(); FunctionType fnTypeB = required.toMaybeFunctionType(); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error);"
      },
      {
        "txt": "} registerIfMismatch( fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); } } private void registerIfMismatch( JSType found, JSType required, JSError error) { if (found != null && required != null && !found.isSubtype(required)) { registerMismatch(found, required, error);"
      },
      {
        "txt": "} } private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { if (n.isGetProp()) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) {"
      },
      {
        "txt": "String propName = n.getLastChild().getString(); if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { objectType = FunctionType.getTopDefiningInterface( objectType, propName); } else { while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } }"
      },
      {
        "txt": "(objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } } } <extra_id_0> String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName; } else if (type.isFunctionType()) { return \"function\"; } else {"
      },
      {
        "txt": "return \"function\"; } else { return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else {"
      },
      {
        "txt": "return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } private JSError report(JSError error) { if (shouldReport) { compiler.report(error); }"
      },
      {
        "txt": "return error; } static class TypeMismatch { final JSType typeA; final JSType typeB; final JSError src; TypeMismatch(JSType a, JSType b, JSError src) { this.typeA = a; this.typeB = b; this.src = src;"
      },
      {
        "txt": "} @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB)); } return false;"
      },
      {
        "txt": "} @Override public int hashCode() { return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  }
]