[
  {
    "id": 362,
    "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
    "start-bug-line": 907,
    "end-bug-line": 908,
    "bug": "int lhType = left.getType(); int rhType = right.getType();",
    "fix": "int lhType = getNormalizedNodeType(left); int rhType = getNormalizedNodeType(right);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.List; import java.util.Locale; class PeepholeFoldConstants extends AbstractPeepholeOptimization { static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error( \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error( \"JSC_NEGATING_A_NON_NUMBER_ERROR\", \"Can't negate non-numeric value: {0}\");"
      },
      {
        "txt": "static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\", \"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error( \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error( \"JSC_FRACTIONAL_BITWISE_OPERAND\", \"Fractional bitwise operand: {0}\");"
      },
      {
        "txt": "private static final double MAX_FOLD_NUMBER = Math.pow(2, 53); private static final Locale ROOT_LOCALE = new Locale(\"\"); @Override Node optimizeSubtree(Node subtree) { switch(subtree.getType()) { case Token.CALL: return tryFoldKnownMethods(subtree); case Token.NEW: return tryFoldCtorCall(subtree); case Token.TYPEOF:"
      },
      {
        "txt": "return tryFoldTypeof(subtree); case Token.NOT: case Token.POS: case Token.NEG: case Token.BITNOT: tryReduceOperandsForOp(subtree); return tryFoldUnaryOperator(subtree); case Token.VOID: return tryReduceVoid(subtree); default:"
      },
      {
        "txt": "tryReduceOperandsForOp(subtree); return tryFoldBinaryOperator(subtree); } } private Node tryFoldBinaryOperator(Node subtree) { Node left = subtree.getFirstChild(); if (left == null) { return subtree; } Node right = left.getNext();"
      },
      {
        "txt": "if (right == null) { return subtree; } switch(subtree.getType()) { case Token.GETPROP: return tryFoldGetProp(subtree, left, right); case Token.GETELEM: return tryFoldGetElem(subtree, left, right); case Token.INSTANCEOF: return tryFoldInstanceof(subtree, left, right);"
      },
      {
        "txt": "case Token.AND: case Token.OR: return tryFoldAndOr(subtree, left, right); case Token.LSH: case Token.RSH: case Token.URSH: return tryFoldShift(subtree, left, right); case Token.ASSIGN: return tryFoldAssign(subtree, left, right); case Token.ADD:"
      },
      {
        "txt": "return tryFoldAdd(subtree, left, right); case Token.SUB: case Token.DIV: case Token.MOD: return tryFoldArithmeticOp(subtree, left, right); case Token.MUL: case Token.BITAND: case Token.BITOR: case Token.BITXOR: Node result = tryFoldArithmeticOp(subtree, left, right);"
      },
      {
        "txt": "if (result != subtree) { return result; } return tryFoldLeftChildOp(subtree, left, right); case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.EQ: case Token.NE:"
      },
      {
        "txt": "case Token.SHEQ: case Token.SHNE: return tryFoldComparison(subtree, left, right); default: return subtree; } } private Node tryReduceVoid(Node n) { Node child = n.getFirstChild(); if (child.getType() != Token.NUMBER || child.getDouble() != 0.0) {"
      },
      {
        "txt": "if (!mayHaveSideEffects(n)) { n.replaceChild(child, Node.newNumber(0)); reportCodeChange(); } } return n; } private void tryReduceOperandsForOp(Node n) { switch (n.getType()) { case Token.ADD:"
      },
      {
        "txt": "Node left = n.getFirstChild(); Node right = n.getLastChild(); if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) { tryConvertOperandsToNumber(n); } break; case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH:"
      },
      {
        "txt": "case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_MOD: case Token.ASSIGN_DIV: tryConvertToNumber(n.getLastChild()); break; case Token.BITNOT: case Token.BITOR:"
      },
      {
        "txt": "case Token.BITXOR: case Token.BITAND: case Token.LSH: case Token.RSH: case Token.URSH: case Token.SUB: case Token.MUL: case Token.MOD: case Token.DIV: case Token.POS:"
      },
      {
        "txt": "case Token.NEG: tryConvertOperandsToNumber(n); break; } } private void tryConvertOperandsToNumber(Node n) { Node next; for (Node c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); tryConvertToNumber(c);"
      },
      {
        "txt": "} } private void tryConvertToNumber(Node n) { switch (n.getType()) { case Token.NUMBER: return; case Token.AND: case Token.OR: case Token.COMMA: tryConvertToNumber(n.getLastChild());"
      },
      {
        "txt": "return; case Token.HOOK: tryConvertToNumber(n.getChildAtIndex(1)); tryConvertToNumber(n.getLastChild()); return; case Token.NAME: if (!NodeUtil.isUndefined(n)) { return; } break;"
      },
      {
        "txt": "} Double result = NodeUtil.getNumberValue(n); if (result == null) { return; } double value = result; Node replacement; if (Double.isNaN(value)) { replacement = Node.newString(Token.NAME, \"NaN\"); } else if (value == Double.POSITIVE_INFINITY) {"
      },
      {
        "txt": "replacement = Node.newString(Token.NAME, \"Infinity\"); } else if (value == Double.NEGATIVE_INFINITY) { replacement = new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\")); replacement.copyInformationFromForTree(n); } else { replacement = Node.newNumber(value); } n.getParent().replaceChild(n, replacement); reportCodeChange(); }"
      },
      {
        "txt": "private Node tryFoldTypeof(Node originalTypeofNode) { Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF); Node argumentNode = originalTypeofNode.getFirstChild(); if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode, true)) { return originalTypeofNode; } String typeNameString = null; switch (argumentNode.getType()) { case Token.FUNCTION: typeNameString = \"function\";"
      },
      {
        "txt": "break; case Token.STRING: typeNameString = \"string\"; break; case Token.NUMBER: typeNameString = \"number\"; break; case Token.TRUE: case Token.FALSE: typeNameString = \"boolean\";"
      },
      {
        "txt": "break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: typeNameString = \"object\"; break; case Token.VOID: typeNameString = \"undefined\"; break; case Token.NAME:"
      },
      {
        "txt": "if (\"undefined\".equals(argumentNode.getString())) { typeNameString = \"undefined\"; } break; } if (typeNameString != null) { Node newNode = Node.newString(typeNameString); originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode); reportCodeChange(); return newNode;"
      },
      {
        "txt": "} return originalTypeofNode; } private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; }"
      },
      {
        "txt": "TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT: if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n;"
      },
      {
        "txt": "} } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS: if (NodeUtil.isNumericResult(left)) { parent.replaceChild(n, left.detachFromParent());"
      },
      {
        "txt": "reportCodeChange(); return left; } return n; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) { return n; } else if (left.getString().equals(\"NaN\")) {"
      },
      {
        "txt": "n.removeChild(left); parent.replaceChild(n, left); reportCodeChange(); return left; } } double negNum = -left.getDouble(); Node negNumNode = Node.newNumber(negNum); parent.replaceChild(n, negNumNode); reportCodeChange();"
      },
      {
        "txt": "return negNumNode; } catch (UnsupportedOperationException ex) { error(NEGATING_A_NON_NUMBER_ERROR, left); return n; } case Token.BITNOT: try { double val = left.getDouble(); if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val;"
      },
      {
        "txt": "if (intVal == val) { Node notIntValNode = Node.newNumber(~intVal); parent.replaceChild(n, notIntValNode); reportCodeChange(); return notIntValNode; } else { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } } else {"
      },
      {
        "txt": "error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } } catch (UnsupportedOperationException ex) { error(NEGATING_A_NON_NUMBER_ERROR, left); return n; } default: return n; }"
      },
      {
        "txt": "} private Node tryFoldInstanceof(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.INSTANCEOF); if (NodeUtil.isLiteralValue(left, true) && !mayHaveSideEffects(right)) { Node replacementNode = null; if (NodeUtil.isImmutableValue(left)) { replacementNode = new Node(Token.FALSE); } else if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) {"
      },
      {
        "txt": "replacementNode = new Node(Token.TRUE); } if (replacementNode != null) { n.getParent().replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; } } return n; }"
      },
      {
        "txt": "private Node tryFoldAssign(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN); if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return n; } if (mayHaveSideEffects(left)) { return n; } Node newRight;"
      },
      {
        "txt": "if (areNodesEqualForInlining(left, right.getFirstChild())) { newRight = right.getLastChild(); } else if (NodeUtil.isCommutative(right.getType()) && areNodesEqualForInlining(left, right.getLastChild())) { newRight = right.getFirstChild(); } else { return n; } int newType = -1; switch (right.getType()) {"
      },
      {
        "txt": "case Token.ADD: newType = Token.ASSIGN_ADD; break; case Token.BITAND: newType = Token.ASSIGN_BITAND; break; case Token.BITOR: newType = Token.ASSIGN_BITOR; break; case Token.BITXOR:"
      },
      {
        "txt": "newType = Token.ASSIGN_BITXOR; break; case Token.DIV: newType = Token.ASSIGN_DIV; break; case Token.LSH: newType = Token.ASSIGN_LSH; break; case Token.MOD: newType = Token.ASSIGN_MOD;"
      },
      {
        "txt": "break; case Token.MUL: newType = Token.ASSIGN_MUL; break; case Token.RSH: newType = Token.ASSIGN_RSH; break; case Token.SUB: newType = Token.ASSIGN_SUB; break;"
      },
      {
        "txt": "case Token.URSH: newType = Token.ASSIGN_URSH; break; default: return n; } Node newNode = new Node(newType, left.detachFromParent(), newRight.detachFromParent()); n.getParent().replaceChild(n, newNode); reportCodeChange();"
      },
      {
        "txt": "return newNode; } private Node tryFoldAndOr(Node n, Node left, Node right) { Node parent = n.getParent(); Node result = null; int type = n.getType(); TernaryValue leftVal = NodeUtil.getImpureBooleanValue(left); if (leftVal != TernaryValue.UNKNOWN) { boolean lval = leftVal.toBoolean(true); if (lval && type == Token.OR ||"
      },
      {
        "txt": "!lval && type == Token.AND) { result = left; } else if (!mayHaveSideEffects(left)) { result = right; } } if (result != null) { n.removeChild(result); parent.replaceChild(n, result); reportCodeChange();"
      },
      {
        "txt": "return result; } else { return n; } } private Node tryFoldChildAddString(Node n, Node left, Node right) { if (NodeUtil.isLiteralValue(right, false) && left.getType() == Token.ADD) { Node ll = left.getFirstChild(); Node lr = ll.getNext();"
      },
      {
        "txt": "if (lr.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { left.removeChild(ll); String result = leftString + rightString; n.replaceChild(left, ll); n.replaceChild(right, Node.newString(result)); reportCodeChange(); return n;"
      },
      {
        "txt": "} } } if (NodeUtil.isLiteralValue(left, false) && right.getType() == Token.ADD) { Node rl = right.getFirstChild(); Node rr = right.getLastChild(); if (rl.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(rl);"
      },
      {
        "txt": "if (leftString != null && rightString != null) { right.removeChild(rr); String result = leftString + rightString; n.replaceChild(right, rr); n.replaceChild(left, Node.newString(result)); reportCodeChange(); return n; } } }"
      },
      {
        "txt": "return n; } private Node tryFoldAddConstantString(Node n, Node left, Node right) { if (left.getType() == Token.STRING || right.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { Node newStringNode = Node.newString(leftString + rightString); n.getParent().replaceChild(n, newStringNode);"
      },
      {
        "txt": "reportCodeChange(); return newStringNode; } } return n; } private Node tryFoldArithmeticOp(Node n, Node left, Node right) { Node result = performArithmeticOp(n.getType(), left, right); if (result != null) { result.copyInformationFromForTree(n);"
      },
      {
        "txt": "n.getParent().replaceChild(n, result); reportCodeChange(); return result; } return n; } private Node performArithmeticOp(int opType, Node left, Node right) { if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {"
      },
      {
        "txt": "return null; } double result; Double lValObj = NodeUtil.getNumberValue(left); if (lValObj == null) { return null; } Double rValObj = NodeUtil.getNumberValue(right); if (rValObj == null) { return null;"
      },
      {
        "txt": "} double lval = lValObj; double rval = rValObj; switch (opType) { case Token.BITAND: result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval); break; case Token.BITOR: result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval); break;"
      },
      {
        "txt": "case Token.BITXOR: result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval); break; case Token.ADD: result = lval + rval; break; case Token.SUB: result = lval - rval; break; case Token.MUL:"
      },
      {
        "txt": "result = lval * rval; break; case Token.MOD: if (rval == 0) { return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) {"
      },
      {
        "txt": "return null; } result = lval / rval; break; default: throw new Error(\"Unexpected arithmetic operator\"); } if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && Math.abs(result) <= MAX_FOLD_NUMBER) {"
      },
      {
        "txt": "Node newNumber = Node.newNumber(result); return newNumber; } else if (Double.isNaN(result)) { return Node.newString(Token.NAME, \"NaN\"); } else if (result == Double.POSITIVE_INFINITY) { return Node.newString(Token.NAME, \"Infinity\"); } else if (result == Double.NEGATIVE_INFINITY) { return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\")); } return null;"
      },
      {
        "txt": "} private Node tryFoldLeftChildOp(Node n, Node left, Node right) { int opType = n.getType(); Preconditions.checkState( (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType)) || n.getType() == Token.ADD); Preconditions.checkState( n.getType() != Token.ADD || !NodeUtil.mayBeString(n)); Double rightValObj = NodeUtil.getNumberValue(right); if (rightValObj != null && left.getType() == opType) {"
      },
      {
        "txt": "Preconditions.checkState(left.getChildCount() == 2); Node ll = left.getFirstChild(); Node lr = ll.getNext(); Node valueToCombine = ll; Node replacement = performArithmeticOp(opType, valueToCombine, right); if (replacement == null) { valueToCombine = lr; replacement = performArithmeticOp(opType, valueToCombine, right); } if (replacement != null) {"
      },
      {
        "txt": "left.removeChild(valueToCombine); n.replaceChild(left, left.removeFirstChild()); replacement.copyInformationFromForTree(right); n.replaceChild(right, replacement); reportCodeChange(); } } return n; } private Node tryFoldAdd(Node node, Node left, Node right) {"
      },
      {
        "txt": "Preconditions.checkArgument(node.getType() == Token.ADD); if (NodeUtil.mayBeString(node, true)) { if (NodeUtil.isLiteralValue(left, false) && NodeUtil.isLiteralValue(right, false)) { return tryFoldAddConstantString(node, left, right); } else { return tryFoldChildAddString(node, left, right); } } else { Node result = tryFoldArithmeticOp(node, left, right);"
      },
      {
        "txt": "if (result != node) { return result; } return tryFoldLeftChildOp(node, left, right); } } private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result;"
      },
      {
        "txt": "double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; }"
      },
      {
        "txt": "int lvalInt = (int) lval; if (lvalInt != lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt != rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; }"
      },
      {
        "txt": "switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt;"
      },
      {
        "txt": "break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; }"
      },
      {
        "txt": "return n; } @SuppressWarnings(\"fallthrough\") private Node tryFoldComparison(Node n, Node left, Node right) { if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) { if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } }"
      },
      {
        "txt": "boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); <extra_id_0> switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n;"
      },
      {
        "txt": "} else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) {"
      },
      {
        "txt": "result = compareToUndefined(left, op); break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ:"
      },
      {
        "txt": "case Token.EQ: result = lhType == rhType; break; case Token.SHNE: case Token.NE: result = lhType != rhType; break; case Token.GE: case Token.LE: case Token.GT:"
      },
      {
        "txt": "case Token.LT: Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { return n; } break; default: return n; // we only handle == and != here"
      },
      {
        "txt": "} break; case Token.THIS: if (right.getType() != Token.THIS) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = true;"
      },
      {
        "txt": "break; case Token.SHNE: case Token.NE: result = false; break; default: return n; } break; case Token.STRING:"
      },
      {
        "txt": "if (undefinedRight) { result = compareToUndefined(left, op); break; } if (Token.STRING != right.getType()) { return n; // Only eval if they are the same type } switch (op) { case Token.SHEQ: case Token.EQ:"
      },
      {
        "txt": "result = left.getString().equals(right.getString()); break; case Token.SHNE: case Token.NE: result = !left.getString().equals(right.getString()); break; default: return n; // we only handle == and != here } break;"
      },
      {
        "txt": "case Token.NUMBER: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (Token.NUMBER != right.getType()) { return n; // Only eval if they are the same type } Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) {"
      },
      {
        "txt": "result = compareResult; } else { return null; } break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; }"
      },
      {
        "txt": "if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n; // Only eval if they are the same type }"
      },
      {
        "txt": "String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return n; // Not the same value name. } switch (op) { case Token.LT: case Token.GT: result = false; break;"
      },
      {
        "txt": "default: return n; // don't handle that op } break; default: return n; } Node newNode = new Node(result ? Token.TRUE : Token.FALSE); n.getParent().replaceChild(n, newNode); reportCodeChange();"
      },
      {
        "txt": "return newNode; } private Boolean compareAsNumbers(int op, Node left, Node right) { Double leftValue = NodeUtil.getNumberValue(left); if (leftValue == null) { return null; } Double rightValue = NodeUtil.getNumberValue(right); if (rightValue == null) { return null;"
      },
      {
        "txt": "} double lv = leftValue; double rv = rightValue; Boolean result; switch (op) { case Token.SHEQ: case Token.EQ: Preconditions.checkState( left.getType() == Token.NUMBER && right.getType() == Token.NUMBER); result = lv == rv;"
      },
      {
        "txt": "break; case Token.SHNE: case Token.NE: Preconditions.checkState( left.getType() == Token.NUMBER && right.getType() == Token.NUMBER); result = lv != rv; break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break;"
      },
      {
        "txt": "case Token.GT: result = lv > rv; break; default: return null; // don't handle that op } return result; } private boolean compareToUndefined(Node value, int op) { boolean valueUndefined = ((Token.NAME == value.getType() && value.getString().equals(\"undefined\")) || (Token.VOID == value.getType()"
      },
      {
        "txt": "&& NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ: return equivalent; case Token.NE: return !equivalent; case Token.SHEQ: return valueUndefined;"
      },
      {
        "txt": "case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: return false; default: throw new IllegalStateException(\"unexpected.\"); }"
      },
      {
        "txt": "} private Node tryFoldCtorCall(Node n) { Preconditions.checkArgument(n.getType() == Token.NEW); if (inForcedStringContext(n)) { return tryFoldInForcedStringContext(n); } return n; } private boolean inForcedStringContext(Node n) { return n.getParent().getType() == Token.GETELEM &&"
      },
      {
        "txt": "n.getParent().getLastChild() == n; } private Node tryFoldInForcedStringContext(Node n) { Preconditions.checkArgument(n.getType() == Token.NEW); Node objectType = n.getFirstChild(); if (objectType.getType() != Token.NAME) { return n; } if (objectType.getString().equals(\"String\")) { Node value = objectType.getNext();"
      },
      {
        "txt": "String stringValue = null; if (value == null) { stringValue = \"\"; } else { if (!NodeUtil.isImmutableValue(value)) { return n; } stringValue = NodeUtil.getStringValue(value); } if (stringValue == null) {"
      },
      {
        "txt": "return n; } Node parent = n.getParent(); Node newString = Node.newString(stringValue); parent.replaceChild(n, newString); newString.copyInformationFrom(parent); reportCodeChange(); return newString; } return n;"
      },
      {
        "txt": "} private Node tryFoldKnownMethods(Node subtree) { subtree = tryFoldArrayJoin(subtree); if (subtree.getType() == Token.CALL) { subtree = tryFoldKnownStringMethods(subtree); } return subtree; } private Node tryFoldKnownStringMethods(Node subtree) { Preconditions.checkArgument(subtree.getType() == Token.CALL);"
      },
      {
        "txt": "Node callTarget = subtree.getFirstChild(); if (callTarget == null) { return subtree; } if (!NodeUtil.isGet(callTarget)) { return subtree; } Node stringNode = callTarget.getFirstChild(); Node functionName = stringNode.getNext(); if ((stringNode.getType() != Token.STRING) || ("
      },
      {
        "txt": "(functionName.getType() != Token.STRING))) { return subtree; } String functionNameString = functionName.getString(); Node firstArg = callTarget.getNext(); if (firstArg == null) { if (functionNameString.equals(\"toLowerCase\")) { subtree = tryFoldStringToLowerCase(subtree, stringNode); } else if (functionNameString.equals(\"toUpperCase\")) { subtree = tryFoldStringToUpperCase(subtree, stringNode);"
      },
      {
        "txt": "} return subtree; } else if (NodeUtil.isImmutableValue(firstArg)) { if (functionNameString.equals(\"indexOf\") || functionNameString.equals(\"lastIndexOf\")) { subtree = tryFoldStringIndexOf(subtree, functionNameString, stringNode, firstArg); } else if (functionNameString.equals(\"substr\")) { subtree = tryFoldStringSubstr(subtree, stringNode, firstArg); } else if (functionNameString.equals(\"substring\")) {"
      },
      {
        "txt": "subtree = tryFoldStringSubstring(subtree, stringNode, firstArg); } } return subtree; } private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) { String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE); Node replacement = Node.newString(lowered); subtree.getParent().replaceChild(subtree, replacement); reportCodeChange();"
      },
      {
        "txt": "return replacement; } private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) { String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE); Node replacement = Node.newString(uppered); subtree.getParent().replaceChild(subtree, replacement); reportCodeChange(); return replacement; } private Node tryFoldStringIndexOf("
      },
      {
        "txt": "Node n, String functionName, Node lstringNode, Node firstArg) { Preconditions.checkArgument(n.getType() == Token.CALL); Preconditions.checkArgument(lstringNode.getType() == Token.STRING); String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.equals(\"indexOf\"); Node secondArg = firstArg.getNext(); String searchValue = NodeUtil.getStringValue(firstArg); if (searchValue == null) { return n; }"
      },
      {
        "txt": "int fromIndex = isIndexOf ? 0 : lstring.length(); if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) { return n; } else { fromIndex = (int) secondArg.getDouble(); } } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)"
      },
      {
        "txt": ": lstring.lastIndexOf(searchValue, fromIndex); Node newNode = Node.newNumber(indexVal); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } private Node tryFoldArrayJoin(Node n) { Node callTarget = n.getFirstChild(); if (callTarget == null || !NodeUtil.isGetProp(callTarget)) { return n;"
      },
      {
        "txt": "} Node right = callTarget.getNext(); if (right != null && !NodeUtil.isImmutableValue(right)) { return n; } Node arrayNode = callTarget.getFirstChild(); Node functionName = arrayNode.getNext(); if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) { return n;"
      },
      {
        "txt": "} String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = null; int foldedSize = 0; Node prev = null; Node elem = arrayNode.getFirstChild(); while (elem != null) { if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) { if (sb == null) {"
      },
      {
        "txt": "sb = new StringBuilder(); } else { sb.append(joinString); } sb.append(NodeUtil.getArrayElementStringValue(elem)); } else { if (sb != null) { Preconditions.checkNotNull(prev); foldedSize += sb.length() + 2; arrayFoldedChildren.add("
      },
      {
        "txt": "Node.newString(sb.toString()).copyInformationFrom(prev)); sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } prev = elem; elem = elem.getNext(); } if (sb != null) {"
      },
      {
        "txt": "Preconditions.checkNotNull(prev); foldedSize += sb.length() + 2; arrayFoldedChildren.add( Node.newString(sb.toString()).copyInformationFrom(prev)); } foldedSize += arrayFoldedChildren.size() - 1; int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0: Node emptyStringNode = Node.newString(\"\");"
      },
      {
        "txt": "n.getParent().replaceChild(n, emptyStringNode); reportCodeChange(); return emptyStringNode; case 1: Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) { return n; } arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) {"
      },
      {
        "txt": "Node replacement = new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode); foldedStringNode = replacement; } n.getParent().replaceChild(n, foldedStringNode); reportCodeChange(); return foldedStringNode; default: if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {"
      },
      {
        "txt": "return n; } int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead; foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0; if (foldedSize > originalSize) { return n; } arrayNode.detachChildren(); for (Node node : arrayFoldedChildren) {"
      },
      {
        "txt": "arrayNode.addChildToBack(node); } reportCodeChange(); break; } return n; } private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) { Preconditions.checkArgument(n.getType() == Token.CALL); Preconditions.checkArgument(stringNode.getType() == Token.STRING);"
      },
      {
        "txt": "int start, length; String stringAsString = stringNode.getString(); if (arg1 != null && arg1.getType() == Token.NUMBER) { start = (int) arg1.getDouble(); } else { return n; } Node arg2 = arg1.getNext(); if (arg2 != null) { if (arg2.getType() == Token.NUMBER) {"
      },
      {
        "txt": "length = (int) arg2.getDouble(); } else { return n; } if (arg2.getNext() != null) { return n; } } else { length = stringAsString.length() - start; }"
      },
      {
        "txt": "if ((start + length) > stringAsString.length() || (length < 0) || (start < 0)) { return n; } String result = stringAsString.substring(start, start + length); Node resultNode = Node.newString(result); Node parent = n.getParent(); parent.replaceChild(n, resultNode); reportCodeChange();"
      },
      {
        "txt": "return resultNode; } private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) { Preconditions.checkArgument(n.getType() == Token.CALL); Preconditions.checkArgument(stringNode.getType() == Token.STRING); int start, end; String stringAsString = stringNode.getString(); if (arg1 != null && arg1.getType() == Token.NUMBER) { start = (int) arg1.getDouble(); } else {"
      },
      {
        "txt": "return n; } Node arg2 = arg1.getNext(); if (arg2 != null) { if (arg2.getType() == Token.NUMBER) { end = (int) arg2.getDouble(); } else { return n; } if (arg2.getNext() != null) {"
      },
      {
        "txt": "return n; } } else { end = stringAsString.length(); } if ((end > stringAsString.length()) || (start > stringAsString.length()) || (end < 0) || (start < 0)) { return n;"
      },
      {
        "txt": "} String result = stringAsString.substring(start, end); Node resultNode = Node.newString(result); Node parent = n.getParent(); parent.replaceChild(n, resultNode); reportCodeChange(); return resultNode; } private Node tryFoldGetElem(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.GETELEM);"
      },
      {
        "txt": "if (left.getType() == Token.OBJECTLIT) { return tryFoldObjectPropAccess(n, left, right); } if (left.getType() == Token.ARRAYLIT) { if (right.getType() != Token.NUMBER) { return n; } double index = right.getDouble(); int intIndex = (int) index; if (intIndex != index) {"
      },
      {
        "txt": "error(INVALID_GETELEM_INDEX_ERROR, right); return n; } if (intIndex < 0) { error(INDEX_OUT_OF_BOUNDS_ERROR, right); return n; } Node elem = left.getFirstChild(); for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext();"
      },
      {
        "txt": "} if (elem == null) { error(INDEX_OUT_OF_BOUNDS_ERROR, right); return n; } if (elem.getType() == Token.EMPTY) { elem = NodeUtil.newUndefinedNode(elem); } else { left.removeChild(elem); }"
      },
      {
        "txt": "n.getParent().replaceChild(n, elem); reportCodeChange(); return elem; } return n; } private Node tryFoldGetProp(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.GETPROP); if (left.getType() == Token.OBJECTLIT) { return tryFoldObjectPropAccess(n, left, right);"
      },
      {
        "txt": "} if (right.getType() == Token.STRING && right.getString().equals(\"length\")) { int knownLength = -1; switch (left.getType()) { case Token.ARRAYLIT: if (mayHaveSideEffects(left)) { return n; } knownLength = left.getChildCount();"
      },
      {
        "txt": "break; case Token.STRING: knownLength = left.getString().length(); break; default: return n; } Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); n.getParent().replaceChild(n, lengthNode);"
      },
      {
        "txt": "reportCodeChange(); return lengthNode; } return n; } private Node tryFoldObjectPropAccess(Node n, Node left, Node right) { Preconditions.checkArgument(NodeUtil.isGet(n)); if (left.getType() != Token.OBJECTLIT || right.getType() != Token.STRING) { return n; }"
      },
      {
        "txt": "Node parent = n.getParent(); if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.getType() == Token.INC || parent.getType() == Token.DEC) { return n; } Node key = null; Node value = null; for (Node c = left.getFirstChild(); c != null; c = c.getNext()) { if (c.getString().equals(right.getString())) {"
      },
      {
        "txt": "switch (c.getType()) { case Token.SET: continue; case Token.GET: case Token.STRING: if (value != null && mayHaveSideEffects(value)) { return n; } key = c; value = key.getFirstChild();"
      },
      {
        "txt": "break; default: throw new IllegalStateException(); } } else if (mayHaveSideEffects(c.getFirstChild())) { return n; } } if (value == null) { return n;"
      },
      {
        "txt": "} if (value.getType() == Token.FUNCTION && NodeUtil.referencesThis(value)) { return n; } Node replacement = value.detachFromParent(); if (key.getType() == Token.GET){ replacement = new Node(Token.CALL, replacement); } n.getParent().replaceChild(n, replacement); reportCodeChange();"
      },
      {
        "txt": "return n; }"
      }
    ]
  },
  {
    "id": 363,
    "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
    "start-bug-line": 1074,
    "end-bug-line": 1074,
    "bug": "",
    "fix": "private int getNormalizedNodeType(Node n) { int type = n.getType(); if (type == Token.NOT) { TernaryValue value = NodeUtil.getPureBooleanValue(n); switch (value) { case TRUE: return Token.TRUE; case FALSE: return Token.FALSE; } } return type; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.List; import java.util.Locale; class PeepholeFoldConstants extends AbstractPeepholeOptimization {"
      },
      {
        "txt": "static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error( \"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error( \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_NEGATING_A_NON_NUMBER_ERROR\", \"Can't negate non-numeric value: {0}\"); static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\", \"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error( \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_FRACTIONAL_BITWISE_OPERAND\", \"Fractional bitwise operand: {0}\"); private static final double MAX_FOLD_NUMBER = Math.pow(2, 53); private static final Locale ROOT_LOCALE = new Locale(\"\"); @Override Node optimizeSubtree(Node subtree) { switch(subtree.getType()) { case Token.CALL: return tryFoldKnownMethods(subtree); case Token.NEW:"
      },
      {
        "txt": "return tryFoldCtorCall(subtree); case Token.TYPEOF: return tryFoldTypeof(subtree); case Token.NOT: case Token.POS: case Token.NEG: case Token.BITNOT: tryReduceOperandsForOp(subtree); return tryFoldUnaryOperator(subtree); case Token.VOID:"
      },
      {
        "txt": "return tryReduceVoid(subtree); default: tryReduceOperandsForOp(subtree); return tryFoldBinaryOperator(subtree); } } private Node tryFoldBinaryOperator(Node subtree) { Node left = subtree.getFirstChild(); if (left == null) { return subtree;"
      },
      {
        "txt": "} Node right = left.getNext(); if (right == null) { return subtree; } switch(subtree.getType()) { case Token.GETPROP: return tryFoldGetProp(subtree, left, right); case Token.GETELEM: return tryFoldGetElem(subtree, left, right);"
      },
      {
        "txt": "case Token.INSTANCEOF: return tryFoldInstanceof(subtree, left, right); case Token.AND: case Token.OR: return tryFoldAndOr(subtree, left, right); case Token.LSH: case Token.RSH: case Token.URSH: return tryFoldShift(subtree, left, right); case Token.ASSIGN:"
      },
      {
        "txt": "return tryFoldAssign(subtree, left, right); case Token.ADD: return tryFoldAdd(subtree, left, right); case Token.SUB: case Token.DIV: case Token.MOD: return tryFoldArithmeticOp(subtree, left, right); case Token.MUL: case Token.BITAND: case Token.BITOR:"
      },
      {
        "txt": "case Token.BITXOR: Node result = tryFoldArithmeticOp(subtree, left, right); if (result != subtree) { return result; } return tryFoldLeftChildOp(subtree, left, right); case Token.LT: case Token.GT: case Token.LE: case Token.GE:"
      },
      {
        "txt": "case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: return tryFoldComparison(subtree, left, right); default: return subtree; } } private Node tryReduceVoid(Node n) {"
      },
      {
        "txt": "Node child = n.getFirstChild(); if (child.getType() != Token.NUMBER || child.getDouble() != 0.0) { if (!mayHaveSideEffects(n)) { n.replaceChild(child, Node.newNumber(0)); reportCodeChange(); } } return n; } private void tryReduceOperandsForOp(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.ADD: Node left = n.getFirstChild(); Node right = n.getLastChild(); if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) { tryConvertOperandsToNumber(n); } break; case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR:"
      },
      {
        "txt": "case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_MOD: case Token.ASSIGN_DIV: tryConvertToNumber(n.getLastChild()); break;"
      },
      {
        "txt": "case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.LSH: case Token.RSH: case Token.URSH: case Token.SUB: case Token.MUL: case Token.MOD:"
      },
      {
        "txt": "case Token.DIV: case Token.POS: case Token.NEG: tryConvertOperandsToNumber(n); break; } } private void tryConvertOperandsToNumber(Node n) { Node next; for (Node c = n.getFirstChild(); c != null; c = next) {"
      },
      {
        "txt": "next = c.getNext(); tryConvertToNumber(c); } } private void tryConvertToNumber(Node n) { switch (n.getType()) { case Token.NUMBER: return; case Token.AND: case Token.OR:"
      },
      {
        "txt": "case Token.COMMA: tryConvertToNumber(n.getLastChild()); return; case Token.HOOK: tryConvertToNumber(n.getChildAtIndex(1)); tryConvertToNumber(n.getLastChild()); return; case Token.NAME: if (!NodeUtil.isUndefined(n)) { return;"
      },
      {
        "txt": "} break; } Double result = NodeUtil.getNumberValue(n); if (result == null) { return; } double value = result; Node replacement; if (Double.isNaN(value)) {"
      },
      {
        "txt": "replacement = Node.newString(Token.NAME, \"NaN\"); } else if (value == Double.POSITIVE_INFINITY) { replacement = Node.newString(Token.NAME, \"Infinity\"); } else if (value == Double.NEGATIVE_INFINITY) { replacement = new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\")); replacement.copyInformationFromForTree(n); } else { replacement = Node.newNumber(value); } n.getParent().replaceChild(n, replacement);"
      },
      {
        "txt": "reportCodeChange(); } private Node tryFoldTypeof(Node originalTypeofNode) { Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF); Node argumentNode = originalTypeofNode.getFirstChild(); if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode, true)) { return originalTypeofNode; } String typeNameString = null; switch (argumentNode.getType()) {"
      },
      {
        "txt": "case Token.FUNCTION: typeNameString = \"function\"; break; case Token.STRING: typeNameString = \"string\"; break; case Token.NUMBER: typeNameString = \"number\"; break; case Token.TRUE:"
      },
      {
        "txt": "case Token.FALSE: typeNameString = \"boolean\"; break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: typeNameString = \"object\"; break; case Token.VOID: typeNameString = \"undefined\";"
      },
      {
        "txt": "break; case Token.NAME: if (\"undefined\".equals(argumentNode.getString())) { typeNameString = \"undefined\"; } break; } if (typeNameString != null) { Node newNode = Node.newString(typeNameString); originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);"
      },
      {
        "txt": "reportCodeChange(); return newNode; } return originalTypeofNode; } private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) {"
      },
      {
        "txt": "return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT: if (left.getType() == Token.NUMBER) { double numValue = left.getDouble();"
      },
      {
        "txt": "if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS:"
      },
      {
        "txt": "if (NodeUtil.isNumericResult(left)) { parent.replaceChild(n, left.detachFromParent()); reportCodeChange(); return left; } return n; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) {"
      },
      {
        "txt": "return n; } else if (left.getString().equals(\"NaN\")) { n.removeChild(left); parent.replaceChild(n, left); reportCodeChange(); return left; } } double negNum = -left.getDouble(); Node negNumNode = Node.newNumber(negNum);"
      },
      {
        "txt": "parent.replaceChild(n, negNumNode); reportCodeChange(); return negNumNode; } catch (UnsupportedOperationException ex) { error(NEGATING_A_NON_NUMBER_ERROR, left); return n; } case Token.BITNOT: try { double val = left.getDouble();"
      },
      {
        "txt": "if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val; if (intVal == val) { Node notIntValNode = Node.newNumber(~intVal); parent.replaceChild(n, notIntValNode); reportCodeChange(); return notIntValNode; } else { error(FRACTIONAL_BITWISE_OPERAND, left); return n;"
      },
      {
        "txt": "} } else { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } } catch (UnsupportedOperationException ex) { error(NEGATING_A_NON_NUMBER_ERROR, left); return n; } default:"
      },
      {
        "txt": "return n; } } private Node tryFoldInstanceof(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.INSTANCEOF); if (NodeUtil.isLiteralValue(left, true) && !mayHaveSideEffects(right)) { Node replacementNode = null; if (NodeUtil.isImmutableValue(left)) { replacementNode = new Node(Token.FALSE);"
      },
      {
        "txt": "} else if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) { replacementNode = new Node(Token.TRUE); } if (replacementNode != null) { n.getParent().replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; } }"
      },
      {
        "txt": "return n; } private Node tryFoldAssign(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN); if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return n; } if (mayHaveSideEffects(left)) { return n;"
      },
      {
        "txt": "} Node newRight; if (areNodesEqualForInlining(left, right.getFirstChild())) { newRight = right.getLastChild(); } else if (NodeUtil.isCommutative(right.getType()) && areNodesEqualForInlining(left, right.getLastChild())) { newRight = right.getFirstChild(); } else { return n; }"
      },
      {
        "txt": "int newType = -1; switch (right.getType()) { case Token.ADD: newType = Token.ASSIGN_ADD; break; case Token.BITAND: newType = Token.ASSIGN_BITAND; break; case Token.BITOR: newType = Token.ASSIGN_BITOR;"
      },
      {
        "txt": "break; case Token.BITXOR: newType = Token.ASSIGN_BITXOR; break; case Token.DIV: newType = Token.ASSIGN_DIV; break; case Token.LSH: newType = Token.ASSIGN_LSH; break;"
      },
      {
        "txt": "case Token.MOD: newType = Token.ASSIGN_MOD; break; case Token.MUL: newType = Token.ASSIGN_MUL; break; case Token.RSH: newType = Token.ASSIGN_RSH; break; case Token.SUB:"
      },
      {
        "txt": "newType = Token.ASSIGN_SUB; break; case Token.URSH: newType = Token.ASSIGN_URSH; break; default: return n; } Node newNode = new Node(newType, left.detachFromParent(), newRight.detachFromParent());"
      },
      {
        "txt": "n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } private Node tryFoldAndOr(Node n, Node left, Node right) { Node parent = n.getParent(); Node result = null; int type = n.getType(); TernaryValue leftVal = NodeUtil.getImpureBooleanValue(left); if (leftVal != TernaryValue.UNKNOWN) {"
      },
      {
        "txt": "boolean lval = leftVal.toBoolean(true); if (lval && type == Token.OR || !lval && type == Token.AND) { result = left; } else if (!mayHaveSideEffects(left)) { result = right; } } if (result != null) { n.removeChild(result);"
      },
      {
        "txt": "parent.replaceChild(n, result); reportCodeChange(); return result; } else { return n; } } private Node tryFoldChildAddString(Node n, Node left, Node right) { if (NodeUtil.isLiteralValue(right, false) && left.getType() == Token.ADD) {"
      },
      {
        "txt": "Node ll = left.getFirstChild(); Node lr = ll.getNext(); if (lr.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { left.removeChild(ll); String result = leftString + rightString; n.replaceChild(left, ll); n.replaceChild(right, Node.newString(result));"
      },
      {
        "txt": "reportCodeChange(); return n; } } } if (NodeUtil.isLiteralValue(left, false) && right.getType() == Token.ADD) { Node rl = right.getFirstChild(); Node rr = right.getLastChild(); if (rl.getType() == Token.STRING) {"
      },
      {
        "txt": "String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(rl); if (leftString != null && rightString != null) { right.removeChild(rr); String result = leftString + rightString; n.replaceChild(right, rr); n.replaceChild(left, Node.newString(result)); reportCodeChange(); return n; }"
      },
      {
        "txt": "} } return n; } private Node tryFoldAddConstantString(Node n, Node left, Node right) { if (left.getType() == Token.STRING || right.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) {"
      },
      {
        "txt": "Node newStringNode = Node.newString(leftString + rightString); n.getParent().replaceChild(n, newStringNode); reportCodeChange(); return newStringNode; } } return n; } private Node tryFoldArithmeticOp(Node n, Node left, Node right) { Node result = performArithmeticOp(n.getType(), left, right);"
      },
      {
        "txt": "if (result != null) { result.copyInformationFromForTree(n); n.getParent().replaceChild(n, result); reportCodeChange(); return result; } return n; } private Node performArithmeticOp(int opType, Node left, Node right) { if (opType == Token.ADD"
      },
      {
        "txt": "&& (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) { return null; } double result; Double lValObj = NodeUtil.getNumberValue(left); if (lValObj == null) { return null; } Double rValObj = NodeUtil.getNumberValue(right);"
      },
      {
        "txt": "if (rValObj == null) { return null; } double lval = lValObj; double rval = rValObj; switch (opType) { case Token.BITAND: result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval); break; case Token.BITOR:"
      },
      {
        "txt": "result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval); break; case Token.BITXOR: result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval); break; case Token.ADD: result = lval + rval; break; case Token.SUB: result = lval - rval;"
      },
      {
        "txt": "break; case Token.MUL: result = lval * rval; break; case Token.MOD: if (rval == 0) { return null; } result = lval % rval; break;"
      },
      {
        "txt": "case Token.DIV: if (rval == 0) { return null; } result = lval / rval; break; default: throw new Error(\"Unexpected arithmetic operator\"); } if (String.valueOf(result).length() <="
      },
      {
        "txt": "String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && Math.abs(result) <= MAX_FOLD_NUMBER) { Node newNumber = Node.newNumber(result); return newNumber; } else if (Double.isNaN(result)) { return Node.newString(Token.NAME, \"NaN\"); } else if (result == Double.POSITIVE_INFINITY) { return Node.newString(Token.NAME, \"Infinity\"); } else if (result == Double.NEGATIVE_INFINITY) { return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));"
      },
      {
        "txt": "} return null; } private Node tryFoldLeftChildOp(Node n, Node left, Node right) { int opType = n.getType(); Preconditions.checkState( (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType)) || n.getType() == Token.ADD); Preconditions.checkState( n.getType() != Token.ADD || !NodeUtil.mayBeString(n));"
      },
      {
        "txt": "Double rightValObj = NodeUtil.getNumberValue(right); if (rightValObj != null && left.getType() == opType) { Preconditions.checkState(left.getChildCount() == 2); Node ll = left.getFirstChild(); Node lr = ll.getNext(); Node valueToCombine = ll; Node replacement = performArithmeticOp(opType, valueToCombine, right); if (replacement == null) { valueToCombine = lr; replacement = performArithmeticOp(opType, valueToCombine, right);"
      },
      {
        "txt": "} if (replacement != null) { left.removeChild(valueToCombine); n.replaceChild(left, left.removeFirstChild()); replacement.copyInformationFromForTree(right); n.replaceChild(right, replacement); reportCodeChange(); } } return n;"
      },
      {
        "txt": "} private Node tryFoldAdd(Node node, Node left, Node right) { Preconditions.checkArgument(node.getType() == Token.ADD); if (NodeUtil.mayBeString(node, true)) { if (NodeUtil.isLiteralValue(left, false) && NodeUtil.isLiteralValue(right, false)) { return tryFoldAddConstantString(node, left, right); } else { return tryFoldChildAddString(node, left, right); }"
      },
      {
        "txt": "} else { Node result = tryFoldArithmeticOp(node, left, right); if (result != node) { return result; } return tryFoldLeftChildOp(node, left, right); } } private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER &&"
      },
      {
        "txt": "right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);"
      },
      {
        "txt": "return n; } int lvalInt = (int) lval; if (lvalInt != lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt != rval) { error(FRACTIONAL_BITWISE_OPERAND, right);"
      },
      {
        "txt": "return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH:"
      },
      {
        "txt": "long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange();"
      },
      {
        "txt": "return newNumber; } return n; } @SuppressWarnings(\"fallthrough\") private Node tryFoldComparison(Node n, Node left, Node right) { if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) { if (n.getType() != Token.GT && n.getType() != Token.LT) { return n;"
      },
      {
        "txt": "} } int op = n.getType(); boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType();"
      },
      {
        "txt": "int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); }"
      },
      {
        "txt": "break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rhType != Token.TRUE && rhType != Token.FALSE &&"
      },
      {
        "txt": "rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; break; case Token.SHNE: case Token.NE:"
      },
      {
        "txt": "result = lhType != rhType; break; case Token.GE: case Token.LE: case Token.GT: case Token.LT: Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else {"
      },
      {
        "txt": "return n; } break; default: return n; // we only handle == and != here } break; case Token.THIS: if (right.getType() != Token.THIS) { return n;"
      },
      {
        "txt": "} switch (op) { case Token.SHEQ: case Token.EQ: result = true; break; case Token.SHNE: case Token.NE: result = false; break;"
      },
      {
        "txt": "default: return n; } break; case Token.STRING: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (Token.STRING != right.getType()) {"
      },
      {
        "txt": "return n; // Only eval if they are the same type } switch (op) { case Token.SHEQ: case Token.EQ: result = left.getString().equals(right.getString()); break; case Token.SHNE: case Token.NE: result = !left.getString().equals(right.getString());"
      },
      {
        "txt": "break; default: return n; // we only handle == and != here } break; case Token.NUMBER: if (undefinedRight) { result = compareToUndefined(left, op); break; }"
      },
      {
        "txt": "if (Token.NUMBER != right.getType()) { return n; // Only eval if they are the same type } Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { return null; } break;"
      },
      {
        "txt": "case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { result = compareToUndefined(right, op); break;"
      },
      {
        "txt": "} } if (Token.NAME != right.getType()) { return n; // Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return n; // Not the same value name. }"
      },
      {
        "txt": "switch (op) { case Token.LT: case Token.GT: result = false; break; default: return n; // don't handle that op } break; default:"
      },
      {
        "txt": "} Node newNode = new Node(result ? Token.TRUE : Token.FALSE); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } <extra_id_0> private Boolean compareAsNumbers(int op, Node left, Node right) { Double leftValue = NodeUtil.getNumberValue(left); if (leftValue == null) { return null; } Double rightValue = NodeUtil.getNumberValue(right);"
      },
      {
        "txt": "} Double rightValue = NodeUtil.getNumberValue(right); if (rightValue == null) { return null; } double lv = leftValue; double rv = rightValue; Boolean result; switch (op) { case Token.SHEQ:"
      },
      {
        "txt": "case Token.EQ: Preconditions.checkState( left.getType() == Token.NUMBER && right.getType() == Token.NUMBER); result = lv == rv; break; case Token.SHNE: case Token.NE: Preconditions.checkState( left.getType() == Token.NUMBER && right.getType() == Token.NUMBER); result = lv != rv;"
      },
      {
        "txt": "break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break; case Token.GT: result = lv > rv; break; default: return null; // don't handle that op } return result; }"
      },
      {
        "txt": "private boolean compareToUndefined(Node value, int op) { boolean valueUndefined = ((Token.NAME == value.getType() && value.getString().equals(\"undefined\")) || (Token.VOID == value.getType() && NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ: return equivalent;"
      },
      {
        "txt": "case Token.NE: return !equivalent; case Token.SHEQ: return valueUndefined; case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE:"
      },
      {
        "txt": "return false; default: throw new IllegalStateException(\"unexpected.\"); } } private Node tryFoldCtorCall(Node n) { Preconditions.checkArgument(n.getType() == Token.NEW); if (inForcedStringContext(n)) { return tryFoldInForcedStringContext(n); }"
      },
      {
        "txt": "return n; } private boolean inForcedStringContext(Node n) { return n.getParent().getType() == Token.GETELEM && n.getParent().getLastChild() == n; } private Node tryFoldInForcedStringContext(Node n) { Preconditions.checkArgument(n.getType() == Token.NEW); Node objectType = n.getFirstChild(); if (objectType.getType() != Token.NAME) {"
      },
      {
        "txt": "return n; } if (objectType.getString().equals(\"String\")) { Node value = objectType.getNext(); String stringValue = null; if (value == null) { stringValue = \"\"; } else { if (!NodeUtil.isImmutableValue(value)) { return n;"
      },
      {
        "txt": "} stringValue = NodeUtil.getStringValue(value); } if (stringValue == null) { return n; } Node parent = n.getParent(); Node newString = Node.newString(stringValue); parent.replaceChild(n, newString); newString.copyInformationFrom(parent);"
      },
      {
        "txt": "reportCodeChange(); return newString; } return n; } private Node tryFoldKnownMethods(Node subtree) { subtree = tryFoldArrayJoin(subtree); if (subtree.getType() == Token.CALL) { subtree = tryFoldKnownStringMethods(subtree); }"
      },
      {
        "txt": "return subtree; } private Node tryFoldKnownStringMethods(Node subtree) { Preconditions.checkArgument(subtree.getType() == Token.CALL); Node callTarget = subtree.getFirstChild(); if (callTarget == null) { return subtree; } if (!NodeUtil.isGet(callTarget)) { return subtree;"
      },
      {
        "txt": "} Node stringNode = callTarget.getFirstChild(); Node functionName = stringNode.getNext(); if ((stringNode.getType() != Token.STRING) || ( (functionName.getType() != Token.STRING))) { return subtree; } String functionNameString = functionName.getString(); Node firstArg = callTarget.getNext(); if (firstArg == null) {"
      },
      {
        "txt": "if (functionNameString.equals(\"toLowerCase\")) { subtree = tryFoldStringToLowerCase(subtree, stringNode); } else if (functionNameString.equals(\"toUpperCase\")) { subtree = tryFoldStringToUpperCase(subtree, stringNode); } return subtree; } else if (NodeUtil.isImmutableValue(firstArg)) { if (functionNameString.equals(\"indexOf\") || functionNameString.equals(\"lastIndexOf\")) { subtree = tryFoldStringIndexOf(subtree, functionNameString,"
      },
      {
        "txt": "stringNode, firstArg); } else if (functionNameString.equals(\"substr\")) { subtree = tryFoldStringSubstr(subtree, stringNode, firstArg); } else if (functionNameString.equals(\"substring\")) { subtree = tryFoldStringSubstring(subtree, stringNode, firstArg); } } return subtree; } private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {"
      },
      {
        "txt": "String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE); Node replacement = Node.newString(lowered); subtree.getParent().replaceChild(subtree, replacement); reportCodeChange(); return replacement; } private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) { String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE); Node replacement = Node.newString(uppered); subtree.getParent().replaceChild(subtree, replacement);"
      },
      {
        "txt": "reportCodeChange(); return replacement; } private Node tryFoldStringIndexOf( Node n, String functionName, Node lstringNode, Node firstArg) { Preconditions.checkArgument(n.getType() == Token.CALL); Preconditions.checkArgument(lstringNode.getType() == Token.STRING); String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.equals(\"indexOf\"); Node secondArg = firstArg.getNext();"
      },
      {
        "txt": "String searchValue = NodeUtil.getStringValue(firstArg); if (searchValue == null) { return n; } int fromIndex = isIndexOf ? 0 : lstring.length(); if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) { return n; } else {"
      },
      {
        "txt": "fromIndex = (int) secondArg.getDouble(); } } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex); Node newNode = Node.newNumber(indexVal); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; }"
      },
      {
        "txt": "private Node tryFoldArrayJoin(Node n) { Node callTarget = n.getFirstChild(); if (callTarget == null || !NodeUtil.isGetProp(callTarget)) { return n; } Node right = callTarget.getNext(); if (right != null && !NodeUtil.isImmutableValue(right)) { return n; } Node arrayNode = callTarget.getFirstChild();"
      },
      {
        "txt": "Node functionName = arrayNode.getNext(); if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) { return n; } String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = null; int foldedSize = 0; Node prev = null;"
      },
      {
        "txt": "Node elem = arrayNode.getFirstChild(); while (elem != null) { if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) { if (sb == null) { sb = new StringBuilder(); } else { sb.append(joinString); } sb.append(NodeUtil.getArrayElementStringValue(elem)); } else {"
      },
      {
        "txt": "if (sb != null) { Preconditions.checkNotNull(prev); foldedSize += sb.length() + 2; arrayFoldedChildren.add( Node.newString(sb.toString()).copyInformationFrom(prev)); sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); }"
      },
      {
        "txt": "prev = elem; elem = elem.getNext(); } if (sb != null) { Preconditions.checkNotNull(prev); foldedSize += sb.length() + 2; arrayFoldedChildren.add( Node.newString(sb.toString()).copyInformationFrom(prev)); } foldedSize += arrayFoldedChildren.size() - 1;"
      },
      {
        "txt": "int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0: Node emptyStringNode = Node.newString(\"\"); n.getParent().replaceChild(n, emptyStringNode); reportCodeChange(); return emptyStringNode; case 1: Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) {"
      },
      {
        "txt": "return n; } arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) { Node replacement = new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode); foldedStringNode = replacement; } n.getParent().replaceChild(n, foldedStringNode);"
      },
      {
        "txt": "reportCodeChange(); return foldedStringNode; default: if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { return n; } int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead; foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0; if (foldedSize > originalSize) {"
      },
      {
        "txt": "return n; } arrayNode.detachChildren(); for (Node node : arrayFoldedChildren) { arrayNode.addChildToBack(node); } reportCodeChange(); break; } return n;"
      },
      {
        "txt": "} private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) { Preconditions.checkArgument(n.getType() == Token.CALL); Preconditions.checkArgument(stringNode.getType() == Token.STRING); int start, length; String stringAsString = stringNode.getString(); if (arg1 != null && arg1.getType() == Token.NUMBER) { start = (int) arg1.getDouble(); } else { return n;"
      },
      {
        "txt": "} Node arg2 = arg1.getNext(); if (arg2 != null) { if (arg2.getType() == Token.NUMBER) { length = (int) arg2.getDouble(); } else { return n; } if (arg2.getNext() != null) { return n;"
      },
      {
        "txt": "} } else { length = stringAsString.length() - start; } if ((start + length) > stringAsString.length() || (length < 0) || (start < 0)) { return n; } String result = stringAsString.substring(start, start + length);"
      },
      {
        "txt": "Node resultNode = Node.newString(result); Node parent = n.getParent(); parent.replaceChild(n, resultNode); reportCodeChange(); return resultNode; } private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) { Preconditions.checkArgument(n.getType() == Token.CALL); Preconditions.checkArgument(stringNode.getType() == Token.STRING); int start, end;"
      },
      {
        "txt": "String stringAsString = stringNode.getString(); if (arg1 != null && arg1.getType() == Token.NUMBER) { start = (int) arg1.getDouble(); } else { return n; } Node arg2 = arg1.getNext(); if (arg2 != null) { if (arg2.getType() == Token.NUMBER) { end = (int) arg2.getDouble();"
      },
      {
        "txt": "} else { return n; } if (arg2.getNext() != null) { return n; } } else { end = stringAsString.length(); } if ((end > stringAsString.length()) ||"
      },
      {
        "txt": "(start > stringAsString.length()) || (end < 0) || (start < 0)) { return n; } String result = stringAsString.substring(start, end); Node resultNode = Node.newString(result); Node parent = n.getParent(); parent.replaceChild(n, resultNode); reportCodeChange();"
      },
      {
        "txt": "return resultNode; } private Node tryFoldGetElem(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.GETELEM); if (left.getType() == Token.OBJECTLIT) { return tryFoldObjectPropAccess(n, left, right); } if (left.getType() == Token.ARRAYLIT) { if (right.getType() != Token.NUMBER) { return n;"
      },
      {
        "txt": "} double index = right.getDouble(); int intIndex = (int) index; if (intIndex != index) { error(INVALID_GETELEM_INDEX_ERROR, right); return n; } if (intIndex < 0) { error(INDEX_OUT_OF_BOUNDS_ERROR, right); return n;"
      },
      {
        "txt": "} Node elem = left.getFirstChild(); for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext(); } if (elem == null) { error(INDEX_OUT_OF_BOUNDS_ERROR, right); return n; } if (elem.getType() == Token.EMPTY) {"
      },
      {
        "txt": "elem = NodeUtil.newUndefinedNode(elem); } else { left.removeChild(elem); } n.getParent().replaceChild(n, elem); reportCodeChange(); return elem; } return n; }"
      },
      {
        "txt": "private Node tryFoldGetProp(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.GETPROP); if (left.getType() == Token.OBJECTLIT) { return tryFoldObjectPropAccess(n, left, right); } if (right.getType() == Token.STRING && right.getString().equals(\"length\")) { int knownLength = -1; switch (left.getType()) { case Token.ARRAYLIT:"
      },
      {
        "txt": "if (mayHaveSideEffects(left)) { return n; } knownLength = left.getChildCount(); break; case Token.STRING: knownLength = left.getString().length(); break; default: return n;"
      },
      {
        "txt": "} Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); n.getParent().replaceChild(n, lengthNode); reportCodeChange(); return lengthNode; } return n; } private Node tryFoldObjectPropAccess(Node n, Node left, Node right) {"
      },
      {
        "txt": "Preconditions.checkArgument(NodeUtil.isGet(n)); if (left.getType() != Token.OBJECTLIT || right.getType() != Token.STRING) { return n; } Node parent = n.getParent(); if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.getType() == Token.INC || parent.getType() == Token.DEC) { return n; }"
      },
      {
        "txt": "Node key = null; Node value = null; for (Node c = left.getFirstChild(); c != null; c = c.getNext()) { if (c.getString().equals(right.getString())) { switch (c.getType()) { case Token.SET: continue; case Token.GET: case Token.STRING: if (value != null && mayHaveSideEffects(value)) {"
      },
      {
        "txt": "return n; } key = c; value = key.getFirstChild(); break; default: throw new IllegalStateException(); } } else if (mayHaveSideEffects(c.getFirstChild())) { return n;"
      },
      {
        "txt": "} } if (value == null) { return n; } if (value.getType() == Token.FUNCTION && NodeUtil.referencesThis(value)) { return n; } Node replacement = value.detachFromParent(); if (key.getType() == Token.GET){"
      },
      {
        "txt": "replacement = new Node(Token.CALL, replacement); } n.getParent().replaceChild(n, replacement); reportCodeChange(); return n; }"
      }
    ]
  }
]