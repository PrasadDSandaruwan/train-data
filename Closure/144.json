[
  {
    "id": 569,
    "file_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
    "start-bug-line": 74,
    "end-bug-line": 74,
    "bug": "",
    "fix": "private boolean returnTypeInferred = false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionBuilder; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.InstanceObjectType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import java.util.Set; import javax.annotation.Nullable; final class FunctionTypeBuilder { private final String fnName;"
      },
      {
        "txt": "private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private final Node errorRoot; private final String sourceName; private final Scope scope; private JSType returnType = null; <extra_id_0> private ObjectType baseType = null; private ObjectType thisType = null; private boolean isConstructor = false; private boolean isInterface = false; private Node parametersNode = null; private Node sourceNode = null;"
      },
      {
        "txt": "private Node parametersNode = null; private Node sourceNode = null; private String templateTypeName = null; static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning( \"JSC_EXTENDS_WITHOUT_TYPEDEF\", \"@extends used without @constructor or @interface for {0}\"); static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning( \"JSC_EXTENDS_NON_OBJECT\", \"{0} @extends non-object type {1}\"); static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\", \"@implements used without @constructor or @interface for {0}\"); static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning( \"JSC_VAR_ARGS_MUST_BE_LAST\", \"variable length argument must be last\"); static final DiagnosticType OPTIONAL_ARG_AT_END = DiagnosticType.warning( \"JSC_OPTIONAL_ARG_AT_END\", \"optional arguments must be at the end\"); static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_INEXISTANT_PARAM\", \"parameter {0} does not appear in {1}''s parameter list\"); static final DiagnosticType TYPE_REDEFINITION = DiagnosticType.warning( \"JSC_TYPE_REDEFINITION\", \"attempted re-definition of type {0}\\n\" + \"found : {1}\\n\" + \"expected: {2}\"); static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_DUPLICATED\", \"Only one parameter type must be the template type\");"
      },
      {
        "txt": "static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_EXPECTED\", \"The template type must be a parameter type\"); FunctionTypeBuilder(String fnName, AbstractCompiler compiler, Node errorRoot, String sourceName, Scope scope) { Preconditions.checkNotNull(errorRoot); this.fnName = fnName == null ? \"\" : fnName; this.codingConvention = compiler.getCodingConvention(); this.typeRegistry = compiler.getTypeRegistry(); this.errorRoot = errorRoot;"
      },
      {
        "txt": "this.sourceName = sourceName; this.compiler = compiler; this.scope = scope; } FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) { this.sourceNode = sourceNode; return this; } FunctionTypeBuilder inferFromOverriddenFunction( FunctionType oldType, @Nullable Node paramsParent) {"
      },
      {
        "txt": "returnType = oldType.getReturnType(); if (paramsParent == null) { parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator();"
      },
      {
        "txt": "boolean warnedAboutArgList = false; for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } else { warnedAboutArgList |= addParameter( paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList,"
      },
      {
        "txt": "codingConvention.isOptionalParameter(currentParam), codingConvention.isVarArgsParameter(currentParam)); } } parametersNode = paramBuilder.build(); } return this; } FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ?"
      },
      {
        "txt": "info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } return this; } FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { if (info != null) {"
      },
      {
        "txt": "isConstructor = info.isConstructor(); isInterface = info.isInterface(); if (info.hasBaseType()) { if (isConstructor || isInterface) { baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry)); if (baseType == null) { reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString()); } } else { reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);"
      },
      {
        "txt": "} } if (isConstructor || isInterface) { implementedInterfaces = Lists.newArrayList(); for (JSTypeExpression t : info.getImplementedInterfaces()) { ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry)); if (interType != null) { implementedInterfaces.add(interType); } else { reportError(BAD_IMPLEMENTED_TYPE, fnName);"
      },
      {
        "txt": "} } if (baseType != null) { JSType maybeFunctionType = baseType.getConstructor(); if (maybeFunctionType instanceof FunctionType) { FunctionType functionType = baseType.getConstructor(); Iterables.addAll( implementedInterfaces, functionType.getImplementedInterfaces()); }"
      },
      {
        "txt": "} } else if (info.getImplementedInterfaceCount() > 0) { reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName); } } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) { ObjectType objType = ObjectType.cast(type); if (objType != null && (info == null || !info.hasType())) {"
      },
      {
        "txt": "thisType = objType; } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) { ObjectType maybeThisType = null; if (info != null && info.hasThisType()) { maybeThisType = ObjectType.cast( info.getThisType().evaluate(scope, typeRegistry));"
      },
      {
        "txt": "} if (maybeThisType != null) { thisType = maybeThisType; } else if (owner != null && (info == null || !info.hasType())) { String ownerTypeName = owner.getQualifiedName(); ObjectType ownerType = ObjectType.cast( typeRegistry.getType( scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno()));"
      },
      {
        "txt": "if (ownerType != null) { thisType = ownerType; } } return this; } FunctionTypeBuilder inferParameterTypes(JSDocInfo info) { Node lp = new Node(Token.LP); for (String name : info.getParameterNames()) { lp.addChildToBack(Node.newString(Token.NAME, name));"
      },
      {
        "txt": "} return inferParameterTypes(lp, info); } FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) { if (info == null) { return this; } else { return inferParameterTypes(info);"
      },
      {
        "txt": "} } FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false; for (Node arg : argsParent.children()) { String argumentName = arg.getString();"
      },
      {
        "txt": "allJsDocParams.remove(argumentName); JSType parameterType = info != null && info.hasParameterType(argumentName) ? info.getParameterType(argumentName).evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) { reportError(TEMPLATE_TYPE_DUPLICATED, fnName); }"
      },
      {
        "txt": "foundTemplateType = true; } warnedAboutArgList |= addParameter( builder, parameterType, warnedAboutArgList, isOptionalParameter(arg, info), isVarArgsParameter(arg, info)); } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); }"
      },
      {
        "txt": "for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName); } parametersNode = builder.build(); return this; } private boolean isOptionalParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isOptionalParameter(param)) { return true;"
      },
      {
        "txt": "} String paramName = param.getString(); return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isOptionalArg(); } private boolean isVarArgsParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isVarArgsParameter(param)) { return true; }"
      },
      {
        "txt": "String paramName = param.getString(); return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isVarArgs(); } FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) { if (info != null) { templateTypeName = info.getTemplateTypeName(); typeRegistry.setTemplateTypeName(templateTypeName); } return this;"
      },
      {
        "txt": "} private boolean addParameter(FunctionParamBuilder builder, JSType paramType, boolean warnedAboutArgList, boolean isOptional, boolean isVarArgs) { boolean emittedWarning = false; if (isOptional) { if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; }"
      },
      {
        "txt": "} else if (isVarArgs) { if (!builder.addVarArgs(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else { if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) { if (builder.hasVarArgs()) { reportWarning(VAR_ARGS_MUST_BE_LAST); } else {"
      },
      {
        "txt": "reportWarning(OPTIONAL_ARG_AT_END); } emittedWarning = true; } } return emittedWarning; } FunctionType buildAndRegister() { if (returnType == null) { returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} if (parametersNode == null) { throw new IllegalStateException( \"All Function types must have params and a return type\"); } FunctionType fnType; if (isConstructor) { fnType = getOrCreateConstructor(); } else if (isInterface) { fnType = typeRegistry.createInterfaceType(fnName, sourceNode);"
      },
      {
        "txt": "if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); } maybeSetBaseType(fnType); } else { fnType = new FunctionBuilder(typeRegistry) .withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType)"
      },
      {
        "txt": ".withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build(); maybeSetBaseType(fnType); } if (implementedInterfaces != null) { fnType.setImplementedInterfaces(implementedInterfaces); } typeRegistry.clearTemplateTypeName(); return fnType;"
      },
      {
        "txt": "} private void maybeSetBaseType(FunctionType fnType) { if (baseType != null) { fnType.setPrototypeBasedOn(baseType); } } private FunctionType getOrCreateConstructor() { FunctionType fnType = typeRegistry.createConstructorType( fnName, sourceNode, parametersNode, returnType); JSType existingType = typeRegistry.getType(fnName);"
      },
      {
        "txt": "if (existingType != null) { boolean isInstanceObject = existingType instanceof InstanceObjectType; if (isInstanceObject || fnName.equals(\"Function\")) { FunctionType existingFn = isInstanceObject ? ((InstanceObjectType) existingType).getConstructor() : typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE); if (existingFn.getSource() == null) { existingFn.setSource(sourceNode); }"
      },
      {
        "txt": "if (!existingFn.hasEqualCallType(fnType)) { reportWarning(TYPE_REDEFINITION, fnName, fnType.toString(), existingFn.toString()); } return existingFn; } else { } } maybeSetBaseType(fnType); if (scope.isGlobal() && !fnName.isEmpty()) {"
      },
      {
        "txt": "typeRegistry.declareType(fnName, fnType.getInstanceType()); } return fnType; } private void reportWarning(DiagnosticType warning, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, warning, args)); } private void reportError(DiagnosticType error, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, error, args)); }"
      },
      {
        "txt": "static boolean isFunctionTypeDeclaration(JSDocInfo info) { return info.getParameterCount() > 0 || info.hasReturnType() || info.hasThisType() || info.isConstructor() || info.isInterface(); }"
      }
    ]
  },
  {
    "id": 570,
    "file_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
    "start-bug-line": 200,
    "end-bug-line": 201,
    "bug": "info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE);",
    "fix": "info.getReturnType().evaluate(scope, typeRegistry) : null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSTypeExpression;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionBuilder; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.InstanceObjectType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; import java.util.Set; import javax.annotation.Nullable; final class FunctionTypeBuilder { private final String fnName; private final AbstractCompiler compiler; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private final Node errorRoot; private final String sourceName;"
      },
      {
        "txt": "private final Scope scope; private JSType returnType = null; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null; private boolean isConstructor = false; private boolean isInterface = false; private Node parametersNode = null; private Node sourceNode = null; private String templateTypeName = null;"
      },
      {
        "txt": "static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning( \"JSC_EXTENDS_WITHOUT_TYPEDEF\", \"@extends used without @constructor or @interface for {0}\"); static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning( \"JSC_EXTENDS_NON_OBJECT\", \"{0} @extends non-object type {1}\"); static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR = DiagnosticType.warning( \"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\", \"@implements used without @constructor or @interface for {0}\");"
      },
      {
        "txt": "static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning( \"JSC_VAR_ARGS_MUST_BE_LAST\", \"variable length argument must be last\"); static final DiagnosticType OPTIONAL_ARG_AT_END = DiagnosticType.warning( \"JSC_OPTIONAL_ARG_AT_END\", \"optional arguments must be at the end\"); static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning( \"JSC_INEXISTANT_PARAM\", \"parameter {0} does not appear in {1}''s parameter list\"); static final DiagnosticType TYPE_REDEFINITION = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_TYPE_REDEFINITION\", \"attempted re-definition of type {0}\\n\" + \"found : {1}\\n\" + \"expected: {2}\"); static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_DUPLICATED\", \"Only one parameter type must be the template type\"); static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_EXPECTED\", \"The template type must be a parameter type\");"
      },
      {
        "txt": "FunctionTypeBuilder(String fnName, AbstractCompiler compiler, Node errorRoot, String sourceName, Scope scope) { Preconditions.checkNotNull(errorRoot); this.fnName = fnName == null ? \"\" : fnName; this.codingConvention = compiler.getCodingConvention(); this.typeRegistry = compiler.getTypeRegistry(); this.errorRoot = errorRoot; this.sourceName = sourceName; this.compiler = compiler; this.scope = scope;"
      },
      {
        "txt": "} FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) { this.sourceNode = sourceNode; return this; } FunctionTypeBuilder inferFromOverriddenFunction( FunctionType oldType, @Nullable Node paramsParent) { returnType = oldType.getReturnType(); if (paramsParent == null) { parametersNode = oldType.getParametersNode();"
      },
      {
        "txt": "if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false; for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {"
      },
      {
        "txt": "if (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } else { warnedAboutArgList |= addParameter( paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam), codingConvention.isVarArgsParameter(currentParam)); }"
      },
      {
        "txt": "parametersNode = paramBuilder.build(); } return this; } FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? <extra_id_0> if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } return this; }"
      },
      {
        "txt": "return this; } FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { if (info != null) { isConstructor = info.isConstructor(); isInterface = info.isInterface(); if (info.hasBaseType()) { if (isConstructor || isInterface) { baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry)); if (baseType == null) {"
      },
      {
        "txt": "reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString()); } } else { reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName); } } if (isConstructor || isInterface) { implementedInterfaces = Lists.newArrayList(); for (JSTypeExpression t : info.getImplementedInterfaces()) { ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry));"
      },
      {
        "txt": "if (interType != null) { implementedInterfaces.add(interType); } else { reportError(BAD_IMPLEMENTED_TYPE, fnName); } } if (baseType != null) { JSType maybeFunctionType = baseType.getConstructor(); if (maybeFunctionType instanceof FunctionType) { FunctionType functionType = baseType.getConstructor();"
      },
      {
        "txt": "Iterables.addAll( implementedInterfaces, functionType.getImplementedInterfaces()); } } } else if (info.getImplementedInterfaceCount() > 0) { reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName); } } return this;"
      },
      {
        "txt": "} FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) { ObjectType objType = ObjectType.cast(type); if (objType != null && (info == null || !info.hasType())) { thisType = objType; } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) {"
      },
      {
        "txt": "ObjectType maybeThisType = null; if (info != null && info.hasThisType()) { maybeThisType = ObjectType.cast( info.getThisType().evaluate(scope, typeRegistry)); } if (maybeThisType != null) { thisType = maybeThisType; } else if (owner != null && (info == null || !info.hasType())) { String ownerTypeName = owner.getQualifiedName();"
      },
      {
        "txt": "ObjectType ownerType = ObjectType.cast( typeRegistry.getType( scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno())); if (ownerType != null) { thisType = ownerType; } } return this; }"
      },
      {
        "txt": "FunctionTypeBuilder inferParameterTypes(JSDocInfo info) { Node lp = new Node(Token.LP); for (String name : info.getParameterNames()) { lp.addChildToBack(Node.newString(Token.NAME, name)); } return inferParameterTypes(lp, info); } FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) {"
      },
      {
        "txt": "if (info == null) { return this; } else { return inferParameterTypes(info); } } FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() :"
      },
      {
        "txt": "Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false; for (Node arg : argsParent.children()) { String argumentName = arg.getString(); allJsDocParams.remove(argumentName); JSType parameterType = info != null && info.hasParameterType(argumentName) ? info.getParameterType(argumentName).evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null &&"
      },
      {
        "txt": "parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) { reportError(TEMPLATE_TYPE_DUPLICATED, fnName); } foundTemplateType = true; } warnedAboutArgList |= addParameter( builder, parameterType, warnedAboutArgList, isOptionalParameter(arg, info), isVarArgsParameter(arg, info));"
      },
      {
        "txt": "} if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName); } parametersNode = builder.build(); return this; }"
      },
      {
        "txt": "private boolean isOptionalParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isOptionalParameter(param)) { return true; } String paramName = param.getString(); return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isOptionalArg(); } private boolean isVarArgsParameter("
      },
      {
        "txt": "Node param, @Nullable JSDocInfo info) { if (codingConvention.isVarArgsParameter(param)) { return true; } String paramName = param.getString(); return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isVarArgs(); } FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) { if (info != null) {"
      },
      {
        "txt": "templateTypeName = info.getTemplateTypeName(); typeRegistry.setTemplateTypeName(templateTypeName); } return this; } private boolean addParameter(FunctionParamBuilder builder, JSType paramType, boolean warnedAboutArgList, boolean isOptional, boolean isVarArgs) { boolean emittedWarning = false; if (isOptional) {"
      },
      {
        "txt": "if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else if (isVarArgs) { if (!builder.addVarArgs(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else {"
      },
      {
        "txt": "if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) { if (builder.hasVarArgs()) { reportWarning(VAR_ARGS_MUST_BE_LAST); } else { reportWarning(OPTIONAL_ARG_AT_END); } emittedWarning = true; } } return emittedWarning;"
      },
      {
        "txt": "} FunctionType buildAndRegister() { if (returnType == null) { returnType = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (parametersNode == null) { throw new IllegalStateException( \"All Function types must have params and a return type\"); } FunctionType fnType;"
      },
      {
        "txt": "if (isConstructor) { fnType = getOrCreateConstructor(); } else if (isInterface) { fnType = typeRegistry.createInterfaceType(fnName, sourceNode); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); } maybeSetBaseType(fnType); } else { fnType = new FunctionBuilder(typeRegistry)"
      },
      {
        "txt": ".withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType) .withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build(); maybeSetBaseType(fnType); } if (implementedInterfaces != null) {"
      },
      {
        "txt": "fnType.setImplementedInterfaces(implementedInterfaces); } typeRegistry.clearTemplateTypeName(); return fnType; } private void maybeSetBaseType(FunctionType fnType) { if (baseType != null) { fnType.setPrototypeBasedOn(baseType); } }"
      },
      {
        "txt": "private FunctionType getOrCreateConstructor() { FunctionType fnType = typeRegistry.createConstructorType( fnName, sourceNode, parametersNode, returnType); JSType existingType = typeRegistry.getType(fnName); if (existingType != null) { boolean isInstanceObject = existingType instanceof InstanceObjectType; if (isInstanceObject || fnName.equals(\"Function\")) { FunctionType existingFn = isInstanceObject ? ((InstanceObjectType) existingType).getConstructor() :"
      },
      {
        "txt": "typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE); if (existingFn.getSource() == null) { existingFn.setSource(sourceNode); } if (!existingFn.hasEqualCallType(fnType)) { reportWarning(TYPE_REDEFINITION, fnName, fnType.toString(), existingFn.toString()); } return existingFn; } else {"
      },
      {
        "txt": "} } maybeSetBaseType(fnType); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); } return fnType; } private void reportWarning(DiagnosticType warning, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, warning, args));"
      },
      {
        "txt": "} private void reportError(DiagnosticType error, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, error, args)); } static boolean isFunctionTypeDeclaration(JSDocInfo info) { return info.getParameterCount() > 0 || info.hasReturnType() || info.hasThisType() || info.isConstructor() || info.isInterface();"
      }
    ]
  },
  {
    "id": 571,
    "file_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
    "start-bug-line": 203,
    "end-bug-line": 203,
    "bug": "",
    "fix": "returnType != null &&",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionBuilder;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.InstanceObjectType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import java.util.Set; import javax.annotation.Nullable;"
      },
      {
        "txt": "final class FunctionTypeBuilder { private final String fnName; private final AbstractCompiler compiler; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private final Node errorRoot; private final String sourceName; private final Scope scope; private JSType returnType = null; private List<ObjectType> implementedInterfaces = null;"
      },
      {
        "txt": "private ObjectType baseType = null; private ObjectType thisType = null; private boolean isConstructor = false; private boolean isInterface = false; private Node parametersNode = null; private Node sourceNode = null; private String templateTypeName = null; static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning( \"JSC_EXTENDS_WITHOUT_TYPEDEF\", \"@extends used without @constructor or @interface for {0}\");"
      },
      {
        "txt": "static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning( \"JSC_EXTENDS_NON_OBJECT\", \"{0} @extends non-object type {1}\"); static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR = DiagnosticType.warning( \"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\", \"@implements used without @constructor or @interface for {0}\"); static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning( \"JSC_VAR_ARGS_MUST_BE_LAST\", \"variable length argument must be last\");"
      },
      {
        "txt": "static final DiagnosticType OPTIONAL_ARG_AT_END = DiagnosticType.warning( \"JSC_OPTIONAL_ARG_AT_END\", \"optional arguments must be at the end\"); static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning( \"JSC_INEXISTANT_PARAM\", \"parameter {0} does not appear in {1}''s parameter list\"); static final DiagnosticType TYPE_REDEFINITION = DiagnosticType.warning( \"JSC_TYPE_REDEFINITION\", \"attempted re-definition of type {0}\\n\" + \"found : {1}\\n\""
      },
      {
        "txt": "+ \"expected: {2}\"); static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_DUPLICATED\", \"Only one parameter type must be the template type\"); static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_EXPECTED\", \"The template type must be a parameter type\"); FunctionTypeBuilder(String fnName, AbstractCompiler compiler, Node errorRoot, String sourceName, Scope scope) { Preconditions.checkNotNull(errorRoot);"
      },
      {
        "txt": "this.fnName = fnName == null ? \"\" : fnName; this.codingConvention = compiler.getCodingConvention(); this.typeRegistry = compiler.getTypeRegistry(); this.errorRoot = errorRoot; this.sourceName = sourceName; this.compiler = compiler; this.scope = scope; } FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) { this.sourceNode = sourceNode;"
      },
      {
        "txt": "return this; } FunctionTypeBuilder inferFromOverriddenFunction( FunctionType oldType, @Nullable Node paramsParent) { returnType = oldType.getReturnType(); if (paramsParent == null) { parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); }"
      },
      {
        "txt": "} else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false; for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } else {"
      },
      {
        "txt": "warnedAboutArgList |= addParameter( paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam), codingConvention.isVarArgsParameter(currentParam)); } } parametersNode = paramBuilder.build(); }"
      },
      {
        "txt": "} FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && <extra_id_0> reportError(TEMPLATE_TYPE_EXPECTED, fnName); } return this; } FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { if (info != null) {"
      },
      {
        "txt": "FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { if (info != null) { isConstructor = info.isConstructor(); isInterface = info.isInterface(); if (info.hasBaseType()) { if (isConstructor || isInterface) { baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry)); if (baseType == null) { reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString()); }"
      },
      {
        "txt": "} else { reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName); } } if (isConstructor || isInterface) { implementedInterfaces = Lists.newArrayList(); for (JSTypeExpression t : info.getImplementedInterfaces()) { ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry)); if (interType != null) { implementedInterfaces.add(interType);"
      },
      {
        "txt": "} else { reportError(BAD_IMPLEMENTED_TYPE, fnName); } } if (baseType != null) { JSType maybeFunctionType = baseType.getConstructor(); if (maybeFunctionType instanceof FunctionType) { FunctionType functionType = baseType.getConstructor(); Iterables.addAll( implementedInterfaces,"
      },
      {
        "txt": "functionType.getImplementedInterfaces()); } } } else if (info.getImplementedInterfaceCount() > 0) { reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName); } } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {"
      },
      {
        "txt": "ObjectType objType = ObjectType.cast(type); if (objType != null && (info == null || !info.hasType())) { thisType = objType; } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) { ObjectType maybeThisType = null; if (info != null && info.hasThisType()) {"
      },
      {
        "txt": "maybeThisType = ObjectType.cast( info.getThisType().evaluate(scope, typeRegistry)); } if (maybeThisType != null) { thisType = maybeThisType; } else if (owner != null && (info == null || !info.hasType())) { String ownerTypeName = owner.getQualifiedName(); ObjectType ownerType = ObjectType.cast( typeRegistry.getType("
      },
      {
        "txt": "scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno())); if (ownerType != null) { thisType = ownerType; } } return this; } FunctionTypeBuilder inferParameterTypes(JSDocInfo info) { Node lp = new Node(Token.LP);"
      },
      {
        "txt": "for (String name : info.getParameterNames()) { lp.addChildToBack(Node.newString(Token.NAME, name)); } return inferParameterTypes(lp, info); } FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) { if (info == null) { return this;"
      },
      {
        "txt": "} else { return inferParameterTypes(info); } } FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false;"
      },
      {
        "txt": "for (Node arg : argsParent.children()) { String argumentName = arg.getString(); allJsDocParams.remove(argumentName); JSType parameterType = info != null && info.hasParameterType(argumentName) ? info.getParameterType(argumentName).evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) {"
      },
      {
        "txt": "reportError(TEMPLATE_TYPE_DUPLICATED, fnName); } foundTemplateType = true; } warnedAboutArgList |= addParameter( builder, parameterType, warnedAboutArgList, isOptionalParameter(arg, info), isVarArgsParameter(arg, info)); } if (templateTypeName != null && !foundTemplateType) {"
      },
      {
        "txt": "reportError(TEMPLATE_TYPE_EXPECTED, fnName); } for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName); } parametersNode = builder.build(); return this; } private boolean isOptionalParameter( Node param, @Nullable JSDocInfo info) {"
      },
      {
        "txt": "if (codingConvention.isOptionalParameter(param)) { return true; } String paramName = param.getString(); return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isOptionalArg(); } private boolean isVarArgsParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isVarArgsParameter(param)) {"
      },
      {
        "txt": "return true; } String paramName = param.getString(); return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isVarArgs(); } FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) { if (info != null) { templateTypeName = info.getTemplateTypeName(); typeRegistry.setTemplateTypeName(templateTypeName);"
      },
      {
        "txt": "} return this; } private boolean addParameter(FunctionParamBuilder builder, JSType paramType, boolean warnedAboutArgList, boolean isOptional, boolean isVarArgs) { boolean emittedWarning = false; if (isOptional) { if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST);"
      },
      {
        "txt": "emittedWarning = true; } } else if (isVarArgs) { if (!builder.addVarArgs(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else { if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) { if (builder.hasVarArgs()) {"
      },
      {
        "txt": "reportWarning(VAR_ARGS_MUST_BE_LAST); } else { reportWarning(OPTIONAL_ARG_AT_END); } emittedWarning = true; } } return emittedWarning; } FunctionType buildAndRegister() {"
      },
      {
        "txt": "if (returnType == null) { returnType = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (parametersNode == null) { throw new IllegalStateException( \"All Function types must have params and a return type\"); } FunctionType fnType; if (isConstructor) { fnType = getOrCreateConstructor();"
      },
      {
        "txt": "} else if (isInterface) { fnType = typeRegistry.createInterfaceType(fnName, sourceNode); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); } maybeSetBaseType(fnType); } else { fnType = new FunctionBuilder(typeRegistry) .withName(fnName) .withSourceNode(sourceNode)"
      },
      {
        "txt": ".withParamsNode(parametersNode) .withReturnType(returnType) .withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build(); maybeSetBaseType(fnType); } if (implementedInterfaces != null) { fnType.setImplementedInterfaces(implementedInterfaces); }"
      },
      {
        "txt": "typeRegistry.clearTemplateTypeName(); return fnType; } private void maybeSetBaseType(FunctionType fnType) { if (baseType != null) { fnType.setPrototypeBasedOn(baseType); } } private FunctionType getOrCreateConstructor() { FunctionType fnType = typeRegistry.createConstructorType("
      },
      {
        "txt": "fnName, sourceNode, parametersNode, returnType); JSType existingType = typeRegistry.getType(fnName); if (existingType != null) { boolean isInstanceObject = existingType instanceof InstanceObjectType; if (isInstanceObject || fnName.equals(\"Function\")) { FunctionType existingFn = isInstanceObject ? ((InstanceObjectType) existingType).getConstructor() : typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE); if (existingFn.getSource() == null) {"
      },
      {
        "txt": "existingFn.setSource(sourceNode); } if (!existingFn.hasEqualCallType(fnType)) { reportWarning(TYPE_REDEFINITION, fnName, fnType.toString(), existingFn.toString()); } return existingFn; } else { } }"
      },
      {
        "txt": "maybeSetBaseType(fnType); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); } return fnType; } private void reportWarning(DiagnosticType warning, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, warning, args)); } private void reportError(DiagnosticType error, String ... args) {"
      },
      {
        "txt": "compiler.report(JSError.make(sourceName, errorRoot, error, args)); } static boolean isFunctionTypeDeclaration(JSDocInfo info) { return info.getParameterCount() > 0 || info.hasReturnType() || info.hasThisType() || info.isConstructor() || info.isInterface(); }"
      }
    ]
  },
  {
    "id": 572,
    "file_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
    "start-bug-line": 213,
    "end-bug-line": 213,
    "bug": "",
    "fix": "FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) { if (functionBlock == null || compiler.getInput(sourceName).isExtern()) { return this; } Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK); if (returnType == null) { boolean hasNonEmptyReturns = false; List<Node> worklist = Lists.newArrayList(functionBlock); while (!worklist.isEmpty()) { Node current = worklist.remove(worklist.size() - 1); int cType = current.getType(); if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) { hasNonEmptyReturns = true; break; } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) { for (Node child = current.getFirstChild(); child != null; child = child.getNext()) { worklist.add(child); } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionBuilder; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.InstanceObjectType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeRegistry;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import java.util.Set; import javax.annotation.Nullable; final class FunctionTypeBuilder { private final String fnName; private final AbstractCompiler compiler; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry;"
      },
      {
        "txt": "private final Node errorRoot; private final String sourceName; private final Scope scope; private JSType returnType = null; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null; private boolean isConstructor = false; private boolean isInterface = false; private Node parametersNode = null;"
      },
      {
        "txt": "private Node sourceNode = null; private String templateTypeName = null; static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning( \"JSC_EXTENDS_WITHOUT_TYPEDEF\", \"@extends used without @constructor or @interface for {0}\"); static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning( \"JSC_EXTENDS_NON_OBJECT\", \"{0} @extends non-object type {1}\"); static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\", \"@implements used without @constructor or @interface for {0}\"); static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning( \"JSC_VAR_ARGS_MUST_BE_LAST\", \"variable length argument must be last\"); static final DiagnosticType OPTIONAL_ARG_AT_END = DiagnosticType.warning( \"JSC_OPTIONAL_ARG_AT_END\", \"optional arguments must be at the end\"); static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning( \"JSC_INEXISTANT_PARAM\","
      },
      {
        "txt": "\"parameter {0} does not appear in {1}''s parameter list\"); static final DiagnosticType TYPE_REDEFINITION = DiagnosticType.warning( \"JSC_TYPE_REDEFINITION\", \"attempted re-definition of type {0}\\n\" + \"found : {1}\\n\" + \"expected: {2}\"); static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_DUPLICATED\", \"Only one parameter type must be the template type\"); static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_TEMPLATE_TYPE_EXPECTED\", \"The template type must be a parameter type\"); FunctionTypeBuilder(String fnName, AbstractCompiler compiler, Node errorRoot, String sourceName, Scope scope) { Preconditions.checkNotNull(errorRoot); this.fnName = fnName == null ? \"\" : fnName; this.codingConvention = compiler.getCodingConvention(); this.typeRegistry = compiler.getTypeRegistry(); this.errorRoot = errorRoot; this.sourceName = sourceName;"
      },
      {
        "txt": "this.compiler = compiler; this.scope = scope; } FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) { this.sourceNode = sourceNode; return this; } FunctionTypeBuilder inferFromOverriddenFunction( FunctionType oldType, @Nullable Node paramsParent) { returnType = oldType.getReturnType();"
      },
      {
        "txt": "if (paramsParent == null) { parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false;"
      },
      {
        "txt": "for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } else { warnedAboutArgList |= addParameter( paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam),"
      },
      {
        "txt": "codingConvention.isVarArgsParameter(currentParam)); } } parametersNode = paramBuilder.build(); } return this; } FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) :"
      },
      {
        "txt": "if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } return this; } <extra_id_0> FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { if (info != null) { isConstructor = info.isConstructor(); isInterface = info.isInterface(); if (info.hasBaseType()) { if (isConstructor || isInterface) {"
      },
      {
        "txt": "if (info.hasBaseType()) { if (isConstructor || isInterface) { baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry)); if (baseType == null) { reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString()); } } else { reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName); } }"
      },
      {
        "txt": "if (isConstructor || isInterface) { implementedInterfaces = Lists.newArrayList(); for (JSTypeExpression t : info.getImplementedInterfaces()) { ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry)); if (interType != null) { implementedInterfaces.add(interType); } else { reportError(BAD_IMPLEMENTED_TYPE, fnName); } }"
      },
      {
        "txt": "if (baseType != null) { JSType maybeFunctionType = baseType.getConstructor(); if (maybeFunctionType instanceof FunctionType) { FunctionType functionType = baseType.getConstructor(); Iterables.addAll( implementedInterfaces, functionType.getImplementedInterfaces()); } } } else if (info.getImplementedInterfaceCount() > 0) {"
      },
      {
        "txt": "reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName); } } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) { ObjectType objType = ObjectType.cast(type); if (objType != null && (info == null || !info.hasType())) { thisType = objType; }"
      },
      {
        "txt": "return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) { ObjectType maybeThisType = null; if (info != null && info.hasThisType()) { maybeThisType = ObjectType.cast( info.getThisType().evaluate(scope, typeRegistry)); } if (maybeThisType != null) {"
      },
      {
        "txt": "thisType = maybeThisType; } else if (owner != null && (info == null || !info.hasType())) { String ownerTypeName = owner.getQualifiedName(); ObjectType ownerType = ObjectType.cast( typeRegistry.getType( scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno())); if (ownerType != null) { thisType = ownerType;"
      },
      {
        "txt": "} } return this; } FunctionTypeBuilder inferParameterTypes(JSDocInfo info) { Node lp = new Node(Token.LP); for (String name : info.getParameterNames()) { lp.addChildToBack(Node.newString(Token.NAME, name)); } return inferParameterTypes(lp, info);"
      },
      {
        "txt": "} FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) { if (info == null) { return this; } else { return inferParameterTypes(info); } }"
      },
      {
        "txt": "FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false; for (Node arg : argsParent.children()) { String argumentName = arg.getString(); allJsDocParams.remove(argumentName); JSType parameterType ="
      },
      {
        "txt": "info != null && info.hasParameterType(argumentName) ? info.getParameterType(argumentName).evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) { reportError(TEMPLATE_TYPE_DUPLICATED, fnName); } foundTemplateType = true; }"
      },
      {
        "txt": "warnedAboutArgList |= addParameter( builder, parameterType, warnedAboutArgList, isOptionalParameter(arg, info), isVarArgsParameter(arg, info)); } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName);"
      },
      {
        "txt": "} parametersNode = builder.build(); return this; } private boolean isOptionalParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isOptionalParameter(param)) { return true; } String paramName = param.getString();"
      },
      {
        "txt": "return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isOptionalArg(); } private boolean isVarArgsParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isVarArgsParameter(param)) { return true; } String paramName = param.getString(); return info != null && info.hasParameterType(paramName) &&"
      },
      {
        "txt": "info.getParameterType(paramName).isVarArgs(); } FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) { if (info != null) { templateTypeName = info.getTemplateTypeName(); typeRegistry.setTemplateTypeName(templateTypeName); } return this; } private boolean addParameter(FunctionParamBuilder builder,"
      },
      {
        "txt": "JSType paramType, boolean warnedAboutArgList, boolean isOptional, boolean isVarArgs) { boolean emittedWarning = false; if (isOptional) { if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else if (isVarArgs) { if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {"
      },
      {
        "txt": "reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else { if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) { if (builder.hasVarArgs()) { reportWarning(VAR_ARGS_MUST_BE_LAST); } else { reportWarning(OPTIONAL_ARG_AT_END); }"
      },
      {
        "txt": "emittedWarning = true; } } return emittedWarning; } FunctionType buildAndRegister() { if (returnType == null) { returnType = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (parametersNode == null) {"
      },
      {
        "txt": "throw new IllegalStateException( \"All Function types must have params and a return type\"); } FunctionType fnType; if (isConstructor) { fnType = getOrCreateConstructor(); } else if (isInterface) { fnType = typeRegistry.createInterfaceType(fnName, sourceNode); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType());"
      },
      {
        "txt": "} maybeSetBaseType(fnType); } else { fnType = new FunctionBuilder(typeRegistry) .withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType) .withTypeOfThis(thisType) .withTemplateName(templateTypeName)"
      },
      {
        "txt": ".build(); maybeSetBaseType(fnType); } if (implementedInterfaces != null) { fnType.setImplementedInterfaces(implementedInterfaces); } typeRegistry.clearTemplateTypeName(); return fnType; } private void maybeSetBaseType(FunctionType fnType) {"
      },
      {
        "txt": "if (baseType != null) { fnType.setPrototypeBasedOn(baseType); } } private FunctionType getOrCreateConstructor() { FunctionType fnType = typeRegistry.createConstructorType( fnName, sourceNode, parametersNode, returnType); JSType existingType = typeRegistry.getType(fnName); if (existingType != null) { boolean isInstanceObject = existingType instanceof InstanceObjectType;"
      },
      {
        "txt": "if (isInstanceObject || fnName.equals(\"Function\")) { FunctionType existingFn = isInstanceObject ? ((InstanceObjectType) existingType).getConstructor() : typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE); if (existingFn.getSource() == null) { existingFn.setSource(sourceNode); } if (!existingFn.hasEqualCallType(fnType)) { reportWarning(TYPE_REDEFINITION, fnName,"
      },
      {
        "txt": "fnType.toString(), existingFn.toString()); } return existingFn; } else { } } maybeSetBaseType(fnType); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); }"
      },
      {
        "txt": "return fnType; } private void reportWarning(DiagnosticType warning, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, warning, args)); } private void reportError(DiagnosticType error, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, error, args)); } static boolean isFunctionTypeDeclaration(JSDocInfo info) { return info.getParameterCount() > 0 ||"
      },
      {
        "txt": "info.hasReturnType() || info.hasThisType() || info.isConstructor() || info.isInterface(); }"
      }
    ]
  },
  {
    "id": 573,
    "file_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
    "start-bug-line": 214,
    "end-bug-line": 214,
    "bug": "",
    "fix": "if (!hasNonEmptyReturns) { returnType = typeRegistry.getNativeType(VOID_TYPE); returnTypeInferred = true; } } return this; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionBuilder; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.InstanceObjectType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeRegistry;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import java.util.Set; import javax.annotation.Nullable; final class FunctionTypeBuilder { private final String fnName; private final AbstractCompiler compiler; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry;"
      },
      {
        "txt": "private final Node errorRoot; private final String sourceName; private final Scope scope; private JSType returnType = null; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null; private boolean isConstructor = false; private boolean isInterface = false; private Node parametersNode = null;"
      },
      {
        "txt": "private Node sourceNode = null; private String templateTypeName = null; static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning( \"JSC_EXTENDS_WITHOUT_TYPEDEF\", \"@extends used without @constructor or @interface for {0}\"); static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning( \"JSC_EXTENDS_NON_OBJECT\", \"{0} @extends non-object type {1}\"); static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\", \"@implements used without @constructor or @interface for {0}\"); static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning( \"JSC_VAR_ARGS_MUST_BE_LAST\", \"variable length argument must be last\"); static final DiagnosticType OPTIONAL_ARG_AT_END = DiagnosticType.warning( \"JSC_OPTIONAL_ARG_AT_END\", \"optional arguments must be at the end\"); static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning( \"JSC_INEXISTANT_PARAM\","
      },
      {
        "txt": "\"parameter {0} does not appear in {1}''s parameter list\"); static final DiagnosticType TYPE_REDEFINITION = DiagnosticType.warning( \"JSC_TYPE_REDEFINITION\", \"attempted re-definition of type {0}\\n\" + \"found : {1}\\n\" + \"expected: {2}\"); static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_DUPLICATED\", \"Only one parameter type must be the template type\"); static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_TEMPLATE_TYPE_EXPECTED\", \"The template type must be a parameter type\"); FunctionTypeBuilder(String fnName, AbstractCompiler compiler, Node errorRoot, String sourceName, Scope scope) { Preconditions.checkNotNull(errorRoot); this.fnName = fnName == null ? \"\" : fnName; this.codingConvention = compiler.getCodingConvention(); this.typeRegistry = compiler.getTypeRegistry(); this.errorRoot = errorRoot; this.sourceName = sourceName;"
      },
      {
        "txt": "this.compiler = compiler; this.scope = scope; } FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) { this.sourceNode = sourceNode; return this; } FunctionTypeBuilder inferFromOverriddenFunction( FunctionType oldType, @Nullable Node paramsParent) { returnType = oldType.getReturnType();"
      },
      {
        "txt": "if (paramsParent == null) { parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false;"
      },
      {
        "txt": "for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } else { warnedAboutArgList |= addParameter( paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam),"
      },
      {
        "txt": "codingConvention.isVarArgsParameter(currentParam)); } } parametersNode = paramBuilder.build(); } return this; } FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) :"
      },
      {
        "txt": "if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } return this; } <extra_id_0> FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { if (info != null) { isConstructor = info.isConstructor(); isInterface = info.isInterface(); if (info.hasBaseType()) { if (isConstructor || isInterface) {"
      },
      {
        "txt": "if (info.hasBaseType()) { if (isConstructor || isInterface) { baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry)); if (baseType == null) { reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString()); } } else { reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName); } }"
      },
      {
        "txt": "if (isConstructor || isInterface) { implementedInterfaces = Lists.newArrayList(); for (JSTypeExpression t : info.getImplementedInterfaces()) { ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry)); if (interType != null) { implementedInterfaces.add(interType); } else { reportError(BAD_IMPLEMENTED_TYPE, fnName); } }"
      },
      {
        "txt": "if (baseType != null) { JSType maybeFunctionType = baseType.getConstructor(); if (maybeFunctionType instanceof FunctionType) { FunctionType functionType = baseType.getConstructor(); Iterables.addAll( implementedInterfaces, functionType.getImplementedInterfaces()); } } } else if (info.getImplementedInterfaceCount() > 0) {"
      },
      {
        "txt": "reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName); } } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) { ObjectType objType = ObjectType.cast(type); if (objType != null && (info == null || !info.hasType())) { thisType = objType; }"
      },
      {
        "txt": "return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) { ObjectType maybeThisType = null; if (info != null && info.hasThisType()) { maybeThisType = ObjectType.cast( info.getThisType().evaluate(scope, typeRegistry)); } if (maybeThisType != null) {"
      },
      {
        "txt": "thisType = maybeThisType; } else if (owner != null && (info == null || !info.hasType())) { String ownerTypeName = owner.getQualifiedName(); ObjectType ownerType = ObjectType.cast( typeRegistry.getType( scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno())); if (ownerType != null) { thisType = ownerType;"
      },
      {
        "txt": "} } return this; } FunctionTypeBuilder inferParameterTypes(JSDocInfo info) { Node lp = new Node(Token.LP); for (String name : info.getParameterNames()) { lp.addChildToBack(Node.newString(Token.NAME, name)); } return inferParameterTypes(lp, info);"
      },
      {
        "txt": "} FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) { if (info == null) { return this; } else { return inferParameterTypes(info); } }"
      },
      {
        "txt": "FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false; for (Node arg : argsParent.children()) { String argumentName = arg.getString(); allJsDocParams.remove(argumentName); JSType parameterType ="
      },
      {
        "txt": "info != null && info.hasParameterType(argumentName) ? info.getParameterType(argumentName).evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) { reportError(TEMPLATE_TYPE_DUPLICATED, fnName); } foundTemplateType = true; }"
      },
      {
        "txt": "warnedAboutArgList |= addParameter( builder, parameterType, warnedAboutArgList, isOptionalParameter(arg, info), isVarArgsParameter(arg, info)); } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName);"
      },
      {
        "txt": "} parametersNode = builder.build(); return this; } private boolean isOptionalParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isOptionalParameter(param)) { return true; } String paramName = param.getString();"
      },
      {
        "txt": "return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isOptionalArg(); } private boolean isVarArgsParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isVarArgsParameter(param)) { return true; } String paramName = param.getString(); return info != null && info.hasParameterType(paramName) &&"
      },
      {
        "txt": "info.getParameterType(paramName).isVarArgs(); } FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) { if (info != null) { templateTypeName = info.getTemplateTypeName(); typeRegistry.setTemplateTypeName(templateTypeName); } return this; } private boolean addParameter(FunctionParamBuilder builder,"
      },
      {
        "txt": "JSType paramType, boolean warnedAboutArgList, boolean isOptional, boolean isVarArgs) { boolean emittedWarning = false; if (isOptional) { if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else if (isVarArgs) { if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {"
      },
      {
        "txt": "reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else { if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) { if (builder.hasVarArgs()) { reportWarning(VAR_ARGS_MUST_BE_LAST); } else { reportWarning(OPTIONAL_ARG_AT_END); }"
      },
      {
        "txt": "emittedWarning = true; } } return emittedWarning; } FunctionType buildAndRegister() { if (returnType == null) { returnType = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (parametersNode == null) {"
      },
      {
        "txt": "throw new IllegalStateException( \"All Function types must have params and a return type\"); } FunctionType fnType; if (isConstructor) { fnType = getOrCreateConstructor(); } else if (isInterface) { fnType = typeRegistry.createInterfaceType(fnName, sourceNode); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType());"
      },
      {
        "txt": "} maybeSetBaseType(fnType); } else { fnType = new FunctionBuilder(typeRegistry) .withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType) .withTypeOfThis(thisType) .withTemplateName(templateTypeName)"
      },
      {
        "txt": ".build(); maybeSetBaseType(fnType); } if (implementedInterfaces != null) { fnType.setImplementedInterfaces(implementedInterfaces); } typeRegistry.clearTemplateTypeName(); return fnType; } private void maybeSetBaseType(FunctionType fnType) {"
      },
      {
        "txt": "if (baseType != null) { fnType.setPrototypeBasedOn(baseType); } } private FunctionType getOrCreateConstructor() { FunctionType fnType = typeRegistry.createConstructorType( fnName, sourceNode, parametersNode, returnType); JSType existingType = typeRegistry.getType(fnName); if (existingType != null) { boolean isInstanceObject = existingType instanceof InstanceObjectType;"
      },
      {
        "txt": "if (isInstanceObject || fnName.equals(\"Function\")) { FunctionType existingFn = isInstanceObject ? ((InstanceObjectType) existingType).getConstructor() : typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE); if (existingFn.getSource() == null) { existingFn.setSource(sourceNode); } if (!existingFn.hasEqualCallType(fnType)) { reportWarning(TYPE_REDEFINITION, fnName,"
      },
      {
        "txt": "fnType.toString(), existingFn.toString()); } return existingFn; } else { } } maybeSetBaseType(fnType); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); }"
      },
      {
        "txt": "return fnType; } private void reportWarning(DiagnosticType warning, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, warning, args)); } private void reportError(DiagnosticType error, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, error, args)); } static boolean isFunctionTypeDeclaration(JSDocInfo info) { return info.getParameterCount() > 0 ||"
      },
      {
        "txt": "info.hasReturnType() || info.hasThisType() || info.isConstructor() || info.isInterface(); }"
      }
    ]
  },
  {
    "id": 574,
    "file_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
    "start-bug-line": 496,
    "end-bug-line": 496,
    "bug": ".withReturnType(returnType)",
    "fix": ".withReturnType(returnType, returnTypeInferred)",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionBuilder; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.InstanceObjectType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Set; import javax.annotation.Nullable; final class FunctionTypeBuilder { private final String fnName; private final AbstractCompiler compiler; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private final Node errorRoot;"
      },
      {
        "txt": "private final String sourceName; private final Scope scope; private JSType returnType = null; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null; private boolean isConstructor = false; private boolean isInterface = false; private Node parametersNode = null; private Node sourceNode = null;"
      },
      {
        "txt": "private String templateTypeName = null; static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning( \"JSC_EXTENDS_WITHOUT_TYPEDEF\", \"@extends used without @constructor or @interface for {0}\"); static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning( \"JSC_EXTENDS_NON_OBJECT\", \"{0} @extends non-object type {1}\"); static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR = DiagnosticType.warning( \"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\","
      },
      {
        "txt": "\"@implements used without @constructor or @interface for {0}\"); static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning( \"JSC_VAR_ARGS_MUST_BE_LAST\", \"variable length argument must be last\"); static final DiagnosticType OPTIONAL_ARG_AT_END = DiagnosticType.warning( \"JSC_OPTIONAL_ARG_AT_END\", \"optional arguments must be at the end\"); static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning( \"JSC_INEXISTANT_PARAM\", \"parameter {0} does not appear in {1}''s parameter list\");"
      },
      {
        "txt": "static final DiagnosticType TYPE_REDEFINITION = DiagnosticType.warning( \"JSC_TYPE_REDEFINITION\", \"attempted re-definition of type {0}\\n\" + \"found : {1}\\n\" + \"expected: {2}\"); static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_DUPLICATED\", \"Only one parameter type must be the template type\"); static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error( \"JSC_TEMPLATE_TYPE_EXPECTED\","
      },
      {
        "txt": "\"The template type must be a parameter type\"); FunctionTypeBuilder(String fnName, AbstractCompiler compiler, Node errorRoot, String sourceName, Scope scope) { Preconditions.checkNotNull(errorRoot); this.fnName = fnName == null ? \"\" : fnName; this.codingConvention = compiler.getCodingConvention(); this.typeRegistry = compiler.getTypeRegistry(); this.errorRoot = errorRoot; this.sourceName = sourceName; this.compiler = compiler;"
      },
      {
        "txt": "this.scope = scope; } FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) { this.sourceNode = sourceNode; return this; } FunctionTypeBuilder inferFromOverriddenFunction( FunctionType oldType, @Nullable Node paramsParent) { returnType = oldType.getReturnType(); if (paramsParent == null) {"
      },
      {
        "txt": "parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false; for (Node currentParam = paramsParent.getFirstChild();"
      },
      {
        "txt": "currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } else { warnedAboutArgList |= addParameter( paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam), codingConvention.isVarArgsParameter(currentParam));"
      },
      {
        "txt": "} } parametersNode = paramBuilder.build(); } return this; } FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } return this; } FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { if (info != null) { isConstructor = info.isConstructor(); isInterface = info.isInterface();"
      },
      {
        "txt": "if (info.hasBaseType()) { if (isConstructor || isInterface) { baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry)); if (baseType == null) { reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString()); } } else { reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName); } }"
      },
      {
        "txt": "if (isConstructor || isInterface) { implementedInterfaces = Lists.newArrayList(); for (JSTypeExpression t : info.getImplementedInterfaces()) { ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry)); if (interType != null) { implementedInterfaces.add(interType); } else { reportError(BAD_IMPLEMENTED_TYPE, fnName); } }"
      },
      {
        "txt": "if (baseType != null) { JSType maybeFunctionType = baseType.getConstructor(); if (maybeFunctionType instanceof FunctionType) { FunctionType functionType = baseType.getConstructor(); Iterables.addAll( implementedInterfaces, functionType.getImplementedInterfaces()); } } } else if (info.getImplementedInterfaceCount() > 0) {"
      },
      {
        "txt": "reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName); } } return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) { ObjectType objType = ObjectType.cast(type); if (objType != null && (info == null || !info.hasType())) { thisType = objType; }"
      },
      {
        "txt": "return this; } FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) { ObjectType maybeThisType = null; if (info != null && info.hasThisType()) { maybeThisType = ObjectType.cast( info.getThisType().evaluate(scope, typeRegistry)); } if (maybeThisType != null) {"
      },
      {
        "txt": "thisType = maybeThisType; } else if (owner != null && (info == null || !info.hasType())) { String ownerTypeName = owner.getQualifiedName(); ObjectType ownerType = ObjectType.cast( typeRegistry.getType( scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno())); if (ownerType != null) { thisType = ownerType;"
      },
      {
        "txt": "} } return this; } FunctionTypeBuilder inferParameterTypes(JSDocInfo info) { Node lp = new Node(Token.LP); for (String name : info.getParameterNames()) { lp.addChildToBack(Node.newString(Token.NAME, name)); } return inferParameterTypes(lp, info);"
      },
      {
        "txt": "} FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) { if (info == null) { return this; } else { return inferParameterTypes(info); } }"
      },
      {
        "txt": "FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false; for (Node arg : argsParent.children()) { String argumentName = arg.getString(); allJsDocParams.remove(argumentName); JSType parameterType ="
      },
      {
        "txt": "info != null && info.hasParameterType(argumentName) ? info.getParameterType(argumentName).evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) { reportError(TEMPLATE_TYPE_DUPLICATED, fnName); } foundTemplateType = true; }"
      },
      {
        "txt": "warnedAboutArgList |= addParameter( builder, parameterType, warnedAboutArgList, isOptionalParameter(arg, info), isVarArgsParameter(arg, info)); } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName);"
      },
      {
        "txt": "} parametersNode = builder.build(); return this; } private boolean isOptionalParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isOptionalParameter(param)) { return true; } String paramName = param.getString();"
      },
      {
        "txt": "return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isOptionalArg(); } private boolean isVarArgsParameter( Node param, @Nullable JSDocInfo info) { if (codingConvention.isVarArgsParameter(param)) { return true; } String paramName = param.getString(); return info != null && info.hasParameterType(paramName) &&"
      },
      {
        "txt": "info.getParameterType(paramName).isVarArgs(); } FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) { if (info != null) { templateTypeName = info.getTemplateTypeName(); typeRegistry.setTemplateTypeName(templateTypeName); } return this; } private boolean addParameter(FunctionParamBuilder builder,"
      },
      {
        "txt": "JSType paramType, boolean warnedAboutArgList, boolean isOptional, boolean isVarArgs) { boolean emittedWarning = false; if (isOptional) { if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) { reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else if (isVarArgs) { if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {"
      },
      {
        "txt": "reportWarning(VAR_ARGS_MUST_BE_LAST); emittedWarning = true; } } else { if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) { if (builder.hasVarArgs()) { reportWarning(VAR_ARGS_MUST_BE_LAST); } else { reportWarning(OPTIONAL_ARG_AT_END); }"
      },
      {
        "txt": "emittedWarning = true; } } return emittedWarning; } FunctionType buildAndRegister() { if (returnType == null) { returnType = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (parametersNode == null) {"
      },
      {
        "txt": "throw new IllegalStateException( \"All Function types must have params and a return type\"); } FunctionType fnType; if (isConstructor) { fnType = getOrCreateConstructor(); } else if (isInterface) { fnType = typeRegistry.createInterfaceType(fnName, sourceNode); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType());"
      },
      {
        "txt": "maybeSetBaseType(fnType); } else { fnType = new FunctionBuilder(typeRegistry) .withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) <extra_id_0> .withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build(); maybeSetBaseType(fnType); } if (implementedInterfaces != null) {"
      },
      {
        "txt": "} if (implementedInterfaces != null) { fnType.setImplementedInterfaces(implementedInterfaces); } typeRegistry.clearTemplateTypeName(); return fnType; } private void maybeSetBaseType(FunctionType fnType) { if (baseType != null) { fnType.setPrototypeBasedOn(baseType);"
      },
      {
        "txt": "} } private FunctionType getOrCreateConstructor() { FunctionType fnType = typeRegistry.createConstructorType( fnName, sourceNode, parametersNode, returnType); JSType existingType = typeRegistry.getType(fnName); if (existingType != null) { boolean isInstanceObject = existingType instanceof InstanceObjectType; if (isInstanceObject || fnName.equals(\"Function\")) { FunctionType existingFn ="
      },
      {
        "txt": "isInstanceObject ? ((InstanceObjectType) existingType).getConstructor() : typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE); if (existingFn.getSource() == null) { existingFn.setSource(sourceNode); } if (!existingFn.hasEqualCallType(fnType)) { reportWarning(TYPE_REDEFINITION, fnName, fnType.toString(), existingFn.toString()); }"
      },
      {
        "txt": "return existingFn; } else { } } maybeSetBaseType(fnType); if (scope.isGlobal() && !fnName.isEmpty()) { typeRegistry.declareType(fnName, fnType.getInstanceType()); } return fnType; }"
      },
      {
        "txt": "private void reportWarning(DiagnosticType warning, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, warning, args)); } private void reportError(DiagnosticType error, String ... args) { compiler.report(JSError.make(sourceName, errorRoot, error, args)); } static boolean isFunctionTypeDeclaration(JSDocInfo info) { return info.getParameterCount() > 0 || info.hasReturnType() || info.hasThisType() ||"
      },
      {
        "txt": "info.isConstructor() || info.isInterface(); }"
      }
    ]
  },
  {
    "id": 575,
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
    "start-bug-line": 577,
    "end-bug-line": 577,
    "bug": "",
    "fix": "Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP; import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT; import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.CodingConvention.SubclassType; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import javax.annotation.Nullable; final class TypedScopeCreator implements ScopeCreator {"
      },
      {
        "txt": "static final DiagnosticType MALFORMED_TYPEDEF = DiagnosticType.warning( \"JSC_MALFORMED_TYPEDEF\", \"Typedef for {0} does not have any type information\"); static final DiagnosticType ENUM_INITIALIZER = DiagnosticType.warning( \"JSC_ENUM_INITIALIZER_NOT_ENUM\", \"enum initializer must be an object literal or an enum\"); static final DiagnosticType CONSTRUCTOR_EXPECTED = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_REFLECT_CONSTRUCTOR_EXPECTED\", \"Constructor expected as first argument\"); private final AbstractCompiler compiler; private final ErrorReporter typeParsingErrorReporter; private final TypeValidator validator; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList(); private class DeferredSetType { final Node node;"
      },
      {
        "txt": "final JSType type; DeferredSetType(Node node, JSType type) { Preconditions.checkNotNull(node); Preconditions.checkNotNull(type); this.node = node; this.type = type; node.setJSType(type); } void resolve(Scope scope) { node.setJSType(type.resolve(typeParsingErrorReporter, scope));"
      },
      {
        "txt": "} } TypedScopeCreator(AbstractCompiler compiler) { this(compiler, compiler.getCodingConvention()); } TypedScopeCreator(AbstractCompiler compiler, CodingConvention codingConvention) { this.compiler = compiler; this.validator = compiler.getTypeValidator(); this.codingConvention = codingConvention;"
      },
      {
        "txt": "this.typeRegistry = compiler.getTypeRegistry(); this.typeParsingErrorReporter = typeRegistry.getErrorReporter(); } public Scope createScope(Node root, Scope parent) { Scope newScope = null; if (parent == null) { newScope = createInitialScope(root); GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope); NodeTraversal.traverse(compiler, root, scopeBuilder); scopeBuilder.resolveStubDeclarations();"
      },
      {
        "txt": "scopeBuilder.resolveTypes(); for (Node functionNode : scopeBuilder.nonExternFunctions) { JSType type = functionNode.getJSType(); if (type != null && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; ObjectType fnThisType = fnType.getTypeOfThis(); if (!fnThisType.isUnknownType()) { NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType)); }"
      },
      {
        "txt": "} } codingConvention.defineDelegateProxyPrototypeProperties( typeRegistry, newScope, delegateProxyPrototypes); } else { newScope = new Scope(parent, root); LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope); scopeBuilder.build(); scopeBuilder.resolveTypes(); }"
      },
      {
        "txt": "return newScope; } @VisibleForTesting Scope createInitialScope(Node root) { NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry)); Scope s = new Scope(root, compiler); declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE); declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, DATE_FUNCTION_TYPE); declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE); declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE); declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE); declareNativeValueType(s, \"undefined\", VOID_TYPE); declareNativeValueType(s, \"goog.typedef\", NO_TYPE); declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE); return s; } private void declareNativeFunctionType(Scope scope, JSTypeNative tId) { FunctionType t = typeRegistry.getNativeFunctionType(tId); declareNativeType(scope, t.getInstanceType().getReferenceName(), t); declareNativeType("
      },
      {
        "txt": "scope, t.getPrototype().getReferenceName(), t.getPrototype()); } private void declareNativeValueType(Scope scope, String name, JSTypeNative tId) { declareNativeType(scope, name, typeRegistry.getNativeType(tId)); } private void declareNativeType(Scope scope, String name, JSType t) { scope.declare(name, null, t, null, false); } private static class DiscoverEnums extends AbstractShallowCallback {"
      },
      {
        "txt": "private final JSTypeRegistry registry; DiscoverEnums(JSTypeRegistry registry) { this.registry = registry; } @Override public void visit(NodeTraversal t, Node node, Node parent) { Node nameNode = null; switch (node.getType()) { case Token.NAME: nameNode = node;"
      },
      {
        "txt": "break; case Token.VAR: if (node.hasOneChild()) { nameNode = node.getFirstChild(); } break; case Token.ASSIGN: nameNode = node.getFirstChild(); break; }"
      },
      {
        "txt": "if (nameNode != null) { JSDocInfo info = node.getJSDocInfo(); if (info != null && info.hasEnumParameterType()) { registry.identifyEnumName(nameNode.getQualifiedName()); } } } } private static Node getPrototypePropertyOwner(Node n) { if (n.getType() == Token.GETPROP) {"
      },
      {
        "txt": "Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.getLastChild().getString().equals(\"prototype\")) { Node maybeOwner = firstChild.getFirstChild(); if (maybeOwner.isQualifiedName()) { return maybeOwner; } } } return null;"
      },
      {
        "txt": "} private abstract class AbstractScopeBuilder implements NodeTraversal.Callback { final Scope scope; private final List<DeferredSetType> deferredSetTypes = Lists.newArrayList(); private String sourceName = null; private AbstractScopeBuilder(Scope scope) { this.scope = scope; }"
      },
      {
        "txt": "void setDeferredType(Node node, JSType type) { deferredSetTypes.add(new DeferredSetType(node, type)); } void resolveTypes() { for (DeferredSetType deferred : deferredSetTypes) { deferred.resolve(scope); } Iterator<Var> vars = scope.getVars(); while (vars.hasNext()) { vars.next().resolveType(typeParsingErrorReporter);"
      },
      {
        "txt": "} typeRegistry.resolveTypesInScope(scope); } @Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); }"
      },
      {
        "txt": "return parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild() || parent == scope.getRootNode(); } @Override public abstract void visit(NodeTraversal t, Node n, Node parent); JSType getDeclaredTypeInAnnotation( NodeTraversal t, Node node, JSDocInfo info) { return getDeclaredTypeInAnnotation(t.getSourceName(), node, info); } JSType getDeclaredTypeInAnnotation(String sourceName,"
      },
      {
        "txt": "Node node, JSDocInfo info) { JSType jsType = null; Node objNode = node.getType() == Token.GETPROP ? node.getFirstChild() : null; if (info != null) { if (info.hasType()) { jsType = info.getType().evaluate(scope, typeRegistry); } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { String fnName = node.getQualifiedName(); if (info.isConstructor() && typeRegistry.getType(fnName) != null) {"
      },
      {
        "txt": "return null; } FunctionTypeBuilder builder = new FunctionTypeBuilder( fnName, compiler, node, sourceName, scope) .inferTemplateTypeName(info) .inferReturnType(info) .inferParameterTypes(info) .inferInheritance(info); boolean searchedForThisType = false;"
      },
      {
        "txt": "if (objNode != null) { if (objNode.getType() == Token.GETPROP && objNode.getLastChild().getString().equals(\"prototype\")) { builder.inferThisType(info, objNode.getFirstChild()); searchedForThisType = true; } else if (objNode.getType() == Token.THIS) { builder.inferThisType(info, objNode.getJSType()); searchedForThisType = true; } }"
      },
      {
        "txt": "if (!searchedForThisType) { builder.inferThisType(info, (Node) null); } jsType = builder.buildAndRegister(); } } return jsType; } void define(Node n, Node parent) { Preconditions.checkState(sourceName != null);"
      },
      {
        "txt": "JSDocInfo info = n.getJSDocInfo(); switch (n.getType()) { case Token.CATCH: Node catchName = n.getFirstChild(); defineSlot(catchName, n, null); break; case Token.VAR: if (n.getChildCount() > 1) { if (info != null) { compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));"
      },
      {
        "txt": "} for (Node name : n.children()) { defineName(name, n, parent, name.getJSDocInfo()); } } else { Node name = n.getFirstChild(); defineName(name, n, parent, (info != null) ? info : name.getJSDocInfo()); } break;"
      },
      {
        "txt": "case Token.FUNCTION: int parentType = parent.getType(); Preconditions.checkState( (scope.isLocal() || parentType != Token.ASSIGN) && parentType != Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\"); String functionName = n.getFirstChild().getString(); FunctionType functionType = getFunctionType(functionName, n, info, null);"
      },
      {
        "txt": "if (NodeUtil.isFunctionDeclaration(n)) { defineSlot(n.getFirstChild(), n, functionType); } break; case Token.ASSIGN: Node rvalue = n.getLastChild(); Node lvalue = n.getFirstChild(); info = (info != null) ? info : rvalue.getJSDocInfo(); if (rvalue.getType() == Token.FUNCTION || info != null && info.isConstructor()) {"
      },
      {
        "txt": "getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue); } else if (info != null && info.hasEnumParameterType()) { JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry)); if (type != null) { setDeferredType(lvalue, type); } } break;"
      },
      {
        "txt": "default: throw new IllegalStateException(Integer.toString(n.getType())); } } private void defineName(Node name, Node var, Node parent, JSDocInfo info) { Node value = name.getFirstChild(); if (value != null && value.getType() == Token.FUNCTION) { String functionName = name.getString(); FunctionType functionType = getFunctionType(functionName, value, info, null);"
      },
      {
        "txt": "if (functionType.isReturnTypeInferred() && scope.isLocal()) { defineSlot(name, var, null); } else { defineSlot(name, var, functionType); } } else { JSType type = null; if (info == null) { CompilerInput input = compiler.getInput(sourceName);"
      },
      {
        "txt": "Preconditions.checkNotNull(input, sourceName); type = input.isExtern() ? typeRegistry.getNativeType(UNKNOWN_TYPE) : null; } else if (info.hasEnumParameterType()) { type = getEnumType(name.getString(), var, value, info.getEnumParameterType().evaluate(scope, typeRegistry)); } else if (info.isConstructor()) { type = getFunctionType(name.getString(), value, info, name); } else { type = getDeclaredTypeInAnnotation(sourceName, name, info);"
      },
      {
        "txt": "} defineSlot(name, var, type); } } private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) { FunctionType functionType = null; if (rValue != null && rValue.isQualifiedName()) { Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() instanceof FunctionType) {"
      },
      {
        "txt": "functionType = (FunctionType) var.getType(); if (functionType != null && functionType.isConstructor()) { typeRegistry.declareType(name, functionType.getInstanceType()); } } return functionType; } Node owner = null; if (lvalueNode != null) { owner = getPrototypePropertyOwner(lvalueNode);"
      },
      {
        "txt": "Node errorRoot = rValue == null ? lvalueNode : rValue; boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION; Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; <extra_id_0> if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry); type = type.restrictByNotNullOrUndefined(); if (type.isFunctionType()) { functionType = (FunctionType) type; functionType.setJSDocInfo(info);"
      },
      {
        "txt": "functionType = (FunctionType) type; functionType.setJSDocInfo(info); } } if (functionType == null) { if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) { Var var = scope.getVar("
      },
      {
        "txt": "lvalueNode.getFirstChild().getQualifiedName()); if (var != null) { ObjectType ownerType = ObjectType.cast(var.getType()); FunctionType propType = null; if (ownerType != null) { String propName = lvalueNode.getLastChild().getString(); propType = findOverriddenFunction(ownerType, propName); } if (propType != null) { functionType ="
      },
      {
        "txt": "new FunctionTypeBuilder( name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferFromOverriddenFunction(propType, parametersNode) .inferThisType(info, owner) .buildAndRegister(); } } } }"
      },
      {
        "txt": "} // end if (functionType == null) if (functionType == null) { functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferTemplateTypeName(info) .inferReturnType(info) .inferInheritance(info) .inferThisType(info, owner)"
      },
      {
        "txt": ".inferParameterTypes(parametersNode, info) .buildAndRegister(); } if (rValue != null) { setDeferredType(rValue, functionType); } return functionType; } private FunctionType findOverriddenFunction( ObjectType ownerType, String propName) {"
      },
      {
        "txt": "JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; }"
      },
      {
        "txt": "} } return null; } private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) { EnumType enumType = null; if (value != null) { if (value.getType() == Token.OBJECTLIT) { enumType = typeRegistry.createEnumType(name, elementsType);"
      },
      {
        "txt": "Node key = value.getFirstChild(); while (key != null) { String keyName = NodeUtil.getStringValue(key); if (enumType.hasOwnProperty(keyName)) { compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName)); } else if (!codingConvention.isValidEnumKey(keyName)) { compiler.report( JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else { enumType.defineElement(keyName);"
      },
      {
        "txt": "} key = key.getNext(); key = (key == null) ? null : key.getNext(); } } else if (value.isQualifiedName()) { Var var = scope.getVar(value.getQualifiedName()); if (var != null && var.getType() instanceof EnumType) { enumType = (EnumType) var.getType(); } }"
      },
      {
        "txt": "} if (enumType == null) { compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER)); } else if (scope.isGlobal()) { if (name != null && !name.isEmpty()) { typeRegistry.declareType(name, enumType.getElementsType()); } } return enumType; }"
      },
      {
        "txt": "private void defineSlot(Node name, Node parent, JSType type) { defineSlot(name, parent, type, type == null); } void defineSlot(Node n, Node parent, JSType type, boolean inferred) { Preconditions.checkArgument(inferred || type != null); boolean shouldDeclareOnGlobalThis = false; if (n.getType() == Token.NAME) { Preconditions.checkArgument( parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR ||"
      },
      {
        "txt": "parent.getType() == Token.LP || parent.getType() == Token.CATCH); shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION); } else { Preconditions.checkArgument( n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));"
      },
      {
        "txt": "} String variableName = n.getQualifiedName(); Preconditions.checkArgument(!variableName.isEmpty()); if (scope.isDeclared(variableName, false)) { Var oldVar = scope.getVar(variableName); validator.expectUndeclaredVariable( sourceName, n, parent, oldVar, variableName, type); } else { if (!inferred) { setDeferredType(n, type);"
      },
      {
        "txt": "} CompilerInput input = compiler.getInput(sourceName); scope.declare(variableName, n, type, input, inferred); if (shouldDeclareOnGlobalThis) { ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS); boolean isExtern = input.isExtern(); if (inferred) { globalThis.defineInferredProperty(variableName, type == null ?"
      },
      {
        "txt": "typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern); } else { globalThis.defineDeclaredProperty(variableName, type, isExtern); } } if (scope.isGlobal() && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; if (fnType.isConstructor() || fnType.isInterface()) {"
      },
      {
        "txt": "FunctionType superClassCtor = fnType.getSuperClassConstructor(); scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null || superClassCtor.getInstanceType().equals( typeRegistry.getNativeType(OBJECT_TYPE))); } } } }"
      },
      {
        "txt": "} private final class GlobalScopeBuilder extends AbstractScopeBuilder { private final List<Node> nonExternFunctions = Lists.newArrayList(); private final List<StubDeclaration> stubDeclarations = Lists.newArrayList(); private GlobalScopeBuilder(Scope scope) { super(scope); } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.CALL: SubclassRelationship relationship = codingConvention.getClassesDefinedByCall(n); if (relationship != null) { ObjectType superClass = ObjectType.cast( typeRegistry.getType(relationship.superclassName)); ObjectType subClass = ObjectType.cast( typeRegistry.getType(relationship.subclassName)); if (superClass != null && subClass != null) { FunctionType superCtor = superClass.getConstructor();"
      },
      {
        "txt": "FunctionType subCtor = subClass.getConstructor(); if (relationship.type == SubclassType.INHERITS) { validator.expectSuperType(t, n, superClass, subClass); } if (superCtor != null && subCtor != null) { codingConvention.applySubclassRelationship( superCtor, subCtor, relationship.type); } } }"
      },
      {
        "txt": "String singletonGetterClassName = codingConvention.getSingletonGetterClassName(n); if (singletonGetterClassName != null) { ObjectType objectType = ObjectType.cast( typeRegistry.getType(singletonGetterClassName)); if (objectType != null) { FunctionType functionType = objectType.getConstructor(); if (functionType != null) { FunctionType getterType = typeRegistry.createFunctionType(objectType);"
      },
      {
        "txt": "codingConvention.applySingletonGetter(functionType, getterType, objectType); } } } DelegateRelationship delegateRelationship = codingConvention.getDelegateRelationship(n); if (delegateRelationship != null) { applyDelegateRelationship(delegateRelationship); }"
      },
      {
        "txt": "ObjectLiteralCast objectLiteralCast = codingConvention.getObjectLiteralCast(t, n); if (objectLiteralCast != null) { ObjectType type = ObjectType.cast( typeRegistry.getType(objectLiteralCast.typeName)); if (type != null && type.getConstructor() != null) { setDeferredType(objectLiteralCast.objectNode, type); } else { compiler.report(JSError.make(t.getSourceName(), n, CONSTRUCTOR_EXPECTED));"
      },
      {
        "txt": "} } break; case Token.FUNCTION: if (!t.getInput().isExtern()) { nonExternFunctions.add(n); } if (parent.getType() == Token.ASSIGN || parent.getType() == Token.NAME) { return;"
      },
      {
        "txt": "} define(n, parent); break; case Token.ASSIGN: define(n, parent); checkForOldStyleTypedef(t, n); Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(),"
      },
      {
        "txt": "firstChild, n, firstChild.getNext()); } break; case Token.CATCH: define(n, parent); break; case Token.VAR: define(n, parent); if (n.hasOneChild()) { checkForOldStyleTypedef(t, n);"
      },
      {
        "txt": "checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo()); } break; case Token.GETPROP: if (parent.getType() == Token.EXPR_RESULT && n.isQualifiedName()) { checkForTypedef(t, n, n.getJSDocInfo()); maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); } break;"
      },
      {
        "txt": "} } private void applyDelegateRelationship( DelegateRelationship delegateRelationship) { ObjectType delegatorObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegator)); ObjectType delegateBaseObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegateBase)); ObjectType delegateSuperObject = ObjectType.cast( typeRegistry.getType(codingConvention.getDelegateSuperclassName()));"
      },
      {
        "txt": "if (delegatorObject != null && delegateBaseObject != null && delegateSuperObject != null) { FunctionType delegatorCtor = delegatorObject.getConstructor(); FunctionType delegateBaseCtor = delegateBaseObject.getConstructor(); FunctionType delegateSuperCtor = delegateSuperObject.getConstructor(); if (delegatorCtor != null && delegateBaseCtor != null && delegateSuperCtor != null) { FunctionParamBuilder functionParamBuilder = new FunctionParamBuilder(typeRegistry);"
      },
      {
        "txt": "functionParamBuilder.addRequiredParams( typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE)); FunctionType findDelegate = typeRegistry.createFunctionType( typeRegistry.createDefaultObjectUnion(delegateBaseObject), functionParamBuilder.build()); FunctionType delegateProxy = typeRegistry.createConstructorType( delegateBaseObject.getReferenceName() + \"(Proxy)\", null, null, null); delegateProxy.setPrototypeBasedOn(delegateBaseObject); codingConvention.applyDelegateRelationship("
      },
      {
        "txt": "delegateSuperObject, delegateBaseObject, delegatorObject, delegateProxy, findDelegate); delegateProxyPrototypes.add(delegateProxy.getPrototype()); } } } private void checkForTypedef( NodeTraversal t, Node candidate, JSDocInfo info) { if (info == null || !info.hasTypedefType()) { return;"
      },
      {
        "txt": "} String typedef = candidate.getQualifiedName(); if (typedef == null) { return; } typeRegistry.forwardDeclareType(typedef); JSType realType = info.getTypedefType().evaluate(scope, typeRegistry); if (realType == null) { compiler.report( JSError.make("
      },
      {
        "txt": "t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); if (candidate.getType() == Token.GETPROP) { defineSlot(candidate, candidate.getParent(), typeRegistry.getNativeType(NO_TYPE), false); } } private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) { String typedef = codingConvention.identifyTypeDefAssign(candidate);"
      },
      {
        "txt": "if (typedef != null) { typeRegistry.forwardDeclareType(typedef); JSDocInfo info = candidate.getJSDocInfo(); JSType realType = null; if (info != null && info.getType() != null) { realType = info.getType().evaluate(scope, typeRegistry); } if (realType == null) { compiler.report( JSError.make("
      },
      {
        "txt": "t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); } } private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName();"
      },
      {
        "txt": "String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null); if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { if (!qVar.isTypeInferred()) { return; } scope.undeclare(qVar); }"
      },
      {
        "txt": "} JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue); if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (valueType == null) { if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration( n, t.getInput().isExtern(), ownerName)); } else if (rhsValue != null &&"
      },
      {
        "txt": "rhsValue.getType() == Token.TRUE) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType instanceof FunctionType) { JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE),"
      },
      {
        "txt": "true); } } } return; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));"
      },
      {
        "txt": "} if (inferred) { inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && !scope.isDeclared(qName, false)); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput().isExtern();"
      },
      {
        "txt": "if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, isExtern); } } defineSlot(n, parent, valueType, inferred); } }"
      },
      {
        "txt": "private ObjectType getObjectSlot(String slotName) { Var ownerVar = scope.getVar(slotName); if (ownerVar != null) { JSType ownerVarType = ownerVar.getType(); return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()); } return null; } private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,"
      },
      {
        "txt": "Node n, Node rhsValue) { if (info != null && info.hasType()) { return getDeclaredTypeInAnnotation(t, n, info); } else if (info != null && info.hasEnumParameterType()) { return n.getJSType(); } else if (rhsValue != null && rhsValue.getType() == Token.FUNCTION) { return rhsValue.getJSType(); } else { return getDeclaredTypeInAnnotation(t, n, info);"
      },
      {
        "txt": "} } private void resolveStubDeclarations() { for (StubDeclaration stub : stubDeclarations) { Node n = stub.node; Node parent = n.getParent(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); String ownerName = stub.ownerName; boolean isExtern = stub.isExtern;"
      },
      {
        "txt": "if (scope.isDeclared(qName, false)) { continue; } ObjectType ownerType = getObjectSlot(ownerName); ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE); defineSlot(n, parent, unknownType, true); if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) { ownerType.defineInferredProperty( propName, unknownType, isExtern);"
      },
      {
        "txt": "} else { typeRegistry.registerPropertyOnType( propName, ownerType == null ? unknownType : ownerType); } } } private final class StubDeclaration { private final Node node; private final boolean isExtern; private final String ownerName;"
      },
      {
        "txt": "private StubDeclaration(Node node, boolean isExtern, String ownerName) { this.node = node; this.isExtern = isExtern; this.ownerName = ownerName; } } private final class CollectProperties extends AbstractShallowCallback { private final ObjectType thisType; CollectProperties(ObjectType thisType) {"
      },
      {
        "txt": "this.thisType = thisType; } public void visit(NodeTraversal t, Node n, Node parent) { if (parent != null && parent.getType() == Token.EXPR_RESULT) { switch (n.getType()) { case Token.ASSIGN: maybeCollectMember(t, n.getFirstChild(), n); break; case Token.GETPROP: maybeCollectMember(t, n, n);"
      },
      {
        "txt": "break; } } } private void maybeCollectMember(NodeTraversal t, Node member, Node nodeWithJsDocInfo) { JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo(); if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) {"
      },
      {
        "txt": "return; } member.getFirstChild().setJSType(thisType); JSType jsType = getDeclaredTypeInAnnotation(t, member, info); Node name = member.getLastChild(); if (jsType != null && (name.getType() == Token.NAME || name.getType() == Token.STRING)) { thisType.defineDeclaredProperty( name.getString(), jsType,"
      },
      {
        "txt": "false /* functions with implementations are not in externs */); } } } // end CollectProperties } // end GlobalScopeBuilder private final class LocalScopeBuilder extends AbstractScopeBuilder { private LocalScopeBuilder(Scope scope) { super(scope); } void build() {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, scope.getRootNode(), this); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } switch (n.getType()) { case Token.FUNCTION:"
      },
      {
        "txt": "if (parent.getType() == Token.NAME) { return; } define(n, parent); break; case Token.CATCH: case Token.VAR: define(n, parent); break; }"
      },
      {
        "txt": "} private void handleFunctionInputs(Node fnNode) { Node fnNameNode = fnNode.getFirstChild(); String fnName = fnNameNode.getString(); if (!fnName.isEmpty()) { Scope.Var fnVar = scope.getVar(fnName); if (fnVar == null || (fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);"
      },
      {
        "txt": "} } declareArguments(fnNode); } private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode();"
      },
      {
        "txt": "if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); }"
      },
      {
        "txt": "} } } } // end declareArguments } // end LocalScopeBuilder"
      }
    ]
  },
  {
    "id": 576,
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
    "start-bug-line": 617,
    "end-bug-line": 617,
    "bug": "",
    "fix": ".inferReturnStatements(fnBlock)",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP; import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT; import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CodingConvention.DelegateRelationship; import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.CodingConvention.SubclassType; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import javax.annotation.Nullable;"
      },
      {
        "txt": "final class TypedScopeCreator implements ScopeCreator { static final DiagnosticType MALFORMED_TYPEDEF = DiagnosticType.warning( \"JSC_MALFORMED_TYPEDEF\", \"Typedef for {0} does not have any type information\"); static final DiagnosticType ENUM_INITIALIZER = DiagnosticType.warning( \"JSC_ENUM_INITIALIZER_NOT_ENUM\", \"enum initializer must be an object literal or an enum\"); static final DiagnosticType CONSTRUCTOR_EXPECTED ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\", \"Constructor expected as first argument\"); private final AbstractCompiler compiler; private final ErrorReporter typeParsingErrorReporter; private final TypeValidator validator; private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList(); private class DeferredSetType {"
      },
      {
        "txt": "final Node node; final JSType type; DeferredSetType(Node node, JSType type) { Preconditions.checkNotNull(node); Preconditions.checkNotNull(type); this.node = node; this.type = type; node.setJSType(type); } void resolve(Scope scope) {"
      },
      {
        "txt": "node.setJSType(type.resolve(typeParsingErrorReporter, scope)); } } TypedScopeCreator(AbstractCompiler compiler) { this(compiler, compiler.getCodingConvention()); } TypedScopeCreator(AbstractCompiler compiler, CodingConvention codingConvention) { this.compiler = compiler; this.validator = compiler.getTypeValidator();"
      },
      {
        "txt": "this.codingConvention = codingConvention; this.typeRegistry = compiler.getTypeRegistry(); this.typeParsingErrorReporter = typeRegistry.getErrorReporter(); } public Scope createScope(Node root, Scope parent) { Scope newScope = null; if (parent == null) { newScope = createInitialScope(root); GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope); NodeTraversal.traverse(compiler, root, scopeBuilder);"
      },
      {
        "txt": "scopeBuilder.resolveStubDeclarations(); scopeBuilder.resolveTypes(); for (Node functionNode : scopeBuilder.nonExternFunctions) { JSType type = functionNode.getJSType(); if (type != null && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; ObjectType fnThisType = fnType.getTypeOfThis(); if (!fnThisType.isUnknownType()) { NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));"
      },
      {
        "txt": "} } } codingConvention.defineDelegateProxyPrototypeProperties( typeRegistry, newScope, delegateProxyPrototypes); } else { newScope = new Scope(parent, root); LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope); scopeBuilder.build(); scopeBuilder.resolveTypes();"
      },
      {
        "txt": "} return newScope; } @VisibleForTesting Scope createInitialScope(Node root) { NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry)); Scope s = new Scope(root, compiler); declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE); declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, DATE_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE); declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE); declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE); declareNativeValueType(s, \"undefined\", VOID_TYPE); declareNativeValueType(s, \"goog.typedef\", NO_TYPE); declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE); return s; } private void declareNativeFunctionType(Scope scope, JSTypeNative tId) { FunctionType t = typeRegistry.getNativeFunctionType(tId); declareNativeType(scope, t.getInstanceType().getReferenceName(), t);"
      },
      {
        "txt": "declareNativeType( scope, t.getPrototype().getReferenceName(), t.getPrototype()); } private void declareNativeValueType(Scope scope, String name, JSTypeNative tId) { declareNativeType(scope, name, typeRegistry.getNativeType(tId)); } private void declareNativeType(Scope scope, String name, JSType t) { scope.declare(name, null, t, null, false); }"
      },
      {
        "txt": "private static class DiscoverEnums extends AbstractShallowCallback { private final JSTypeRegistry registry; DiscoverEnums(JSTypeRegistry registry) { this.registry = registry; } @Override public void visit(NodeTraversal t, Node node, Node parent) { Node nameNode = null; switch (node.getType()) { case Token.NAME:"
      },
      {
        "txt": "nameNode = node; break; case Token.VAR: if (node.hasOneChild()) { nameNode = node.getFirstChild(); } break; case Token.ASSIGN: nameNode = node.getFirstChild(); break;"
      },
      {
        "txt": "} if (nameNode != null) { JSDocInfo info = node.getJSDocInfo(); if (info != null && info.hasEnumParameterType()) { registry.identifyEnumName(nameNode.getQualifiedName()); } } } } private static Node getPrototypePropertyOwner(Node n) {"
      },
      {
        "txt": "if (n.getType() == Token.GETPROP) { Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.getLastChild().getString().equals(\"prototype\")) { Node maybeOwner = firstChild.getFirstChild(); if (maybeOwner.isQualifiedName()) { return maybeOwner; } } }"
      },
      {
        "txt": "return null; } private abstract class AbstractScopeBuilder implements NodeTraversal.Callback { final Scope scope; private final List<DeferredSetType> deferredSetTypes = Lists.newArrayList(); private String sourceName = null; private AbstractScopeBuilder(Scope scope) { this.scope = scope;"
      },
      {
        "txt": "} void setDeferredType(Node node, JSType type) { deferredSetTypes.add(new DeferredSetType(node, type)); } void resolveTypes() { for (DeferredSetType deferred : deferredSetTypes) { deferred.resolve(scope); } Iterator<Var> vars = scope.getVars(); while (vars.hasNext()) {"
      },
      {
        "txt": "vars.next().resolveType(typeParsingErrorReporter); } typeRegistry.resolveTypesInScope(scope); } @Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP);"
      },
      {
        "txt": "} return parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild() || parent == scope.getRootNode(); } @Override public abstract void visit(NodeTraversal t, Node n, Node parent); JSType getDeclaredTypeInAnnotation( NodeTraversal t, Node node, JSDocInfo info) { return getDeclaredTypeInAnnotation(t.getSourceName(), node, info); }"
      },
      {
        "txt": "JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) { JSType jsType = null; Node objNode = node.getType() == Token.GETPROP ? node.getFirstChild() : null; if (info != null) { if (info.hasType()) { jsType = info.getType().evaluate(scope, typeRegistry); } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { String fnName = node.getQualifiedName();"
      },
      {
        "txt": "if (info.isConstructor() && typeRegistry.getType(fnName) != null) { return null; } FunctionTypeBuilder builder = new FunctionTypeBuilder( fnName, compiler, node, sourceName, scope) .inferTemplateTypeName(info) .inferReturnType(info) .inferParameterTypes(info) .inferInheritance(info);"
      },
      {
        "txt": "boolean searchedForThisType = false; if (objNode != null) { if (objNode.getType() == Token.GETPROP && objNode.getLastChild().getString().equals(\"prototype\")) { builder.inferThisType(info, objNode.getFirstChild()); searchedForThisType = true; } else if (objNode.getType() == Token.THIS) { builder.inferThisType(info, objNode.getJSType()); searchedForThisType = true; }"
      },
      {
        "txt": "} if (!searchedForThisType) { builder.inferThisType(info, (Node) null); } jsType = builder.buildAndRegister(); } } return jsType; } void define(Node n, Node parent) {"
      },
      {
        "txt": "Preconditions.checkState(sourceName != null); JSDocInfo info = n.getJSDocInfo(); switch (n.getType()) { case Token.CATCH: Node catchName = n.getFirstChild(); defineSlot(catchName, n, null); break; case Token.VAR: if (n.getChildCount() > 1) { if (info != null) {"
      },
      {
        "txt": "compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF)); } for (Node name : n.children()) { defineName(name, n, parent, name.getJSDocInfo()); } } else { Node name = n.getFirstChild(); defineName(name, n, parent, (info != null) ? info : name.getJSDocInfo()); }"
      },
      {
        "txt": "break; case Token.FUNCTION: int parentType = parent.getType(); Preconditions.checkState( (scope.isLocal() || parentType != Token.ASSIGN) && parentType != Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\"); String functionName = n.getFirstChild().getString(); FunctionType functionType = getFunctionType(functionName, n, info,"
      },
      {
        "txt": "null); if (NodeUtil.isFunctionDeclaration(n)) { defineSlot(n.getFirstChild(), n, functionType); } break; case Token.ASSIGN: Node rvalue = n.getLastChild(); Node lvalue = n.getFirstChild(); info = (info != null) ? info : rvalue.getJSDocInfo(); if (rvalue.getType() == Token.FUNCTION ||"
      },
      {
        "txt": "info != null && info.isConstructor()) { getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue); } else if (info != null && info.hasEnumParameterType()) { JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry)); if (type != null) { setDeferredType(lvalue, type); } }"
      },
      {
        "txt": "break; default: throw new IllegalStateException(Integer.toString(n.getType())); } } private void defineName(Node name, Node var, Node parent, JSDocInfo info) { Node value = name.getFirstChild(); if (value != null && value.getType() == Token.FUNCTION) { String functionName = name.getString(); FunctionType functionType ="
      },
      {
        "txt": "getFunctionType(functionName, value, info, null); if (functionType.isReturnTypeInferred() && scope.isLocal()) { defineSlot(name, var, null); } else { defineSlot(name, var, functionType); } } else { JSType type = null; if (info == null) {"
      },
      {
        "txt": "CompilerInput input = compiler.getInput(sourceName); Preconditions.checkNotNull(input, sourceName); type = input.isExtern() ? typeRegistry.getNativeType(UNKNOWN_TYPE) : null; } else if (info.hasEnumParameterType()) { type = getEnumType(name.getString(), var, value, info.getEnumParameterType().evaluate(scope, typeRegistry)); } else if (info.isConstructor()) { type = getFunctionType(name.getString(), value, info, name); } else {"
      },
      {
        "txt": "type = getDeclaredTypeInAnnotation(sourceName, name, info); } defineSlot(name, var, type); } } private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) { FunctionType functionType = null; if (rValue != null && rValue.isQualifiedName()) { Var var = scope.getVar(rValue.getQualifiedName());"
      },
      {
        "txt": "if (var != null && var.getType() instanceof FunctionType) { functionType = (FunctionType) var.getType(); if (functionType != null && functionType.isConstructor()) { typeRegistry.declareType(name, functionType.getInstanceType()); } } return functionType; } Node owner = null; if (lvalueNode != null) {"
      },
      {
        "txt": "owner = getPrototypePropertyOwner(lvalueNode); } Node errorRoot = rValue == null ? lvalueNode : rValue; boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION; Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry);"
      },
      {
        "txt": "type = type.restrictByNotNullOrUndefined(); if (type.isFunctionType()) { functionType = (FunctionType) type; functionType.setJSDocInfo(info); } } if (functionType == null) { if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&"
      },
      {
        "txt": "lvalueNode.isQualifiedName()) { Var var = scope.getVar( lvalueNode.getFirstChild().getQualifiedName()); if (var != null) { ObjectType ownerType = ObjectType.cast(var.getType()); FunctionType propType = null; if (ownerType != null) { String propName = lvalueNode.getLastChild().getString(); propType = findOverriddenFunction(ownerType, propName); }"
      },
      {
        "txt": "functionType = new FunctionTypeBuilder( name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferFromOverriddenFunction(propType, parametersNode) .inferThisType(info, owner) <extra_id_0> } } } } } // end if (functionType == null) if (functionType == null) {"
      },
      {
        "txt": "} // end if (functionType == null) if (functionType == null) { functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferTemplateTypeName(info) .inferReturnType(info) .inferInheritance(info) .inferThisType(info, owner)"
      },
      {
        "txt": ".inferParameterTypes(parametersNode, info) .buildAndRegister(); } if (rValue != null) { setDeferredType(rValue, functionType); } return functionType; } private FunctionType findOverriddenFunction( ObjectType ownerType, String propName) {"
      },
      {
        "txt": "JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; }"
      },
      {
        "txt": "} } return null; } private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) { EnumType enumType = null; if (value != null) { if (value.getType() == Token.OBJECTLIT) { enumType = typeRegistry.createEnumType(name, elementsType);"
      },
      {
        "txt": "Node key = value.getFirstChild(); while (key != null) { String keyName = NodeUtil.getStringValue(key); if (enumType.hasOwnProperty(keyName)) { compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName)); } else if (!codingConvention.isValidEnumKey(keyName)) { compiler.report( JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else { enumType.defineElement(keyName);"
      },
      {
        "txt": "} key = key.getNext(); key = (key == null) ? null : key.getNext(); } } else if (value.isQualifiedName()) { Var var = scope.getVar(value.getQualifiedName()); if (var != null && var.getType() instanceof EnumType) { enumType = (EnumType) var.getType(); } }"
      },
      {
        "txt": "} if (enumType == null) { compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER)); } else if (scope.isGlobal()) { if (name != null && !name.isEmpty()) { typeRegistry.declareType(name, enumType.getElementsType()); } } return enumType; }"
      },
      {
        "txt": "private void defineSlot(Node name, Node parent, JSType type) { defineSlot(name, parent, type, type == null); } void defineSlot(Node n, Node parent, JSType type, boolean inferred) { Preconditions.checkArgument(inferred || type != null); boolean shouldDeclareOnGlobalThis = false; if (n.getType() == Token.NAME) { Preconditions.checkArgument( parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR ||"
      },
      {
        "txt": "parent.getType() == Token.LP || parent.getType() == Token.CATCH); shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION); } else { Preconditions.checkArgument( n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));"
      },
      {
        "txt": "} String variableName = n.getQualifiedName(); Preconditions.checkArgument(!variableName.isEmpty()); if (scope.isDeclared(variableName, false)) { Var oldVar = scope.getVar(variableName); validator.expectUndeclaredVariable( sourceName, n, parent, oldVar, variableName, type); } else { if (!inferred) { setDeferredType(n, type);"
      },
      {
        "txt": "} CompilerInput input = compiler.getInput(sourceName); scope.declare(variableName, n, type, input, inferred); if (shouldDeclareOnGlobalThis) { ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS); boolean isExtern = input.isExtern(); if (inferred) { globalThis.defineInferredProperty(variableName, type == null ?"
      },
      {
        "txt": "typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern); } else { globalThis.defineDeclaredProperty(variableName, type, isExtern); } } if (scope.isGlobal() && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; if (fnType.isConstructor() || fnType.isInterface()) {"
      },
      {
        "txt": "FunctionType superClassCtor = fnType.getSuperClassConstructor(); scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null || superClassCtor.getInstanceType().equals( typeRegistry.getNativeType(OBJECT_TYPE))); } } } }"
      },
      {
        "txt": "} private final class GlobalScopeBuilder extends AbstractScopeBuilder { private final List<Node> nonExternFunctions = Lists.newArrayList(); private final List<StubDeclaration> stubDeclarations = Lists.newArrayList(); private GlobalScopeBuilder(Scope scope) { super(scope); } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.CALL: SubclassRelationship relationship = codingConvention.getClassesDefinedByCall(n); if (relationship != null) { ObjectType superClass = ObjectType.cast( typeRegistry.getType(relationship.superclassName)); ObjectType subClass = ObjectType.cast( typeRegistry.getType(relationship.subclassName)); if (superClass != null && subClass != null) { FunctionType superCtor = superClass.getConstructor();"
      },
      {
        "txt": "FunctionType subCtor = subClass.getConstructor(); if (relationship.type == SubclassType.INHERITS) { validator.expectSuperType(t, n, superClass, subClass); } if (superCtor != null && subCtor != null) { codingConvention.applySubclassRelationship( superCtor, subCtor, relationship.type); } } }"
      },
      {
        "txt": "String singletonGetterClassName = codingConvention.getSingletonGetterClassName(n); if (singletonGetterClassName != null) { ObjectType objectType = ObjectType.cast( typeRegistry.getType(singletonGetterClassName)); if (objectType != null) { FunctionType functionType = objectType.getConstructor(); if (functionType != null) { FunctionType getterType = typeRegistry.createFunctionType(objectType);"
      },
      {
        "txt": "codingConvention.applySingletonGetter(functionType, getterType, objectType); } } } DelegateRelationship delegateRelationship = codingConvention.getDelegateRelationship(n); if (delegateRelationship != null) { applyDelegateRelationship(delegateRelationship); }"
      },
      {
        "txt": "ObjectLiteralCast objectLiteralCast = codingConvention.getObjectLiteralCast(t, n); if (objectLiteralCast != null) { ObjectType type = ObjectType.cast( typeRegistry.getType(objectLiteralCast.typeName)); if (type != null && type.getConstructor() != null) { setDeferredType(objectLiteralCast.objectNode, type); } else { compiler.report(JSError.make(t.getSourceName(), n, CONSTRUCTOR_EXPECTED));"
      },
      {
        "txt": "} } break; case Token.FUNCTION: if (!t.getInput().isExtern()) { nonExternFunctions.add(n); } if (parent.getType() == Token.ASSIGN || parent.getType() == Token.NAME) { return;"
      },
      {
        "txt": "} define(n, parent); break; case Token.ASSIGN: define(n, parent); checkForOldStyleTypedef(t, n); Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(),"
      },
      {
        "txt": "firstChild, n, firstChild.getNext()); } break; case Token.CATCH: define(n, parent); break; case Token.VAR: define(n, parent); if (n.hasOneChild()) { checkForOldStyleTypedef(t, n);"
      },
      {
        "txt": "checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo()); } break; case Token.GETPROP: if (parent.getType() == Token.EXPR_RESULT && n.isQualifiedName()) { checkForTypedef(t, n, n.getJSDocInfo()); maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); } break;"
      },
      {
        "txt": "} } private void applyDelegateRelationship( DelegateRelationship delegateRelationship) { ObjectType delegatorObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegator)); ObjectType delegateBaseObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegateBase)); ObjectType delegateSuperObject = ObjectType.cast( typeRegistry.getType(codingConvention.getDelegateSuperclassName()));"
      },
      {
        "txt": "if (delegatorObject != null && delegateBaseObject != null && delegateSuperObject != null) { FunctionType delegatorCtor = delegatorObject.getConstructor(); FunctionType delegateBaseCtor = delegateBaseObject.getConstructor(); FunctionType delegateSuperCtor = delegateSuperObject.getConstructor(); if (delegatorCtor != null && delegateBaseCtor != null && delegateSuperCtor != null) { FunctionParamBuilder functionParamBuilder = new FunctionParamBuilder(typeRegistry);"
      },
      {
        "txt": "functionParamBuilder.addRequiredParams( typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE)); FunctionType findDelegate = typeRegistry.createFunctionType( typeRegistry.createDefaultObjectUnion(delegateBaseObject), functionParamBuilder.build()); FunctionType delegateProxy = typeRegistry.createConstructorType( delegateBaseObject.getReferenceName() + \"(Proxy)\", null, null, null); delegateProxy.setPrototypeBasedOn(delegateBaseObject); codingConvention.applyDelegateRelationship("
      },
      {
        "txt": "delegateSuperObject, delegateBaseObject, delegatorObject, delegateProxy, findDelegate); delegateProxyPrototypes.add(delegateProxy.getPrototype()); } } } private void checkForTypedef( NodeTraversal t, Node candidate, JSDocInfo info) { if (info == null || !info.hasTypedefType()) { return;"
      },
      {
        "txt": "} String typedef = candidate.getQualifiedName(); if (typedef == null) { return; } typeRegistry.forwardDeclareType(typedef); JSType realType = info.getTypedefType().evaluate(scope, typeRegistry); if (realType == null) { compiler.report( JSError.make("
      },
      {
        "txt": "t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); if (candidate.getType() == Token.GETPROP) { defineSlot(candidate, candidate.getParent(), typeRegistry.getNativeType(NO_TYPE), false); } } private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) { String typedef = codingConvention.identifyTypeDefAssign(candidate);"
      },
      {
        "txt": "if (typedef != null) { typeRegistry.forwardDeclareType(typedef); JSDocInfo info = candidate.getJSDocInfo(); JSType realType = null; if (info != null && info.getType() != null) { realType = info.getType().evaluate(scope, typeRegistry); } if (realType == null) { compiler.report( JSError.make("
      },
      {
        "txt": "t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); } } private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName();"
      },
      {
        "txt": "String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null); if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { if (!qVar.isTypeInferred()) { return; } scope.undeclare(qVar); }"
      },
      {
        "txt": "} JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue); if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (valueType == null) { if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration( n, t.getInput().isExtern(), ownerName)); } else if (rhsValue != null &&"
      },
      {
        "txt": "rhsValue.getType() == Token.TRUE) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType instanceof FunctionType) { JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE),"
      },
      {
        "txt": "true); } } } return; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));"
      },
      {
        "txt": "} if (inferred) { inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && !scope.isDeclared(qName, false)); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput().isExtern();"
      },
      {
        "txt": "if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, isExtern); } } defineSlot(n, parent, valueType, inferred); } }"
      },
      {
        "txt": "private ObjectType getObjectSlot(String slotName) { Var ownerVar = scope.getVar(slotName); if (ownerVar != null) { JSType ownerVarType = ownerVar.getType(); return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()); } return null; } private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,"
      },
      {
        "txt": "Node n, Node rhsValue) { if (info != null && info.hasType()) { return getDeclaredTypeInAnnotation(t, n, info); } else if (info != null && info.hasEnumParameterType()) { return n.getJSType(); } else if (rhsValue != null && rhsValue.getType() == Token.FUNCTION) { return rhsValue.getJSType(); } else { return getDeclaredTypeInAnnotation(t, n, info);"
      },
      {
        "txt": "} } private void resolveStubDeclarations() { for (StubDeclaration stub : stubDeclarations) { Node n = stub.node; Node parent = n.getParent(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); String ownerName = stub.ownerName; boolean isExtern = stub.isExtern;"
      },
      {
        "txt": "if (scope.isDeclared(qName, false)) { continue; } ObjectType ownerType = getObjectSlot(ownerName); ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE); defineSlot(n, parent, unknownType, true); if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) { ownerType.defineInferredProperty( propName, unknownType, isExtern);"
      },
      {
        "txt": "} else { typeRegistry.registerPropertyOnType( propName, ownerType == null ? unknownType : ownerType); } } } private final class StubDeclaration { private final Node node; private final boolean isExtern; private final String ownerName;"
      },
      {
        "txt": "private StubDeclaration(Node node, boolean isExtern, String ownerName) { this.node = node; this.isExtern = isExtern; this.ownerName = ownerName; } } private final class CollectProperties extends AbstractShallowCallback { private final ObjectType thisType; CollectProperties(ObjectType thisType) {"
      },
      {
        "txt": "this.thisType = thisType; } public void visit(NodeTraversal t, Node n, Node parent) { if (parent != null && parent.getType() == Token.EXPR_RESULT) { switch (n.getType()) { case Token.ASSIGN: maybeCollectMember(t, n.getFirstChild(), n); break; case Token.GETPROP: maybeCollectMember(t, n, n);"
      },
      {
        "txt": "break; } } } private void maybeCollectMember(NodeTraversal t, Node member, Node nodeWithJsDocInfo) { JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo(); if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) {"
      },
      {
        "txt": "return; } member.getFirstChild().setJSType(thisType); JSType jsType = getDeclaredTypeInAnnotation(t, member, info); Node name = member.getLastChild(); if (jsType != null && (name.getType() == Token.NAME || name.getType() == Token.STRING)) { thisType.defineDeclaredProperty( name.getString(), jsType,"
      },
      {
        "txt": "false /* functions with implementations are not in externs */); } } } // end CollectProperties } // end GlobalScopeBuilder private final class LocalScopeBuilder extends AbstractScopeBuilder { private LocalScopeBuilder(Scope scope) { super(scope); } void build() {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, scope.getRootNode(), this); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } switch (n.getType()) { case Token.FUNCTION:"
      },
      {
        "txt": "if (parent.getType() == Token.NAME) { return; } define(n, parent); break; case Token.CATCH: case Token.VAR: define(n, parent); break; }"
      },
      {
        "txt": "} private void handleFunctionInputs(Node fnNode) { Node fnNameNode = fnNode.getFirstChild(); String fnName = fnNameNode.getString(); if (!fnName.isEmpty()) { Scope.Var fnVar = scope.getVar(fnName); if (fnVar == null || (fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);"
      },
      {
        "txt": "} } declareArguments(fnNode); } private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode();"
      },
      {
        "txt": "if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); }"
      },
      {
        "txt": "} } } } // end declareArguments } // end LocalScopeBuilder"
      }
    ]
  },
  {
    "id": 577,
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
    "start-bug-line": 634,
    "end-bug-line": 634,
    "bug": "",
    "fix": ".inferReturnStatements(fnBlock)",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP; import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT; import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CodingConvention.DelegateRelationship; import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.CodingConvention.SubclassType; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionParamBuilder; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.ObjectType; import java.util.Iterator; import java.util.List; import javax.annotation.Nullable; final class TypedScopeCreator implements ScopeCreator { static final DiagnosticType MALFORMED_TYPEDEF = DiagnosticType.warning( \"JSC_MALFORMED_TYPEDEF\", \"Typedef for {0} does not have any type information\"); static final DiagnosticType ENUM_INITIALIZER ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_ENUM_INITIALIZER_NOT_ENUM\", \"enum initializer must be an object literal or an enum\"); static final DiagnosticType CONSTRUCTOR_EXPECTED = DiagnosticType.warning( \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\", \"Constructor expected as first argument\"); private final AbstractCompiler compiler; private final ErrorReporter typeParsingErrorReporter; private final TypeValidator validator;"
      },
      {
        "txt": "private final CodingConvention codingConvention; private final JSTypeRegistry typeRegistry; private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList(); private class DeferredSetType { final Node node; final JSType type; DeferredSetType(Node node, JSType type) { Preconditions.checkNotNull(node); Preconditions.checkNotNull(type); this.node = node;"
      },
      {
        "txt": "this.type = type; node.setJSType(type); } void resolve(Scope scope) { node.setJSType(type.resolve(typeParsingErrorReporter, scope)); } } TypedScopeCreator(AbstractCompiler compiler) { this(compiler, compiler.getCodingConvention()); }"
      },
      {
        "txt": "TypedScopeCreator(AbstractCompiler compiler, CodingConvention codingConvention) { this.compiler = compiler; this.validator = compiler.getTypeValidator(); this.codingConvention = codingConvention; this.typeRegistry = compiler.getTypeRegistry(); this.typeParsingErrorReporter = typeRegistry.getErrorReporter(); } public Scope createScope(Node root, Scope parent) { Scope newScope = null;"
      },
      {
        "txt": "if (parent == null) { newScope = createInitialScope(root); GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope); NodeTraversal.traverse(compiler, root, scopeBuilder); scopeBuilder.resolveStubDeclarations(); scopeBuilder.resolveTypes(); for (Node functionNode : scopeBuilder.nonExternFunctions) { JSType type = functionNode.getJSType(); if (type != null && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type;"
      },
      {
        "txt": "ObjectType fnThisType = fnType.getTypeOfThis(); if (!fnThisType.isUnknownType()) { NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType)); } } } codingConvention.defineDelegateProxyPrototypeProperties( typeRegistry, newScope, delegateProxyPrototypes); } else {"
      },
      {
        "txt": "newScope = new Scope(parent, root); LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope); scopeBuilder.build(); scopeBuilder.resolveTypes(); } return newScope; } @VisibleForTesting Scope createInitialScope(Node root) { NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));"
      },
      {
        "txt": "Scope s = new Scope(root, compiler); declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE); declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, DATE_FUNCTION_TYPE); declareNativeFunctionType(s, ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE); declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);"
      },
      {
        "txt": "declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE); declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE); declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE); declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE); declareNativeValueType(s, \"undefined\", VOID_TYPE); declareNativeValueType(s, \"goog.typedef\", NO_TYPE); declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE); return s;"
      },
      {
        "txt": "} private void declareNativeFunctionType(Scope scope, JSTypeNative tId) { FunctionType t = typeRegistry.getNativeFunctionType(tId); declareNativeType(scope, t.getInstanceType().getReferenceName(), t); declareNativeType( scope, t.getPrototype().getReferenceName(), t.getPrototype()); } private void declareNativeValueType(Scope scope, String name, JSTypeNative tId) { declareNativeType(scope, name, typeRegistry.getNativeType(tId));"
      },
      {
        "txt": "} private void declareNativeType(Scope scope, String name, JSType t) { scope.declare(name, null, t, null, false); } private static class DiscoverEnums extends AbstractShallowCallback { private final JSTypeRegistry registry; DiscoverEnums(JSTypeRegistry registry) { this.registry = registry; } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node node, Node parent) { Node nameNode = null; switch (node.getType()) { case Token.NAME: nameNode = node; break; case Token.VAR: if (node.hasOneChild()) { nameNode = node.getFirstChild(); }"
      },
      {
        "txt": "break; case Token.ASSIGN: nameNode = node.getFirstChild(); break; } if (nameNode != null) { JSDocInfo info = node.getJSDocInfo(); if (info != null && info.hasEnumParameterType()) { registry.identifyEnumName(nameNode.getQualifiedName()); }"
      },
      {
        "txt": "} } } private static Node getPrototypePropertyOwner(Node n) { if (n.getType() == Token.GETPROP) { Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.getLastChild().getString().equals(\"prototype\")) { Node maybeOwner = firstChild.getFirstChild(); if (maybeOwner.isQualifiedName()) {"
      },
      {
        "txt": "return maybeOwner; } } } return null; } private abstract class AbstractScopeBuilder implements NodeTraversal.Callback { final Scope scope; private final List<DeferredSetType> deferredSetTypes ="
      },
      {
        "txt": "Lists.newArrayList(); private String sourceName = null; private AbstractScopeBuilder(Scope scope) { this.scope = scope; } void setDeferredType(Node node, JSType type) { deferredSetTypes.add(new DeferredSetType(node, type)); } void resolveTypes() { for (DeferredSetType deferred : deferredSetTypes) {"
      },
      {
        "txt": "deferred.resolve(scope); } Iterator<Var> vars = scope.getVars(); while (vars.hasNext()) { vars.next().resolveType(typeParsingErrorReporter); } typeRegistry.resolveTypesInScope(scope); } @Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,"
      },
      {
        "txt": "Node parent) { if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); } return parent == null || parent.getType() != Token.FUNCTION || n == parent.getFirstChild() || parent == scope.getRootNode(); } @Override public abstract void visit(NodeTraversal t, Node n, Node parent);"
      },
      {
        "txt": "JSType getDeclaredTypeInAnnotation( NodeTraversal t, Node node, JSDocInfo info) { return getDeclaredTypeInAnnotation(t.getSourceName(), node, info); } JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) { JSType jsType = null; Node objNode = node.getType() == Token.GETPROP ? node.getFirstChild() : null; if (info != null) {"
      },
      {
        "txt": "if (info.hasType()) { jsType = info.getType().evaluate(scope, typeRegistry); } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { String fnName = node.getQualifiedName(); if (info.isConstructor() && typeRegistry.getType(fnName) != null) { return null; } FunctionTypeBuilder builder = new FunctionTypeBuilder( fnName, compiler, node, sourceName, scope)"
      },
      {
        "txt": ".inferTemplateTypeName(info) .inferReturnType(info) .inferParameterTypes(info) .inferInheritance(info); boolean searchedForThisType = false; if (objNode != null) { if (objNode.getType() == Token.GETPROP && objNode.getLastChild().getString().equals(\"prototype\")) { builder.inferThisType(info, objNode.getFirstChild()); searchedForThisType = true;"
      },
      {
        "txt": "} else if (objNode.getType() == Token.THIS) { builder.inferThisType(info, objNode.getJSType()); searchedForThisType = true; } } if (!searchedForThisType) { builder.inferThisType(info, (Node) null); } jsType = builder.buildAndRegister(); }"
      },
      {
        "txt": "} return jsType; } void define(Node n, Node parent) { Preconditions.checkState(sourceName != null); JSDocInfo info = n.getJSDocInfo(); switch (n.getType()) { case Token.CATCH: Node catchName = n.getFirstChild(); defineSlot(catchName, n, null);"
      },
      {
        "txt": "break; case Token.VAR: if (n.getChildCount() > 1) { if (info != null) { compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF)); } for (Node name : n.children()) { defineName(name, n, parent, name.getJSDocInfo()); } } else {"
      },
      {
        "txt": "Node name = n.getFirstChild(); defineName(name, n, parent, (info != null) ? info : name.getJSDocInfo()); } break; case Token.FUNCTION: int parentType = parent.getType(); Preconditions.checkState( (scope.isLocal() || parentType != Token.ASSIGN) && parentType != Token.NAME,"
      },
      {
        "txt": "\"function defined as standalone function when it is being \" + \"assigned\"); String functionName = n.getFirstChild().getString(); FunctionType functionType = getFunctionType(functionName, n, info, null); if (NodeUtil.isFunctionDeclaration(n)) { defineSlot(n.getFirstChild(), n, functionType); } break; case Token.ASSIGN:"
      },
      {
        "txt": "Node rvalue = n.getLastChild(); Node lvalue = n.getFirstChild(); info = (info != null) ? info : rvalue.getJSDocInfo(); if (rvalue.getType() == Token.FUNCTION || info != null && info.isConstructor()) { getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue); } else if (info != null && info.hasEnumParameterType()) { JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));"
      },
      {
        "txt": "if (type != null) { setDeferredType(lvalue, type); } } break; default: throw new IllegalStateException(Integer.toString(n.getType())); } } private void defineName(Node name, Node var, Node parent, JSDocInfo info) {"
      },
      {
        "txt": "Node value = name.getFirstChild(); if (value != null && value.getType() == Token.FUNCTION) { String functionName = name.getString(); FunctionType functionType = getFunctionType(functionName, value, info, null); if (functionType.isReturnTypeInferred() && scope.isLocal()) { defineSlot(name, var, null); } else { defineSlot(name, var, functionType);"
      },
      {
        "txt": "} } else { JSType type = null; if (info == null) { CompilerInput input = compiler.getInput(sourceName); Preconditions.checkNotNull(input, sourceName); type = input.isExtern() ? typeRegistry.getNativeType(UNKNOWN_TYPE) : null; } else if (info.hasEnumParameterType()) { type = getEnumType(name.getString(), var, value,"
      },
      {
        "txt": "info.getEnumParameterType().evaluate(scope, typeRegistry)); } else if (info.isConstructor()) { type = getFunctionType(name.getString(), value, info, name); } else { type = getDeclaredTypeInAnnotation(sourceName, name, info); } defineSlot(name, var, type); } } private FunctionType getFunctionType(String name,"
      },
      {
        "txt": "Node rValue, JSDocInfo info, @Nullable Node lvalueNode) { FunctionType functionType = null; if (rValue != null && rValue.isQualifiedName()) { Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() instanceof FunctionType) { functionType = (FunctionType) var.getType(); if (functionType != null && functionType.isConstructor()) { typeRegistry.declareType(name, functionType.getInstanceType()); } }"
      },
      {
        "txt": "return functionType; } Node owner = null; if (lvalueNode != null) { owner = getPrototypePropertyOwner(lvalueNode); } Node errorRoot = rValue == null ? lvalueNode : rValue; boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION; Node fnRoot = isFnLiteral ? rValue : null;"
      },
      {
        "txt": "Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry); type = type.restrictByNotNullOrUndefined(); if (type.isFunctionType()) { functionType = (FunctionType) type; functionType.setJSDocInfo(info); } }"
      },
      {
        "txt": "if (functionType == null) { if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) { Var var = scope.getVar( lvalueNode.getFirstChild().getQualifiedName()); if (var != null) { ObjectType ownerType = ObjectType.cast(var.getType()); FunctionType propType = null;"
      },
      {
        "txt": "if (ownerType != null) { String propName = lvalueNode.getLastChild().getString(); propType = findOverriddenFunction(ownerType, propName); } if (propType != null) { functionType = new FunctionTypeBuilder( name, compiler, errorRoot, sourceName, scope) .setSourceNode(fnRoot) .inferFromOverriddenFunction(propType, parametersNode)"
      },
      {
        "txt": ".inferThisType(info, owner) .buildAndRegister(); } } } } } // end if (functionType == null) if (functionType == null) { functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,"
      },
      {
        "txt": ".setSourceNode(fnRoot) .inferTemplateTypeName(info) .inferReturnType(info) .inferInheritance(info) .inferThisType(info, owner) .inferParameterTypes(parametersNode, info) <extra_id_0> } if (rValue != null) { setDeferredType(rValue, functionType); } return functionType; }"
      },
      {
        "txt": "return functionType; } private FunctionType findOverriddenFunction( ObjectType ownerType, String propName) { JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) {"
      },
      {
        "txt": "propType = iface.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } } } return null; } private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {"
      },
      {
        "txt": "EnumType enumType = null; if (value != null) { if (value.getType() == Token.OBJECTLIT) { enumType = typeRegistry.createEnumType(name, elementsType); Node key = value.getFirstChild(); while (key != null) { String keyName = NodeUtil.getStringValue(key); if (enumType.hasOwnProperty(keyName)) { compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName)); } else if (!codingConvention.isValidEnumKey(keyName)) {"
      },
      {
        "txt": "compiler.report( JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else { enumType.defineElement(keyName); } key = key.getNext(); key = (key == null) ? null : key.getNext(); } } else if (value.isQualifiedName()) { Var var = scope.getVar(value.getQualifiedName());"
      },
      {
        "txt": "if (var != null && var.getType() instanceof EnumType) { enumType = (EnumType) var.getType(); } } } if (enumType == null) { compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER)); } else if (scope.isGlobal()) { if (name != null && !name.isEmpty()) { typeRegistry.declareType(name, enumType.getElementsType());"
      },
      {
        "txt": "} } return enumType; } private void defineSlot(Node name, Node parent, JSType type) { defineSlot(name, parent, type, type == null); } void defineSlot(Node n, Node parent, JSType type, boolean inferred) { Preconditions.checkArgument(inferred || type != null); boolean shouldDeclareOnGlobalThis = false;"
      },
      {
        "txt": "if (n.getType() == Token.NAME) { Preconditions.checkArgument( parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH); shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION); } else {"
      },
      {
        "txt": "Preconditions.checkArgument( n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT)); } String variableName = n.getQualifiedName(); Preconditions.checkArgument(!variableName.isEmpty()); if (scope.isDeclared(variableName, false)) { Var oldVar = scope.getVar(variableName); validator.expectUndeclaredVariable("
      },
      {
        "txt": "sourceName, n, parent, oldVar, variableName, type); } else { if (!inferred) { setDeferredType(n, type); } CompilerInput input = compiler.getInput(sourceName); scope.declare(variableName, n, type, input, inferred); if (shouldDeclareOnGlobalThis) { ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);"
      },
      {
        "txt": "boolean isExtern = input.isExtern(); if (inferred) { globalThis.defineInferredProperty(variableName, type == null ? typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern); } else { globalThis.defineDeclaredProperty(variableName, type, isExtern); }"
      },
      {
        "txt": "} if (scope.isGlobal() && type instanceof FunctionType) { FunctionType fnType = (FunctionType) type; if (fnType.isConstructor() || fnType.isInterface()) { FunctionType superClassCtor = fnType.getSuperClassConstructor(); scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null || superClassCtor.getInstanceType().equals( typeRegistry.getNativeType(OBJECT_TYPE)));"
      },
      {
        "txt": "} } } } } private final class GlobalScopeBuilder extends AbstractScopeBuilder { private final List<Node> nonExternFunctions = Lists.newArrayList(); private final List<StubDeclaration> stubDeclarations = Lists.newArrayList(); private GlobalScopeBuilder(Scope scope) {"
      },
      {
        "txt": "super(scope); } @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.CALL: SubclassRelationship relationship = codingConvention.getClassesDefinedByCall(n); if (relationship != null) { ObjectType superClass = ObjectType.cast( typeRegistry.getType(relationship.superclassName));"
      },
      {
        "txt": "ObjectType subClass = ObjectType.cast( typeRegistry.getType(relationship.subclassName)); if (superClass != null && subClass != null) { FunctionType superCtor = superClass.getConstructor(); FunctionType subCtor = subClass.getConstructor(); if (relationship.type == SubclassType.INHERITS) { validator.expectSuperType(t, n, superClass, subClass); } if (superCtor != null && subCtor != null) { codingConvention.applySubclassRelationship("
      },
      {
        "txt": "superCtor, subCtor, relationship.type); } } } String singletonGetterClassName = codingConvention.getSingletonGetterClassName(n); if (singletonGetterClassName != null) { ObjectType objectType = ObjectType.cast( typeRegistry.getType(singletonGetterClassName)); if (objectType != null) {"
      },
      {
        "txt": "FunctionType functionType = objectType.getConstructor(); if (functionType != null) { FunctionType getterType = typeRegistry.createFunctionType(objectType); codingConvention.applySingletonGetter(functionType, getterType, objectType); } } } DelegateRelationship delegateRelationship ="
      },
      {
        "txt": "codingConvention.getDelegateRelationship(n); if (delegateRelationship != null) { applyDelegateRelationship(delegateRelationship); } ObjectLiteralCast objectLiteralCast = codingConvention.getObjectLiteralCast(t, n); if (objectLiteralCast != null) { ObjectType type = ObjectType.cast( typeRegistry.getType(objectLiteralCast.typeName)); if (type != null && type.getConstructor() != null) {"
      },
      {
        "txt": "setDeferredType(objectLiteralCast.objectNode, type); } else { compiler.report(JSError.make(t.getSourceName(), n, CONSTRUCTOR_EXPECTED)); } } break; case Token.FUNCTION: if (!t.getInput().isExtern()) { nonExternFunctions.add(n);"
      },
      {
        "txt": "} if (parent.getType() == Token.ASSIGN || parent.getType() == Token.NAME) { return; } define(n, parent); break; case Token.ASSIGN: define(n, parent); checkForOldStyleTypedef(t, n);"
      },
      {
        "txt": "Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext()); } break; case Token.CATCH: define(n, parent); break;"
      },
      {
        "txt": "case Token.VAR: define(n, parent); if (n.hasOneChild()) { checkForOldStyleTypedef(t, n); checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo()); } break; case Token.GETPROP: if (parent.getType() == Token.EXPR_RESULT && n.isQualifiedName()) {"
      },
      {
        "txt": "checkForTypedef(t, n, n.getJSDocInfo()); maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); } break; } } private void applyDelegateRelationship( DelegateRelationship delegateRelationship) { ObjectType delegatorObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegator));"
      },
      {
        "txt": "ObjectType delegateBaseObject = ObjectType.cast( typeRegistry.getType(delegateRelationship.delegateBase)); ObjectType delegateSuperObject = ObjectType.cast( typeRegistry.getType(codingConvention.getDelegateSuperclassName())); if (delegatorObject != null && delegateBaseObject != null && delegateSuperObject != null) { FunctionType delegatorCtor = delegatorObject.getConstructor(); FunctionType delegateBaseCtor = delegateBaseObject.getConstructor(); FunctionType delegateSuperCtor = delegateSuperObject.getConstructor();"
      },
      {
        "txt": "if (delegatorCtor != null && delegateBaseCtor != null && delegateSuperCtor != null) { FunctionParamBuilder functionParamBuilder = new FunctionParamBuilder(typeRegistry); functionParamBuilder.addRequiredParams( typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE)); FunctionType findDelegate = typeRegistry.createFunctionType( typeRegistry.createDefaultObjectUnion(delegateBaseObject), functionParamBuilder.build()); FunctionType delegateProxy = typeRegistry.createConstructorType("
      },
      {
        "txt": "delegateBaseObject.getReferenceName() + \"(Proxy)\", null, null, null); delegateProxy.setPrototypeBasedOn(delegateBaseObject); codingConvention.applyDelegateRelationship( delegateSuperObject, delegateBaseObject, delegatorObject, delegateProxy, findDelegate); delegateProxyPrototypes.add(delegateProxy.getPrototype()); } } }"
      },
      {
        "txt": "private void checkForTypedef( NodeTraversal t, Node candidate, JSDocInfo info) { if (info == null || !info.hasTypedefType()) { return; } String typedef = candidate.getQualifiedName(); if (typedef == null) { return; } typeRegistry.forwardDeclareType(typedef);"
      },
      {
        "txt": "JSType realType = info.getTypedefType().evaluate(scope, typeRegistry); if (realType == null) { compiler.report( JSError.make( t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); if (candidate.getType() == Token.GETPROP) { defineSlot(candidate, candidate.getParent(), typeRegistry.getNativeType(NO_TYPE), false);"
      },
      {
        "txt": "} } private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) { String typedef = codingConvention.identifyTypeDefAssign(candidate); if (typedef != null) { typeRegistry.forwardDeclareType(typedef); JSDocInfo info = candidate.getJSDocInfo(); JSType realType = null; if (info != null && info.getType() != null) { realType = info.getType().evaluate(scope, typeRegistry);"
      },
      {
        "txt": "} if (realType == null) { compiler.report( JSError.make( t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); } typeRegistry.declareType(typedef, realType); } } private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,"
      },
      {
        "txt": "Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null); if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { if (!qVar.isTypeInferred()) {"
      },
      {
        "txt": "return; } scope.undeclare(qVar); } } JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue); if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (valueType == null) {"
      },
      {
        "txt": "if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration( n, t.getInput().isExtern(), ownerName)); } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType instanceof FunctionType) { JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ?"
      },
      {
        "txt": "null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true); } } } return; }"
      },
      {
        "txt": "boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && !scope.isDeclared(qName, false)); }"
      },
      {
        "txt": "if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, isExtern); }"
      },
      {
        "txt": "} defineSlot(n, parent, valueType, inferred); } } private ObjectType getObjectSlot(String slotName) { Var ownerVar = scope.getVar(slotName); if (ownerVar != null) { JSType ownerVarType = ownerVar.getType(); return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined());"
      },
      {
        "txt": "} return null; } private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, Node rhsValue) { if (info != null && info.hasType()) { return getDeclaredTypeInAnnotation(t, n, info); } else if (info != null && info.hasEnumParameterType()) { return n.getJSType(); } else if (rhsValue != null &&"
      },
      {
        "txt": "rhsValue.getType() == Token.FUNCTION) { return rhsValue.getJSType(); } else { return getDeclaredTypeInAnnotation(t, n, info); } } private void resolveStubDeclarations() { for (StubDeclaration stub : stubDeclarations) { Node n = stub.node; Node parent = n.getParent();"
      },
      {
        "txt": "String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); String ownerName = stub.ownerName; boolean isExtern = stub.isExtern; if (scope.isDeclared(qName, false)) { continue; } ObjectType ownerType = getObjectSlot(ownerName); ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE); defineSlot(n, parent, unknownType, true);"
      },
      {
        "txt": "if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) { ownerType.defineInferredProperty( propName, unknownType, isExtern); } else { typeRegistry.registerPropertyOnType( propName, ownerType == null ? unknownType : ownerType); } } }"
      },
      {
        "txt": "private final class StubDeclaration { private final Node node; private final boolean isExtern; private final String ownerName; private StubDeclaration(Node node, boolean isExtern, String ownerName) { this.node = node; this.isExtern = isExtern; this.ownerName = ownerName; } }"
      },
      {
        "txt": "private final class CollectProperties extends AbstractShallowCallback { private final ObjectType thisType; CollectProperties(ObjectType thisType) { this.thisType = thisType; } public void visit(NodeTraversal t, Node n, Node parent) { if (parent != null && parent.getType() == Token.EXPR_RESULT) { switch (n.getType()) { case Token.ASSIGN:"
      },
      {
        "txt": "maybeCollectMember(t, n.getFirstChild(), n); break; case Token.GETPROP: maybeCollectMember(t, n, n); break; } } } private void maybeCollectMember(NodeTraversal t, Node member, Node nodeWithJsDocInfo) {"
      },
      {
        "txt": "JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo(); if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) { return; } member.getFirstChild().setJSType(thisType); JSType jsType = getDeclaredTypeInAnnotation(t, member, info); Node name = member.getLastChild(); if (jsType != null &&"
      },
      {
        "txt": "(name.getType() == Token.NAME || name.getType() == Token.STRING)) { thisType.defineDeclaredProperty( name.getString(), jsType, false /* functions with implementations are not in externs */); } } } // end CollectProperties } // end GlobalScopeBuilder private final class LocalScopeBuilder extends AbstractScopeBuilder {"
      },
      {
        "txt": "private LocalScopeBuilder(Scope scope) { super(scope); } void build() { NodeTraversal.traverse(compiler, scope.getRootNode(), this); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent);"
      },
      {
        "txt": "return; } switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } define(n, parent); break; case Token.CATCH:"
      },
      {
        "txt": "case Token.VAR: define(n, parent); break; } } private void handleFunctionInputs(Node fnNode) { Node fnNameNode = fnNode.getFirstChild(); String fnName = fnNameNode.getString(); if (!fnName.isEmpty()) { Scope.Var fnVar = scope.getVar(fnName);"
      },
      {
        "txt": "if (fnVar == null || (fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false); } } declareArguments(fnNode); } private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext();"
      },
      {
        "txt": "Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);"
      },
      {
        "txt": "jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } } // end declareArguments } // end LocalScopeBuilder"
      }
    ]
  },
  {
    "id": 578,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
    "start-bug-line": 101,
    "end-bug-line": 101,
    "bug": "",
    "fix": "public FunctionBuilder withReturnType(JSType returnType, boolean inferred) { this.returnType = returnType; this.inferredReturnType = inferred; return this; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.Node; public final class FunctionBuilder { private final JSTypeRegistry registry; private String name = null; private Node sourceNode = null; private Node parametersNode = null; private JSType returnType = null; private ObjectType typeOfThis = null;"
      },
      {
        "txt": "private String templateTypeName = null; private boolean inferredReturnType = false; private boolean isConstructor = false; private boolean isNativeType = false; public FunctionBuilder(JSTypeRegistry registry) { this.registry = registry; } public FunctionBuilder withName(String name) { this.name = name; return this;"
      },
      {
        "txt": "} public FunctionBuilder withSourceNode(Node sourceNode) { this.sourceNode = sourceNode; return this; } public FunctionBuilder withParams(FunctionParamBuilder params) { this.parametersNode = params.build(); return this; } public FunctionBuilder withParamsNode(Node parametersNode) {"
      },
      {
        "txt": "return this; } public FunctionBuilder withReturnType(JSType returnType) { this.returnType = returnType; return this; } <extra_id_0> public FunctionBuilder withInferredReturnType(JSType returnType) { this.returnType = returnType; this.inferredReturnType = true; return this; } public FunctionBuilder withTypeOfThis(ObjectType typeOfThis) {"
      },
      {
        "txt": "} public FunctionBuilder withTypeOfThis(ObjectType typeOfThis) { this.typeOfThis = typeOfThis; return this; } public FunctionBuilder withTemplateName(String templateTypeName) { this.templateTypeName = templateTypeName; return this; } public FunctionBuilder forConstructor() {"
      },
      {
        "txt": "this.isConstructor = true; return this; } FunctionBuilder forNativeType() { this.isNativeType = true; return this; } public FunctionBuilder copyFromOtherFunction(FunctionType otherType) { this.name = otherType.getReferenceName(); this.sourceNode = otherType.getSource();"
      },
      {
        "txt": "this.parametersNode = otherType.getParametersNode(); this.returnType = otherType.getReturnType(); this.typeOfThis = otherType.getTypeOfThis(); this.templateTypeName = otherType.getTemplateTypeName(); this.isConstructor = otherType.isConstructor(); this.isNativeType = otherType.isNativeObjectType(); return this; } public FunctionType build() { return new FunctionType(registry, name, sourceNode,"
      },
      {
        "txt": "new ArrowType(registry, parametersNode, returnType, inferredReturnType), typeOfThis, templateTypeName, isConstructor, isNativeType); }"
      }
    ]
  },
  {
    "id": 579,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 517,
    "end-bug-line": 517,
    "bug": "registry, null, null,",
    "fix": "registry, null, source,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY, CONSTRUCTOR, INTERFACE"
      },
      {
        "txt": "} private ArrowType call; private FunctionPrototypeType prototype; private final Kind kind; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private String templateTypeName; FunctionType(JSTypeRegistry registry, String name, Node source,"
      },
      {
        "txt": "ArrowType arrowType, ObjectType typeOfThis, String templateTypeName, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;"
      },
      {
        "txt": "if (isConstructor) { this.typeOfThis = typeOfThis != null && typeOfThis.isNoObjectType() ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType; this.templateTypeName = templateTypeName;"
      },
      {
        "txt": "} private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.LP), null); this.kind = Kind.INTERFACE;"
      },
      {
        "txt": "this.typeOfThis = new InstanceObjectType(registry, this); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); } @Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); }"
      },
      {
        "txt": "@Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() { return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() {"
      },
      {
        "txt": "return kind == Kind.ORDINARY; } @Override public boolean isFunctionType() { return true; } @Override public boolean canBeCalled() { return true; }"
      },
      {
        "txt": "public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else { return Collections.emptySet(); } } public Node getParametersNode() { return call.parameters;"
      },
      {
        "txt": "} public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) { i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } }"
      },
      {
        "txt": "return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) { Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } }"
      },
      {
        "txt": "return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType; } public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call;"
      },
      {
        "txt": "} public FunctionPrototypeType getPrototype() { if (prototype == null) { setPrototype(new FunctionPrototypeType(registry, this, null)); } return prototype; } public void setPrototypeBasedOn(ObjectType baseType) { if (prototype == null) { setPrototype("
      },
      {
        "txt": "new FunctionPrototypeType( registry, this, baseType, isNativeObjectType())); } else { prototype.setImplicitPrototype(baseType); } } public boolean setPrototype(FunctionPrototypeType prototype) { if (prototype == null) { return false; }"
      },
      {
        "txt": "if (isConstructor() && prototype == getInstanceType()) { return false; } this.prototype = prototype; if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } }"
      },
      {
        "txt": "return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) {"
      },
      {
        "txt": "FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; } set.add(instance); if (constructor.getSuperClassConstructor() != null) { addRelatedInterfaces( constructor.getSuperClassConstructor().getInstanceType(), set); }"
      },
      {
        "txt": "} } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces());"
      },
      {
        "txt": "} } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } @Override public boolean hasProperty(String name) {"
      },
      {
        "txt": "return super.hasProperty(name) || \"prototype\".equals(name); } @Override public boolean hasOwnProperty(String name) { return super.hasOwnProperty(name) || \"prototype\".equals(name); } @Override public JSType getPropertyType(String name) { if (\"prototype\".equals(name)) { return getPrototype();"
      },
      {
        "txt": "} else { if (!hasOwnProperty(name)) { if (\"call\".equals(name)) { Node params = getParametersNode(); if (params == null) { defineDeclaredProperty(name, new FunctionBuilder(registry) .withReturnType(getReturnType()) .build(), false);"
      },
      {
        "txt": "} else { params = params.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(true); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParamsNode(params)"
      },
      {
        "txt": ".withReturnType(getReturnType()) .build(), false); } } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE)));"
      },
      {
        "txt": "defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(), false); } } return super.getPropertyType(name); }"
      },
      {
        "txt": "} @Override boolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (objType.isEquivalentTo(prototype)) { return true; }"
      },
      {
        "txt": "return setPrototype( new FunctionPrototypeType( registry, this, objType, isNativeObjectType())); } else { return false; } } return super.defineProperty(name, type, inferred, inExterns); } @Override"
      },
      {
        "txt": "public boolean isPropertyTypeInferred(String property) { return \"prototype\".equals(property) || super.isPropertyTypeInferred(property); } @Override public JSType getLeastSupertype(JSType that) { return supAndInfHelper(that, true); } @Override public JSType getGreatestSubtype(JSType that) {"
      },
      {
        "txt": "return supAndInfHelper(that, false); } private JSType supAndInfHelper(JSType that, boolean leastSuper) { if (isFunctionType() && that.isFunctionType()) { if (isEquivalentTo(that)) { return this; } if (isOrdinaryFunction() && that.isOrdinaryFunction() && that instanceof FunctionType) { FunctionType other = (FunctionType) that;"
      },
      {
        "txt": "if (call.hasEqualParameters(other.call) && isEquivalent(typeOfThis, other.typeOfThis)) { JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); return cloneWithNewReturnType( newReturnType, call.returnTypeInferred || other.call.returnTypeInferred); } }"
      },
      {
        "txt": "JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } return leastSuper ? registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE) : registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);"
      },
      {
        "txt": "return leastSuper ? super.getLeastSupertype(that) : super.getGreatestSubtype(that); } FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) { return new FunctionType( <extra_id_0> new ArrowType( registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface());"
      },
      {
        "txt": "public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); } public boolean hasUnknownSupertype() { Preconditions.checkArgument(isConstructor() || isInterface());"
      },
      {
        "txt": "Preconditions.checkArgument(!this.isUnknownType()); FunctionType ctor = this; while (true) { ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return false; } if (maybeSuperInstanceType.isUnknownType()) { return true;"
      },
      {
        "txt": "} ctor = maybeSuperInstanceType.getConstructor(); if (ctor == null) { return false; } Preconditions.checkState(ctor.isConstructor() || ctor.isInterface()); } } public JSType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface());"
      },
      {
        "txt": "Preconditions.checkArgument(getPrototype().hasProperty(propertyName)); FunctionType ctor = this; JSType topInstanceType; do { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName)); return topInstanceType; } @Override"
      },
      {
        "txt": "public boolean isEquivalentTo(JSType otherType) { if (!(otherType instanceof FunctionType)) { return false; } FunctionType that = (FunctionType) otherType; if (!that.isFunctionType()) { return false; } if (this.isConstructor()) { if (that.isConstructor()) {"
      },
      {
        "txt": "return this == that; } return false; } if (this.isInterface()) { if (that.isInterface()) { return this.getReferenceName().equals(that.getReferenceName()); } return false; }"
      },
      {
        "txt": "if (that.isInterface()) { return false; } return this.typeOfThis.isEquivalentTo(that.typeOfThis) && this.call.isEquivalentTo(that.call); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); }"
      },
      {
        "txt": "public boolean hasEqualCallType(FunctionType otherType) { return this.call.isEquivalentTo(otherType.call); } @Override public String toString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } StringBuilder b = new StringBuilder(32); b.append(\"function (\");"
      },
      {
        "txt": "int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\"); b.append(typeOfThis.toString()); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); }"
      },
      {
        "txt": "Node p = call.parameters.getFirstChild(); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); while (p != null) { b.append(\", \"); if (p.isVarArgs()) {"
      },
      {
        "txt": "appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); } } b.append(\"): \"); b.append(call.returnType); return b.toString();"
      },
      {
        "txt": "} private void appendVarArgsString(StringBuilder builder, JSType paramType) { if (paramType.isUnionType()) { paramType = ((UnionType) paramType).getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append(paramType.toString()).append(\"]\"); } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (this.isEquivalentTo(that)) { return true; } if (that.isFunctionType()) { if (((FunctionType) that).isInterface()) { return true; } if (this.isInterface()) { return false; }"
      },
      {
        "txt": "FunctionType other = (FunctionType) that; return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call); } if (that instanceof UnionType) { UnionType union = (UnionType) that; for (JSType element : union.alternates) { if (this.isSubtype(element)) {"
      },
      {
        "txt": "return true; } } } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); } @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); }"
      },
      {
        "txt": "public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); }"
      },
      {
        "txt": "public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis; } public Node getSource() { return source; } public void setSource(Node source) { this.source = source; }"
      },
      {
        "txt": "private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType); } public List<FunctionType> getSubTypes() { return subTypes; } @Override"
      },
      {
        "txt": "public boolean hasCachedValues() { return prototype != null || super.hasCachedValues(); } public String getTemplateTypeName() { return templateTypeName; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope);"
      },
      {
        "txt": "prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); }"
      },
      {
        "txt": "if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }"
      },
      {
        "txt": "@Override public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) {"
      },
      {
        "txt": "b.append(\"this:\"); b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext();"
      },
      {
        "txt": "while (p != null) { b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString();"
      },
      {
        "txt": "} private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); } }"
      }
    ]
  }
]