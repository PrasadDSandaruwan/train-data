[
  {
    "id": 281,
    "file_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
    "start-bug-line": 541,
    "end-bug-line": 541,
    "bug": "body.isBlock());",
    "fix": "body.isBlock(), body);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.InputId;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Deque; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Set; public class NodeTraversal { private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final Callback callback; private Node curNode; public static final DiagnosticType NODE_TRAVERSAL_ERROR = DiagnosticType.error(\"JSC_NODE_TRAVERSAL_ERROR\", \"{0}\"); private final Deque<Scope> scopes = new ArrayDeque<Scope>(); private final Deque<Node> scopeRoots = new ArrayDeque<Node>(); Deque<ControlFlowGraph<Node>> cfgs = new LinkedList<ControlFlowGraph<Node>>(); private String sourceName; private InputId inputId; private ScopeCreator scopeCreator;"
      },
      {
        "txt": "private ScopedCallback scopeCallback; public interface Callback { boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent); void visit(NodeTraversal t, Node n, Node parent); } public interface ScopedCallback extends Callback { void enterScope(NodeTraversal t); void exitScope(NodeTraversal t); } public abstract static class AbstractPostOrderCallback implements Callback {"
      },
      {
        "txt": "@Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { return true; } } public abstract static class AbstractScopedCallback implements ScopedCallback { @Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,"
      },
      {
        "txt": "Node parent) { return true; } @Override public void enterScope(NodeTraversal t) {} @Override public void exitScope(NodeTraversal t) {} } public abstract static class AbstractShallowCallback implements Callback { @Override"
      },
      {
        "txt": "public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { return parent == null || !parent.isFunction() || n == parent.getFirstChild(); } } public abstract static class AbstractShallowStatementCallback implements Callback { @Override public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,"
      },
      {
        "txt": "Node parent) { return parent == null || NodeUtil.isControlStructure(parent) || NodeUtil.isStatementBlock(parent); } } public abstract static class AbstractNodeTypePruningCallback implements Callback { private final Set<Integer> nodeTypes; private final boolean include; public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes) {"
      },
      {
        "txt": "this(nodeTypes, true); } public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes, boolean include) { this.nodeTypes = nodeTypes; this.include = include; } @Override public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {"
      },
      {
        "txt": "return include == nodeTypes.contains(n.getType()); } } public NodeTraversal(AbstractCompiler compiler, Callback cb) { this(compiler, cb, new SyntacticScopeCreator(compiler)); } public NodeTraversal(AbstractCompiler compiler, Callback cb, ScopeCreator scopeCreator) { this.callback = cb; if (cb instanceof ScopedCallback) {"
      },
      {
        "txt": "this.scopeCallback = (ScopedCallback) cb; } this.compiler = compiler; this.inputId = null; this.sourceName = \"\"; this.scopeCreator = scopeCreator; } private void throwUnexpectedException(Exception unexpectedException) { String message = unexpectedException.getMessage(); if (inputId != null) {"
      },
      {
        "txt": "message = unexpectedException.getMessage() + \"\\n\" + formatNodeContext(\"Node\", curNode) + (curNode == null ? \"\" : formatNodeContext(\"Parent\", curNode.getParent())); } compiler.throwInternalError(message, unexpectedException); } private String formatNodeContext(String label, Node n) {"
      },
      {
        "txt": "if (n == null) { return \" \" + label + \": NULL\"; } return \" \" + label + \"(\" + n.toString(false, false, false) + \"): \" + formatNodePosition(n); } public void traverse(Node root) { try { inputId = NodeUtil.getInputId(root); sourceName = \"\";"
      },
      {
        "txt": "curNode = root; pushScope(root); traverseBranch(root, null); popScope(); } catch (Exception unexpectedException) { throwUnexpectedException(unexpectedException); } } public void traverseRoots(Node ... roots) { traverseRoots(Lists.newArrayList(roots));"
      },
      {
        "txt": "} public void traverseRoots(List<Node> roots) { if (roots.isEmpty()) { return; } try { Node scopeRoot = roots.get(0).getParent(); Preconditions.checkState(scopeRoot != null); inputId = NodeUtil.getInputId(scopeRoot); sourceName = \"\";"
      },
      {
        "txt": "curNode = scopeRoot; pushScope(scopeRoot); for (Node root : roots) { Preconditions.checkState(root.getParent() == scopeRoot); traverseBranch(root, scopeRoot); } popScope(); } catch (Exception unexpectedException) { throwUnexpectedException(unexpectedException); }"
      },
      {
        "txt": "} private static final String MISSING_SOURCE = \"[source unknown]\"; private String formatNodePosition(Node n) { if (n == null) { return MISSING_SOURCE + \"\\n\"; } int lineNumber = n.getLineno(); int columnNumber = n.getCharno(); String src = compiler.getSourceLine(sourceName, lineNumber); if (src == null) {"
      },
      {
        "txt": "src = MISSING_SOURCE; } return sourceName + \":\" + lineNumber + \":\" + columnNumber + \"\\n\" + src + \"\\n\"; } void traverseWithScope(Node root, Scope s) { Preconditions.checkState(s.isGlobal()); inputId = null; sourceName = \"\"; curNode = root;"
      },
      {
        "txt": "pushScope(s); traverseBranch(root, null); popScope(); } void traverseAtScope(Scope s) { Node n = s.getRootNode(); if (n.isFunction()) { if (inputId == null) { inputId = NodeUtil.getInputId(n); }"
      },
      {
        "txt": "sourceName = getSourceName(n); curNode = n; pushScope(s); Node args = n.getFirstChild().getNext(); Node body = args.getNext(); traverseBranch(args, n); traverseBranch(body, n); popScope(); } else { traverseWithScope(n, s);"
      },
      {
        "txt": "} } protected void traverseInnerNode(Node node, Node parent, Scope refinedScope) { Preconditions.checkNotNull(parent); if (refinedScope != null && getScope() != refinedScope) { curNode = node; pushScope(refinedScope); traverseBranch(node, parent); popScope(); } else {"
      },
      {
        "txt": "traverseBranch(node, parent); } } public Compiler getCompiler() { return (Compiler) compiler; } public int getLineNumber() { Node cur = curNode; while (cur != null) { int line = cur.getLineno();"
      },
      {
        "txt": "if (line >=0) { return line; } cur = cur.getParent(); } return 0; } public String getSourceName() { return sourceName; }"
      },
      {
        "txt": "public CompilerInput getInput() { return compiler.getInput(inputId); } public JSModule getModule() { CompilerInput input = getInput(); return input == null ? null : input.getModule(); } public Node getCurrentNode() { return curNode; }"
      },
      {
        "txt": "public static void traverse( AbstractCompiler compiler, Node root, Callback cb) { NodeTraversal t = new NodeTraversal(compiler, cb); t.traverse(root); } public static void traverseRoots( AbstractCompiler compiler, List<Node> roots, Callback cb) { NodeTraversal t = new NodeTraversal(compiler, cb); t.traverseRoots(roots); }"
      },
      {
        "txt": "public static void traverseRoots( AbstractCompiler compiler, Callback cb, Node ... roots) { NodeTraversal t = new NodeTraversal(compiler, cb); t.traverseRoots(roots); } @SuppressWarnings(\"fallthrough\") private void traverseBranch(Node n, Node parent) { int type = n.getType(); if (type == Token.SCRIPT) { inputId = n.getInputId();"
      },
      {
        "txt": "sourceName = getSourceName(n); } curNode = n; if (!callback.shouldTraverse(this, n, parent)) return; switch (type) { case Token.FUNCTION: traverseFunction(n, parent); break; default: for (Node child = n.getFirstChild(); child != null; ) {"
      },
      {
        "txt": "Node next = child.getNext(); traverseBranch(child, n); child = next; } break; } curNode = n; callback.visit(this, n, parent); } private void traverseFunction(Node n, Node parent) {"
      },
      {
        "txt": "Preconditions.checkState(n.getChildCount() == 3); Preconditions.checkState(n.isFunction()); final Node fnName = n.getFirstChild(); boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n); if (!isFunctionExpression) { traverseBranch(fnName, n); } curNode = n; pushScope(n);"
      },
      {
        "txt": "traverseBranch(fnName, n); } final Node args = fnName.getNext(); final Node body = args.getNext(); traverseBranch(args, n); Preconditions.checkState(body.getNext() == null && <extra_id_0> traverseBranch(body, n); popScope(); } @SuppressWarnings(\"unchecked\") public Node getEnclosingFunction() { if (scopes.size() + scopeRoots.size() < 2) {"
      },
      {
        "txt": "public Node getEnclosingFunction() { if (scopes.size() + scopeRoots.size() < 2) { return null; } else { if (scopeRoots.isEmpty()) { return scopes.peek().getRootNode(); } else { return scopeRoots.peek(); } }"
      },
      {
        "txt": "} private void pushScope(Node node) { Preconditions.checkState(curNode != null); scopeRoots.push(node); cfgs.push(null); if (scopeCallback != null) { scopeCallback.enterScope(this); } } private void pushScope(Scope s) {"
      },
      {
        "txt": "Preconditions.checkState(curNode != null); scopes.push(s); cfgs.push(null); if (scopeCallback != null) { scopeCallback.enterScope(this); } } private void popScope() { if (scopeCallback != null) { scopeCallback.exitScope(this);"
      },
      {
        "txt": "} if (scopeRoots.isEmpty()) { scopes.pop(); } else { scopeRoots.pop(); } cfgs.pop(); } public Scope getScope() { Scope scope = scopes.isEmpty() ? null : scopes.peek();"
      },
      {
        "txt": "if (scopeRoots.isEmpty()) { return scope; } Iterator<Node> it = scopeRoots.descendingIterator(); while (it.hasNext()) { scope = scopeCreator.createScope(it.next(), scope); scopes.push(scope); } scopeRoots.clear(); return scope;"
      },
      {
        "txt": "} public ControlFlowGraph<Node> getControlFlowGraph() { if (cfgs.peek() == null) { ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); cfa.process(null, getScopeRoot()); cfgs.pop(); cfgs.push(cfa.getCfg()); } return cfgs.peek(); }"
      },
      {
        "txt": "public Node getScopeRoot() { if (scopeRoots.isEmpty()) { return scopes.peek().getRootNode(); } else { return scopeRoots.peek(); } } boolean inGlobalScope() { return getScopeDepth() <= 1; }"
      },
      {
        "txt": "int getScopeDepth() { return scopes.size() + scopeRoots.size(); } public boolean hasScope() { return !(scopes.isEmpty() && scopeRoots.isEmpty()); } public void report(Node n, DiagnosticType diagnosticType, String... arguments) { JSError error = JSError.make(getSourceName(), n, diagnosticType, arguments); compiler.report(error);"
      },
      {
        "txt": "} private static String getSourceName(Node n) { String name = n.getSourceFileName(); return name == null ? \"\" : name; } InputId getInputId() { return inputId; } public JSError makeError(Node n, CheckLevel level, DiagnosticType type, String... arguments) {"
      },
      {
        "txt": "return JSError.make(getSourceName(), n, level, type, arguments); } public JSError makeError(Node n, DiagnosticType type, String... arguments) { return JSError.make(getSourceName(), n, type, arguments); }"
      }
    ]
  },
  {
    "id": 282,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 667,
    "end-bug-line": 667,
    "bug": "",
    "fix": "if (!bodyNode.isBlock()) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.Token.CommentType; import com.google.javascript.rhino.head.ast.ArrayLiteral; import com.google.javascript.rhino.head.ast.Assignment; import com.google.javascript.rhino.head.ast.AstNode; import com.google.javascript.rhino.head.ast.AstRoot; import com.google.javascript.rhino.head.ast.Block;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.BreakStatement; import com.google.javascript.rhino.head.ast.CatchClause; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.head.ast.ConditionalExpression; import com.google.javascript.rhino.head.ast.ContinueStatement; import com.google.javascript.rhino.head.ast.DoLoop; import com.google.javascript.rhino.head.ast.ElementGet; import com.google.javascript.rhino.head.ast.EmptyExpression; import com.google.javascript.rhino.head.ast.ExpressionStatement; import com.google.javascript.rhino.head.ast.ForInLoop;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.ForLoop; import com.google.javascript.rhino.head.ast.FunctionCall; import com.google.javascript.rhino.head.ast.FunctionNode; import com.google.javascript.rhino.head.ast.IfStatement; import com.google.javascript.rhino.head.ast.InfixExpression; import com.google.javascript.rhino.head.ast.KeywordLiteral; import com.google.javascript.rhino.head.ast.Label; import com.google.javascript.rhino.head.ast.LabeledStatement; import com.google.javascript.rhino.head.ast.Name; import com.google.javascript.rhino.head.ast.NewExpression;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.NumberLiteral; import com.google.javascript.rhino.head.ast.ObjectLiteral; import com.google.javascript.rhino.head.ast.ObjectProperty; import com.google.javascript.rhino.head.ast.ParenthesizedExpression; import com.google.javascript.rhino.head.ast.PropertyGet; import com.google.javascript.rhino.head.ast.RegExpLiteral; import com.google.javascript.rhino.head.ast.ReturnStatement; import com.google.javascript.rhino.head.ast.Scope; import com.google.javascript.rhino.head.ast.StringLiteral; import com.google.javascript.rhino.head.ast.SwitchCase;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.SwitchStatement; import com.google.javascript.rhino.head.ast.ThrowStatement; import com.google.javascript.rhino.head.ast.TryStatement; import com.google.javascript.rhino.head.ast.UnaryExpression; import com.google.javascript.rhino.head.ast.VariableDeclaration; import com.google.javascript.rhino.head.ast.VariableInitializer; import com.google.javascript.rhino.head.ast.WhileLoop; import com.google.javascript.rhino.head.ast.WithStatement; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.Set;"
      },
      {
        "txt": "class IRFactory { static final String SUSPICIOUS_COMMENT_WARNING = \"Non-JSDoc comment has annotations. \" + \"Did you mean to start it with '/**'?\"; private final String sourceString; private final StaticSourceFile sourceFile; private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher;"
      },
      {
        "txt": "private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\"); private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords;"
      },
      {
        "txt": "private final Set<Comment> parsedComments = Sets.newHashSet(); Node rootNodeJsDocHolder = new Node(Token.SCRIPT); Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString, StaticSourceFile sourceFile, Config config, ErrorReporter errorReporter) {"
      },
      {
        "txt": "this.sourceString = sourceString; this.sourceFile = sourceFile; this.sourceName = sourceFile == null ? null : sourceFile.getName(); this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null;"
      },
      {
        "txt": "break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS; break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default: throw new IllegalStateException(\"unknown language mode\"); }"
      },
      {
        "txt": "} private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.setStaticSourceFile(sourceFile); return templateNode; } public static Node transformTree(AstRoot node, StaticSourceFile sourceFile, String sourceString, Config config,"
      },
      {
        "txt": "ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, sourceFile, config, errorReporter); Node irNode = irFactory.transform(node); if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == CommentType.JSDOC && !irFactory.parsedComments.contains(comment)) { irFactory.handlePossibleFileOverviewJsDoc(comment, irNode); } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {"
      },
      {
        "txt": "irFactory.handleBlockComment(comment); } } } irFactory.setFileOverviewJsDoc(irNode); return irNode; } private void setFileOverviewJsDoc(Node irNode) { JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo(); if (rootNodeJsDoc != null) {"
      },
      {
        "txt": "irNode.setJSDocInfo(rootNodeJsDoc); rootNodeJsDoc.setAssociatedNode(irNode); } if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); fileOverviewInfo.setAssociatedNode(irNode);"
      },
      {
        "txt": "} } private Node transformBlock(AstNode node) { Node irNode = transform(node); if (!irNode.isBlock()) { if (irNode.isEmpty()) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode);"
      },
      {
        "txt": "newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno()); maybeSetLengthFrom(newBlock, node); irNode = newBlock; } } return irNode; } private void handleBlockComment(Comment comment) { String value = comment.getValue();"
      },
      {
        "txt": "if (value.indexOf(\"/* @\") != -1 || value.indexOf(\"\\n * @\") != -1) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) {"
      },
      {
        "txt": "if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true; } return false; } private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode); parsedComments.add(comment); handlePossibleFileOverviewJsDoc(jsDocParser);"
      },
      {
        "txt": "} private JSDocInfo handleJsDoc(AstNode node, Node irNode) { Comment comment = node.getJsDocNode(); if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode); parsedComments.add(comment); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } }"
      },
      {
        "txt": "return null; } private Node transform(AstNode node) { Node irNode = justTransform(node); JSDocInfo jsDocInfo = handleJsDoc(node, irNode); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode;"
      },
      {
        "txt": "} private Node transformNameAsString(Name node) { Node irNode = transformDispatcher.processName(node, true); JSDocInfo jsDocInfo = handleJsDoc(node, irNode); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; }"
      },
      {
        "txt": "private Node transformNumberAsString(NumberLiteral literalNode) { Node irNode = newStringNode(getStringValue(literalNode.getNumber())); JSDocInfo jsDocInfo = handleJsDoc(literalNode, irNode); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, literalNode); return irNode; } private static String getStringValue(double value) {"
      },
      {
        "txt": "long longValue = (long) value; if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(value); } } private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getLineno() == -1) { int lineno = node.getLineno();"
      },
      {
        "txt": "irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); maybeSetLengthFrom(irNode, node); } } private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition();"
      },
      {
        "txt": "int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars), node, irNode, config, errorReporter);"
      },
      {
        "txt": "jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser; } private void maybeSetLengthFrom(Node node, AstNode source) { if (config.isIdeMode) { node.setLength(source.getLength()); } }"
      },
      {
        "txt": "private int position2charno(int position) { int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else { return position - lineIndex - 1; } } private Node justTransform(AstNode node) { return transformDispatcher.process(node);"
      },
      {
        "txt": "} private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.rhino.head.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.rhino.head.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node; }"
      },
      {
        "txt": "private Node transformAsString(AstNode n) { Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else if (n instanceof NumberLiteral) { ret = transformNumberAsString((NumberLiteral)n); ret.putBooleanProp(Node.QUOTED_PROP, true); } else { ret = transform(n); ret.putBooleanProp(Node.QUOTED_PROP, true);"
      },
      {
        "txt": "} Preconditions.checkState(ret.isString()); return ret; } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT);"
      },
      {
        "txt": "for (AstNode child : literalNode.getElements()) { Node c = transform(child); node.addChildToBack(c); } return node; } @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild();"
      },
      {
        "txt": "if (!validAssignmentTarget(target)) { errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0); } return assign; } @Override Node processAstRoot(AstRoot rootNode) {"
      },
      {
        "txt": "Node node = newNode(Token.SCRIPT); for (com.google.javascript.rhino.head.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node); return node; } private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) {"
      },
      {
        "txt": "String directive = node.removeFirstChild().getFirstChild().getString(); if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive); } } if (directives != null) { node.setDirectives(directives); }"
      },
      {
        "txt": "} private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return nType == Token.EXPR_RESULT && n.getFirstChild().isString() && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override Node processBlock(Block blockNode) {"
      },
      {
        "txt": "return processGeneric(blockNode); } @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); }"
      },
      {
        "txt": "return node; } @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\", sourceName,"
      },
      {
        "txt": "clauseNode.getCatchCondition().getLineno(), \"\", 0); } node.addChildToBack(transformBlock(clauseNode.getBody())); return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK, transform(exprNode.getTestExpression()),"
      },
      {
        "txt": "transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName);"
      },
      {
        "txt": "} return node; } @Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); }"
      },
      {
        "txt": "@Override Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY);"
      },
      {
        "txt": "return node; } @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override Node processForInLoop(ForInLoop loopNode) {"
      },
      {
        "txt": "if (loopNode.isForEach()) { errorReporter.error( \"unsupported language extension: for each\", sourceName, loopNode.getLineno(), \"\", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } return newNode( Token.FOR, transform(loopNode.getIterator()),"
      },
      {
        "txt": "transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()), transform(loopNode.getCondition()), transform(loopNode.getIncrement()));"
      },
      {
        "txt": "node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) { node.addChildToBack(transform(child)); }"
      },
      {
        "txt": "node.setLineno(node.getFirstChild().getLineno()); node.setCharno(node.getFirstChild().getCharno()); maybeSetLengthFrom(node, callNode); return node; } @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) {"
      },
      {
        "txt": "int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } name = new Name(); name.setIdentifier(\"\");"
      },
      {
        "txt": "isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); maybeSetLengthFrom(newName, name);"
      },
      {
        "txt": "} node.addChildToBack(newName); Node lp = newNode(Token.PARAM_LIST); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() +"
      },
      {
        "txt": "lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); <extra_id_0> parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node; } @Override Node processIfStatement(IfStatement statementNode) {"
      },
      {
        "txt": "@Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node; }"
      },
      {
        "txt": "@Override Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition())); maybeSetLengthFrom(n, exprNode); return n;"
      },
      {
        "txt": "} @Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); } @Override"
      },
      {
        "txt": "Node processLabeledStatement(LabeledStatement statementNode) { Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label)); cur.setLineno(label.getLineno());"
      },
      {
        "txt": "maybeSetLengthFrom(cur, label); int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement())); return node; }"
      },
      {
        "txt": "@Override Node processName(Name nameNode) { return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error("
      },
      {
        "txt": "\"identifier is a reserved word\", sourceName, nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); }"
      },
      {
        "txt": "@Override Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) {"
      },
      {
        "txt": "if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) {"
      },
      {
        "txt": "reportSetter(el); continue; } } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GETTER_DEF); Preconditions.checkState(value.isFunction()); if (getFnParamNode(value).hasChildren()) {"
      },
      {
        "txt": "reportGetterParam(el.getLeft()); } } else if (el.isSetter()) { key.setType(Token.SETTER_DEF); Preconditions.checkState(value.isFunction()); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); } } key.addChildToFront(value);"
      },
      {
        "txt": "node.addChildToBack(key); } return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.isFunction()); return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) {"
      },
      {
        "txt": "return processInfixExpression(propertyNode); } @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; } @Override Node processPropertyGet(PropertyGet getNode) {"
      },
      {
        "txt": "Node leftChild = transform(getNode.getTarget()); Node newNode = newNode( Token.GETPROP, leftChild, transformAsString(getNode.getProperty())); newNode.setLineno(leftChild.getLineno()); newNode.setCharno(leftChild.getCharno()); maybeSetLengthFrom(newNode, getNode); return newNode; } @Override Node processRegExpLiteral(RegExpLiteral literalNode) {"
      },
      {
        "txt": "Node literalStringNode = newStringNode(literalNode.getValue()); literalStringNode.setLineno(literalNode.getLineno()); maybeSetLengthFrom(literalStringNode, literalNode); Node node = newNode(Token.REGEXP, literalStringNode); String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); maybeSetLengthFrom(flagsNode, literalNode); node.addChildToBack(flagsNode);"
      },
      {
        "txt": "} return node; } @Override Node processReturnStatement(ReturnStatement statementNode) { Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); } return node;"
      },
      {
        "txt": "} @Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); } @Override Node processStringLiteral(StringLiteral literalNode) { String value = literalNode.getValue(); Node n = newStringNode(value); if (value.indexOf('\\u000B') != -1) {"
      },
      {
        "txt": "int start = literalNode.getAbsolutePosition(); int end = start + literalNode.getLength(); if (start < sourceString.length() && (sourceString.substring( start, Math.min(sourceString.length(), end)) .indexOf(\"\\\\v\") != -1)) { n.putBooleanProp(Node.SLASH_V, true); } } return n;"
      },
      {
        "txt": "} @Override Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT_CASE); } else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); }"
      },
      {
        "txt": "Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); maybeSetLengthFrom(block, caseNode); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) { block.addChildToBack(transform(child)); } }"
      },
      {
        "txt": "node.addChildToBack(block); return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression())); for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); }"
      },
      {
        "txt": "return node; } @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); } @Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY,"
      },
      {
        "txt": "transformBlock(statementNode.getTryBlock())); Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); maybeSetLengthFrom(block, cc); lineSet = true; } block.addChildToBack(transform(cc));"
      },
      {
        "txt": "} node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno()); maybeSetLengthFrom(block, finallyBlock); }"
      },
      {
        "txt": "return node; } @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.isNumber()) { operand.setDouble(-operand.getDouble()); return operand; } else {"
      },
      {
        "txt": "if (type == Token.DELPROP && !(operand.isGetProp() || operand.isGetElem() || operand.isName())) { String msg = \"Invalid delete operand. Only properties can be deleted.\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0);"
      },
      {
        "txt": "} else if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0); }"
      },
      {
        "txt": "} Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; } } private boolean validAssignmentTarget(Node target) { switch (target.getType()) {"
      },
      {
        "txt": "case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) { if (!config.acceptConstKeyword && declarationNode.getType() =="
      },
      {
        "txt": "com.google.javascript.rhino.head.Token.CONST) { processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); } return node; } @Override"
      },
      {
        "txt": "Node processVariableInitializer(VariableInitializer initializerNode) { Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { Node initalizer = transform(initializerNode.getInitializer()); node.addChildToBack(initalizer); } return node; } @Override Node processWhileLoop(WhileLoop loopNode) {"
      },
      {
        "txt": "return newNode( Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH, transform(statementNode.getExpression()),"
      },
      {
        "txt": "transformBlock(statementNode.getStatement())); } @Override Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.rhino.head.Token.typeToName( node.getType()), sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "return newNode(Token.EMPTY); } void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) { errorReporter.error("
      },
      {
        "txt": "\"getters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); }"
      },
      {
        "txt": "void reportGetterParam(AstNode node) { errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\", sourceName,"
      },
      {
        "txt": "node.getLineno(), \"\", 0); } } private static int transformTokenType(int token) { switch (token) { case com.google.javascript.rhino.head.Token.RETURN: return Token.RETURN; case com.google.javascript.rhino.head.Token.BITOR: return Token.BITOR; case com.google.javascript.rhino.head.Token.BITXOR:"
      },
      {
        "txt": "return Token.BITXOR; case com.google.javascript.rhino.head.Token.BITAND: return Token.BITAND; case com.google.javascript.rhino.head.Token.EQ: return Token.EQ; case com.google.javascript.rhino.head.Token.NE: return Token.NE; case com.google.javascript.rhino.head.Token.LT: return Token.LT; case com.google.javascript.rhino.head.Token.LE:"
      },
      {
        "txt": "return Token.LE; case com.google.javascript.rhino.head.Token.GT: return Token.GT; case com.google.javascript.rhino.head.Token.GE: return Token.GE; case com.google.javascript.rhino.head.Token.LSH: return Token.LSH; case com.google.javascript.rhino.head.Token.RSH: return Token.RSH; case com.google.javascript.rhino.head.Token.URSH:"
      },
      {
        "txt": "return Token.URSH; case com.google.javascript.rhino.head.Token.ADD: return Token.ADD; case com.google.javascript.rhino.head.Token.SUB: return Token.SUB; case com.google.javascript.rhino.head.Token.MUL: return Token.MUL; case com.google.javascript.rhino.head.Token.DIV: return Token.DIV; case com.google.javascript.rhino.head.Token.MOD:"
      },
      {
        "txt": "return Token.MOD; case com.google.javascript.rhino.head.Token.NOT: return Token.NOT; case com.google.javascript.rhino.head.Token.BITNOT: return Token.BITNOT; case com.google.javascript.rhino.head.Token.POS: return Token.POS; case com.google.javascript.rhino.head.Token.NEG: return Token.NEG; case com.google.javascript.rhino.head.Token.NEW:"
      },
      {
        "txt": "return Token.NEW; case com.google.javascript.rhino.head.Token.DELPROP: return Token.DELPROP; case com.google.javascript.rhino.head.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.rhino.head.Token.GETPROP: return Token.GETPROP; case com.google.javascript.rhino.head.Token.GETELEM: return Token.GETELEM; case com.google.javascript.rhino.head.Token.CALL:"
      },
      {
        "txt": "return Token.CALL; case com.google.javascript.rhino.head.Token.NAME: return Token.NAME; case com.google.javascript.rhino.head.Token.NUMBER: return Token.NUMBER; case com.google.javascript.rhino.head.Token.STRING: return Token.STRING; case com.google.javascript.rhino.head.Token.NULL: return Token.NULL; case com.google.javascript.rhino.head.Token.THIS:"
      },
      {
        "txt": "return Token.THIS; case com.google.javascript.rhino.head.Token.FALSE: return Token.FALSE; case com.google.javascript.rhino.head.Token.TRUE: return Token.TRUE; case com.google.javascript.rhino.head.Token.SHEQ: return Token.SHEQ; case com.google.javascript.rhino.head.Token.SHNE: return Token.SHNE; case com.google.javascript.rhino.head.Token.REGEXP:"
      },
      {
        "txt": "return Token.REGEXP; case com.google.javascript.rhino.head.Token.THROW: return Token.THROW; case com.google.javascript.rhino.head.Token.IN: return Token.IN; case com.google.javascript.rhino.head.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.rhino.head.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.rhino.head.Token.OBJECTLIT:"
      },
      {
        "txt": "return Token.OBJECTLIT; case com.google.javascript.rhino.head.Token.TRY: return Token.TRY; case com.google.javascript.rhino.head.Token.LP: return Token.PARAM_LIST; case com.google.javascript.rhino.head.Token.COMMA: return Token.COMMA; case com.google.javascript.rhino.head.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:"
      },
      {
        "txt": "return Token.ASSIGN_BITOR; case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.rhino.head.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.rhino.head.Token.ASSIGN_LSH: return Token.ASSIGN_LSH; case com.google.javascript.rhino.head.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.rhino.head.Token.ASSIGN_URSH:"
      },
      {
        "txt": "return Token.ASSIGN_URSH; case com.google.javascript.rhino.head.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.rhino.head.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.rhino.head.Token.ASSIGN_MUL: return Token.ASSIGN_MUL; case com.google.javascript.rhino.head.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.rhino.head.Token.ASSIGN_MOD:"
      },
      {
        "txt": "return Token.ASSIGN_MOD; case com.google.javascript.rhino.head.Token.HOOK: return Token.HOOK; case com.google.javascript.rhino.head.Token.OR: return Token.OR; case com.google.javascript.rhino.head.Token.AND: return Token.AND; case com.google.javascript.rhino.head.Token.INC: return Token.INC; case com.google.javascript.rhino.head.Token.DEC:"
      },
      {
        "txt": "return Token.DEC; case com.google.javascript.rhino.head.Token.FUNCTION: return Token.FUNCTION; case com.google.javascript.rhino.head.Token.IF: return Token.IF; case com.google.javascript.rhino.head.Token.SWITCH: return Token.SWITCH; case com.google.javascript.rhino.head.Token.CASE: return Token.CASE; case com.google.javascript.rhino.head.Token.DEFAULT:"
      },
      {
        "txt": "return Token.DEFAULT_CASE; case com.google.javascript.rhino.head.Token.WHILE: return Token.WHILE; case com.google.javascript.rhino.head.Token.DO: return Token.DO; case com.google.javascript.rhino.head.Token.FOR: return Token.FOR; case com.google.javascript.rhino.head.Token.BREAK: return Token.BREAK; case com.google.javascript.rhino.head.Token.CONTINUE:"
      },
      {
        "txt": "return Token.CONTINUE; case com.google.javascript.rhino.head.Token.VAR: return Token.VAR; case com.google.javascript.rhino.head.Token.WITH: return Token.WITH; case com.google.javascript.rhino.head.Token.CATCH: return Token.CATCH; case com.google.javascript.rhino.head.Token.VOID: return Token.VOID; case com.google.javascript.rhino.head.Token.EMPTY:"
      },
      {
        "txt": "return Token.EMPTY; case com.google.javascript.rhino.head.Token.BLOCK: return Token.BLOCK; case com.google.javascript.rhino.head.Token.LABEL: return Token.LABEL; case com.google.javascript.rhino.head.Token.EXPR_VOID: case com.google.javascript.rhino.head.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.rhino.head.Token.SCRIPT: return Token.SCRIPT;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.GET: return Token.GETTER_DEF; case com.google.javascript.rhino.head.Token.SET: return Token.SETTER_DEF; case com.google.javascript.rhino.head.Token.CONST: return Token.CONST; case com.google.javascript.rhino.head.Token.DEBUGGER: return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token));"
      },
      {
        "txt": "} private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newNode(int type, Node child1, Node child2, Node child3) { return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return IR.string(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) { return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) {"
      },
      {
        "txt": "return IR.number(value).clonePropsFrom(templateNode); }"
      }
    ]
  },
  {
    "id": 283,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 670,
    "end-bug-line": 670,
    "bug": "",
    "fix": "Preconditions.checkState(config.isIdeMode); bodyNode = IR.block(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.Token.CommentType; import com.google.javascript.rhino.head.ast.ArrayLiteral; import com.google.javascript.rhino.head.ast.Assignment; import com.google.javascript.rhino.head.ast.AstNode; import com.google.javascript.rhino.head.ast.AstRoot; import com.google.javascript.rhino.head.ast.Block;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.BreakStatement; import com.google.javascript.rhino.head.ast.CatchClause; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.head.ast.ConditionalExpression; import com.google.javascript.rhino.head.ast.ContinueStatement; import com.google.javascript.rhino.head.ast.DoLoop; import com.google.javascript.rhino.head.ast.ElementGet; import com.google.javascript.rhino.head.ast.EmptyExpression; import com.google.javascript.rhino.head.ast.ExpressionStatement; import com.google.javascript.rhino.head.ast.ForInLoop;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.ForLoop; import com.google.javascript.rhino.head.ast.FunctionCall; import com.google.javascript.rhino.head.ast.FunctionNode; import com.google.javascript.rhino.head.ast.IfStatement; import com.google.javascript.rhino.head.ast.InfixExpression; import com.google.javascript.rhino.head.ast.KeywordLiteral; import com.google.javascript.rhino.head.ast.Label; import com.google.javascript.rhino.head.ast.LabeledStatement; import com.google.javascript.rhino.head.ast.Name; import com.google.javascript.rhino.head.ast.NewExpression;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.NumberLiteral; import com.google.javascript.rhino.head.ast.ObjectLiteral; import com.google.javascript.rhino.head.ast.ObjectProperty; import com.google.javascript.rhino.head.ast.ParenthesizedExpression; import com.google.javascript.rhino.head.ast.PropertyGet; import com.google.javascript.rhino.head.ast.RegExpLiteral; import com.google.javascript.rhino.head.ast.ReturnStatement; import com.google.javascript.rhino.head.ast.Scope; import com.google.javascript.rhino.head.ast.StringLiteral; import com.google.javascript.rhino.head.ast.SwitchCase;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ast.SwitchStatement; import com.google.javascript.rhino.head.ast.ThrowStatement; import com.google.javascript.rhino.head.ast.TryStatement; import com.google.javascript.rhino.head.ast.UnaryExpression; import com.google.javascript.rhino.head.ast.VariableDeclaration; import com.google.javascript.rhino.head.ast.VariableInitializer; import com.google.javascript.rhino.head.ast.WhileLoop; import com.google.javascript.rhino.head.ast.WithStatement; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.Set;"
      },
      {
        "txt": "class IRFactory { static final String SUSPICIOUS_COMMENT_WARNING = \"Non-JSDoc comment has annotations. \" + \"Did you mean to start it with '/**'?\"; private final String sourceString; private final StaticSourceFile sourceFile; private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher;"
      },
      {
        "txt": "private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\"); private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords;"
      },
      {
        "txt": "private final Set<Comment> parsedComments = Sets.newHashSet(); Node rootNodeJsDocHolder = new Node(Token.SCRIPT); Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString, StaticSourceFile sourceFile, Config config, ErrorReporter errorReporter) {"
      },
      {
        "txt": "this.sourceString = sourceString; this.sourceFile = sourceFile; this.sourceName = sourceFile == null ? null : sourceFile.getName(); this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null;"
      },
      {
        "txt": "break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS; break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default: throw new IllegalStateException(\"unknown language mode\"); }"
      },
      {
        "txt": "} private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.setStaticSourceFile(sourceFile); return templateNode; } public static Node transformTree(AstRoot node, StaticSourceFile sourceFile, String sourceString, Config config,"
      },
      {
        "txt": "ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, sourceFile, config, errorReporter); Node irNode = irFactory.transform(node); if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == CommentType.JSDOC && !irFactory.parsedComments.contains(comment)) { irFactory.handlePossibleFileOverviewJsDoc(comment, irNode); } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {"
      },
      {
        "txt": "irFactory.handleBlockComment(comment); } } } irFactory.setFileOverviewJsDoc(irNode); return irNode; } private void setFileOverviewJsDoc(Node irNode) { JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo(); if (rootNodeJsDoc != null) {"
      },
      {
        "txt": "irNode.setJSDocInfo(rootNodeJsDoc); rootNodeJsDoc.setAssociatedNode(irNode); } if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); fileOverviewInfo.setAssociatedNode(irNode);"
      },
      {
        "txt": "} } private Node transformBlock(AstNode node) { Node irNode = transform(node); if (!irNode.isBlock()) { if (irNode.isEmpty()) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode);"
      },
      {
        "txt": "newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno()); maybeSetLengthFrom(newBlock, node); irNode = newBlock; } } return irNode; } private void handleBlockComment(Comment comment) { String value = comment.getValue();"
      },
      {
        "txt": "if (value.indexOf(\"/* @\") != -1 || value.indexOf(\"\\n * @\") != -1) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) {"
      },
      {
        "txt": "if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true; } return false; } private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode); parsedComments.add(comment); handlePossibleFileOverviewJsDoc(jsDocParser);"
      },
      {
        "txt": "} private JSDocInfo handleJsDoc(AstNode node, Node irNode) { Comment comment = node.getJsDocNode(); if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode); parsedComments.add(comment); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } }"
      },
      {
        "txt": "return null; } private Node transform(AstNode node) { Node irNode = justTransform(node); JSDocInfo jsDocInfo = handleJsDoc(node, irNode); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode;"
      },
      {
        "txt": "} private Node transformNameAsString(Name node) { Node irNode = transformDispatcher.processName(node, true); JSDocInfo jsDocInfo = handleJsDoc(node, irNode); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; }"
      },
      {
        "txt": "private Node transformNumberAsString(NumberLiteral literalNode) { Node irNode = newStringNode(getStringValue(literalNode.getNumber())); JSDocInfo jsDocInfo = handleJsDoc(literalNode, irNode); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, literalNode); return irNode; } private static String getStringValue(double value) {"
      },
      {
        "txt": "long longValue = (long) value; if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(value); } } private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getLineno() == -1) { int lineno = node.getLineno();"
      },
      {
        "txt": "irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); maybeSetLengthFrom(irNode, node); } } private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition();"
      },
      {
        "txt": "int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars), node, irNode, config, errorReporter);"
      },
      {
        "txt": "jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser; } private void maybeSetLengthFrom(Node node, AstNode source) { if (config.isIdeMode) { node.setLength(source.getLength()); } }"
      },
      {
        "txt": "private int position2charno(int position) { int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else { return position - lineIndex - 1; } } private Node justTransform(AstNode node) { return transformDispatcher.process(node);"
      },
      {
        "txt": "} private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.rhino.head.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.rhino.head.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node; }"
      },
      {
        "txt": "private Node transformAsString(AstNode n) { Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else if (n instanceof NumberLiteral) { ret = transformNumberAsString((NumberLiteral)n); ret.putBooleanProp(Node.QUOTED_PROP, true); } else { ret = transform(n); ret.putBooleanProp(Node.QUOTED_PROP, true);"
      },
      {
        "txt": "} Preconditions.checkState(ret.isString()); return ret; } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT);"
      },
      {
        "txt": "for (AstNode child : literalNode.getElements()) { Node c = transform(child); node.addChildToBack(c); } return node; } @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild();"
      },
      {
        "txt": "if (!validAssignmentTarget(target)) { errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0); } return assign; } @Override Node processAstRoot(AstRoot rootNode) {"
      },
      {
        "txt": "Node node = newNode(Token.SCRIPT); for (com.google.javascript.rhino.head.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node); return node; } private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) {"
      },
      {
        "txt": "String directive = node.removeFirstChild().getFirstChild().getString(); if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive); } } if (directives != null) { node.setDirectives(directives); }"
      },
      {
        "txt": "} private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return nType == Token.EXPR_RESULT && n.getFirstChild().isString() && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override Node processBlock(Block blockNode) {"
      },
      {
        "txt": "return processGeneric(blockNode); } @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); }"
      },
      {
        "txt": "return node; } @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\", sourceName,"
      },
      {
        "txt": "clauseNode.getCatchCondition().getLineno(), \"\", 0); } node.addChildToBack(transformBlock(clauseNode.getBody())); return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK, transform(exprNode.getTestExpression()),"
      },
      {
        "txt": "transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName);"
      },
      {
        "txt": "} return node; } @Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); }"
      },
      {
        "txt": "@Override Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY);"
      },
      {
        "txt": "return node; } @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override Node processForInLoop(ForInLoop loopNode) {"
      },
      {
        "txt": "if (loopNode.isForEach()) { errorReporter.error( \"unsupported language extension: for each\", sourceName, loopNode.getLineno(), \"\", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } return newNode( Token.FOR, transform(loopNode.getIterator()),"
      },
      {
        "txt": "transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()), transform(loopNode.getCondition()), transform(loopNode.getIncrement()));"
      },
      {
        "txt": "node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) { node.addChildToBack(transform(child)); }"
      },
      {
        "txt": "node.setLineno(node.getFirstChild().getLineno()); node.setCharno(node.getFirstChild().getCharno()); maybeSetLengthFrom(node, callNode); return node; } @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) {"
      },
      {
        "txt": "int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } name = new Name(); name.setIdentifier(\"\");"
      },
      {
        "txt": "isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); maybeSetLengthFrom(newName, name);"
      },
      {
        "txt": "} node.addChildToBack(newName); Node lp = newNode(Token.PARAM_LIST); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() +"
      },
      {
        "txt": "lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); <extra_id_0> node.addChildToBack(bodyNode); return node; } @Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF);"
      },
      {
        "txt": "Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node; } @Override"
      },
      {
        "txt": "Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition())); maybeSetLengthFrom(n, exprNode); return n; }"
      },
      {
        "txt": "@Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); } @Override Node processLabeledStatement(LabeledStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label)); cur.setLineno(label.getLineno()); maybeSetLengthFrom(cur, label);"
      },
      {
        "txt": "int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement())); return node; } @Override"
      },
      {
        "txt": "Node processName(Name nameNode) { return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error( \"identifier is a reserved word\","
      },
      {
        "txt": "sourceName, nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); } @Override"
      },
      {
        "txt": "Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) { if (literalNode.isDestructuring()) {"
      },
      {
        "txt": "reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) { reportSetter(el);"
      },
      {
        "txt": "continue; } } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GETTER_DEF); Preconditions.checkState(value.isFunction()); if (getFnParamNode(value).hasChildren()) { reportGetterParam(el.getLeft());"
      },
      {
        "txt": "} } else if (el.isSetter()) { key.setType(Token.SETTER_DEF); Preconditions.checkState(value.isFunction()); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); } } key.addChildToFront(value); node.addChildToBack(key);"
      },
      {
        "txt": "} return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.isFunction()); return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) { return processInfixExpression(propertyNode);"
      },
      {
        "txt": "} @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; } @Override Node processPropertyGet(PropertyGet getNode) { Node leftChild = transform(getNode.getTarget());"
      },
      {
        "txt": "Node newNode = newNode( Token.GETPROP, leftChild, transformAsString(getNode.getProperty())); newNode.setLineno(leftChild.getLineno()); newNode.setCharno(leftChild.getCharno()); maybeSetLengthFrom(newNode, getNode); return newNode; } @Override Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue());"
      },
      {
        "txt": "literalStringNode.setLineno(literalNode.getLineno()); maybeSetLengthFrom(literalStringNode, literalNode); Node node = newNode(Token.REGEXP, literalStringNode); String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); maybeSetLengthFrom(flagsNode, literalNode); node.addChildToBack(flagsNode); }"
      },
      {
        "txt": "return node; } @Override Node processReturnStatement(ReturnStatement statementNode) { Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); } return node; }"
      },
      {
        "txt": "@Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); } @Override Node processStringLiteral(StringLiteral literalNode) { String value = literalNode.getValue(); Node n = newStringNode(value); if (value.indexOf('\\u000B') != -1) { int start = literalNode.getAbsolutePosition();"
      },
      {
        "txt": "int end = start + literalNode.getLength(); if (start < sourceString.length() && (sourceString.substring( start, Math.min(sourceString.length(), end)) .indexOf(\"\\\\v\") != -1)) { n.putBooleanProp(Node.SLASH_V, true); } } return n; }"
      },
      {
        "txt": "@Override Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT_CASE); } else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); } Node block = newNode(Token.BLOCK);"
      },
      {
        "txt": "block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); maybeSetLengthFrom(block, caseNode); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) { block.addChildToBack(transform(child)); } } node.addChildToBack(block);"
      },
      {
        "txt": "return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression())); for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); } return node;"
      },
      {
        "txt": "} @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); } @Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));"
      },
      {
        "txt": "Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); maybeSetLengthFrom(block, cc); lineSet = true; } block.addChildToBack(transform(cc)); }"
      },
      {
        "txt": "node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno()); maybeSetLengthFrom(block, finallyBlock); } return node;"
      },
      {
        "txt": "} @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.isNumber()) { operand.setDouble(-operand.getDouble()); return operand; } else { if (type == Token.DELPROP &&"
      },
      {
        "txt": "!(operand.isGetProp() || operand.isGetElem() || operand.isName())) { String msg = \"Invalid delete operand. Only properties can be deleted.\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0); } else if (type == Token.INC || type == Token.DEC) {"
      },
      {
        "txt": "if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0); } }"
      },
      {
        "txt": "Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; } } private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME:"
      },
      {
        "txt": "case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) { if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.rhino.head.Token.CONST) {"
      },
      {
        "txt": "processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); } return node; } @Override Node processVariableInitializer(VariableInitializer initializerNode) {"
      },
      {
        "txt": "Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { Node initalizer = transform(initializerNode.getInitializer()); node.addChildToBack(initalizer); } return node; } @Override Node processWhileLoop(WhileLoop loopNode) { return newNode("
      },
      {
        "txt": "Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement()));"
      },
      {
        "txt": "} @Override Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.rhino.head.Token.typeToName( node.getType()), sourceName, node.getLineno(), \"\", 0); return newNode(Token.EMPTY);"
      },
      {
        "txt": "} void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) { errorReporter.error( \"getters are not supported in Internet Explorer\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportGetterParam(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} } private static int transformTokenType(int token) { switch (token) { case com.google.javascript.rhino.head.Token.RETURN: return Token.RETURN; case com.google.javascript.rhino.head.Token.BITOR: return Token.BITOR; case com.google.javascript.rhino.head.Token.BITXOR: return Token.BITXOR;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.BITAND: return Token.BITAND; case com.google.javascript.rhino.head.Token.EQ: return Token.EQ; case com.google.javascript.rhino.head.Token.NE: return Token.NE; case com.google.javascript.rhino.head.Token.LT: return Token.LT; case com.google.javascript.rhino.head.Token.LE: return Token.LE;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.GT: return Token.GT; case com.google.javascript.rhino.head.Token.GE: return Token.GE; case com.google.javascript.rhino.head.Token.LSH: return Token.LSH; case com.google.javascript.rhino.head.Token.RSH: return Token.RSH; case com.google.javascript.rhino.head.Token.URSH: return Token.URSH;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.ADD: return Token.ADD; case com.google.javascript.rhino.head.Token.SUB: return Token.SUB; case com.google.javascript.rhino.head.Token.MUL: return Token.MUL; case com.google.javascript.rhino.head.Token.DIV: return Token.DIV; case com.google.javascript.rhino.head.Token.MOD: return Token.MOD;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.NOT: return Token.NOT; case com.google.javascript.rhino.head.Token.BITNOT: return Token.BITNOT; case com.google.javascript.rhino.head.Token.POS: return Token.POS; case com.google.javascript.rhino.head.Token.NEG: return Token.NEG; case com.google.javascript.rhino.head.Token.NEW: return Token.NEW;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.DELPROP: return Token.DELPROP; case com.google.javascript.rhino.head.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.rhino.head.Token.GETPROP: return Token.GETPROP; case com.google.javascript.rhino.head.Token.GETELEM: return Token.GETELEM; case com.google.javascript.rhino.head.Token.CALL: return Token.CALL;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.NAME: return Token.NAME; case com.google.javascript.rhino.head.Token.NUMBER: return Token.NUMBER; case com.google.javascript.rhino.head.Token.STRING: return Token.STRING; case com.google.javascript.rhino.head.Token.NULL: return Token.NULL; case com.google.javascript.rhino.head.Token.THIS: return Token.THIS;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.FALSE: return Token.FALSE; case com.google.javascript.rhino.head.Token.TRUE: return Token.TRUE; case com.google.javascript.rhino.head.Token.SHEQ: return Token.SHEQ; case com.google.javascript.rhino.head.Token.SHNE: return Token.SHNE; case com.google.javascript.rhino.head.Token.REGEXP: return Token.REGEXP;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.THROW: return Token.THROW; case com.google.javascript.rhino.head.Token.IN: return Token.IN; case com.google.javascript.rhino.head.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.rhino.head.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.rhino.head.Token.OBJECTLIT: return Token.OBJECTLIT;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.TRY: return Token.TRY; case com.google.javascript.rhino.head.Token.LP: return Token.PARAM_LIST; case com.google.javascript.rhino.head.Token.COMMA: return Token.COMMA; case com.google.javascript.rhino.head.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.rhino.head.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.rhino.head.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.rhino.head.Token.ASSIGN_LSH: return Token.ASSIGN_LSH; case com.google.javascript.rhino.head.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.rhino.head.Token.ASSIGN_URSH: return Token.ASSIGN_URSH;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.rhino.head.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.rhino.head.Token.ASSIGN_MUL: return Token.ASSIGN_MUL; case com.google.javascript.rhino.head.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.rhino.head.Token.ASSIGN_MOD: return Token.ASSIGN_MOD;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.HOOK: return Token.HOOK; case com.google.javascript.rhino.head.Token.OR: return Token.OR; case com.google.javascript.rhino.head.Token.AND: return Token.AND; case com.google.javascript.rhino.head.Token.INC: return Token.INC; case com.google.javascript.rhino.head.Token.DEC: return Token.DEC;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.FUNCTION: return Token.FUNCTION; case com.google.javascript.rhino.head.Token.IF: return Token.IF; case com.google.javascript.rhino.head.Token.SWITCH: return Token.SWITCH; case com.google.javascript.rhino.head.Token.CASE: return Token.CASE; case com.google.javascript.rhino.head.Token.DEFAULT: return Token.DEFAULT_CASE;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.WHILE: return Token.WHILE; case com.google.javascript.rhino.head.Token.DO: return Token.DO; case com.google.javascript.rhino.head.Token.FOR: return Token.FOR; case com.google.javascript.rhino.head.Token.BREAK: return Token.BREAK; case com.google.javascript.rhino.head.Token.CONTINUE: return Token.CONTINUE;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.VAR: return Token.VAR; case com.google.javascript.rhino.head.Token.WITH: return Token.WITH; case com.google.javascript.rhino.head.Token.CATCH: return Token.CATCH; case com.google.javascript.rhino.head.Token.VOID: return Token.VOID; case com.google.javascript.rhino.head.Token.EMPTY: return Token.EMPTY;"
      },
      {
        "txt": "case com.google.javascript.rhino.head.Token.BLOCK: return Token.BLOCK; case com.google.javascript.rhino.head.Token.LABEL: return Token.LABEL; case com.google.javascript.rhino.head.Token.EXPR_VOID: case com.google.javascript.rhino.head.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.rhino.head.Token.SCRIPT: return Token.SCRIPT; case com.google.javascript.rhino.head.Token.GET:"
      },
      {
        "txt": "return Token.GETTER_DEF; case com.google.javascript.rhino.head.Token.SET: return Token.SETTER_DEF; case com.google.javascript.rhino.head.Token.CONST: return Token.CONST; case com.google.javascript.rhino.head.Token.DEBUGGER: return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token)); }"
      },
      {
        "txt": "private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2, Node child3) {"
      },
      {
        "txt": "return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return IR.string(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) { return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) { return IR.number(value).clonePropsFrom(templateNode);"
      }
    ]
  }
]