[
  {
    "id": 716,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 343,
    "end-bug-line": 343,
    "bug": "if (TokenStream.isJSIdentifier(name) &&",
    "fix": "if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) &&",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Charsets; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator { private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7',"
      },
      {
        "txt": "'8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc; private final CharsetEncoder outputCharsetEncoder; CodeGenerator( CodeConsumer consumer, Charset outputCharset) { cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null; } else { this.outputCharsetEncoder = outputCharset.newEncoder();"
      },
      {
        "txt": "} } CodeGenerator(CodeConsumer consumer) { this(consumer, null); } public void tagAsStrict() { add(\"'use strict';\"); } void add(String str) { cc.add(str);"
      },
      {
        "txt": "} private void addIdentifier(String identifier) { cc.addIdentifier(identifierEscape(identifier)); } void add(Node n) { add(n, Context.OTHER); } void add(Node n, Context context) { if (!cc.continueProcessing()) { return;"
      },
      {
        "txt": "} int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState( childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\","
      },
      {
        "txt": "opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context); cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext);"
      },
      {
        "txt": "} else { addExpr(last, p + 1, rhsContext); } return; } cc.startSourceMapping(n); switch (type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());"
      },
      {
        "txt": "Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\"finally\"); add(last, Context.PRESERVE_BLOCK);"
      },
      {
        "txt": "} break; } case Token.CATCH: Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\"); add(last, Context.PRESERVE_BLOCK); break;"
      },
      {
        "txt": "case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\"return\"); if (childCount == 1) { add(first);"
      },
      {
        "txt": "} else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\"var \"); addList(first, false, getContextForNoInOperator(context)); }"
      },
      {
        "txt": "break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT:"
      },
      {
        "txt": "add(\"[\"); addArrayList(first); add(\"]\"); break; case Token.LP: add(\"(\"); addList(first); add(\")\"); break; case Token.COMMA:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); addList(first, false, context); break; case Token.NUMBER: Preconditions.checkState( childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)); cc.addNumber(n.getDouble()); break;"
      },
      {
        "txt": "case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; }"
      },
      {
        "txt": "case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); } break; }"
      },
      {
        "txt": "case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1); break; }"
      },
      {
        "txt": "case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) { throw new Error(\"Expected children to be strings\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "add(regexp); } break; case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\".\");"
      },
      {
        "txt": "add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\"(\");"
      },
      {
        "txt": "} add(\"function\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\"); } break;"
      },
      {
        "txt": "case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\"get \"); } else {"
      },
      {
        "txt": "add(\"set \"); } String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); <extra_id_0> NodeUtil.isLatin(name)) { add(name); } else { add(jsString(n.getString(), outputCharsetEncoder)); } add(parameters);"
      },
      {
        "txt": "} add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK;"
      },
      {
        "txt": "if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) {"
      },
      {
        "txt": "add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); }"
      },
      {
        "txt": "} if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) {"
      },
      {
        "txt": "add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\";\"); add(first.getNext()); add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement("
      },
      {
        "txt": "last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\"for(\"); add(first); add(\"in\"); add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false);"
      },
      {
        "txt": "} break; case Token.DO: Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false); add(\"while(\"); add(last); add(\")\"); cc.endStatement();"
      },
      {
        "txt": "break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount); Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER);"
      },
      {
        "txt": "if (needsParens) { add(\"(\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\"); } add(\".\"); addIdentifier(last.getString()); break;"
      },
      {
        "txt": "} case Token.GETELEM: Preconditions.checkState( childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context); add(\"[\"); add(first.getNext()); add(\"]\"); break;"
      },
      {
        "txt": "case Token.WITH: Preconditions.checkState(childCount == 2); add(\"with(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: {"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); }"
      },
      {
        "txt": "break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\"); addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context);"
      },
      {
        "txt": "} add(\"(\"); addList(first.getNext()); add(\")\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) {"
      },
      {
        "txt": "cc.beginBlock(); } add(\"if(\"); add(first); add(\")\"); if (hasElse) { addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement("
      },
      {
        "txt": "last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL:"
      },
      {
        "txt": "case Token.THIS: case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) {"
      },
      {
        "txt": "if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0);"
      },
      {
        "txt": "add(\"debugger\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); }"
      },
      {
        "txt": "add(\" \"); add(first); } cc.endStatement(); break; case Token.EXPR_VOID: throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR);"
      },
      {
        "txt": "cc.endStatement(); break; case Token.NEW: add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext();"
      },
      {
        "txt": "if (next != null) { add(\"(\"); addList(next); add(\")\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {"
      },
      {
        "txt": "throw new IllegalStateException( \"Unexpected String children: \" + n.getParent().toStringTree()); } add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break;"
      },
      {
        "txt": "case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\"); } add(\"{\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); }"
      },
      {
        "txt": "if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); } else {"
      },
      {
        "txt": "addExpr(c, 1); } add(\":\"); addExpr(c.getFirstChild(), 1); } } add(\"}\"); if (needsParens) { add(\")\"); }"
      },
      {
        "txt": "break; } case Token.SWITCH: add(\"switch(\"); add(first); add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break;"
      },
      {
        "txt": "case Token.CASE: Preconditions.checkState(childCount == 2); add(\"case \"); add(first); addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first);"
      },
      {
        "txt": "break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true);"
      },
      {
        "txt": "break; case Token.SETNAME: break; default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n); } private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&"
      },
      {
        "txt": "!n.getBooleanProp(Node.DIRECT_EVAL); } private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2);"
      },
      {
        "txt": "if (count == 0) { if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); } return; } if (count == 1) {"
      },
      {
        "txt": "Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild;"
      },
      {
        "txt": "} } if (count > 1) { context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context);"
      },
      {
        "txt": "if (nodeToProcess.getType() == Token.VAR) { cc.endStatement(); } } } private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement);"
      },
      {
        "txt": "} else { if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); }"
      },
      {
        "txt": "} void addLeftExpr(Node n, int minPrecedence, Context context) { addExpr(n, minPrecedence, context); } void addExpr(Node n, int minPrecedence) { addExpr(n, minPrecedence, Context.OTHER); } private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) &&"
      },
      {
        "txt": "(n.getType() == Token.IN))){ add(\"(\"); add(n, clearContextForNoInOperator(context)); add(\")\"); } else { add(n, context); } } void addList(Node firstInList) { addList(firstInList, true, Context.OTHER);"
      },
      {
        "txt": "} void addList(Node firstInList, boolean isArrayOrFunctionArgument) { addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) { boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);"
      },
      {
        "txt": "} else { cc.listSeparator(); addExpr(n, isArrayOrFunctionArgument ? 1 : 0); } } } void addArrayList(Node firstInList) { boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) {"
      },
      {
        "txt": "cc.listSeparator(); } addExpr(n, 1); lastWasEmpty = n.getType() == Token.EMPTY; } if (lastWasEmpty) { cc.listSeparator(); } } void addCaseBody(Node caseBody) {"
      },
      {
        "txt": "cc.beginCaseBody(); add(caseBody); cc.endCaseBody(); } void addAllSiblings(Node n) { for (Node c = n; c != null; c = c.getNext()) { add(c); } } static String jsString(String s, CharsetEncoder outputCharsetEncoder) {"
      },
      {
        "txt": "int singleq = 0, doubleq = 0; for (int i = 0; i < s.length(); i++) { switch (s.charAt(i)) { case '\"': doubleq++; break; case '\\'': singleq++; break; } } String doublequote, singlequote; char quote; if (singleq < doubleq) {"
      },
      {
        "txt": "quote = '\\''; doublequote = \"\\\"\"; singlequote = \"\\\\\\'\"; } else { quote = '\\\"'; doublequote = \"\\\\\\\"\"; singlequote = \"\\'\"; } return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder);"
      },
      {
        "txt": "} static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) { return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder); } static String escapeToDoubleQuotedJsString(String s) { return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); } they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null);"
      },
      {
        "txt": "} static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i);"
      },
      {
        "txt": "switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 &&"
      },
      {
        "txt": "((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\";"
      },
      {
        "txt": "if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break;"
      },
      {
        "txt": "default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c);"
      },
      {
        "txt": "} else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } static String identifierEscape(String s) {"
      },
      {
        "txt": "if (NodeUtil.isLatin(s)) { return s; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 0x1F && c < 0x7F) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c);"
      },
      {
        "txt": "} } return sb.toString(); } private static int getNonEmptyChildCount(Node n, int maxCount) { int i = 0; Node c = n.getFirstChild(); for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i);"
      },
      {
        "txt": "} else if (c.getType() != Token.EMPTY) { i++; } } return i; } private static Node getFirstNonEmptyChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c);"
      },
      {
        "txt": "if (result != null) { return result; } } else if (c.getType() != Token.EMPTY) { return c; } } return null; } enum Context {"
      },
      {
        "txt": "STATEMENT, BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity START_OF_EXPR, PRESERVE_BLOCK, IN_FOR_INIT_CLAUSE, OTHER } private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER;"
      },
      {
        "txt": "} private Context getContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); } private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation("
      },
      {
        "txt": "StringBuilder sb, char c) { try { appendHexJavaScriptRepresentation(c, sb); } catch (IOException ex) { throw new RuntimeException(ex); } } private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException {"
      },
      {
        "txt": "if (Character.isSupplementaryCodePoint(codePoint)) { char[] surrogates = Character.toChars(codePoint); appendHexJavaScriptRepresentation(surrogates[0], out); appendHexJavaScriptRepresentation(surrogates[1], out); return; } out.append(\"\\\\u\") .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf])"
      },
      {
        "txt": ".append(HEX_CHARS[codePoint & 0xf]); }"
      }
    ]
  },
  {
    "id": 717,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 350,
    "end-bug-line": 350,
    "bug": "add(jsString(n.getString(), outputCharsetEncoder));",
    "fix": "double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { add(jsString(n.getString(), outputCharsetEncoder)); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Charsets; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream;"
      },
      {
        "txt": "import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator { private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc; private final CharsetEncoder outputCharsetEncoder; CodeGenerator("
      },
      {
        "txt": "CodeConsumer consumer, Charset outputCharset) { cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null; } else { this.outputCharsetEncoder = outputCharset.newEncoder(); } } CodeGenerator(CodeConsumer consumer) { this(consumer, null);"
      },
      {
        "txt": "} public void tagAsStrict() { add(\"'use strict';\"); } void add(String str) { cc.add(str); } private void addIdentifier(String identifier) { cc.addIdentifier(identifierEscape(identifier)); }"
      },
      {
        "txt": "void add(Node n) { add(n, Context.OTHER); } void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount();"
      },
      {
        "txt": "Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState( childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context); cc.addOp(opstr, true);"
      },
      {
        "txt": "Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); } return;"
      },
      {
        "txt": "} cc.startSourceMapping(n); switch (type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild();"
      },
      {
        "txt": "if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\"); add(first);"
      },
      {
        "txt": "cc.endStatement(true); break; case Token.RETURN: add(\"return\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement();"
      },
      {
        "txt": "break; case Token.VAR: if (first != null) { add(\"var \"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString());"
      },
      {
        "txt": "break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN));"
      },
      {
        "txt": "} else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first); add(\"]\"); break;"
      },
      {
        "txt": "case Token.LP: add(\"(\"); addList(first); add(\")\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context); break; case Token.NUMBER:"
      },
      {
        "txt": "Preconditions.checkState( childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT:"
      },
      {
        "txt": "case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) { cc.addNumber(-n.getFirstChild().getDouble());"
      },
      {
        "txt": "} else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context);"
      },
      {
        "txt": "cc.addOp(\"?\", true); addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1); break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) { throw new Error(\"Expected children to be strings\");"
      },
      {
        "txt": "} String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.GET_REF:"
      },
      {
        "txt": "add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\".\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION: if (n.getClass() != Node.class) {"
      },
      {
        "txt": "throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\"(\"); } add(\"function\"); add(first); add(first.getNext());"
      },
      {
        "txt": "add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\"); } break; case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT); Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \"); } String name = n.getString();"
      },
      {
        "txt": "Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { <extra_id_0> } add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: {"
      },
      {
        "txt": "case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks ="
      },
      {
        "txt": "type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement(); }"
      },
      {
        "txt": "if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); }"
      },
      {
        "txt": "break; } case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); }"
      },
      {
        "txt": "add(\";\"); add(first.getNext()); add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\"for(\");"
      },
      {
        "txt": "add(first); add(\"in\"); add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2);"
      },
      {
        "txt": "add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false); add(\"while(\"); add(last); add(\")\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\");"
      },
      {
        "txt": "add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState("
      },
      {
        "txt": "childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount); Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) { add(\"(\"); } addLeftExpr(first, NodeUtil.precedence(type), context);"
      },
      {
        "txt": "if (needsParens) { add(\")\"); } add(\".\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState( childCount == 2,"
      },
      {
        "txt": "\"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context); add(\"[\"); add(first.getNext()); add(\"]\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\"with(\"); add(first);"
      },
      {
        "txt": "add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) {"
      },
      {
        "txt": "addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (isIndirectEval(first)"
      },
      {
        "txt": "|| n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\"); addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); } add(\"(\"); addList(first.getNext()); add(\")\");"
      },
      {
        "txt": "break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\"if(\"); add(first);"
      },
      {
        "txt": "add(\")\"); if (hasElse) { addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2);"
      },
      {
        "txt": "} if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0);"
      },
      {
        "txt": "add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \");"
      },
      {
        "txt": "add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\"debugger\"); cc.endStatement(); break; case Token.BREAK:"
      },
      {
        "txt": "Preconditions.checkState(childCount <= 1); add(\"break\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement();"
      },
      {
        "txt": "break; case Token.EXPR_VOID: throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\"new \");"
      },
      {
        "txt": "int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) { add(\"(\"); addList(next); add(\")\");"
      },
      {
        "txt": "} break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) { throw new IllegalStateException( \"Unexpected String children: \" + n.getParent().toStringTree()); } add(jsString(n.getString(), outputCharsetEncoder));"
      },
      {
        "txt": "break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\");"
      },
      {
        "txt": "} add(\"{\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { if (c.getType() == Token.STRING &&"
      },
      {
        "txt": "!c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { addExpr(c, 1); } add(\":\"); addExpr(c.getFirstChild(), 1);"
      },
      {
        "txt": "} } add(\"}\"); if (needsParens) { add(\")\"); } break; } case Token.SWITCH: add(\"switch(\");"
      },
      {
        "txt": "add(first); add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\"case \"); add(first);"
      },
      {
        "txt": "addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) {"
      },
      {
        "txt": "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break; case Token.SETNAME: break; default:"
      },
      {
        "txt": "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n); } private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL); } private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) {"
      },
      {
        "txt": "Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));"
      },
      {
        "txt": "} else { cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock();"
      },
      {
        "txt": "add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; } } if (count > 1) { context = Context.PRESERVE_BLOCK;"
      },
      {
        "txt": "} } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement(); } }"
      },
      {
        "txt": "} private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else {"
      },
      {
        "txt": "return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } void addLeftExpr(Node n, int minPrecedence, Context context) { addExpr(n, minPrecedence, context); }"
      },
      {
        "txt": "void addExpr(Node n, int minPrecedence) { addExpr(n, minPrecedence, Context.OTHER); } private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.getType() == Token.IN))){ add(\"(\"); add(n, clearContextForNoInOperator(context)); add(\")\");"
      },
      {
        "txt": "} else { add(n, context); } } void addList(Node firstInList) { addList(firstInList, true, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument) { addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); }"
      },
      {
        "txt": "void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) { boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); } else { cc.listSeparator(); addExpr(n, isArrayOrFunctionArgument ? 1 : 0); }"
      },
      {
        "txt": "} } void addArrayList(Node firstInList) { boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) { cc.listSeparator(); } addExpr(n, 1); lastWasEmpty = n.getType() == Token.EMPTY;"
      },
      {
        "txt": "} if (lastWasEmpty) { cc.listSeparator(); } } void addCaseBody(Node caseBody) { cc.beginCaseBody(); add(caseBody); cc.endCaseBody(); }"
      },
      {
        "txt": "void addAllSiblings(Node n) { for (Node c = n; c != null; c = c.getNext()) { add(c); } } static String jsString(String s, CharsetEncoder outputCharsetEncoder) { int singleq = 0, doubleq = 0; for (int i = 0; i < s.length(); i++) { switch (s.charAt(i)) { case '\"': doubleq++; break;"
      },
      {
        "txt": "case '\\'': singleq++; break; } } String doublequote, singlequote; char quote; if (singleq < doubleq) { quote = '\\''; doublequote = \"\\\"\"; singlequote = \"\\\\\\'\"; } else {"
      },
      {
        "txt": "quote = '\\\"'; doublequote = \"\\\\\\\"\"; singlequote = \"\\'\"; } return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder); } static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) { return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder); }"
      },
      {
        "txt": "static String escapeToDoubleQuotedJsString(String s) { return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); } they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null); } static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape,"
      },
      {
        "txt": "String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break;"
      },
      {
        "txt": "case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else {"
      },
      {
        "txt": "sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,"
      },
      {
        "txt": "START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c);"
      },
      {
        "txt": "} else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } }"
      },
      {
        "txt": "} } sb.append(quote); return sb.toString(); } static String identifierEscape(String s) { if (NodeUtil.isLatin(s)) { return s; } StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 0x1F && c < 0x7F) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } return sb.toString(); }"
      },
      {
        "txt": "private static int getNonEmptyChildCount(Node n, int maxCount) { int i = 0; Node c = n.getFirstChild(); for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i); } else if (c.getType() != Token.EMPTY) { i++; } }"
      },
      {
        "txt": "return i; } private static Node getFirstNonEmptyChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c); if (result != null) { return result; } } else if (c.getType() != Token.EMPTY) {"
      },
      {
        "txt": "return c; } } return null; } enum Context { STATEMENT, BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity START_OF_EXPR, PRESERVE_BLOCK,"
      },
      {
        "txt": "IN_FOR_INIT_CLAUSE, OTHER } private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; } private Context getContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);"
      },
      {
        "txt": "} private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation( StringBuilder sb, char c) { try { appendHexJavaScriptRepresentation(c, sb); } catch (IOException ex) {"
      },
      {
        "txt": "throw new RuntimeException(ex); } } private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException { if (Character.isSupplementaryCodePoint(codePoint)) { char[] surrogates = Character.toChars(codePoint); appendHexJavaScriptRepresentation(surrogates[0], out); appendHexJavaScriptRepresentation(surrogates[1], out);"
      },
      {
        "txt": "return; } out.append(\"\\\\u\") .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) .append(HEX_CHARS[codePoint & 0xf]); }"
      }
    ]
  },
  {
    "id": 718,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 654,
    "end-bug-line": 654,
    "bug": "",
    "fix": "Preconditions.checkState(c.getType() == Token.STRING); String key = c.getString();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Charsets; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator {"
      },
      {
        "txt": "private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc; private final CharsetEncoder outputCharsetEncoder; CodeGenerator( CodeConsumer consumer, Charset outputCharset) { cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null;"
      },
      {
        "txt": "} else { this.outputCharsetEncoder = outputCharset.newEncoder(); } } CodeGenerator(CodeConsumer consumer) { this(consumer, null); } public void tagAsStrict() { add(\"'use strict';\"); }"
      },
      {
        "txt": "void add(String str) { cc.add(str); } private void addIdentifier(String identifier) { cc.addIdentifier(identifierEscape(identifier)); } void add(Node n) { add(n, Context.OTHER); } void add(Node n, Context context) {"
      },
      {
        "txt": "if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState("
      },
      {
        "txt": "childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context); cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext);"
      },
      {
        "txt": "} else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); } return; } cc.startSourceMapping(n); switch (type) { case Token.TRY: {"
      },
      {
        "txt": "Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) {"
      },
      {
        "txt": "add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\");"
      },
      {
        "txt": "add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\"return\");"
      },
      {
        "txt": "if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\"var \");"
      },
      {
        "txt": "addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString());"
      },
      {
        "txt": "} else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } }"
      },
      {
        "txt": "break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first); add(\"]\"); break; case Token.LP: add(\"(\"); addList(first); add(\")\");"
      },
      {
        "txt": "break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context); break; case Token.NUMBER: Preconditions.checkState( childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));"
      },
      {
        "txt": "cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type));"
      },
      {
        "txt": "break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); }"
      },
      {
        "txt": "break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1);"
      },
      {
        "txt": "break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) { throw new Error(\"Expected children to be strings\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString());"
      },
      {
        "txt": "} else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "add(first); add(\".\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR);"
      },
      {
        "txt": "if (funcNeedsParens) { add(\"(\"); } add(\"function\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\");"
      },
      {
        "txt": "} break; case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());"
      },
      {
        "txt": "add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \"); } String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (TokenStream.isJSIdentifier(name) &&"
      },
      {
        "txt": "NodeUtil.isLatin(name)) { add(name); } else { add(jsString(n.getString(), outputCharsetEncoder)); } add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: {"
      },
      {
        "txt": "if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK &&"
      },
      {
        "txt": "!preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak();"
      },
      {
        "txt": "} if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; }"
      },
      {
        "txt": "case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\";\"); add(first.getNext());"
      },
      {
        "txt": "add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\"for(\"); add(first); add(\"in\");"
      },
      {
        "txt": "add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false);"
      },
      {
        "txt": "add(\"while(\"); add(last); add(\")\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\"); add(first); add(\")\");"
      },
      {
        "txt": "addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);"
      },
      {
        "txt": "Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) { add(\"(\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\");"
      },
      {
        "txt": "} add(\".\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState( childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context);"
      },
      {
        "txt": "add(\"[\"); add(first.getNext()); add(\"]\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\"with(\"); add(first); add(\")\"); addNonEmptyStatement("
      },
      {
        "txt": "last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false);"
      },
      {
        "txt": "} else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\");"
      },
      {
        "txt": "addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); } add(\"(\"); addList(first.getNext()); add(\")\"); break; case Token.IF:"
      },
      {
        "txt": "boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\"if(\"); add(first); add(\")\"); if (hasElse) {"
      },
      {
        "txt": "addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) {"
      },
      {
        "txt": "cc.endBlock(); } break; case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break;"
      },
      {
        "txt": "case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); }"
      },
      {
        "txt": "cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\"debugger\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\");"
      },
      {
        "txt": "if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.EXPR_VOID:"
      },
      {
        "txt": "throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {"
      },
      {
        "txt": "precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) { add(\"(\"); addList(next); add(\")\"); } break;"
      },
      {
        "txt": "case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) { throw new IllegalStateException( \"Unexpected String children: \" + n.getParent().toStringTree()); } add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\"); } add(\"{\");"
      },
      {
        "txt": "if (c != first) { cc.listSeparator(); } if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { <extra_id_0> if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString());"
      },
      {
        "txt": "NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { addExpr(c, 1); } add(\":\"); addExpr(c.getFirstChild(), 1); } } add(\"}\");"
      },
      {
        "txt": "if (needsParens) { add(\")\"); } break; } case Token.SWITCH: add(\"switch(\"); add(first); add(\")\"); cc.beginBlock();"
      },
      {
        "txt": "addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\"case \"); add(first); addCaseBody(last); break; case Token.DEFAULT:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first);"
      },
      {
        "txt": "add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break; case Token.SETNAME: break; default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n);"
      },
      {
        "txt": "} private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL); } private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\");"
      },
      {
        "txt": "} if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); }"
      },
      {
        "txt": "return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));"
      },
      {
        "txt": "return; } else { nodeToProcess = firstAndOnlyChild; } } if (count > 1) { context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) {"
      },
      {
        "txt": "cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement(); } } } private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) {"
      },
      {
        "txt": "Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false; } }"
      },
      {
        "txt": "} else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } void addLeftExpr(Node n, int minPrecedence, Context context) { addExpr(n, minPrecedence, context); } void addExpr(Node n, int minPrecedence) { addExpr(n, minPrecedence, Context.OTHER); }"
      },
      {
        "txt": "private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.getType() == Token.IN))){ add(\"(\"); add(n, clearContextForNoInOperator(context)); add(\")\"); } else { add(n, context); }"
      },
      {
        "txt": "} void addList(Node firstInList) { addList(firstInList, true, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument) { addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) {"
      },
      {
        "txt": "boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); } else { cc.listSeparator(); addExpr(n, isArrayOrFunctionArgument ? 1 : 0); } } } void addArrayList(Node firstInList) {"
      },
      {
        "txt": "boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) { cc.listSeparator(); } addExpr(n, 1); lastWasEmpty = n.getType() == Token.EMPTY; } if (lastWasEmpty) { cc.listSeparator();"
      },
      {
        "txt": "} } void addCaseBody(Node caseBody) { cc.beginCaseBody(); add(caseBody); cc.endCaseBody(); } void addAllSiblings(Node n) { for (Node c = n; c != null; c = c.getNext()) { add(c);"
      },
      {
        "txt": "} } static String jsString(String s, CharsetEncoder outputCharsetEncoder) { int singleq = 0, doubleq = 0; for (int i = 0; i < s.length(); i++) { switch (s.charAt(i)) { case '\"': doubleq++; break; case '\\'': singleq++; break; } }"
      },
      {
        "txt": "String doublequote, singlequote; char quote; if (singleq < doubleq) { quote = '\\''; doublequote = \"\\\"\"; singlequote = \"\\\\\\'\"; } else { quote = '\\\"'; doublequote = \"\\\\\\\"\"; singlequote = \"\\'\";"
      },
      {
        "txt": "} return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder); } static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) { return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder); } static String escapeToDoubleQuotedJsString(String s) { return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); }"
      },
      {
        "txt": "they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null); } static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2);"
      },
      {
        "txt": "sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break;"
      },
      {
        "txt": "case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break;"
      },
      {
        "txt": "case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else {"
      },
      {
        "txt": "sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); }"
      },
      {
        "txt": "} else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote);"
      },
      {
        "txt": "return sb.toString(); } static String identifierEscape(String s) { if (NodeUtil.isLatin(s)) { return s; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 0x1F && c < 0x7F) {"
      },
      {
        "txt": "sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } return sb.toString(); } private static int getNonEmptyChildCount(Node n, int maxCount) { int i = 0; Node c = n.getFirstChild();"
      },
      {
        "txt": "for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i); } else if (c.getType() != Token.EMPTY) { i++; } } return i; } private static Node getFirstNonEmptyChild(Node n) {"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c); if (result != null) { return result; } } else if (c.getType() != Token.EMPTY) { return c; } }"
      },
      {
        "txt": "return null; } enum Context { STATEMENT, BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity START_OF_EXPR, PRESERVE_BLOCK, IN_FOR_INIT_CLAUSE, OTHER }"
      },
      {
        "txt": "private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; } private Context getContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); } private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE"
      },
      {
        "txt": "? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation( StringBuilder sb, char c) { try { appendHexJavaScriptRepresentation(c, sb); } catch (IOException ex) { throw new RuntimeException(ex); } }"
      },
      {
        "txt": "private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException { if (Character.isSupplementaryCodePoint(codePoint)) { char[] surrogates = Character.toChars(codePoint); appendHexJavaScriptRepresentation(surrogates[0], out); appendHexJavaScriptRepresentation(surrogates[1], out); return; } out.append(\"\\\\u\")"
      },
      {
        "txt": ".append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) .append(HEX_CHARS[codePoint & 0xf]); }"
      }
    ]
  },
  {
    "id": 719,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 656,
    "end-bug-line": 659,
    "bug": "if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) &&",
    "fix": "if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) &&",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Charsets; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator {"
      },
      {
        "txt": "private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc; private final CharsetEncoder outputCharsetEncoder; CodeGenerator( CodeConsumer consumer, Charset outputCharset) { cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null;"
      },
      {
        "txt": "} else { this.outputCharsetEncoder = outputCharset.newEncoder(); } } CodeGenerator(CodeConsumer consumer) { this(consumer, null); } public void tagAsStrict() { add(\"'use strict';\"); }"
      },
      {
        "txt": "void add(String str) { cc.add(str); } private void addIdentifier(String identifier) { cc.addIdentifier(identifierEscape(identifier)); } void add(Node n) { add(n, Context.OTHER); } void add(Node n, Context context) {"
      },
      {
        "txt": "if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState("
      },
      {
        "txt": "childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context); cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext);"
      },
      {
        "txt": "} else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); } return; } cc.startSourceMapping(n); switch (type) { case Token.TRY: {"
      },
      {
        "txt": "Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) {"
      },
      {
        "txt": "add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\");"
      },
      {
        "txt": "add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\"return\");"
      },
      {
        "txt": "if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\"var \");"
      },
      {
        "txt": "addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString());"
      },
      {
        "txt": "} else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } }"
      },
      {
        "txt": "break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first); add(\"]\"); break; case Token.LP: add(\"(\"); addList(first); add(\")\");"
      },
      {
        "txt": "break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context); break; case Token.NUMBER: Preconditions.checkState( childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));"
      },
      {
        "txt": "cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type));"
      },
      {
        "txt": "break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); }"
      },
      {
        "txt": "break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1);"
      },
      {
        "txt": "break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) { throw new Error(\"Expected children to be strings\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString());"
      },
      {
        "txt": "} else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "add(first); add(\".\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR);"
      },
      {
        "txt": "if (funcNeedsParens) { add(\"(\"); } add(\"function\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\");"
      },
      {
        "txt": "} break; case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());"
      },
      {
        "txt": "add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \"); } String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (TokenStream.isJSIdentifier(name) &&"
      },
      {
        "txt": "NodeUtil.isLatin(name)) { add(name); } else { add(jsString(n.getString(), outputCharsetEncoder)); } add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: {"
      },
      {
        "txt": "if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK &&"
      },
      {
        "txt": "!preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak();"
      },
      {
        "txt": "} if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; }"
      },
      {
        "txt": "case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\";\"); add(first.getNext());"
      },
      {
        "txt": "add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\"for(\"); add(first); add(\"in\");"
      },
      {
        "txt": "add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false);"
      },
      {
        "txt": "add(\"while(\"); add(last); add(\")\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\"); add(first); add(\")\");"
      },
      {
        "txt": "addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);"
      },
      {
        "txt": "Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) { add(\"(\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\");"
      },
      {
        "txt": "} add(\".\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState( childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context);"
      },
      {
        "txt": "add(\"[\"); add(first.getNext()); add(\"]\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\"with(\"); add(first); add(\")\"); addNonEmptyStatement("
      },
      {
        "txt": "last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false);"
      },
      {
        "txt": "} else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\");"
      },
      {
        "txt": "addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); } add(\"(\"); addList(first.getNext()); add(\")\"); break; case Token.IF:"
      },
      {
        "txt": "boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\"if(\"); add(first); add(\")\"); if (hasElse) {"
      },
      {
        "txt": "addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) {"
      },
      {
        "txt": "cc.endBlock(); } break; case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break;"
      },
      {
        "txt": "case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); }"
      },
      {
        "txt": "cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\"debugger\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\");"
      },
      {
        "txt": "if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.EXPR_VOID:"
      },
      {
        "txt": "throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {"
      },
      {
        "txt": "precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) { add(\"(\"); addList(next); add(\")\"); } break;"
      },
      {
        "txt": "case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) { throw new IllegalStateException( \"Unexpected String children: \" + n.getParent().toStringTree()); } add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\"); } add(\"{\");"
      },
      {
        "txt": "if (c != first) { cc.listSeparator(); } if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { <extra_id_0> NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { addExpr(c, 1); } add(\":\");"
      },
      {
        "txt": "} add(\":\"); addExpr(c.getFirstChild(), 1); } } add(\"}\"); if (needsParens) { add(\")\"); } break;"
      },
      {
        "txt": "} case Token.SWITCH: add(\"switch(\"); add(first); add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); add(\"case \"); add(first); addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break;"
      },
      {
        "txt": "case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break;"
      },
      {
        "txt": "case Token.SETNAME: break; default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n); } private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL);"
      },
      {
        "txt": "} private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) {"
      },
      {
        "txt": "if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n);"
      },
      {
        "txt": "boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; }"
      },
      {
        "txt": "} if (count > 1) { context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) {"
      },
      {
        "txt": "cc.endStatement(); } } } private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else {"
      },
      {
        "txt": "if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } }"
      },
      {
        "txt": "void addLeftExpr(Node n, int minPrecedence, Context context) { addExpr(n, minPrecedence, context); } void addExpr(Node n, int minPrecedence) { addExpr(n, minPrecedence, Context.OTHER); } private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.getType() == Token.IN))){"
      },
      {
        "txt": "add(\"(\"); add(n, clearContextForNoInOperator(context)); add(\")\"); } else { add(n, context); } } void addList(Node firstInList) { addList(firstInList, true, Context.OTHER); }"
      },
      {
        "txt": "void addList(Node firstInList, boolean isArrayOrFunctionArgument) { addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) { boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); } else {"
      },
      {
        "txt": "cc.listSeparator(); addExpr(n, isArrayOrFunctionArgument ? 1 : 0); } } } void addArrayList(Node firstInList) { boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) { cc.listSeparator();"
      },
      {
        "txt": "} addExpr(n, 1); lastWasEmpty = n.getType() == Token.EMPTY; } if (lastWasEmpty) { cc.listSeparator(); } } void addCaseBody(Node caseBody) { cc.beginCaseBody();"
      },
      {
        "txt": "add(caseBody); cc.endCaseBody(); } void addAllSiblings(Node n) { for (Node c = n; c != null; c = c.getNext()) { add(c); } } static String jsString(String s, CharsetEncoder outputCharsetEncoder) { int singleq = 0, doubleq = 0;"
      },
      {
        "txt": "for (int i = 0; i < s.length(); i++) { switch (s.charAt(i)) { case '\"': doubleq++; break; case '\\'': singleq++; break; } } String doublequote, singlequote; char quote; if (singleq < doubleq) { quote = '\\'';"
      },
      {
        "txt": "doublequote = \"\\\"\"; singlequote = \"\\\\\\'\"; } else { quote = '\\\"'; doublequote = \"\\\\\\\"\"; singlequote = \"\\'\"; } return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder); }"
      },
      {
        "txt": "static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) { return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder); } static String escapeToDoubleQuotedJsString(String s) { return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); } they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null); }"
      },
      {
        "txt": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) {"
      },
      {
        "txt": "case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||"
      },
      {
        "txt": "(s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0,"
      },
      {
        "txt": "END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default:"
      },
      {
        "txt": "if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else {"
      },
      {
        "txt": "appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } static String identifierEscape(String s) { if (NodeUtil.isLatin(s)) {"
      },
      {
        "txt": "return s; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 0x1F && c < 0x7F) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); }"
      },
      {
        "txt": "} return sb.toString(); } private static int getNonEmptyChildCount(Node n, int maxCount) { int i = 0; Node c = n.getFirstChild(); for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i); } else if (c.getType() != Token.EMPTY) {"
      },
      {
        "txt": "i++; } } return i; } private static Node getFirstNonEmptyChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c); if (result != null) {"
      },
      {
        "txt": "return result; } } else if (c.getType() != Token.EMPTY) { return c; } } return null; } enum Context { STATEMENT,"
      },
      {
        "txt": "BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity START_OF_EXPR, PRESERVE_BLOCK, IN_FOR_INIT_CLAUSE, OTHER } private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; }"
      },
      {
        "txt": "private Context getContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); } private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation( StringBuilder sb, char c) {"
      },
      {
        "txt": "try { appendHexJavaScriptRepresentation(c, sb); } catch (IOException ex) { throw new RuntimeException(ex); } } private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException { if (Character.isSupplementaryCodePoint(codePoint)) {"
      },
      {
        "txt": "char[] surrogates = Character.toChars(codePoint); appendHexJavaScriptRepresentation(surrogates[0], out); appendHexJavaScriptRepresentation(surrogates[1], out); return; } out.append(\"\\\\u\") .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) .append(HEX_CHARS[codePoint & 0xf]);"
      }
    ]
  },
  {
    "id": 720,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 662,
    "end-bug-line": 663,
    "bug": "NodeUtil.isLatin(c.getString())) { add(c.getString());",
    "fix": "NodeUtil.isLatin(key)) { add(key);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Charsets; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator { private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc;"
      },
      {
        "txt": "private final CharsetEncoder outputCharsetEncoder; CodeGenerator( CodeConsumer consumer, Charset outputCharset) { cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null; } else { this.outputCharsetEncoder = outputCharset.newEncoder(); } }"
      },
      {
        "txt": "CodeGenerator(CodeConsumer consumer) { this(consumer, null); } public void tagAsStrict() { add(\"'use strict';\"); } void add(String str) { cc.add(str); } private void addIdentifier(String identifier) {"
      },
      {
        "txt": "cc.addIdentifier(identifierEscape(identifier)); } void add(Node n) { add(n, Context.OTHER); } void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType();"
      },
      {
        "txt": "String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState( childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type);"
      },
      {
        "txt": "addLeftExpr(first, p, context); cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext);"
      },
      {
        "txt": "} return; } cc.startSourceMapping(n); switch (type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\");"
      },
      {
        "txt": "add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break;"
      },
      {
        "txt": "} case Token.CATCH: Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "add(\"throw\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\"return\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0);"
      },
      {
        "txt": "} cc.endStatement(); break; case Token.VAR: if (first != null) { add(\"var \"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME:"
      },
      {
        "txt": "Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true);"
      },
      {
        "txt": "if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first);"
      },
      {
        "txt": "add(\"]\"); break; case Token.LP: add(\"(\"); addList(first); add(\")\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context);"
      },
      {
        "txt": "break; case Token.NUMBER: Preconditions.checkState( childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID:"
      },
      {
        "txt": "case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; } case Token.NEG: { Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "if (n.getFirstChild().getType() == Token.NUMBER) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3);"
      },
      {
        "txt": "int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1); break; } case Token.REGEXP: if (first.getType() != Token.STRING ||"
      },
      {
        "txt": "last.getType() != Token.STRING) { throw new Error(\"Expected children to be strings\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); }"
      },
      {
        "txt": "break; case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\".\"); add((String) n.getProp(Node.NAME_PROP)); break;"
      },
      {
        "txt": "case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\"(\"); } add(\"function\");"
      },
      {
        "txt": "add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\"); } break; case Token.GET: case Token.SET:"
      },
      {
        "txt": "Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \");"
      },
      {
        "txt": "} String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { add(jsString(n.getString(), outputCharsetEncoder));"
      },
      {
        "txt": "} add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK;"
      },
      {
        "txt": "if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) {"
      },
      {
        "txt": "add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); }"
      },
      {
        "txt": "} if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) {"
      },
      {
        "txt": "add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\";\"); add(first.getNext()); add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement("
      },
      {
        "txt": "last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\"for(\"); add(first); add(\"in\"); add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false);"
      },
      {
        "txt": "} break; case Token.DO: Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false); add(\"while(\"); add(last); add(\")\"); cc.endStatement();"
      },
      {
        "txt": "break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount); Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER);"
      },
      {
        "txt": "if (needsParens) { add(\"(\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\"); } add(\".\"); addIdentifier(last.getString()); break;"
      },
      {
        "txt": "} case Token.GETELEM: Preconditions.checkState( childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context); add(\"[\"); add(first.getNext()); add(\"]\"); break;"
      },
      {
        "txt": "case Token.WITH: Preconditions.checkState(childCount == 2); add(\"with(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: {"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); }"
      },
      {
        "txt": "break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\"); addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context);"
      },
      {
        "txt": "} add(\"(\"); addList(first.getNext()); add(\")\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) {"
      },
      {
        "txt": "cc.beginBlock(); } add(\"if(\"); add(first); add(\")\"); if (hasElse) { addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement("
      },
      {
        "txt": "last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL:"
      },
      {
        "txt": "case Token.THIS: case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) {"
      },
      {
        "txt": "if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0);"
      },
      {
        "txt": "add(\"debugger\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); }"
      },
      {
        "txt": "add(\" \"); add(first); } cc.endStatement(); break; case Token.EXPR_VOID: throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR);"
      },
      {
        "txt": "cc.endStatement(); break; case Token.NEW: add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext();"
      },
      {
        "txt": "if (next != null) { add(\"(\"); addList(next); add(\")\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {"
      },
      {
        "txt": "throw new IllegalStateException( \"Unexpected String children: \" + n.getParent().toStringTree()); } add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break;"
      },
      {
        "txt": "case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\"); } add(\"{\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); }"
      },
      {
        "txt": "add(c); } else { if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && <extra_id_0> } else { addExpr(c, 1); } add(\":\"); addExpr(c.getFirstChild(), 1); }"
      },
      {
        "txt": "addExpr(c.getFirstChild(), 1); } } add(\"}\"); if (needsParens) { add(\")\"); } break; } case Token.SWITCH:"
      },
      {
        "txt": "add(\"switch(\"); add(first); add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\"case \");"
      },
      {
        "txt": "add(first); addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2);"
      },
      {
        "txt": "if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break; case Token.SETNAME: break;"
      },
      {
        "txt": "default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n); } private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL); } private void addNonEmptyStatement("
      },
      {
        "txt": "Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock();"
      },
      {
        "txt": "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {"
      },
      {
        "txt": "cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; } } if (count > 1) {"
      },
      {
        "txt": "context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement(); }"
      },
      {
        "txt": "} } private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));"
      },
      {
        "txt": "} else { return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } void addLeftExpr(Node n, int minPrecedence, Context context) { addExpr(n, minPrecedence, context);"
      },
      {
        "txt": "} void addExpr(Node n, int minPrecedence) { addExpr(n, minPrecedence, Context.OTHER); } private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.getType() == Token.IN))){ add(\"(\"); add(n, clearContextForNoInOperator(context));"
      },
      {
        "txt": "add(\")\"); } else { add(n, context); } } void addList(Node firstInList) { addList(firstInList, true, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument) { addList(firstInList, isArrayOrFunctionArgument, Context.OTHER);"
      },
      {
        "txt": "} void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) { boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); } else { cc.listSeparator(); addExpr(n, isArrayOrFunctionArgument ? 1 : 0);"
      },
      {
        "txt": "} } } void addArrayList(Node firstInList) { boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) { cc.listSeparator(); } addExpr(n, 1);"
      },
      {
        "txt": "lastWasEmpty = n.getType() == Token.EMPTY; } if (lastWasEmpty) { cc.listSeparator(); } } void addCaseBody(Node caseBody) { cc.beginCaseBody(); add(caseBody); cc.endCaseBody();"
      },
      {
        "txt": "} void addAllSiblings(Node n) { for (Node c = n; c != null; c = c.getNext()) { add(c); } } static String jsString(String s, CharsetEncoder outputCharsetEncoder) { int singleq = 0, doubleq = 0; for (int i = 0; i < s.length(); i++) { switch (s.charAt(i)) {"
      },
      {
        "txt": "case '\"': doubleq++; break; case '\\'': singleq++; break; } } String doublequote, singlequote; char quote; if (singleq < doubleq) { quote = '\\''; doublequote = \"\\\"\"; singlequote = \"\\\\\\'\";"
      },
      {
        "txt": "} else { quote = '\\\"'; doublequote = \"\\\\\\\"\"; singlequote = \"\\'\"; } return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder); } static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) { return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);"
      },
      {
        "txt": "} static String escapeToDoubleQuotedJsString(String s) { return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); } they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null); } static String strEscape(String s, char quote, String doublequoteEscape,"
      },
      {
        "txt": "String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break;"
      },
      {
        "txt": "case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\");"
      },
      {
        "txt": "} else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\");"
      },
      {
        "txt": "} else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) {"
      },
      {
        "txt": "sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); }"
      },
      {
        "txt": "} } } sb.append(quote); return sb.toString(); } static String identifierEscape(String s) { if (NodeUtil.isLatin(s)) { return s; }"
      },
      {
        "txt": "StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 0x1F && c < 0x7F) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } return sb.toString();"
      },
      {
        "txt": "} private static int getNonEmptyChildCount(Node n, int maxCount) { int i = 0; Node c = n.getFirstChild(); for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i); } else if (c.getType() != Token.EMPTY) { i++; }"
      },
      {
        "txt": "} return i; } private static Node getFirstNonEmptyChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c); if (result != null) { return result; }"
      },
      {
        "txt": "} else if (c.getType() != Token.EMPTY) { return c; } } return null; } enum Context { STATEMENT, BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity START_OF_EXPR,"
      },
      {
        "txt": "PRESERVE_BLOCK, IN_FOR_INIT_CLAUSE, OTHER } private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; } private Context getContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE"
      },
      {
        "txt": "? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); } private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation( StringBuilder sb, char c) { try { appendHexJavaScriptRepresentation(c, sb);"
      },
      {
        "txt": "} catch (IOException ex) { throw new RuntimeException(ex); } } private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException { if (Character.isSupplementaryCodePoint(codePoint)) { char[] surrogates = Character.toChars(codePoint); appendHexJavaScriptRepresentation(surrogates[0], out);"
      },
      {
        "txt": "appendHexJavaScriptRepresentation(surrogates[1], out); return; } out.append(\"\\\\u\") .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) .append(HEX_CHARS[codePoint & 0xf]); }"
      }
    ]
  },
  {
    "id": 721,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 666,
    "end-bug-line": 666,
    "bug": "addExpr(c, 1);",
    "fix": "double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Charsets; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.io.IOException;"
      },
      {
        "txt": "import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator { private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc; private final CharsetEncoder outputCharsetEncoder; CodeGenerator( CodeConsumer consumer, Charset outputCharset) {"
      },
      {
        "txt": "cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null; } else { this.outputCharsetEncoder = outputCharset.newEncoder(); } } CodeGenerator(CodeConsumer consumer) { this(consumer, null); }"
      },
      {
        "txt": "public void tagAsStrict() { add(\"'use strict';\"); } void add(String str) { cc.add(str); } private void addIdentifier(String identifier) { cc.addIdentifier(identifierEscape(identifier)); } void add(Node n) {"
      },
      {
        "txt": "add(n, Context.OTHER); } void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild();"
      },
      {
        "txt": "Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState( childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context); cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context);"
      },
      {
        "txt": "if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); } return; }"
      },
      {
        "txt": "cc.startSourceMapping(n); switch (type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) {"
      },
      {
        "txt": "add(catchblock); } if (childCount == 3) { add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 2);"
      },
      {
        "txt": "add(\"catch(\"); add(first); add(\")\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\"); add(first); cc.endStatement(true);"
      },
      {
        "txt": "break; case Token.RETURN: add(\"return\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break;"
      },
      {
        "txt": "case Token.VAR: if (first != null) { add(\"var \"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break;"
      },
      {
        "txt": "case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else {"
      },
      {
        "txt": "addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first); add(\"]\"); break; case Token.LP:"
      },
      {
        "txt": "add(\"(\"); addList(first); add(\")\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context); break; case Token.NUMBER: Preconditions.checkState("
      },
      {
        "txt": "childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: {"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) { cc.addNumber(-n.getFirstChild().getDouble()); } else {"
      },
      {
        "txt": "cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context); cc.addOp(\"?\", true);"
      },
      {
        "txt": "addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1); break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) { throw new Error(\"Expected children to be strings\"); }"
      },
      {
        "txt": "String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.GET_REF: add(first);"
      },
      {
        "txt": "break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\".\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\");"
      },
      {
        "txt": "} Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\"(\"); } add(\"function\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK);"
      },
      {
        "txt": "cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\"); } break; case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION);"
      },
      {
        "txt": "Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \"); } String name = n.getString(); Node fn = first;"
      },
      {
        "txt": "Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { add(jsString(n.getString(), outputCharsetEncoder)); } add(parameters); add(body, Context.PRESERVE_BLOCK);"
      },
      {
        "txt": "break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); }"
      },
      {
        "txt": "boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement();"
      },
      {
        "txt": "} if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));"
      },
      {
        "txt": "} break; } case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);"
      },
      {
        "txt": "} add(\";\"); add(first.getNext()); add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3);"
      },
      {
        "txt": "add(\"for(\"); add(first); add(\"in\"); add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } break; case Token.DO:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false); add(\"while(\"); add(last); add(\")\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2);"
      },
      {
        "txt": "add(\"while(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: {"
      },
      {
        "txt": "Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount); Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) { add(\"(\"); }"
      },
      {
        "txt": "addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\"); } add(\".\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState("
      },
      {
        "txt": "childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context); add(\"[\"); add(first.getNext()); add(\"]\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\"with(\");"
      },
      {
        "txt": "add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP);"
      },
      {
        "txt": "if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break; } case Token.CALL:"
      },
      {
        "txt": "if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\"); addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); } add(\"(\"); addList(first.getNext());"
      },
      {
        "txt": "add(\")\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\"if(\");"
      },
      {
        "txt": "add(first); add(\")\"); if (hasElse) { addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false);"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); }"
      },
      {
        "txt": "add(\" \"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\"debugger\"); cc.endStatement(); break;"
      },
      {
        "txt": "case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); }"
      },
      {
        "txt": "cc.endStatement(); break; case Token.EXPR_VOID: throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW:"
      },
      {
        "txt": "add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) { add(\"(\"); addList(next);"
      },
      {
        "txt": "add(\")\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) { throw new IllegalStateException( \"Unexpected String children: \" + n.getParent().toStringTree()); }"
      },
      {
        "txt": "add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) {"
      },
      {
        "txt": "add(\"(\"); } add(\"{\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else {"
      },
      {
        "txt": "!c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { <extra_id_0> } add(\":\"); addExpr(c.getFirstChild(), 1); } } add(\"}\");"
      },
      {
        "txt": "} add(\"}\"); if (needsParens) { add(\")\"); } break; } case Token.SWITCH: add(\"switch(\"); add(first);"
      },
      {
        "txt": "add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\"case \"); add(first); addCaseBody(last);"
      },
      {
        "txt": "break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");"
      },
      {
        "txt": "} add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break; case Token.SETNAME: break; default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());"
      },
      {
        "txt": "} cc.endSourceMapping(n); } private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL); } private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n;"
      },
      {
        "txt": "if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else {"
      },
      {
        "txt": "cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT);"
      },
      {
        "txt": "cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; } } if (count > 1) { context = Context.PRESERVE_BLOCK; }"
      },
      {
        "txt": "} if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement(); } } }"
      },
      {
        "txt": "private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false;"
      },
      {
        "txt": "} } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } void addLeftExpr(Node n, int minPrecedence, Context context) { addExpr(n, minPrecedence, context); } void addExpr(Node n, int minPrecedence) {"
      },
      {
        "txt": "addExpr(n, minPrecedence, Context.OTHER); } private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.getType() == Token.IN))){ add(\"(\"); add(n, clearContextForNoInOperator(context)); add(\")\"); } else {"
      },
      {
        "txt": "add(n, context); } } void addList(Node firstInList) { addList(firstInList, true, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument) { addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument,"
      },
      {
        "txt": "Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) { boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); } else { cc.listSeparator(); addExpr(n, isArrayOrFunctionArgument ? 1 : 0); } }"
      },
      {
        "txt": "} void addArrayList(Node firstInList) { boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) { cc.listSeparator(); } addExpr(n, 1); lastWasEmpty = n.getType() == Token.EMPTY; }"
      },
      {
        "txt": "if (lastWasEmpty) { cc.listSeparator(); } } void addCaseBody(Node caseBody) { cc.beginCaseBody(); add(caseBody); cc.endCaseBody(); } void addAllSiblings(Node n) {"
      },
      {
        "txt": "for (Node c = n; c != null; c = c.getNext()) { add(c); } } static String jsString(String s, CharsetEncoder outputCharsetEncoder) { int singleq = 0, doubleq = 0; for (int i = 0; i < s.length(); i++) { switch (s.charAt(i)) { case '\"': doubleq++; break; case '\\'': singleq++; break;"
      },
      {
        "txt": "} } String doublequote, singlequote; char quote; if (singleq < doubleq) { quote = '\\''; doublequote = \"\\\"\"; singlequote = \"\\\\\\'\"; } else { quote = '\\\"';"
      },
      {
        "txt": "doublequote = \"\\\\\\\"\"; singlequote = \"\\'\"; } return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder); } static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) { return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder); } static String escapeToDoubleQuotedJsString(String s) {"
      },
      {
        "txt": "return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); } they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null); } static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape,"
      },
      {
        "txt": "CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break;"
      },
      {
        "txt": "case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c);"
      },
      {
        "txt": "} break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {"
      },
      {
        "txt": "sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else {"
      },
      {
        "txt": "appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } }"
      },
      {
        "txt": "} sb.append(quote); return sb.toString(); } static String identifierEscape(String s) { if (NodeUtil.isLatin(s)) { return s; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) {"
      },
      {
        "txt": "char c = s.charAt(i); if (c > 0x1F && c < 0x7F) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } return sb.toString(); } private static int getNonEmptyChildCount(Node n, int maxCount) {"
      },
      {
        "txt": "int i = 0; Node c = n.getFirstChild(); for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i); } else if (c.getType() != Token.EMPTY) { i++; } } return i;"
      },
      {
        "txt": "} private static Node getFirstNonEmptyChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c); if (result != null) { return result; } } else if (c.getType() != Token.EMPTY) { return c;"
      },
      {
        "txt": "} } return null; } enum Context { STATEMENT, BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity START_OF_EXPR, PRESERVE_BLOCK, IN_FOR_INIT_CLAUSE,"
      },
      {
        "txt": "OTHER } private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; } private Context getContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); }"
      },
      {
        "txt": "private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation( StringBuilder sb, char c) { try { appendHexJavaScriptRepresentation(c, sb); } catch (IOException ex) { throw new RuntimeException(ex);"
      },
      {
        "txt": "} } private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException { if (Character.isSupplementaryCodePoint(codePoint)) { char[] surrogates = Character.toChars(codePoint); appendHexJavaScriptRepresentation(surrogates[0], out); appendHexJavaScriptRepresentation(surrogates[1], out); return;"
      },
      {
        "txt": "} out.append(\"\\\\u\") .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) .append(HEX_CHARS[codePoint & 0xf]); }"
      }
    ]
  },
  {
    "id": 722,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 724,
    "end-bug-line": 724,
    "bug": "",
    "fix": "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len > 0; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Charsets; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator { private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc; private final CharsetEncoder outputCharsetEncoder;"
      },
      {
        "txt": "CodeGenerator( CodeConsumer consumer, Charset outputCharset) { cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null; } else { this.outputCharsetEncoder = outputCharset.newEncoder(); } } CodeGenerator(CodeConsumer consumer) {"
      },
      {
        "txt": "this(consumer, null); } public void tagAsStrict() { add(\"'use strict';\"); } void add(String str) { cc.add(str); } private void addIdentifier(String identifier) { cc.addIdentifier(identifierEscape(identifier));"
      },
      {
        "txt": "} void add(Node n) { add(n, Context.OTHER); } void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type);"
      },
      {
        "txt": "int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState( childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context);"
      },
      {
        "txt": "cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); }"
      },
      {
        "txt": "return; } cc.startSourceMapping(n); switch (type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK);"
      },
      {
        "txt": "Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break; }"
      },
      {
        "txt": "case Token.CATCH: Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\");"
      },
      {
        "txt": "add(first); cc.endStatement(true); break; case Token.RETURN: add(\"return\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); }"
      },
      {
        "txt": "cc.endStatement(); break; case Token.VAR: if (first != null) { add(\"var \"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty());"
      },
      {
        "txt": "addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.getType() == Token.COMMA) {"
      },
      {
        "txt": "addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first); add(\"]\");"
      },
      {
        "txt": "break; case Token.LP: add(\"(\"); addList(first); add(\")\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context); break;"
      },
      {
        "txt": "case Token.NUMBER: Preconditions.checkState( childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT:"
      },
      {
        "txt": "case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) {"
      },
      {
        "txt": "cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type);"
      },
      {
        "txt": "addLeftExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1); break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) {"
      },
      {
        "txt": "throw new Error(\"Expected children to be strings\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break;"
      },
      {
        "txt": "case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\".\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION:"
      },
      {
        "txt": "if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\"(\"); } add(\"function\"); add(first);"
      },
      {
        "txt": "add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\"); } break; case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \"); }"
      },
      {
        "txt": "String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { add(jsString(n.getString(), outputCharsetEncoder)); }"
      },
      {
        "txt": "add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) {"
      },
      {
        "txt": "cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT);"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } }"
      },
      {
        "txt": "if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE);"
      },
      {
        "txt": "} else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\";\"); add(first.getNext()); add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false);"
      },
      {
        "txt": "} else { Preconditions.checkState(childCount == 3); add(\"for(\"); add(first); add(\"in\"); add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); }"
      },
      {
        "txt": "break; case Token.DO: Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false); add(\"while(\"); add(last); add(\")\"); cc.endStatement(); break;"
      },
      {
        "txt": "case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0);"
      },
      {
        "txt": "break; case Token.GETPROP: { Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount); Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) {"
      },
      {
        "txt": "add(\"(\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\"); } add(\".\"); addIdentifier(last.getString()); break; }"
      },
      {
        "txt": "case Token.GETELEM: Preconditions.checkState( childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context); add(\"[\"); add(first.getNext()); add(\"]\"); break; case Token.WITH:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); add(\"with(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break;"
      },
      {
        "txt": "} case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\"); addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); }"
      },
      {
        "txt": "add(\"(\"); addList(first.getNext()); add(\")\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock();"
      },
      {
        "txt": "} add(\"if(\"); add(first); add(\")\"); if (hasElse) { addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false);"
      },
      {
        "txt": "} else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: case Token.THIS:"
      },
      {
        "txt": "case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) {"
      },
      {
        "txt": "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\"debugger\");"
      },
      {
        "txt": "cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \");"
      },
      {
        "txt": "add(first); } cc.endStatement(); break; case Token.EXPR_VOID: throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement();"
      },
      {
        "txt": "break; case Token.NEW: add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) {"
      },
      {
        "txt": "add(\"(\"); addList(next); add(\")\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) { throw new IllegalStateException("
      },
      {
        "txt": "\"Unexpected String children: \" + n.getParent().toStringTree()); } add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break; case Token.OBJECTLIT: {"
      },
      {
        "txt": "boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\"); } add(\"{\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.getType() == Token.GET || c.getType() == Token.SET) {"
      },
      {
        "txt": "add(c); } else { if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { addExpr(c, 1);"
      },
      {
        "txt": "} add(\":\"); addExpr(c.getFirstChild(), 1); } } add(\"}\"); if (needsParens) { add(\")\"); } break;"
      },
      {
        "txt": "} case Token.SWITCH: add(\"switch(\"); add(first); add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); add(\"case \"); add(first); addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break;"
      },
      {
        "txt": "case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break;"
      },
      {
        "txt": "break; default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n); } <extra_id_0> private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL); } private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) {"
      },
      {
        "txt": "private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) {"
      },
      {
        "txt": "cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();"
      },
      {
        "txt": "if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; } }"
      },
      {
        "txt": "if (count > 1) { context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement();"
      },
      {
        "txt": "} } } private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) {"
      },
      {
        "txt": "return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } void addLeftExpr(Node n, int minPrecedence, Context context) {"
      },
      {
        "txt": "addExpr(n, minPrecedence, context); } void addExpr(Node n, int minPrecedence) { addExpr(n, minPrecedence, Context.OTHER); } private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.getType() == Token.IN))){ add(\"(\");"
      },
      {
        "txt": "add(n, clearContextForNoInOperator(context)); add(\")\"); } else { add(n, context); } } void addList(Node firstInList) { addList(firstInList, true, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument) {"
      },
      {
        "txt": "addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) { boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); } else { cc.listSeparator();"
      },
      {
        "txt": "addExpr(n, isArrayOrFunctionArgument ? 1 : 0); } } } void addArrayList(Node firstInList) { boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) { cc.listSeparator(); }"
      },
      {
        "txt": "addExpr(n, 1); lastWasEmpty = n.getType() == Token.EMPTY; } if (lastWasEmpty) { cc.listSeparator(); } } void addCaseBody(Node caseBody) { cc.beginCaseBody(); add(caseBody);"
      },
      {
        "txt": "cc.endCaseBody(); } void addAllSiblings(Node n) { for (Node c = n; c != null; c = c.getNext()) { add(c); } } static String jsString(String s, CharsetEncoder outputCharsetEncoder) { int singleq = 0, doubleq = 0; for (int i = 0; i < s.length(); i++) {"
      },
      {
        "txt": "switch (s.charAt(i)) { case '\"': doubleq++; break; case '\\'': singleq++; break; } } String doublequote, singlequote; char quote; if (singleq < doubleq) { quote = '\\''; doublequote = \"\\\"\";"
      },
      {
        "txt": "singlequote = \"\\\\\\'\"; } else { quote = '\\\"'; doublequote = \"\\\\\\\"\"; singlequote = \"\\'\"; } return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder); } static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {"
      },
      {
        "txt": "return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder); } static String escapeToDoubleQuotedJsString(String s) { return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); } they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null); } static String strEscape(String s, char quote,"
      },
      {
        "txt": "String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break;"
      },
      {
        "txt": "case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {"
      },
      {
        "txt": "sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {"
      },
      {
        "txt": "sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) {"
      },
      {
        "txt": "if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c);"
      },
      {
        "txt": "} } } } sb.append(quote); return sb.toString(); } static String identifierEscape(String s) { if (NodeUtil.isLatin(s)) { return s;"
      },
      {
        "txt": "} StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 0x1F && c < 0x7F) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } }"
      },
      {
        "txt": "return sb.toString(); } private static int getNonEmptyChildCount(Node n, int maxCount) { int i = 0; Node c = n.getFirstChild(); for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i); } else if (c.getType() != Token.EMPTY) { i++;"
      },
      {
        "txt": "} } return i; } private static Node getFirstNonEmptyChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c); if (result != null) { return result;"
      },
      {
        "txt": "} } else if (c.getType() != Token.EMPTY) { return c; } } return null; } enum Context { STATEMENT, BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity"
      },
      {
        "txt": "START_OF_EXPR, PRESERVE_BLOCK, IN_FOR_INIT_CLAUSE, OTHER } private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; } private Context getContextForNoInOperator(Context context) {"
      },
      {
        "txt": "return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); } private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation( StringBuilder sb, char c) { try {"
      },
      {
        "txt": "appendHexJavaScriptRepresentation(c, sb); } catch (IOException ex) { throw new RuntimeException(ex); } } private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException { if (Character.isSupplementaryCodePoint(codePoint)) { char[] surrogates = Character.toChars(codePoint);"
      },
      {
        "txt": "appendHexJavaScriptRepresentation(surrogates[0], out); appendHexJavaScriptRepresentation(surrogates[1], out); return; } out.append(\"\\\\u\") .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) .append(HEX_CHARS[codePoint & 0xf]); }"
      }
    ]
  },
  {
    "id": 723,
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
    "start-bug-line": 725,
    "end-bug-line": 725,
    "bug": "",
    "fix": "static double getSimpleNumber(String s) { if (isSimpleNumber(s)) { long l = Long.parseLong(s); if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) { return l; } } return Double.NaN; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Charsets; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeUtil.MatchNotFunction; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.TokenStream; import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; class CodeGenerator { private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final CodeConsumer cc; private final CharsetEncoder outputCharsetEncoder;"
      },
      {
        "txt": "CodeGenerator( CodeConsumer consumer, Charset outputCharset) { cc = consumer; if (outputCharset == null || outputCharset == Charsets.US_ASCII) { this.outputCharsetEncoder = null; } else { this.outputCharsetEncoder = outputCharset.newEncoder(); } } CodeGenerator(CodeConsumer consumer) {"
      },
      {
        "txt": "this(consumer, null); } public void tagAsStrict() { add(\"'use strict';\"); } void add(String str) { cc.add(str); } private void addIdentifier(String identifier) { cc.addIdentifier(identifierEscape(identifier));"
      },
      {
        "txt": "} void add(Node n) { add(n, Context.OTHER); } void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type);"
      },
      {
        "txt": "int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState( childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context);"
      },
      {
        "txt": "cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); }"
      },
      {
        "txt": "return; } cc.startSourceMapping(n); switch (type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK);"
      },
      {
        "txt": "Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break; }"
      },
      {
        "txt": "case Token.CATCH: Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\");"
      },
      {
        "txt": "add(first); cc.endStatement(true); break; case Token.RETURN: add(\"return\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); }"
      },
      {
        "txt": "cc.endStatement(); break; case Token.VAR: if (first != null) { add(\"var \"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty());"
      },
      {
        "txt": "addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.getType() == Token.COMMA) {"
      },
      {
        "txt": "addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first); add(\"]\");"
      },
      {
        "txt": "break; case Token.LP: add(\"(\"); addList(first); add(\")\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context); break;"
      },
      {
        "txt": "case Token.NUMBER: Preconditions.checkState( childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT:"
      },
      {
        "txt": "case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) {"
      },
      {
        "txt": "cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type);"
      },
      {
        "txt": "addLeftExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1); cc.addOp(\":\", true); addExpr(last, 1); break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) {"
      },
      {
        "txt": "throw new Error(\"Expected children to be strings\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break;"
      },
      {
        "txt": "case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\".\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION:"
      },
      {
        "txt": "if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\"(\"); } add(\"function\"); add(first);"
      },
      {
        "txt": "add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\"); } break; case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);"
      },
      {
        "txt": "Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \"); }"
      },
      {
        "txt": "String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { add(jsString(n.getString(), outputCharsetEncoder)); }"
      },
      {
        "txt": "add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) {"
      },
      {
        "txt": "cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT);"
      },
      {
        "txt": "if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } }"
      },
      {
        "txt": "if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE);"
      },
      {
        "txt": "} else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\";\"); add(first.getNext()); add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false);"
      },
      {
        "txt": "} else { Preconditions.checkState(childCount == 3); add(\"for(\"); add(first); add(\"in\"); add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); }"
      },
      {
        "txt": "break; case Token.DO: Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false); add(\"while(\"); add(last); add(\")\"); cc.endStatement(); break;"
      },
      {
        "txt": "case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0);"
      },
      {
        "txt": "break; case Token.GETPROP: { Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount); Preconditions.checkState( last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) {"
      },
      {
        "txt": "add(\"(\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\"); } add(\".\"); addIdentifier(last.getString()); break; }"
      },
      {
        "txt": "case Token.GETELEM: Preconditions.checkState( childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context); add(\"[\"); add(first.getNext()); add(\"]\"); break; case Token.WITH:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); add(\"with(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1);"
      },
      {
        "txt": "String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break;"
      },
      {
        "txt": "} case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\"); addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\")\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); }"
      },
      {
        "txt": "add(\"(\"); addList(first.getNext()); add(\")\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock();"
      },
      {
        "txt": "} add(\"if(\"); add(first); add(\")\"); if (hasElse) { addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false);"
      },
      {
        "txt": "} else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: case Token.THIS:"
      },
      {
        "txt": "case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) {"
      },
      {
        "txt": "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\"debugger\");"
      },
      {
        "txt": "cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \");"
      },
      {
        "txt": "add(first); } cc.endStatement(); break; case Token.EXPR_VOID: throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement();"
      },
      {
        "txt": "break; case Token.NEW: add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) {"
      },
      {
        "txt": "add(\"(\"); addList(next); add(\")\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) { throw new IllegalStateException("
      },
      {
        "txt": "\"Unexpected String children: \" + n.getParent().toStringTree()); } add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break; case Token.OBJECTLIT: {"
      },
      {
        "txt": "boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\"); } add(\"{\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.getType() == Token.GET || c.getType() == Token.SET) {"
      },
      {
        "txt": "add(c); } else { if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { addExpr(c, 1);"
      },
      {
        "txt": "} add(\":\"); addExpr(c.getFirstChild(), 1); } } add(\"}\"); if (needsParens) { add(\")\"); } break;"
      },
      {
        "txt": "} case Token.SWITCH: add(\"switch(\"); add(first); add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE:"
      },
      {
        "txt": "Preconditions.checkState(childCount == 2); add(\"case \"); add(first); addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break;"
      },
      {
        "txt": "case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break;"
      },
      {
        "txt": "break; default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n); } <extra_id_0> private boolean isIndirectEval(Node n) { return n.getType() == Token.NAME && \"eval\".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL); } private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) {"
      },
      {
        "txt": "private void addNonEmptyStatement( Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\"Missing BLOCK child.\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) {"
      },
      {
        "txt": "cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();"
      },
      {
        "txt": "if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; } }"
      },
      {
        "txt": "if (count > 1) { context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement();"
      },
      {
        "txt": "} } } private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) {"
      },
      {
        "txt": "return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } void addLeftExpr(Node n, int minPrecedence, Context context) {"
      },
      {
        "txt": "addExpr(n, minPrecedence, context); } void addExpr(Node n, int minPrecedence) { addExpr(n, minPrecedence, Context.OTHER); } private void addExpr(Node n, int minPrecedence, Context context) { if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.getType() == Token.IN))){ add(\"(\");"
      },
      {
        "txt": "add(n, clearContextForNoInOperator(context)); add(\")\"); } else { add(n, context); } } void addList(Node firstInList) { addList(firstInList, true, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument) {"
      },
      {
        "txt": "addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); } void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { for (Node n = firstInList; n != null; n = n.getNext()) { boolean isFirst = n == firstInList; if (isFirst) { addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); } else { cc.listSeparator();"
      },
      {
        "txt": "addExpr(n, isArrayOrFunctionArgument ? 1 : 0); } } } void addArrayList(Node firstInList) { boolean lastWasEmpty = false; for (Node n = firstInList; n != null; n = n.getNext()) { if (n != firstInList) { cc.listSeparator(); }"
      },
      {
        "txt": "addExpr(n, 1); lastWasEmpty = n.getType() == Token.EMPTY; } if (lastWasEmpty) { cc.listSeparator(); } } void addCaseBody(Node caseBody) { cc.beginCaseBody(); add(caseBody);"
      },
      {
        "txt": "cc.endCaseBody(); } void addAllSiblings(Node n) { for (Node c = n; c != null; c = c.getNext()) { add(c); } } static String jsString(String s, CharsetEncoder outputCharsetEncoder) { int singleq = 0, doubleq = 0; for (int i = 0; i < s.length(); i++) {"
      },
      {
        "txt": "switch (s.charAt(i)) { case '\"': doubleq++; break; case '\\'': singleq++; break; } } String doublequote, singlequote; char quote; if (singleq < doubleq) { quote = '\\''; doublequote = \"\\\"\";"
      },
      {
        "txt": "singlequote = \"\\\\\\'\"; } else { quote = '\\\"'; doublequote = \"\\\\\\\"\"; singlequote = \"\\'\"; } return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\", outputCharsetEncoder); } static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {"
      },
      {
        "txt": "return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder); } static String escapeToDoubleQuotedJsString(String s) { return strEscape(s, '\"', \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null); } they want Latin/ASCII characters only. static String regexpEscape(String s) { return regexpEscape(s, null); } static String strEscape(String s, char quote,"
      },
      {
        "txt": "String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break;"
      },
      {
        "txt": "case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {"
      },
      {
        "txt": "sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {"
      },
      {
        "txt": "sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) {"
      },
      {
        "txt": "if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c);"
      },
      {
        "txt": "} } } } sb.append(quote); return sb.toString(); } static String identifierEscape(String s) { if (NodeUtil.isLatin(s)) { return s;"
      },
      {
        "txt": "} StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 0x1F && c < 0x7F) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } }"
      },
      {
        "txt": "return sb.toString(); } private static int getNonEmptyChildCount(Node n, int maxCount) { int i = 0; Node c = n.getFirstChild(); for (; c != null && i < maxCount; c = c.getNext()) { if (c.getType() == Token.BLOCK) { i += getNonEmptyChildCount(c, maxCount-i); } else if (c.getType() != Token.EMPTY) { i++;"
      },
      {
        "txt": "} } return i; } private static Node getFirstNonEmptyChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.getType() == Token.BLOCK) { Node result = getFirstNonEmptyChild(c); if (result != null) { return result;"
      },
      {
        "txt": "} } else if (c.getType() != Token.EMPTY) { return c; } } return null; } enum Context { STATEMENT, BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity"
      },
      {
        "txt": "START_OF_EXPR, PRESERVE_BLOCK, IN_FOR_INIT_CLAUSE, OTHER } private Context getContextForNonEmptyExpression(Context currentContext) { return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; } private Context getContextForNoInOperator(Context context) {"
      },
      {
        "txt": "return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); } private Context clearContextForNoInOperator(Context context) { return (context == Context.IN_FOR_INIT_CLAUSE ? Context.OTHER : context); } private static void appendHexJavaScriptRepresentation( StringBuilder sb, char c) { try {"
      },
      {
        "txt": "appendHexJavaScriptRepresentation(c, sb); } catch (IOException ex) { throw new RuntimeException(ex); } } private static void appendHexJavaScriptRepresentation( int codePoint, Appendable out) throws IOException { if (Character.isSupplementaryCodePoint(codePoint)) { char[] surrogates = Character.toChars(codePoint);"
      },
      {
        "txt": "appendHexJavaScriptRepresentation(surrogates[0], out); appendHexJavaScriptRepresentation(surrogates[1], out); return; } out.append(\"\\\\u\") .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) .append(HEX_CHARS[codePoint & 0xf]); }"
      }
    ]
  },
  {
    "id": 724,
    "file_path": "src/com/google/javascript/jscomp/RenamePrototypes.java",
    "start-bug-line": 336,
    "end-bug-line": 336,
    "bug": "if (child.getType() != Token.NUMBER) {",
    "fix": "if (TokenStream.isJSIdentifier(child.getString())) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.SortedSet; import java.util.TreeSet; import javax.annotation.Nullable; class RenamePrototypes implements CompilerPass { private final AbstractCompiler compiler; private final boolean aggressiveRenaming; private final char[] reservedCharacters; private final VariableMap prevUsedRenameMap; private class Property {"
      },
      {
        "txt": "String oldName; String newName; int prototypeCount; int objLitCount; int refCount; Property(String name) { this.oldName = name; this.newName = null; this.prototypeCount = 0; this.objLitCount = 0;"
      },
      {
        "txt": "this.refCount = 0; } int count() { return prototypeCount + objLitCount + refCount; } boolean canRename() { if (this.prototypeCount > 0 && this.objLitCount == 0) { return canRenamePrototypeProperty(); } if (this.objLitCount > 0 && this.prototypeCount == 0) {"
      },
      {
        "txt": "return canRenameObjLitProperty(); } return canRenamePrototypeProperty() && canRenameObjLitProperty(); } private boolean canRenamePrototypeProperty() { if (compiler.getCodingConvention().isExported(oldName)) { return false; } if (compiler.getCodingConvention().isPrivate(oldName)) { return true;"
      },
      {
        "txt": "} if (aggressiveRenaming) { return true; } for (int i = 0, n = oldName.length(); i < n; i++) { char ch = oldName.charAt(i); if (Character.isUpperCase(ch) || !Character.isLetter(ch)) { return true; } }"
      },
      {
        "txt": "return false; } private boolean canRenameObjLitProperty() { if (compiler.getCodingConvention().isExported(oldName)) { return false; } if (compiler.getCodingConvention().isPrivate(oldName)) { return true; } return false;"
      },
      {
        "txt": "} } private static final Comparator<Property> FREQUENCY_COMPARATOR = new Comparator<Property>() { public int compare(Property a1, Property a2) { int n1 = a1.count(); int n2 = a2.count(); if (n1 != n2) { return n2 - n1; }"
      },
      {
        "txt": "return a1.oldName.compareTo(a2.oldName); } }; private final Set<Node> stringNodes = new HashSet<Node>(); private final Map<String, Property> properties = new HashMap<String, Property>(); private final Set<String> reservedNames = new HashSet<String>(Arrays.asList( \"indexOf\", \"lastIndexOf\", \"toString\", \"valueOf\")); private final Set<Node> prototypeObjLits = new HashSet<Node>();"
      },
      {
        "txt": "RenamePrototypes(AbstractCompiler compiler, boolean aggressiveRenaming, @Nullable char[] reservedCharacters, @Nullable VariableMap prevUsedRenameMap) { this.compiler = compiler; this.aggressiveRenaming = aggressiveRenaming; this.reservedCharacters = reservedCharacters; this.prevUsedRenameMap = prevUsedRenameMap; } public void process(Node externs, Node root) { Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties()); NodeTraversal.traverse(compiler, root, new ProcessProperties()); SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR); for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) { Property a = it.next().getValue(); if (a.canRename() && !reservedNames.contains(a.oldName)) { propsByFrequency.add(a);"
      },
      {
        "txt": "} else { it.remove(); reservedNames.add(a.oldName); } } if (prevUsedRenameMap != null) { reusePrototypeNames(propsByFrequency); } NameGenerator nameGen = new NameGenerator(reservedNames, \"\", reservedCharacters);"
      },
      {
        "txt": "StringBuilder debug = new StringBuilder(); for (Property a : propsByFrequency) { if (a.newName == null) { a.newName = nameGen.generateNextName(); reservedNames.add(a.newName); } debug.append(a.oldName).append(\" => \").append(a.newName).append('\\n'); } compiler.addToDebugLog(\"JS property assignments:\\n\" + debug); boolean changed = false;"
      },
      {
        "txt": "for (Node n : stringNodes) { String oldName = n.getString(); Property a = properties.get(oldName); if (a != null && a.newName != null) { n.setString(a.newName); changed = changed || !a.newName.equals(oldName); } } if (changed) { compiler.reportCodeChange();"
      },
      {
        "txt": "} compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED); } private void reusePrototypeNames(Set<Property> properties) { for (Property prop : properties) { String prevName = prevUsedRenameMap.lookupNewName(prop.oldName); if (prevName != null) { if (reservedNames.contains(prevName)) { continue; }"
      },
      {
        "txt": "prop.newName = prevName; reservedNames.add(prevName); } } } private class ProcessExternedProperties extends AbstractPostOrderCallback { public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.GETPROP: case Token.GETELEM:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING) { reservedNames.add(dest.getString()); } } } } private class ProcessProperties extends AbstractPostOrderCallback { public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.GETPROP: case Token.GETELEM: Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING) { String s = dest.getString(); if (s.equals(\"prototype\")) { processPrototypeParent(parent, t.getInput()); } else { markPropertyAccessCandidate(dest, t.getInput()); }"
      },
      {
        "txt": "break; case Token.OBJECTLIT: if (!prototypeObjLits.contains(n)) { for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { <extra_id_0> markObjLitPropertyCandidate(child, t.getInput()); } } } break; }"
      },
      {
        "txt": "break; } } private void processPrototypeParent(Node n, CompilerInput input) { switch (n.getType()) { case Token.GETPROP: case Token.GETELEM: Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING) { markPrototypePropertyCandidate(dest, input);"
      },
      {
        "txt": "} break; case Token.ASSIGN: case Token.CALL: Node map; if (n.getType() == Token.ASSIGN) { map = n.getFirstChild().getNext(); } else { map = n.getLastChild(); }"
      },
      {
        "txt": "if (map.getType() == Token.OBJECTLIT) { prototypeObjLits.add(map); for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { if (key.getType() != Token.NUMBER) { markPrototypePropertyCandidate(key, input); } } } break;"
      },
      {
        "txt": "} } private void markPrototypePropertyCandidate(Node n, CompilerInput input) { stringNodes.add(n); getProperty(n.getString()).prototypeCount++; } private void markObjLitPropertyCandidate(Node n, CompilerInput input) { stringNodes.add(n); getProperty(n.getString()).objLitCount++; }"
      },
      {
        "txt": "private void markPropertyAccessCandidate(Node n, CompilerInput input) { stringNodes.add(n); getProperty(n.getString()).refCount++; } private Property getProperty(String name) { Property prop = properties.get(name); if (prop == null) { prop = new Property(name); properties.put(name, prop); }"
      },
      {
        "txt": "return prop; } } VariableMap getPropertyMap() { Map<String, String> map = new HashMap<String, String>(); for (Property p : properties.values()) { if (p.newName != null) { map.put(p.oldName, p.newName); } }"
      },
      {
        "txt": "return new VariableMap(map); }"
      }
    ]
  },
  {
    "id": 725,
    "file_path": "src/com/google/javascript/jscomp/RenamePrototypes.java",
    "start-bug-line": 377,
    "end-bug-line": 377,
    "bug": "if (key.getType() != Token.NUMBER) {",
    "fix": "if (TokenStream.isJSIdentifier(key.getString())) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet; import javax.annotation.Nullable; class RenamePrototypes implements CompilerPass { private final AbstractCompiler compiler; private final boolean aggressiveRenaming; private final char[] reservedCharacters; private final VariableMap prevUsedRenameMap;"
      },
      {
        "txt": "private class Property { String oldName; String newName; int prototypeCount; int objLitCount; int refCount; Property(String name) { this.oldName = name; this.newName = null; this.prototypeCount = 0;"
      },
      {
        "txt": "this.objLitCount = 0; this.refCount = 0; } int count() { return prototypeCount + objLitCount + refCount; } boolean canRename() { if (this.prototypeCount > 0 && this.objLitCount == 0) { return canRenamePrototypeProperty(); }"
      },
      {
        "txt": "if (this.objLitCount > 0 && this.prototypeCount == 0) { return canRenameObjLitProperty(); } return canRenamePrototypeProperty() && canRenameObjLitProperty(); } private boolean canRenamePrototypeProperty() { if (compiler.getCodingConvention().isExported(oldName)) { return false; } if (compiler.getCodingConvention().isPrivate(oldName)) {"
      },
      {
        "txt": "return true; } if (aggressiveRenaming) { return true; } for (int i = 0, n = oldName.length(); i < n; i++) { char ch = oldName.charAt(i); if (Character.isUpperCase(ch) || !Character.isLetter(ch)) { return true; }"
      },
      {
        "txt": "} return false; } private boolean canRenameObjLitProperty() { if (compiler.getCodingConvention().isExported(oldName)) { return false; } if (compiler.getCodingConvention().isPrivate(oldName)) { return true; }"
      },
      {
        "txt": "return false; } } private static final Comparator<Property> FREQUENCY_COMPARATOR = new Comparator<Property>() { public int compare(Property a1, Property a2) { int n1 = a1.count(); int n2 = a2.count(); if (n1 != n2) { return n2 - n1;"
      },
      {
        "txt": "} return a1.oldName.compareTo(a2.oldName); } }; private final Set<Node> stringNodes = new HashSet<Node>(); private final Map<String, Property> properties = new HashMap<String, Property>(); private final Set<String> reservedNames = new HashSet<String>(Arrays.asList( \"indexOf\", \"lastIndexOf\", \"toString\", \"valueOf\"));"
      },
      {
        "txt": "private final Set<Node> prototypeObjLits = new HashSet<Node>(); RenamePrototypes(AbstractCompiler compiler, boolean aggressiveRenaming, @Nullable char[] reservedCharacters, @Nullable VariableMap prevUsedRenameMap) { this.compiler = compiler; this.aggressiveRenaming = aggressiveRenaming; this.reservedCharacters = reservedCharacters; this.prevUsedRenameMap = prevUsedRenameMap; } public void process(Node externs, Node root) {"
      },
      {
        "txt": "Preconditions.checkState(compiler.getLifeCycleStage().isNormalized()); NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties()); NodeTraversal.traverse(compiler, root, new ProcessProperties()); SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR); for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) { Property a = it.next().getValue(); if (a.canRename() && !reservedNames.contains(a.oldName)) {"
      },
      {
        "txt": "propsByFrequency.add(a); } else { it.remove(); reservedNames.add(a.oldName); } } if (prevUsedRenameMap != null) { reusePrototypeNames(propsByFrequency); } NameGenerator nameGen = new NameGenerator(reservedNames, \"\","
      },
      {
        "txt": "reservedCharacters); StringBuilder debug = new StringBuilder(); for (Property a : propsByFrequency) { if (a.newName == null) { a.newName = nameGen.generateNextName(); reservedNames.add(a.newName); } debug.append(a.oldName).append(\" => \").append(a.newName).append('\\n'); } compiler.addToDebugLog(\"JS property assignments:\\n\" + debug);"
      },
      {
        "txt": "boolean changed = false; for (Node n : stringNodes) { String oldName = n.getString(); Property a = properties.get(oldName); if (a != null && a.newName != null) { n.setString(a.newName); changed = changed || !a.newName.equals(oldName); } } if (changed) {"
      },
      {
        "txt": "compiler.reportCodeChange(); } compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED); } private void reusePrototypeNames(Set<Property> properties) { for (Property prop : properties) { String prevName = prevUsedRenameMap.lookupNewName(prop.oldName); if (prevName != null) { if (reservedNames.contains(prevName)) { continue;"
      },
      {
        "txt": "} prop.newName = prevName; reservedNames.add(prevName); } } } private class ProcessExternedProperties extends AbstractPostOrderCallback { public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.GETPROP:"
      },
      {
        "txt": "case Token.GETELEM: Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING) { reservedNames.add(dest.getString()); } } } } private class ProcessProperties extends AbstractPostOrderCallback { public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.GETPROP: case Token.GETELEM: Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING) { String s = dest.getString(); if (s.equals(\"prototype\")) { processPrototypeParent(parent, t.getInput()); } else { markPropertyAccessCandidate(dest, t.getInput());"
      },
      {
        "txt": "} } break; case Token.OBJECTLIT: if (!prototypeObjLits.contains(n)) { for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (child.getType() != Token.NUMBER) { markObjLitPropertyCandidate(child, t.getInput());"
      },
      {
        "txt": "} } } break; } } private void processPrototypeParent(Node n, CompilerInput input) { switch (n.getType()) { case Token.GETPROP: case Token.GETELEM:"
      },
      {
        "txt": "Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING) { markPrototypePropertyCandidate(dest, input); } break; case Token.ASSIGN: case Token.CALL: Node map; if (n.getType() == Token.ASSIGN) { map = n.getFirstChild().getNext();"
      },
      {
        "txt": "map = n.getLastChild(); } if (map.getType() == Token.OBJECTLIT) { prototypeObjLits.add(map); for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { <extra_id_0> markPrototypePropertyCandidate(key, input); } } } break; }"
      },
      {
        "txt": "break; } } private void markPrototypePropertyCandidate(Node n, CompilerInput input) { stringNodes.add(n); getProperty(n.getString()).prototypeCount++; } private void markObjLitPropertyCandidate(Node n, CompilerInput input) { stringNodes.add(n); getProperty(n.getString()).objLitCount++;"
      },
      {
        "txt": "} private void markPropertyAccessCandidate(Node n, CompilerInput input) { stringNodes.add(n); getProperty(n.getString()).refCount++; } private Property getProperty(String name) { Property prop = properties.get(name); if (prop == null) { prop = new Property(name); properties.put(name, prop);"
      },
      {
        "txt": "} return prop; } } VariableMap getPropertyMap() { Map<String, String> map = new HashMap<String, String>(); for (Property p : properties.values()) { if (p.newName != null) { map.put(p.oldName, p.newName); }"
      },
      {
        "txt": "} return new VariableMap(map); }"
      }
    ]
  },
  {
    "id": 726,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 255,
    "end-bug-line": 255,
    "bug": "",
    "fix": "private Node transformNumberAsString(NumberLiteral literalNode) { JSDocInfo jsDocInfo = handleJsDoc(literalNode); Node irNode = newStringNode(getStringValue(literalNode.getNumber())); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, literalNode); return irNode; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment; import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode; import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot; import com.google.javascript.jscomp.mozilla.rhino.ast.Block;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet; import com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode; import com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Label; import com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Name; import com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty; import com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet; import com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Scope; import com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer; import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Set; public class IRFactory { private final String sourceString; private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher; private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");"
      },
      {
        "txt": "private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords; Node rootNodeJsDocHolder = new Node(Token.SCRIPT);"
      },
      {
        "txt": "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString, String sourceName, Config config, ErrorReporter errorReporter) { this.sourceString = sourceString; this.sourceName = sourceName;"
      },
      {
        "txt": "this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null; break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS;"
      },
      {
        "txt": "break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default: throw new IllegalStateException(\"unknown language mode\"); } } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT);"
      },
      {
        "txt": "templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } public static Node transformTree(AstRoot node, String sourceString, Config config, ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(), config, errorReporter); Node irNode = irFactory.transform(node);"
      },
      {
        "txt": "if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == JSDOC && !comment.isParsed()) { irFactory.handlePossibleFileOverviewJsDoc(comment); } } } irFactory.setFileOverviewJsDoc(irNode); return irNode; }"
      },
      {
        "txt": "private void setFileOverviewJsDoc(Node irNode) { irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo()); if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); } }"
      },
      {
        "txt": "private Node transformBlock(AstNode node) { Node irNode = transform(node); if (irNode.getType() != Token.BLOCK) { if (irNode.getType() == Token.EMPTY) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode); newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno());"
      },
      {
        "txt": "irNode = newBlock; } } return irNode; } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) { if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true;"
      },
      {
        "txt": "} return false; } private void handlePossibleFileOverviewJsDoc(Comment comment) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); handlePossibleFileOverviewJsDoc(jsDocParser); } private JSDocInfo handleJsDoc(AstNode node) { Comment comment = node.getJsDocNode();"
      },
      {
        "txt": "if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } } return null; } private Node transform(AstNode node) {"
      },
      {
        "txt": "JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = justTransform(node); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } private Node transformNameAsString(Name node) { JSDocInfo jsDocInfo = handleJsDoc(node);"
      },
      {
        "txt": "if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } <extra_id_0> private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getType() == Token.FUNCTION && irNode.getFirstChild().getLineno() != -1) { irNode.setLineno(irNode.getFirstChild().getLineno()); irNode.setCharno(irNode.getFirstChild().getCharno()); } else {"
      },
      {
        "txt": "irNode.setCharno(irNode.getFirstChild().getCharno()); } else { if (irNode.getLineno() == -1) { int lineno = node.getLineno(); irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); } } }"
      },
      {
        "txt": "private JsDocInfoParser createJsDocInfoParser(Comment node) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition(); int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars),"
      },
      {
        "txt": "node, sourceName, config, errorReporter); jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser; } private int position2charno(int position) {"
      },
      {
        "txt": "int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else { return position - lineIndex - 1; } } private Node justTransform(AstNode node) { return transformDispatcher.process(node); }"
      },
      {
        "txt": "private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.jscomp.mozilla.rhino.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node; } private Node transformAsString(AstNode n) {"
      },
      {
        "txt": "Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else { ret = transform(n); Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); }"
      },
      {
        "txt": "} return ret; } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT); for (AstNode child : literalNode.getElements()) {"
      },
      {
        "txt": "Node c = transform(child); node.addChildToBack(c); } return node; } @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) {"
      },
      {
        "txt": "errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0); } return assign; } @Override Node processAstRoot(AstRoot rootNode) { Node node = newNode(Token.SCRIPT);"
      },
      {
        "txt": "for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node); return node; } private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) { String directive = node.removeFirstChild().getFirstChild().getString();"
      },
      {
        "txt": "if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive); } } if (directives != null) { node.setDirectives(directives); } }"
      },
      {
        "txt": "private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) && n.getFirstChild().getType() == Token.STRING && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override Node processBlock(Block blockNode) { return processGeneric(blockNode);"
      },
      {
        "txt": "} @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node;"
      },
      {
        "txt": "} @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0);"
      },
      {
        "txt": "} node.addChildToBack(transformBlock(clauseNode.getBody())); return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()),"
      },
      {
        "txt": "transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); }"
      },
      {
        "txt": "return node; } @Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); } @Override"
      },
      {
        "txt": "Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY); return node;"
      },
      {
        "txt": "} @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override Node processForInLoop(ForInLoop loopNode) { return newNode("
      },
      {
        "txt": "Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()),"
      },
      {
        "txt": "transform(loopNode.getCondition()), transform(loopNode.getIncrement())); node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) {"
      },
      {
        "txt": "node.addChildToBack(transform(child)); } int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp(); node.setLineno(callNode.getLineno()); node.setCharno(position2charno(leftParamPos)); return node; } @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName();"
      },
      {
        "txt": "Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); } name = new Name();"
      },
      {
        "txt": "name.setIdentifier(\"\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn));"
      },
      {
        "txt": "} node.addChildToBack(newName); Node lp = newNode(Token.LP); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() +"
      },
      {
        "txt": "functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"
      },
      {
        "txt": "} @Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node;"
      },
      {
        "txt": "} @Override Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition() + exprNode.getOperatorPosition()));"
      },
      {
        "txt": "return n; } @Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); }"
      },
      {
        "txt": "@Override Node processLabeledStatement(LabeledStatement statementNode) { Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label));"
      },
      {
        "txt": "cur.setLineno(label.getLineno()); int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement())); return node; }"
      },
      {
        "txt": "@Override Node processName(Name nameNode) { return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error("
      },
      {
        "txt": "\"identifier is a reserved word\", sourceName, nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); }"
      },
      {
        "txt": "@Override Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) {"
      },
      {
        "txt": "if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) {"
      },
      {
        "txt": "reportSetter(el); continue; } } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (getFnParamNode(value).hasChildren()) {"
      },
      {
        "txt": "reportGetterParam(el.getLeft()); } } else if (el.isSetter()) { key.setType(Token.SET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); } } key.addChildToFront(value);"
      },
      {
        "txt": "node.addChildToBack(key); } return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) {"
      },
      {
        "txt": "return processInfixExpression(propertyNode); } @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; } @Override Node processPropertyGet(PropertyGet getNode) {"
      },
      {
        "txt": "return newNode( Token.GETPROP, transform(getNode.getTarget()), transformAsString(getNode.getProperty())); } @Override Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue()); literalStringNode.setLineno(literalNode.getLineno()); Node node = newNode(Token.REGEXP, literalStringNode);"
      },
      {
        "txt": "String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); node.addChildToBack(flagsNode); } return node; } @Override Node processReturnStatement(ReturnStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); } return node; } @Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); }"
      },
      {
        "txt": "@Override Node processStringLiteral(StringLiteral literalNode) { Node n = newStringNode(literalNode.getValue()); return n; } @Override Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT);"
      },
      {
        "txt": "} else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); } Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) {"
      },
      {
        "txt": "block.addChildToBack(transform(child)); } } node.addChildToBack(block); return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));"
      },
      {
        "txt": "for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); } return node; } @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); }"
      },
      {
        "txt": "@Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock())); Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); lineSet = true;"
      },
      {
        "txt": "} block.addChildToBack(transform(cc)); } node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno());"
      },
      {
        "txt": "} return node; } @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.getType() == Token.NUMBER) { operand.setDouble(-operand.getDouble()); return operand;"
      },
      {
        "txt": "} else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0);"
      },
      {
        "txt": "} } Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; } } private boolean validAssignmentTarget(Node target) {"
      },
      {
        "txt": "switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {"
      },
      {
        "txt": "if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.jscomp.mozilla.rhino.Token.CONST) { processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); } return node; }"
      },
      {
        "txt": "@Override Node processVariableInitializer(VariableInitializer initializerNode) { Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { node.addChildToBack(transform(initializerNode.getInitializer())); node.setLineno(node.getLineno()); } return node; } @Override"
      },
      {
        "txt": "Node processWhileLoop(WhileLoop loopNode) { return newNode( Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH,"
      },
      {
        "txt": "transform(statementNode.getExpression()), transformBlock(statementNode.getStatement())); } @Override Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.jscomp.mozilla.rhino.Token.typeToName( node.getType()), sourceName,"
      },
      {
        "txt": "node.getLineno(), \"\", 0); return newNode(Token.EMPTY); } void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"getters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} void reportGetterParam(AstNode node) { errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } } private static int transformTokenType(int token) { switch (token) { case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR: return Token.ERROR; case com.google.javascript.jscomp.mozilla.rhino.Token.EOF: return Token.EOF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EOL: return Token.EOL; case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH: return Token.ENTERWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH: return Token.LEAVEWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN: return Token.RETURN; case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO: return Token.GOTO;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ: return Token.IFEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE: return Token.IFNE; case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME: return Token.SETNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR: return Token.BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR: return Token.BITXOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND: return Token.BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.EQ: return Token.EQ; case com.google.javascript.jscomp.mozilla.rhino.Token.NE: return Token.NE; case com.google.javascript.jscomp.mozilla.rhino.Token.LT: return Token.LT; case com.google.javascript.jscomp.mozilla.rhino.Token.LE: return Token.LE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GT: return Token.GT; case com.google.javascript.jscomp.mozilla.rhino.Token.GE: return Token.GE; case com.google.javascript.jscomp.mozilla.rhino.Token.LSH: return Token.LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.RSH: return Token.RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.URSH: return Token.URSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ADD: return Token.ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.SUB: return Token.SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.MUL: return Token.MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.DIV: return Token.DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.MOD: return Token.MOD;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NOT: return Token.NOT; case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT: return Token.BITNOT; case com.google.javascript.jscomp.mozilla.rhino.Token.POS: return Token.POS; case com.google.javascript.jscomp.mozilla.rhino.Token.NEG: return Token.NEG; case com.google.javascript.jscomp.mozilla.rhino.Token.NEW: return Token.NEW;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP: return Token.DELPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP: return Token.GETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP: return Token.SETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM: return Token.GETELEM;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM: return Token.SETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.CALL: return Token.CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.NAME: return Token.NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER: return Token.NUMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.STRING: return Token.STRING;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NULL: return Token.NULL; case com.google.javascript.jscomp.mozilla.rhino.Token.THIS: return Token.THIS; case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE: return Token.FALSE; case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE: return Token.TRUE; case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ: return Token.SHEQ;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE: return Token.SHNE; case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP: return Token.REGEXP; case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME: return Token.BINDNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.THROW: return Token.THROW; case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW: return Token.RETHROW;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IN: return Token.IN; case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD: return Token.LOCAL_LOAD; case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR: return Token.GETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR: return Token.SETVAR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE: return Token.CATCH_SCOPE; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS: return Token.ENUM_INIT_KEYS; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES: return Token.ENUM_INIT_VALUES; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT: return Token.ENUM_NEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID: return Token.ENUM_ID;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN: return Token.THISFN; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT: return Token.RETURN_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT: return Token.OBJECTLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF: return Token.GET_REF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF: return Token.SET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF: return Token.DEL_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL: return Token.REF_CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL: return Token.REF_SPECIAL; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE: return Token.DEFAULTNAMESPACE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT: return Token.ESCXMLTEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR: return Token.ESCXMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER: return Token.REF_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER: return Token.REF_NS_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME: return Token.REF_NAME;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME: return Token.REF_NS_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.TRY: return Token.TRY; case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI: return Token.SEMI; case com.google.javascript.jscomp.mozilla.rhino.Token.LB: return Token.LB; case com.google.javascript.jscomp.mozilla.rhino.Token.RB: return Token.RB;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LC: return Token.LC; case com.google.javascript.jscomp.mozilla.rhino.Token.RC: return Token.RC; case com.google.javascript.jscomp.mozilla.rhino.Token.LP: return Token.LP; case com.google.javascript.jscomp.mozilla.rhino.Token.RP: return Token.RP; case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA: return Token.COMMA;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH: return Token.ASSIGN_LSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH: return Token.ASSIGN_URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL: return Token.ASSIGN_MUL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD: return Token.ASSIGN_MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK: return Token.HOOK; case com.google.javascript.jscomp.mozilla.rhino.Token.COLON: return Token.COLON; case com.google.javascript.jscomp.mozilla.rhino.Token.OR: return Token.OR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.AND: return Token.AND; case com.google.javascript.jscomp.mozilla.rhino.Token.INC: return Token.INC; case com.google.javascript.jscomp.mozilla.rhino.Token.DEC: return Token.DEC; case com.google.javascript.jscomp.mozilla.rhino.Token.DOT: return Token.DOT; case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION: return Token.FUNCTION;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT: return Token.EXPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT: return Token.IMPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IF: return Token.IF; case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE: return Token.ELSE; case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH: return Token.SWITCH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CASE: return Token.CASE; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT: return Token.DEFAULT; case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE: return Token.WHILE; case com.google.javascript.jscomp.mozilla.rhino.Token.DO: return Token.DO; case com.google.javascript.jscomp.mozilla.rhino.Token.FOR: return Token.FOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK: return Token.BREAK; case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE: return Token.CONTINUE; case com.google.javascript.jscomp.mozilla.rhino.Token.VAR: return Token.VAR; case com.google.javascript.jscomp.mozilla.rhino.Token.WITH: return Token.WITH; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH: return Token.CATCH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY: return Token.FINALLY; case com.google.javascript.jscomp.mozilla.rhino.Token.VOID: return Token.VOID; case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED: return Token.RESERVED; case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY: return Token.EMPTY; case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK: return Token.BLOCK;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL: return Token.LABEL; case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET: return Token.TARGET; case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP: return Token.LOOP; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID: case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:"
      },
      {
        "txt": "return Token.JSR; case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT: return Token.SCRIPT; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME: return Token.TYPEOFNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK: return Token.USE_STACK; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP: return Token.SETPROP_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:"
      },
      {
        "txt": "return Token.SETELEM_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK: return Token.LOCAL_BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP: return Token.SET_REF_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT: return Token.DOTDOT; case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON: return Token.COLONCOLON; case com.google.javascript.jscomp.mozilla.rhino.Token.XML:"
      },
      {
        "txt": "return Token.XML; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY: return Token.DOTQUERY; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR: return Token.XMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND: return Token.XMLEND; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT: return Token.TO_OBJECT; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:"
      },
      {
        "txt": "return Token.TO_DOUBLE; case com.google.javascript.jscomp.mozilla.rhino.Token.GET: return Token.GET; case com.google.javascript.jscomp.mozilla.rhino.Token.SET: return Token.SET; case com.google.javascript.jscomp.mozilla.rhino.Token.CONST: return Token.CONST; case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST: return Token.SETCONST; case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:"
      },
      {
        "txt": "return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token)); } private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2, Node child3) { return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return Node.newString(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) {"
      },
      {
        "txt": "return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) { return Node.newNumber(value).clonePropsFrom(templateNode); }"
      }
    ]
  },
  {
    "id": 727,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 256,
    "end-bug-line": 256,
    "bug": "",
    "fix": "private static String getStringValue(double value) { long longValue = (long) value;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment; import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode; import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot; import com.google.javascript.jscomp.mozilla.rhino.ast.Block;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet; import com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode; import com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Label; import com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Name; import com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty; import com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet; import com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Scope; import com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer; import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Set; public class IRFactory { private final String sourceString; private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher; private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");"
      },
      {
        "txt": "private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords; Node rootNodeJsDocHolder = new Node(Token.SCRIPT);"
      },
      {
        "txt": "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString, String sourceName, Config config, ErrorReporter errorReporter) { this.sourceString = sourceString; this.sourceName = sourceName;"
      },
      {
        "txt": "this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null; break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS;"
      },
      {
        "txt": "break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default: throw new IllegalStateException(\"unknown language mode\"); } } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT);"
      },
      {
        "txt": "templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } public static Node transformTree(AstRoot node, String sourceString, Config config, ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(), config, errorReporter); Node irNode = irFactory.transform(node);"
      },
      {
        "txt": "if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == JSDOC && !comment.isParsed()) { irFactory.handlePossibleFileOverviewJsDoc(comment); } } } irFactory.setFileOverviewJsDoc(irNode); return irNode; }"
      },
      {
        "txt": "private void setFileOverviewJsDoc(Node irNode) { irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo()); if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); } }"
      },
      {
        "txt": "private Node transformBlock(AstNode node) { Node irNode = transform(node); if (irNode.getType() != Token.BLOCK) { if (irNode.getType() == Token.EMPTY) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode); newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno());"
      },
      {
        "txt": "irNode = newBlock; } } return irNode; } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) { if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true;"
      },
      {
        "txt": "} return false; } private void handlePossibleFileOverviewJsDoc(Comment comment) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); handlePossibleFileOverviewJsDoc(jsDocParser); } private JSDocInfo handleJsDoc(AstNode node) { Comment comment = node.getJsDocNode();"
      },
      {
        "txt": "if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } } return null; } private Node transform(AstNode node) {"
      },
      {
        "txt": "JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = justTransform(node); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } private Node transformNameAsString(Name node) { JSDocInfo jsDocInfo = handleJsDoc(node);"
      },
      {
        "txt": "if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } <extra_id_0> private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getType() == Token.FUNCTION && irNode.getFirstChild().getLineno() != -1) { irNode.setLineno(irNode.getFirstChild().getLineno()); irNode.setCharno(irNode.getFirstChild().getCharno()); } else {"
      },
      {
        "txt": "irNode.setCharno(irNode.getFirstChild().getCharno()); } else { if (irNode.getLineno() == -1) { int lineno = node.getLineno(); irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); } } }"
      },
      {
        "txt": "private JsDocInfoParser createJsDocInfoParser(Comment node) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition(); int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars),"
      },
      {
        "txt": "node, sourceName, config, errorReporter); jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser; } private int position2charno(int position) {"
      },
      {
        "txt": "int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else { return position - lineIndex - 1; } } private Node justTransform(AstNode node) { return transformDispatcher.process(node); }"
      },
      {
        "txt": "private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.jscomp.mozilla.rhino.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node; } private Node transformAsString(AstNode n) {"
      },
      {
        "txt": "Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else { ret = transform(n); Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); }"
      },
      {
        "txt": "} return ret; } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT); for (AstNode child : literalNode.getElements()) {"
      },
      {
        "txt": "Node c = transform(child); node.addChildToBack(c); } return node; } @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) {"
      },
      {
        "txt": "errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0); } return assign; } @Override Node processAstRoot(AstRoot rootNode) { Node node = newNode(Token.SCRIPT);"
      },
      {
        "txt": "for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node); return node; } private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) { String directive = node.removeFirstChild().getFirstChild().getString();"
      },
      {
        "txt": "if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive); } } if (directives != null) { node.setDirectives(directives); } }"
      },
      {
        "txt": "private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) && n.getFirstChild().getType() == Token.STRING && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override Node processBlock(Block blockNode) { return processGeneric(blockNode);"
      },
      {
        "txt": "} @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node;"
      },
      {
        "txt": "} @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0);"
      },
      {
        "txt": "} node.addChildToBack(transformBlock(clauseNode.getBody())); return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()),"
      },
      {
        "txt": "transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); }"
      },
      {
        "txt": "return node; } @Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); } @Override"
      },
      {
        "txt": "Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY); return node;"
      },
      {
        "txt": "} @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override Node processForInLoop(ForInLoop loopNode) { return newNode("
      },
      {
        "txt": "Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()),"
      },
      {
        "txt": "transform(loopNode.getCondition()), transform(loopNode.getIncrement())); node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) {"
      },
      {
        "txt": "node.addChildToBack(transform(child)); } int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp(); node.setLineno(callNode.getLineno()); node.setCharno(position2charno(leftParamPos)); return node; } @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName();"
      },
      {
        "txt": "Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); } name = new Name();"
      },
      {
        "txt": "name.setIdentifier(\"\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn));"
      },
      {
        "txt": "} node.addChildToBack(newName); Node lp = newNode(Token.LP); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() +"
      },
      {
        "txt": "functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"
      },
      {
        "txt": "} @Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node;"
      },
      {
        "txt": "} @Override Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition() + exprNode.getOperatorPosition()));"
      },
      {
        "txt": "return n; } @Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); }"
      },
      {
        "txt": "@Override Node processLabeledStatement(LabeledStatement statementNode) { Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label));"
      },
      {
        "txt": "cur.setLineno(label.getLineno()); int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement())); return node; }"
      },
      {
        "txt": "@Override Node processName(Name nameNode) { return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error("
      },
      {
        "txt": "\"identifier is a reserved word\", sourceName, nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); }"
      },
      {
        "txt": "@Override Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) {"
      },
      {
        "txt": "if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) {"
      },
      {
        "txt": "reportSetter(el); continue; } } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (getFnParamNode(value).hasChildren()) {"
      },
      {
        "txt": "reportGetterParam(el.getLeft()); } } else if (el.isSetter()) { key.setType(Token.SET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); } } key.addChildToFront(value);"
      },
      {
        "txt": "node.addChildToBack(key); } return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) {"
      },
      {
        "txt": "return processInfixExpression(propertyNode); } @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; } @Override Node processPropertyGet(PropertyGet getNode) {"
      },
      {
        "txt": "return newNode( Token.GETPROP, transform(getNode.getTarget()), transformAsString(getNode.getProperty())); } @Override Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue()); literalStringNode.setLineno(literalNode.getLineno()); Node node = newNode(Token.REGEXP, literalStringNode);"
      },
      {
        "txt": "String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); node.addChildToBack(flagsNode); } return node; } @Override Node processReturnStatement(ReturnStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); } return node; } @Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); }"
      },
      {
        "txt": "@Override Node processStringLiteral(StringLiteral literalNode) { Node n = newStringNode(literalNode.getValue()); return n; } @Override Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT);"
      },
      {
        "txt": "} else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); } Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) {"
      },
      {
        "txt": "block.addChildToBack(transform(child)); } } node.addChildToBack(block); return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));"
      },
      {
        "txt": "for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); } return node; } @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); }"
      },
      {
        "txt": "@Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock())); Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); lineSet = true;"
      },
      {
        "txt": "} block.addChildToBack(transform(cc)); } node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno());"
      },
      {
        "txt": "} return node; } @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.getType() == Token.NUMBER) { operand.setDouble(-operand.getDouble()); return operand;"
      },
      {
        "txt": "} else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0);"
      },
      {
        "txt": "} } Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; } } private boolean validAssignmentTarget(Node target) {"
      },
      {
        "txt": "switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {"
      },
      {
        "txt": "if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.jscomp.mozilla.rhino.Token.CONST) { processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); } return node; }"
      },
      {
        "txt": "@Override Node processVariableInitializer(VariableInitializer initializerNode) { Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { node.addChildToBack(transform(initializerNode.getInitializer())); node.setLineno(node.getLineno()); } return node; } @Override"
      },
      {
        "txt": "Node processWhileLoop(WhileLoop loopNode) { return newNode( Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH,"
      },
      {
        "txt": "transform(statementNode.getExpression()), transformBlock(statementNode.getStatement())); } @Override Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.jscomp.mozilla.rhino.Token.typeToName( node.getType()), sourceName,"
      },
      {
        "txt": "node.getLineno(), \"\", 0); return newNode(Token.EMPTY); } void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"getters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} void reportGetterParam(AstNode node) { errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } } private static int transformTokenType(int token) { switch (token) { case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR: return Token.ERROR; case com.google.javascript.jscomp.mozilla.rhino.Token.EOF: return Token.EOF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EOL: return Token.EOL; case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH: return Token.ENTERWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH: return Token.LEAVEWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN: return Token.RETURN; case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO: return Token.GOTO;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ: return Token.IFEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE: return Token.IFNE; case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME: return Token.SETNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR: return Token.BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR: return Token.BITXOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND: return Token.BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.EQ: return Token.EQ; case com.google.javascript.jscomp.mozilla.rhino.Token.NE: return Token.NE; case com.google.javascript.jscomp.mozilla.rhino.Token.LT: return Token.LT; case com.google.javascript.jscomp.mozilla.rhino.Token.LE: return Token.LE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GT: return Token.GT; case com.google.javascript.jscomp.mozilla.rhino.Token.GE: return Token.GE; case com.google.javascript.jscomp.mozilla.rhino.Token.LSH: return Token.LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.RSH: return Token.RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.URSH: return Token.URSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ADD: return Token.ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.SUB: return Token.SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.MUL: return Token.MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.DIV: return Token.DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.MOD: return Token.MOD;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NOT: return Token.NOT; case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT: return Token.BITNOT; case com.google.javascript.jscomp.mozilla.rhino.Token.POS: return Token.POS; case com.google.javascript.jscomp.mozilla.rhino.Token.NEG: return Token.NEG; case com.google.javascript.jscomp.mozilla.rhino.Token.NEW: return Token.NEW;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP: return Token.DELPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP: return Token.GETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP: return Token.SETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM: return Token.GETELEM;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM: return Token.SETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.CALL: return Token.CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.NAME: return Token.NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER: return Token.NUMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.STRING: return Token.STRING;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NULL: return Token.NULL; case com.google.javascript.jscomp.mozilla.rhino.Token.THIS: return Token.THIS; case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE: return Token.FALSE; case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE: return Token.TRUE; case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ: return Token.SHEQ;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE: return Token.SHNE; case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP: return Token.REGEXP; case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME: return Token.BINDNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.THROW: return Token.THROW; case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW: return Token.RETHROW;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IN: return Token.IN; case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD: return Token.LOCAL_LOAD; case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR: return Token.GETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR: return Token.SETVAR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE: return Token.CATCH_SCOPE; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS: return Token.ENUM_INIT_KEYS; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES: return Token.ENUM_INIT_VALUES; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT: return Token.ENUM_NEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID: return Token.ENUM_ID;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN: return Token.THISFN; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT: return Token.RETURN_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT: return Token.OBJECTLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF: return Token.GET_REF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF: return Token.SET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF: return Token.DEL_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL: return Token.REF_CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL: return Token.REF_SPECIAL; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE: return Token.DEFAULTNAMESPACE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT: return Token.ESCXMLTEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR: return Token.ESCXMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER: return Token.REF_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER: return Token.REF_NS_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME: return Token.REF_NAME;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME: return Token.REF_NS_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.TRY: return Token.TRY; case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI: return Token.SEMI; case com.google.javascript.jscomp.mozilla.rhino.Token.LB: return Token.LB; case com.google.javascript.jscomp.mozilla.rhino.Token.RB: return Token.RB;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LC: return Token.LC; case com.google.javascript.jscomp.mozilla.rhino.Token.RC: return Token.RC; case com.google.javascript.jscomp.mozilla.rhino.Token.LP: return Token.LP; case com.google.javascript.jscomp.mozilla.rhino.Token.RP: return Token.RP; case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA: return Token.COMMA;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH: return Token.ASSIGN_LSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH: return Token.ASSIGN_URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL: return Token.ASSIGN_MUL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD: return Token.ASSIGN_MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK: return Token.HOOK; case com.google.javascript.jscomp.mozilla.rhino.Token.COLON: return Token.COLON; case com.google.javascript.jscomp.mozilla.rhino.Token.OR: return Token.OR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.AND: return Token.AND; case com.google.javascript.jscomp.mozilla.rhino.Token.INC: return Token.INC; case com.google.javascript.jscomp.mozilla.rhino.Token.DEC: return Token.DEC; case com.google.javascript.jscomp.mozilla.rhino.Token.DOT: return Token.DOT; case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION: return Token.FUNCTION;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT: return Token.EXPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT: return Token.IMPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IF: return Token.IF; case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE: return Token.ELSE; case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH: return Token.SWITCH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CASE: return Token.CASE; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT: return Token.DEFAULT; case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE: return Token.WHILE; case com.google.javascript.jscomp.mozilla.rhino.Token.DO: return Token.DO; case com.google.javascript.jscomp.mozilla.rhino.Token.FOR: return Token.FOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK: return Token.BREAK; case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE: return Token.CONTINUE; case com.google.javascript.jscomp.mozilla.rhino.Token.VAR: return Token.VAR; case com.google.javascript.jscomp.mozilla.rhino.Token.WITH: return Token.WITH; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH: return Token.CATCH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY: return Token.FINALLY; case com.google.javascript.jscomp.mozilla.rhino.Token.VOID: return Token.VOID; case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED: return Token.RESERVED; case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY: return Token.EMPTY; case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK: return Token.BLOCK;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL: return Token.LABEL; case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET: return Token.TARGET; case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP: return Token.LOOP; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID: case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:"
      },
      {
        "txt": "return Token.JSR; case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT: return Token.SCRIPT; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME: return Token.TYPEOFNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK: return Token.USE_STACK; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP: return Token.SETPROP_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:"
      },
      {
        "txt": "return Token.SETELEM_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK: return Token.LOCAL_BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP: return Token.SET_REF_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT: return Token.DOTDOT; case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON: return Token.COLONCOLON; case com.google.javascript.jscomp.mozilla.rhino.Token.XML:"
      },
      {
        "txt": "return Token.XML; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY: return Token.DOTQUERY; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR: return Token.XMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND: return Token.XMLEND; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT: return Token.TO_OBJECT; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:"
      },
      {
        "txt": "return Token.TO_DOUBLE; case com.google.javascript.jscomp.mozilla.rhino.Token.GET: return Token.GET; case com.google.javascript.jscomp.mozilla.rhino.Token.SET: return Token.SET; case com.google.javascript.jscomp.mozilla.rhino.Token.CONST: return Token.CONST; case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST: return Token.SETCONST; case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:"
      },
      {
        "txt": "return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token)); } private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2, Node child3) { return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return Node.newString(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) {"
      },
      {
        "txt": "return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) { return Node.newNumber(value).clonePropsFrom(templateNode); }"
      }
    ]
  },
  {
    "id": 728,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 258,
    "end-bug-line": 258,
    "bug": "",
    "fix": "if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(value); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment; import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode; import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot; import com.google.javascript.jscomp.mozilla.rhino.ast.Block;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet; import com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode; import com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Label; import com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Name; import com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty; import com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet; import com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Scope; import com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer; import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Set; public class IRFactory { private final String sourceString; private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher; private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");"
      },
      {
        "txt": "private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords; Node rootNodeJsDocHolder = new Node(Token.SCRIPT);"
      },
      {
        "txt": "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString, String sourceName, Config config, ErrorReporter errorReporter) { this.sourceString = sourceString; this.sourceName = sourceName;"
      },
      {
        "txt": "this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null; break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS;"
      },
      {
        "txt": "break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default: throw new IllegalStateException(\"unknown language mode\"); } } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT);"
      },
      {
        "txt": "templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } public static Node transformTree(AstRoot node, String sourceString, Config config, ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(), config, errorReporter); Node irNode = irFactory.transform(node);"
      },
      {
        "txt": "if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == JSDOC && !comment.isParsed()) { irFactory.handlePossibleFileOverviewJsDoc(comment); } } } irFactory.setFileOverviewJsDoc(irNode); return irNode; }"
      },
      {
        "txt": "private void setFileOverviewJsDoc(Node irNode) { irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo()); if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); } }"
      },
      {
        "txt": "private Node transformBlock(AstNode node) { Node irNode = transform(node); if (irNode.getType() != Token.BLOCK) { if (irNode.getType() == Token.EMPTY) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode); newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno());"
      },
      {
        "txt": "irNode = newBlock; } } return irNode; } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) { if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true;"
      },
      {
        "txt": "} return false; } private void handlePossibleFileOverviewJsDoc(Comment comment) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); handlePossibleFileOverviewJsDoc(jsDocParser); } private JSDocInfo handleJsDoc(AstNode node) { Comment comment = node.getJsDocNode();"
      },
      {
        "txt": "if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } } return null; } private Node transform(AstNode node) {"
      },
      {
        "txt": "JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = justTransform(node); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } private Node transformNameAsString(Name node) { JSDocInfo jsDocInfo = handleJsDoc(node);"
      },
      {
        "txt": "if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } <extra_id_0> private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getType() == Token.FUNCTION && irNode.getFirstChild().getLineno() != -1) { irNode.setLineno(irNode.getFirstChild().getLineno()); irNode.setCharno(irNode.getFirstChild().getCharno()); } else {"
      },
      {
        "txt": "irNode.setCharno(irNode.getFirstChild().getCharno()); } else { if (irNode.getLineno() == -1) { int lineno = node.getLineno(); irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); } } }"
      },
      {
        "txt": "private JsDocInfoParser createJsDocInfoParser(Comment node) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition(); int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars),"
      },
      {
        "txt": "node, sourceName, config, errorReporter); jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser; } private int position2charno(int position) {"
      },
      {
        "txt": "int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else { return position - lineIndex - 1; } } private Node justTransform(AstNode node) { return transformDispatcher.process(node); }"
      },
      {
        "txt": "private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.jscomp.mozilla.rhino.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node; } private Node transformAsString(AstNode n) {"
      },
      {
        "txt": "Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else { ret = transform(n); Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); }"
      },
      {
        "txt": "} return ret; } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT); for (AstNode child : literalNode.getElements()) {"
      },
      {
        "txt": "Node c = transform(child); node.addChildToBack(c); } return node; } @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) {"
      },
      {
        "txt": "errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0); } return assign; } @Override Node processAstRoot(AstRoot rootNode) { Node node = newNode(Token.SCRIPT);"
      },
      {
        "txt": "for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node); return node; } private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) { String directive = node.removeFirstChild().getFirstChild().getString();"
      },
      {
        "txt": "if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive); } } if (directives != null) { node.setDirectives(directives); } }"
      },
      {
        "txt": "private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) && n.getFirstChild().getType() == Token.STRING && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override Node processBlock(Block blockNode) { return processGeneric(blockNode);"
      },
      {
        "txt": "} @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node;"
      },
      {
        "txt": "} @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0);"
      },
      {
        "txt": "} node.addChildToBack(transformBlock(clauseNode.getBody())); return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()),"
      },
      {
        "txt": "transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); }"
      },
      {
        "txt": "return node; } @Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); } @Override"
      },
      {
        "txt": "Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY); return node;"
      },
      {
        "txt": "} @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override Node processForInLoop(ForInLoop loopNode) { return newNode("
      },
      {
        "txt": "Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()),"
      },
      {
        "txt": "transform(loopNode.getCondition()), transform(loopNode.getIncrement())); node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) {"
      },
      {
        "txt": "node.addChildToBack(transform(child)); } int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp(); node.setLineno(callNode.getLineno()); node.setCharno(position2charno(leftParamPos)); return node; } @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName();"
      },
      {
        "txt": "Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); } name = new Name();"
      },
      {
        "txt": "name.setIdentifier(\"\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn));"
      },
      {
        "txt": "} node.addChildToBack(newName); Node lp = newNode(Token.LP); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() +"
      },
      {
        "txt": "functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"
      },
      {
        "txt": "} @Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node;"
      },
      {
        "txt": "} @Override Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition() + exprNode.getOperatorPosition()));"
      },
      {
        "txt": "return n; } @Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); }"
      },
      {
        "txt": "@Override Node processLabeledStatement(LabeledStatement statementNode) { Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label));"
      },
      {
        "txt": "cur.setLineno(label.getLineno()); int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement())); return node; }"
      },
      {
        "txt": "@Override Node processName(Name nameNode) { return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error("
      },
      {
        "txt": "\"identifier is a reserved word\", sourceName, nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); }"
      },
      {
        "txt": "@Override Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) {"
      },
      {
        "txt": "if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) {"
      },
      {
        "txt": "reportSetter(el); continue; } } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (getFnParamNode(value).hasChildren()) {"
      },
      {
        "txt": "reportGetterParam(el.getLeft()); } } else if (el.isSetter()) { key.setType(Token.SET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); } } key.addChildToFront(value);"
      },
      {
        "txt": "node.addChildToBack(key); } return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) {"
      },
      {
        "txt": "return processInfixExpression(propertyNode); } @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; } @Override Node processPropertyGet(PropertyGet getNode) {"
      },
      {
        "txt": "return newNode( Token.GETPROP, transform(getNode.getTarget()), transformAsString(getNode.getProperty())); } @Override Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue()); literalStringNode.setLineno(literalNode.getLineno()); Node node = newNode(Token.REGEXP, literalStringNode);"
      },
      {
        "txt": "String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); node.addChildToBack(flagsNode); } return node; } @Override Node processReturnStatement(ReturnStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); } return node; } @Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); }"
      },
      {
        "txt": "@Override Node processStringLiteral(StringLiteral literalNode) { Node n = newStringNode(literalNode.getValue()); return n; } @Override Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT);"
      },
      {
        "txt": "} else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); } Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) {"
      },
      {
        "txt": "block.addChildToBack(transform(child)); } } node.addChildToBack(block); return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));"
      },
      {
        "txt": "for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); } return node; } @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); }"
      },
      {
        "txt": "@Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock())); Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); lineSet = true;"
      },
      {
        "txt": "} block.addChildToBack(transform(cc)); } node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno());"
      },
      {
        "txt": "} return node; } @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.getType() == Token.NUMBER) { operand.setDouble(-operand.getDouble()); return operand;"
      },
      {
        "txt": "} else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0);"
      },
      {
        "txt": "} } Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; } } private boolean validAssignmentTarget(Node target) {"
      },
      {
        "txt": "switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {"
      },
      {
        "txt": "if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.jscomp.mozilla.rhino.Token.CONST) { processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); } return node; }"
      },
      {
        "txt": "@Override Node processVariableInitializer(VariableInitializer initializerNode) { Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { node.addChildToBack(transform(initializerNode.getInitializer())); node.setLineno(node.getLineno()); } return node; } @Override"
      },
      {
        "txt": "Node processWhileLoop(WhileLoop loopNode) { return newNode( Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH,"
      },
      {
        "txt": "transform(statementNode.getExpression()), transformBlock(statementNode.getStatement())); } @Override Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.jscomp.mozilla.rhino.Token.typeToName( node.getType()), sourceName,"
      },
      {
        "txt": "node.getLineno(), \"\", 0); return newNode(Token.EMPTY); } void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"getters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} void reportGetterParam(AstNode node) { errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } } private static int transformTokenType(int token) { switch (token) { case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR: return Token.ERROR; case com.google.javascript.jscomp.mozilla.rhino.Token.EOF: return Token.EOF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EOL: return Token.EOL; case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH: return Token.ENTERWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH: return Token.LEAVEWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN: return Token.RETURN; case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO: return Token.GOTO;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ: return Token.IFEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE: return Token.IFNE; case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME: return Token.SETNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR: return Token.BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR: return Token.BITXOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND: return Token.BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.EQ: return Token.EQ; case com.google.javascript.jscomp.mozilla.rhino.Token.NE: return Token.NE; case com.google.javascript.jscomp.mozilla.rhino.Token.LT: return Token.LT; case com.google.javascript.jscomp.mozilla.rhino.Token.LE: return Token.LE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GT: return Token.GT; case com.google.javascript.jscomp.mozilla.rhino.Token.GE: return Token.GE; case com.google.javascript.jscomp.mozilla.rhino.Token.LSH: return Token.LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.RSH: return Token.RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.URSH: return Token.URSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ADD: return Token.ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.SUB: return Token.SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.MUL: return Token.MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.DIV: return Token.DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.MOD: return Token.MOD;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NOT: return Token.NOT; case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT: return Token.BITNOT; case com.google.javascript.jscomp.mozilla.rhino.Token.POS: return Token.POS; case com.google.javascript.jscomp.mozilla.rhino.Token.NEG: return Token.NEG; case com.google.javascript.jscomp.mozilla.rhino.Token.NEW: return Token.NEW;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP: return Token.DELPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP: return Token.GETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP: return Token.SETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM: return Token.GETELEM;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM: return Token.SETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.CALL: return Token.CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.NAME: return Token.NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER: return Token.NUMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.STRING: return Token.STRING;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NULL: return Token.NULL; case com.google.javascript.jscomp.mozilla.rhino.Token.THIS: return Token.THIS; case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE: return Token.FALSE; case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE: return Token.TRUE; case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ: return Token.SHEQ;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE: return Token.SHNE; case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP: return Token.REGEXP; case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME: return Token.BINDNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.THROW: return Token.THROW; case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW: return Token.RETHROW;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IN: return Token.IN; case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD: return Token.LOCAL_LOAD; case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR: return Token.GETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR: return Token.SETVAR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE: return Token.CATCH_SCOPE; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS: return Token.ENUM_INIT_KEYS; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES: return Token.ENUM_INIT_VALUES; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT: return Token.ENUM_NEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID: return Token.ENUM_ID;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN: return Token.THISFN; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT: return Token.RETURN_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT: return Token.OBJECTLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF: return Token.GET_REF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF: return Token.SET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF: return Token.DEL_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL: return Token.REF_CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL: return Token.REF_SPECIAL; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE: return Token.DEFAULTNAMESPACE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT: return Token.ESCXMLTEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR: return Token.ESCXMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER: return Token.REF_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER: return Token.REF_NS_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME: return Token.REF_NAME;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME: return Token.REF_NS_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.TRY: return Token.TRY; case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI: return Token.SEMI; case com.google.javascript.jscomp.mozilla.rhino.Token.LB: return Token.LB; case com.google.javascript.jscomp.mozilla.rhino.Token.RB: return Token.RB;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LC: return Token.LC; case com.google.javascript.jscomp.mozilla.rhino.Token.RC: return Token.RC; case com.google.javascript.jscomp.mozilla.rhino.Token.LP: return Token.LP; case com.google.javascript.jscomp.mozilla.rhino.Token.RP: return Token.RP; case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA: return Token.COMMA;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH: return Token.ASSIGN_LSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH: return Token.ASSIGN_URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL: return Token.ASSIGN_MUL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD: return Token.ASSIGN_MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK: return Token.HOOK; case com.google.javascript.jscomp.mozilla.rhino.Token.COLON: return Token.COLON; case com.google.javascript.jscomp.mozilla.rhino.Token.OR: return Token.OR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.AND: return Token.AND; case com.google.javascript.jscomp.mozilla.rhino.Token.INC: return Token.INC; case com.google.javascript.jscomp.mozilla.rhino.Token.DEC: return Token.DEC; case com.google.javascript.jscomp.mozilla.rhino.Token.DOT: return Token.DOT; case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION: return Token.FUNCTION;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT: return Token.EXPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT: return Token.IMPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IF: return Token.IF; case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE: return Token.ELSE; case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH: return Token.SWITCH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CASE: return Token.CASE; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT: return Token.DEFAULT; case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE: return Token.WHILE; case com.google.javascript.jscomp.mozilla.rhino.Token.DO: return Token.DO; case com.google.javascript.jscomp.mozilla.rhino.Token.FOR: return Token.FOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK: return Token.BREAK; case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE: return Token.CONTINUE; case com.google.javascript.jscomp.mozilla.rhino.Token.VAR: return Token.VAR; case com.google.javascript.jscomp.mozilla.rhino.Token.WITH: return Token.WITH; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH: return Token.CATCH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY: return Token.FINALLY; case com.google.javascript.jscomp.mozilla.rhino.Token.VOID: return Token.VOID; case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED: return Token.RESERVED; case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY: return Token.EMPTY; case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK: return Token.BLOCK;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL: return Token.LABEL; case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET: return Token.TARGET; case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP: return Token.LOOP; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID: case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:"
      },
      {
        "txt": "return Token.JSR; case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT: return Token.SCRIPT; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME: return Token.TYPEOFNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK: return Token.USE_STACK; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP: return Token.SETPROP_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:"
      },
      {
        "txt": "return Token.SETELEM_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK: return Token.LOCAL_BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP: return Token.SET_REF_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT: return Token.DOTDOT; case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON: return Token.COLONCOLON; case com.google.javascript.jscomp.mozilla.rhino.Token.XML:"
      },
      {
        "txt": "return Token.XML; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY: return Token.DOTQUERY; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR: return Token.XMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND: return Token.XMLEND; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT: return Token.TO_OBJECT; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:"
      },
      {
        "txt": "return Token.TO_DOUBLE; case com.google.javascript.jscomp.mozilla.rhino.Token.GET: return Token.GET; case com.google.javascript.jscomp.mozilla.rhino.Token.SET: return Token.SET; case com.google.javascript.jscomp.mozilla.rhino.Token.CONST: return Token.CONST; case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST: return Token.SETCONST; case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:"
      },
      {
        "txt": "return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token)); } private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2, Node child3) { return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return Node.newString(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) {"
      },
      {
        "txt": "return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) { return Node.newNumber(value).clonePropsFrom(templateNode); }"
      }
    ]
  },
  {
    "id": 729,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 347,
    "end-bug-line": 347,
    "bug": "",
    "fix": "} else if (n instanceof NumberLiteral) { ret = transformNumberAsString((NumberLiteral)n); ret.putBooleanProp(Node.QUOTED_PROP, true);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode; import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot; import com.google.javascript.jscomp.mozilla.rhino.ast.Block; import com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode; import com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Label;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Name; import com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty; import com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet; import com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.Scope; import com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer; import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Set; public class IRFactory { private final String sourceString; private final String sourceName; private final Config config;"
      },
      {
        "txt": "private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher; private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\"); private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\","
      },
      {
        "txt": "\"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords; Node rootNodeJsDocHolder = new Node(Token.SCRIPT); Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString, String sourceName, Config config,"
      },
      {
        "txt": "ErrorReporter errorReporter) { this.sourceString = sourceString; this.sourceName = sourceName; this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null;"
      },
      {
        "txt": "break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS; break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default: throw new IllegalStateException(\"unknown language mode\"); }"
      },
      {
        "txt": "} private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } public static Node transformTree(AstRoot node, String sourceString, Config config, ErrorReporter errorReporter) {"
      },
      {
        "txt": "IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(), config, errorReporter); Node irNode = irFactory.transform(node); if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == JSDOC && !comment.isParsed()) { irFactory.handlePossibleFileOverviewJsDoc(comment); } } }"
      },
      {
        "txt": "irFactory.setFileOverviewJsDoc(irNode); return irNode; } private void setFileOverviewJsDoc(Node irNode) { irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo()); if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); }"
      },
      {
        "txt": "irNode.setJSDocInfo(fileOverviewInfo); } } private Node transformBlock(AstNode node) { Node irNode = transform(node); if (irNode.getType() != Token.BLOCK) { if (irNode.getType() == Token.EMPTY) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else {"
      },
      {
        "txt": "Node newBlock = newNode(Token.BLOCK, irNode); newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno()); irNode = newBlock; } } return irNode; } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) {"
      },
      {
        "txt": "if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true; } return false; } private void handlePossibleFileOverviewJsDoc(Comment comment) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); handlePossibleFileOverviewJsDoc(jsDocParser);"
      },
      {
        "txt": "} private JSDocInfo handleJsDoc(AstNode node) { Comment comment = node.getJsDocNode(); if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } }"
      },
      {
        "txt": "return null; } private Node transform(AstNode node) { JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = justTransform(node); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode;"
      },
      {
        "txt": "} private Node transformNameAsString(Name node) { JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = transformDispatcher.processName(node, true); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; }"
      },
      {
        "txt": "private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getType() == Token.FUNCTION && irNode.getFirstChild().getLineno() != -1) { irNode.setLineno(irNode.getFirstChild().getLineno()); irNode.setCharno(irNode.getFirstChild().getCharno()); } else { if (irNode.getLineno() == -1) { int lineno = node.getLineno(); irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition());"
      },
      {
        "txt": "irNode.setCharno(charno); } } } private JsDocInfoParser createJsDocInfoParser(Comment node) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition(); int numOpeningChars = 3; JsDocInfoParser jsdocParser ="
      },
      {
        "txt": "new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars), node, sourceName, config, errorReporter); jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);"
      },
      {
        "txt": "jsdocParser.parse(); return jsdocParser; } private int position2charno(int position) { int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else { return position - lineIndex - 1; }"
      },
      {
        "txt": "} private Node justTransform(AstNode node) { return transformDispatcher.process(node); } private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.jscomp.mozilla.rhino.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) { node.addChildToBack(transform((AstNode)child));"
      },
      {
        "txt": "return node; } private Node transformAsString(AstNode n) { Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); <extra_id_0> ret = transform(n); Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); }"
      },
      {
        "txt": "ret.putBooleanProp(Node.QUOTED_PROP, true); } } return ret; } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); }"
      },
      {
        "txt": "Node node = newNode(Token.ARRAYLIT); for (AstNode child : literalNode.getElements()) { Node c = transform(child); node.addChildToBack(c); } return node; } @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode);"
      },
      {
        "txt": "Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0); } return assign; } @Override"
      },
      {
        "txt": "Node processAstRoot(AstRoot rootNode) { Node node = newNode(Token.SCRIPT); for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node); return node; } private void parseDirectives(Node node) { Set<String> directives = null;"
      },
      {
        "txt": "while (isDirective(node.getFirstChild())) { String directive = node.removeFirstChild().getFirstChild().getString(); if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive); } } if (directives != null) { node.setDirectives(directives);"
      },
      {
        "txt": "} } private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) && n.getFirstChild().getType() == Token.STRING && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override"
      },
      {
        "txt": "Node processBlock(Block blockNode) { return processGeneric(blockNode); } @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName);"
      },
      {
        "txt": "} return node; } @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\","
      },
      {
        "txt": "sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0); } node.addChildToBack(transformBlock(clauseNode.getBody())); return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK,"
      },
      {
        "txt": "transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME);"
      },
      {
        "txt": "node.addChildToBack(labelName); } return node; } @Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));"
      },
      {
        "txt": "} @Override Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) {"
      },
      {
        "txt": "Node node = newNode(Token.EMPTY); return node; } @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override"
      },
      {
        "txt": "Node processForInLoop(ForInLoop loopNode) { return newNode( Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override Node processForLoop(ForLoop loopNode) { Node node = newNode("
      },
      {
        "txt": "Token.FOR, transform(loopNode.getInitializer()), transform(loopNode.getCondition()), transform(loopNode.getIncrement())); node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()),"
      },
      {
        "txt": "transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) { node.addChildToBack(transform(child)); } int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp(); node.setLineno(callNode.getLineno()); node.setCharno(position2charno(leftParamPos)); return node; } @Override"
      },
      {
        "txt": "Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);"
      },
      {
        "txt": "} name = new Name(); name.setIdentifier(\"\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() +"
      },
      {
        "txt": "functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); } node.addChildToBack(newName); Node lp = newNode(Token.LP); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno());"
      },
      {
        "txt": "} int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode);"
      },
      {
        "txt": "node.addChildToBack(bodyNode); return node; } @Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart()));"
      },
      {
        "txt": "} return node; } @Override Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno());"
      },
      {
        "txt": "n.setCharno(position2charno(exprNode.getAbsolutePosition() + exprNode.getOperatorPosition())); return n; } @Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) {"
      },
      {
        "txt": "return newStringNode(Token.LABEL_NAME, labelNode.getName()); } @Override Node processLabeledStatement(LabeledStatement statementNode) { Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur);"
      },
      {
        "txt": "} cur.addChildToBack(transform(label)); cur.setLineno(label.getLineno()); int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement()));"
      },
      {
        "txt": "return node; } @Override Node processName(Name nameNode) { return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else {"
      },
      {
        "txt": "if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error( \"identifier is a reserved word\", sourceName, nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) {"
      },
      {
        "txt": "return reservedKeywords != null && reservedKeywords.contains(identifier); } @Override Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); }"
      },
      {
        "txt": "@Override Node processObjectLiteral(ObjectLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el);"
      },
      {
        "txt": "continue; } else if (el.isSetter()) { reportSetter(el); continue; } } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GET);"
      },
      {
        "txt": "Preconditions.checkState(value.getType() == Token.FUNCTION); if (getFnParamNode(value).hasChildren()) { reportGetterParam(el.getLeft()); } } else if (el.isSetter()) { key.setType(Token.SET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); }"
      },
      {
        "txt": "} key.addChildToFront(value); node.addChildToBack(key); } return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); }"
      },
      {
        "txt": "@Override Node processObjectProperty(ObjectProperty propertyNode) { return processInfixExpression(propertyNode); } @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; }"
      },
      {
        "txt": "@Override Node processPropertyGet(PropertyGet getNode) { return newNode( Token.GETPROP, transform(getNode.getTarget()), transformAsString(getNode.getProperty())); } @Override Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue());"
      },
      {
        "txt": "literalStringNode.setLineno(literalNode.getLineno()); Node node = newNode(Token.REGEXP, literalStringNode); String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); node.addChildToBack(flagsNode); } return node; }"
      },
      {
        "txt": "@Override Node processReturnStatement(ReturnStatement statementNode) { Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); } return node; } @Override Node processScope(Scope scopeNode) {"
      },
      {
        "txt": "return processGeneric(scopeNode); } @Override Node processStringLiteral(StringLiteral literalNode) { Node n = newStringNode(literalNode.getValue()); return n; } @Override Node processSwitchCase(SwitchCase caseNode) { Node node;"
      },
      {
        "txt": "if (caseNode.isDefault()) { node = newNode(Token.DEFAULT); } else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); } Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition()));"
      },
      {
        "txt": "if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) { block.addChildToBack(transform(child)); } } node.addChildToBack(block); return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.SWITCH, transform(statementNode.getExpression())); for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); } return node; } @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW,"
      },
      {
        "txt": "transform(statementNode.getExpression())); } @Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock())); Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) {"
      },
      {
        "txt": "block.setLineno(cc.getLineno()); lineSet = true; } block.addChildToBack(transform(cc)); } node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); }"
      },
      {
        "txt": "if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno()); } return node; } @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.getType() == Token.NUMBER) {"
      },
      {
        "txt": "operand.setDouble(-operand.getDouble()); return operand; } else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg,"
      },
      {
        "txt": "sourceName, operand.getLineno(), \"\", 0); } } Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; }"
      },
      {
        "txt": "} private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; }"
      },
      {
        "txt": "@Override Node processVariableDeclaration(VariableDeclaration declarationNode) { if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.jscomp.mozilla.rhino.Token.CONST) { processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); }"
      },
      {
        "txt": "return node; } @Override Node processVariableInitializer(VariableInitializer initializerNode) { Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { node.addChildToBack(transform(initializerNode.getInitializer())); node.setLineno(node.getLineno()); } return node;"
      },
      {
        "txt": "} @Override Node processWhileLoop(WhileLoop loopNode) { return newNode( Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) {"
      },
      {
        "txt": "return newNode( Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement())); } @Override Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.jscomp.mozilla.rhino.Token.typeToName("
      },
      {
        "txt": "node.getType()), sourceName, node.getLineno(), \"\", 0); return newNode(Token.EMPTY); } void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} void reportGetter(AstNode node) { errorReporter.error( \"getters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } void reportGetterParam(AstNode node) { errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"setters must have exactly one parameter\", sourceName, node.getLineno(), \"\", 0); } } private static int transformTokenType(int token) { switch (token) { case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR: return Token.ERROR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EOF: return Token.EOF; case com.google.javascript.jscomp.mozilla.rhino.Token.EOL: return Token.EOL; case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH: return Token.ENTERWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH: return Token.LEAVEWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN: return Token.RETURN;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO: return Token.GOTO; case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ: return Token.IFEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE: return Token.IFNE; case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME: return Token.SETNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR: return Token.BITOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR: return Token.BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND: return Token.BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.EQ: return Token.EQ; case com.google.javascript.jscomp.mozilla.rhino.Token.NE: return Token.NE; case com.google.javascript.jscomp.mozilla.rhino.Token.LT: return Token.LT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LE: return Token.LE; case com.google.javascript.jscomp.mozilla.rhino.Token.GT: return Token.GT; case com.google.javascript.jscomp.mozilla.rhino.Token.GE: return Token.GE; case com.google.javascript.jscomp.mozilla.rhino.Token.LSH: return Token.LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.RSH: return Token.RSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.URSH: return Token.URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ADD: return Token.ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.SUB: return Token.SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.MUL: return Token.MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.DIV: return Token.DIV;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.MOD: return Token.MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.NOT: return Token.NOT; case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT: return Token.BITNOT; case com.google.javascript.jscomp.mozilla.rhino.Token.POS: return Token.POS; case com.google.javascript.jscomp.mozilla.rhino.Token.NEG: return Token.NEG;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NEW: return Token.NEW; case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP: return Token.DELPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP: return Token.GETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP: return Token.SETPROP;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM: return Token.GETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM: return Token.SETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.CALL: return Token.CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.NAME: return Token.NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER: return Token.NUMBER;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.STRING: return Token.STRING; case com.google.javascript.jscomp.mozilla.rhino.Token.NULL: return Token.NULL; case com.google.javascript.jscomp.mozilla.rhino.Token.THIS: return Token.THIS; case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE: return Token.FALSE; case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE: return Token.TRUE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ: return Token.SHEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE: return Token.SHNE; case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP: return Token.REGEXP; case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME: return Token.BINDNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.THROW: return Token.THROW;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW: return Token.RETHROW; case com.google.javascript.jscomp.mozilla.rhino.Token.IN: return Token.IN; case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD: return Token.LOCAL_LOAD; case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR: return Token.GETVAR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR: return Token.SETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE: return Token.CATCH_SCOPE; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS: return Token.ENUM_INIT_KEYS; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES: return Token.ENUM_INIT_VALUES; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT: return Token.ENUM_NEXT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID: return Token.ENUM_ID; case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN: return Token.THISFN; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT: return Token.RETURN_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT: return Token.OBJECTLIT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF: return Token.GET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF: return Token.SET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF: return Token.DEL_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL: return Token.REF_CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL: return Token.REF_SPECIAL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE: return Token.DEFAULTNAMESPACE; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT: return Token.ESCXMLTEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR: return Token.ESCXMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER: return Token.REF_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER: return Token.REF_NS_MEMBER;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME: return Token.REF_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME: return Token.REF_NS_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.TRY: return Token.TRY; case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI: return Token.SEMI; case com.google.javascript.jscomp.mozilla.rhino.Token.LB: return Token.LB;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RB: return Token.RB; case com.google.javascript.jscomp.mozilla.rhino.Token.LC: return Token.LC; case com.google.javascript.jscomp.mozilla.rhino.Token.RC: return Token.RC; case com.google.javascript.jscomp.mozilla.rhino.Token.LP: return Token.LP; case com.google.javascript.jscomp.mozilla.rhino.Token.RP: return Token.RP;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA: return Token.COMMA; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH: return Token.ASSIGN_LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH: return Token.ASSIGN_URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB: return Token.ASSIGN_SUB;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL: return Token.ASSIGN_MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD: return Token.ASSIGN_MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK: return Token.HOOK; case com.google.javascript.jscomp.mozilla.rhino.Token.COLON: return Token.COLON;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.OR: return Token.OR; case com.google.javascript.jscomp.mozilla.rhino.Token.AND: return Token.AND; case com.google.javascript.jscomp.mozilla.rhino.Token.INC: return Token.INC; case com.google.javascript.jscomp.mozilla.rhino.Token.DEC: return Token.DEC; case com.google.javascript.jscomp.mozilla.rhino.Token.DOT: return Token.DOT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION: return Token.FUNCTION; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT: return Token.EXPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT: return Token.IMPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IF: return Token.IF; case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE: return Token.ELSE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH: return Token.SWITCH; case com.google.javascript.jscomp.mozilla.rhino.Token.CASE: return Token.CASE; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT: return Token.DEFAULT; case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE: return Token.WHILE; case com.google.javascript.jscomp.mozilla.rhino.Token.DO: return Token.DO;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.FOR: return Token.FOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK: return Token.BREAK; case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE: return Token.CONTINUE; case com.google.javascript.jscomp.mozilla.rhino.Token.VAR: return Token.VAR; case com.google.javascript.jscomp.mozilla.rhino.Token.WITH: return Token.WITH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH: return Token.CATCH; case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY: return Token.FINALLY; case com.google.javascript.jscomp.mozilla.rhino.Token.VOID: return Token.VOID; case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED: return Token.RESERVED; case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY: return Token.EMPTY;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK: return Token.BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL: return Token.LABEL; case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET: return Token.TARGET; case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP: return Token.LOOP; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID: case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:"
      },
      {
        "txt": "return Token.EXPR_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.JSR: return Token.JSR; case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT: return Token.SCRIPT; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME: return Token.TYPEOFNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK: return Token.USE_STACK; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP:"
      },
      {
        "txt": "return Token.SETPROP_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP: return Token.SETELEM_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK: return Token.LOCAL_BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP: return Token.SET_REF_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT: return Token.DOTDOT; case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON:"
      },
      {
        "txt": "return Token.COLONCOLON; case com.google.javascript.jscomp.mozilla.rhino.Token.XML: return Token.XML; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY: return Token.DOTQUERY; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR: return Token.XMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND: return Token.XMLEND; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT:"
      },
      {
        "txt": "return Token.TO_OBJECT; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE: return Token.TO_DOUBLE; case com.google.javascript.jscomp.mozilla.rhino.Token.GET: return Token.GET; case com.google.javascript.jscomp.mozilla.rhino.Token.SET: return Token.SET; case com.google.javascript.jscomp.mozilla.rhino.Token.CONST: return Token.CONST; case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST:"
      },
      {
        "txt": "return Token.SETCONST; case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER: return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token)); } private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) {"
      },
      {
        "txt": "return new Node(type, child1).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2, Node child3) { return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return Node.newString(value).clonePropsFrom(templateNode);"
      },
      {
        "txt": "} private Node newStringNode(int type, String value) { return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) { return Node.newNumber(value).clonePropsFrom(templateNode); }"
      }
    ]
  },
  {
    "id": 730,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 349,
    "end-bug-line": 351,
    "bug": "Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) {",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment; import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode; import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.Block; import com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet; import com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode; import com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Label; import com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Name;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty; import com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet; import com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Scope; import com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer; import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement; import com.google.javascript.jscomp.parsing.Config.LanguageMode;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Set; public class IRFactory { private final String sourceString; private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher;"
      },
      {
        "txt": "private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\"); private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords;"
      },
      {
        "txt": "Node rootNodeJsDocHolder = new Node(Token.SCRIPT); Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString, String sourceName, Config config, ErrorReporter errorReporter) { this.sourceString = sourceString;"
      },
      {
        "txt": "this.sourceName = sourceName; this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null; break; case ECMASCRIPT5:"
      },
      {
        "txt": "reservedKeywords = ES5_RESERVED_KEYWORDS; break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default: throw new IllegalStateException(\"unknown language mode\"); } } private Node createTemplateNode() {"
      },
      {
        "txt": "Node templateNode = new Node(Token.SCRIPT); templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } public static Node transformTree(AstRoot node, String sourceString, Config config, ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(), config, errorReporter);"
      },
      {
        "txt": "Node irNode = irFactory.transform(node); if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == JSDOC && !comment.isParsed()) { irFactory.handlePossibleFileOverviewJsDoc(comment); } } } irFactory.setFileOverviewJsDoc(irNode); return irNode;"
      },
      {
        "txt": "} private void setFileOverviewJsDoc(Node irNode) { irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo()); if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); }"
      },
      {
        "txt": "} private Node transformBlock(AstNode node) { Node irNode = transform(node); if (irNode.getType() != Token.BLOCK) { if (irNode.getType() == Token.EMPTY) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode); newBlock.setLineno(irNode.getLineno());"
      },
      {
        "txt": "newBlock.setCharno(irNode.getCharno()); irNode = newBlock; } } return irNode; } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) { if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();"
      },
      {
        "txt": "return true; } return false; } private void handlePossibleFileOverviewJsDoc(Comment comment) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); handlePossibleFileOverviewJsDoc(jsDocParser); } private JSDocInfo handleJsDoc(AstNode node) {"
      },
      {
        "txt": "Comment comment = node.getJsDocNode(); if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } } return null; }"
      },
      {
        "txt": "private Node transform(AstNode node) { JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = justTransform(node); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } private Node transformNameAsString(Name node) {"
      },
      {
        "txt": "JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = transformDispatcher.processName(node, true); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getType() == Token.FUNCTION &&"
      },
      {
        "txt": "irNode.getFirstChild().getLineno() != -1) { irNode.setLineno(irNode.getFirstChild().getLineno()); irNode.setCharno(irNode.getFirstChild().getCharno()); } else { if (irNode.getLineno() == -1) { int lineno = node.getLineno(); irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); }"
      },
      {
        "txt": "} } private JsDocInfoParser createJsDocInfoParser(Comment node) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition(); int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars),"
      },
      {
        "txt": "lineno, position2charno(position) + numOpeningChars), node, sourceName, config, errorReporter); jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser;"
      },
      {
        "txt": "} private int position2charno(int position) { int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else { return position - lineIndex - 1; } } private Node justTransform(AstNode node) {"
      },
      {
        "txt": "return transformDispatcher.process(node); } private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.jscomp.mozilla.rhino.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node;"
      },
      {
        "txt": "private Node transformAsString(AstNode n) { Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else { ret = transform(n); <extra_id_0> ret.putBooleanProp(Node.QUOTED_PROP, true); } } return ret; } @Override"
      },
      {
        "txt": "} @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT); for (AstNode child : literalNode.getElements()) { Node c = transform(child); node.addChildToBack(c);"
      },
      {
        "txt": "} return node; } @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( \"invalid assignment target\","
      },
      {
        "txt": "sourceName, target.getLineno(), \"\", 0); } return assign; } @Override Node processAstRoot(AstRoot rootNode) { Node node = newNode(Token.SCRIPT); for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) { node.addChildToBack(transform((AstNode)child));"
      },
      {
        "txt": "} parseDirectives(node); return node; } private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) { String directive = node.removeFirstChild().getFirstChild().getString(); if (directives == null) { directives = Sets.newHashSet(directive);"
      },
      {
        "txt": "} else { directives.add(directive); } } if (directives != null) { node.setDirectives(directives); } } private boolean isDirective(Node n) { if (n == null) return false;"
      },
      {
        "txt": "int nType = n.getType(); return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) && n.getFirstChild().getType() == Token.STRING && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override Node processBlock(Block blockNode) { return processGeneric(blockNode); } @Override"
      },
      {
        "txt": "Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node; } @Override"
      },
      {
        "txt": "Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0); } node.addChildToBack(transformBlock(clauseNode.getBody()));"
      },
      {
        "txt": "return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression())); }"
      },
      {
        "txt": "@Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node; }"
      },
      {
        "txt": "@Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); } @Override Node processElementGet(ElementGet getNode) { return newNode("
      },
      {
        "txt": "Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY); return node; } @Override"
      },
      {
        "txt": "Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override Node processForInLoop(ForInLoop loopNode) { return newNode( Token.FOR, transform(loopNode.getIterator()),"
      },
      {
        "txt": "transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()), transform(loopNode.getCondition()), transform(loopNode.getIncrement()));"
      },
      {
        "txt": "node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) { node.addChildToBack(transform(child)); }"
      },
      {
        "txt": "int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp(); node.setLineno(callNode.getLineno()); node.setCharno(position2charno(leftParamPos)); return node; } @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) {"
      },
      {
        "txt": "int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); } name = new Name(); name.setIdentifier(\"\"); isUnnamedFunction = true;"
      },
      {
        "txt": "} Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); } node.addChildToBack(newName);"
      },
      {
        "txt": "Node lp = newNode(Token.LP); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno));"
      },
      {
        "txt": "for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node; } @Override"
      },
      {
        "txt": "Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node; } @Override"
      },
      {
        "txt": "Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition() + exprNode.getOperatorPosition())); return n; }"
      },
      {
        "txt": "@Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); } @Override Node processLabeledStatement(LabeledStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label)); cur.setLineno(label.getLineno()); int clauseAbsolutePosition ="
      },
      {
        "txt": "position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement())); return node; } @Override Node processName(Name nameNode) {"
      },
      {
        "txt": "return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error( \"identifier is a reserved word\", sourceName,"
      },
      {
        "txt": "nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); } @Override Node processNewExpression(NewExpression exprNode) {"
      },
      {
        "txt": "return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode);"
      },
      {
        "txt": "} Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) { reportSetter(el); continue;"
      },
      {
        "txt": "} } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (getFnParamNode(value).hasChildren()) { reportGetterParam(el.getLeft()); }"
      },
      {
        "txt": "} else if (el.isSetter()) { key.setType(Token.SET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); } } key.addChildToFront(value); node.addChildToBack(key); }"
      },
      {
        "txt": "return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) { return processInfixExpression(propertyNode); }"
      },
      {
        "txt": "@Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; } @Override Node processPropertyGet(PropertyGet getNode) { return newNode( Token.GETPROP,"
      },
      {
        "txt": "transform(getNode.getTarget()), transformAsString(getNode.getProperty())); } @Override Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue()); literalStringNode.setLineno(literalNode.getLineno()); Node node = newNode(Token.REGEXP, literalStringNode); String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) {"
      },
      {
        "txt": "Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); node.addChildToBack(flagsNode); } return node; } @Override Node processReturnStatement(ReturnStatement statementNode) { Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) {"
      },
      {
        "txt": "node.addChildToBack(transform(statementNode.getReturnValue())); } return node; } @Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); } @Override Node processStringLiteral(StringLiteral literalNode) {"
      },
      {
        "txt": "Node n = newStringNode(literalNode.getValue()); return n; } @Override Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT); } else { AstNode expr = caseNode.getExpression();"
      },
      {
        "txt": "node = newNode(Token.CASE, transform(expr)); } Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) { block.addChildToBack(transform(child)); }"
      },
      {
        "txt": "} node.addChildToBack(block); return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression())); for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child));"
      },
      {
        "txt": "} return node; } @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); } @Override Node processTryStatement(TryStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock())); Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); lineSet = true; } block.addChildToBack(transform(cc));"
      },
      {
        "txt": "} node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno()); } return node;"
      },
      {
        "txt": "} @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.getType() == Token.NUMBER) { operand.setDouble(-operand.getDouble()); return operand; } else { if (type == Token.INC || type == Token.DEC) {"
      },
      {
        "txt": "if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0); } }"
      },
      {
        "txt": "Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; } } private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME:"
      },
      {
        "txt": "case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) { if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.jscomp.mozilla.rhino.Token.CONST) {"
      },
      {
        "txt": "processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); } return node; } @Override Node processVariableInitializer(VariableInitializer initializerNode) {"
      },
      {
        "txt": "Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { node.addChildToBack(transform(initializerNode.getInitializer())); node.setLineno(node.getLineno()); } return node; } @Override Node processWhileLoop(WhileLoop loopNode) { return newNode("
      },
      {
        "txt": "Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement()));"
      },
      {
        "txt": "} @Override Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.jscomp.mozilla.rhino.Token.typeToName( node.getType()), sourceName, node.getLineno(), \"\", 0); return newNode(Token.EMPTY);"
      },
      {
        "txt": "} void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) { errorReporter.error( \"getters are not supported in Internet Explorer\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportGetterParam(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} } private static int transformTokenType(int token) { switch (token) { case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR: return Token.ERROR; case com.google.javascript.jscomp.mozilla.rhino.Token.EOF: return Token.EOF; case com.google.javascript.jscomp.mozilla.rhino.Token.EOL: return Token.EOL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH: return Token.ENTERWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH: return Token.LEAVEWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN: return Token.RETURN; case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO: return Token.GOTO; case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ: return Token.IFEQ;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE: return Token.IFNE; case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME: return Token.SETNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR: return Token.BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR: return Token.BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND: return Token.BITAND;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EQ: return Token.EQ; case com.google.javascript.jscomp.mozilla.rhino.Token.NE: return Token.NE; case com.google.javascript.jscomp.mozilla.rhino.Token.LT: return Token.LT; case com.google.javascript.jscomp.mozilla.rhino.Token.LE: return Token.LE; case com.google.javascript.jscomp.mozilla.rhino.Token.GT: return Token.GT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GE: return Token.GE; case com.google.javascript.jscomp.mozilla.rhino.Token.LSH: return Token.LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.RSH: return Token.RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.URSH: return Token.URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ADD: return Token.ADD;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SUB: return Token.SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.MUL: return Token.MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.DIV: return Token.DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.MOD: return Token.MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.NOT: return Token.NOT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT: return Token.BITNOT; case com.google.javascript.jscomp.mozilla.rhino.Token.POS: return Token.POS; case com.google.javascript.jscomp.mozilla.rhino.Token.NEG: return Token.NEG; case com.google.javascript.jscomp.mozilla.rhino.Token.NEW: return Token.NEW; case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP: return Token.DELPROP;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP: return Token.GETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP: return Token.SETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM: return Token.GETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM: return Token.SETELEM;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CALL: return Token.CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.NAME: return Token.NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER: return Token.NUMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.STRING: return Token.STRING; case com.google.javascript.jscomp.mozilla.rhino.Token.NULL: return Token.NULL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.THIS: return Token.THIS; case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE: return Token.FALSE; case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE: return Token.TRUE; case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ: return Token.SHEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE: return Token.SHNE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP: return Token.REGEXP; case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME: return Token.BINDNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.THROW: return Token.THROW; case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW: return Token.RETHROW; case com.google.javascript.jscomp.mozilla.rhino.Token.IN: return Token.IN;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD: return Token.LOCAL_LOAD; case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR: return Token.GETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR: return Token.SETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE: return Token.CATCH_SCOPE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS: return Token.ENUM_INIT_KEYS; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES: return Token.ENUM_INIT_VALUES; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT: return Token.ENUM_NEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID: return Token.ENUM_ID; case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN: return Token.THISFN;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT: return Token.RETURN_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT: return Token.OBJECTLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF: return Token.GET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF: return Token.SET_REF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF: return Token.DEL_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL: return Token.REF_CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL: return Token.REF_SPECIAL; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE: return Token.DEFAULTNAMESPACE; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT: return Token.ESCXMLTEXT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR: return Token.ESCXMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER: return Token.REF_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER: return Token.REF_NS_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME: return Token.REF_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME: return Token.REF_NS_NAME;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.TRY: return Token.TRY; case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI: return Token.SEMI; case com.google.javascript.jscomp.mozilla.rhino.Token.LB: return Token.LB; case com.google.javascript.jscomp.mozilla.rhino.Token.RB: return Token.RB; case com.google.javascript.jscomp.mozilla.rhino.Token.LC: return Token.LC;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RC: return Token.RC; case com.google.javascript.jscomp.mozilla.rhino.Token.LP: return Token.LP; case com.google.javascript.jscomp.mozilla.rhino.Token.RP: return Token.RP; case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA: return Token.COMMA; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN: return Token.ASSIGN;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH: return Token.ASSIGN_LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH: return Token.ASSIGN_RSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH: return Token.ASSIGN_URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL: return Token.ASSIGN_MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV: return Token.ASSIGN_DIV;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD: return Token.ASSIGN_MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK: return Token.HOOK; case com.google.javascript.jscomp.mozilla.rhino.Token.COLON: return Token.COLON; case com.google.javascript.jscomp.mozilla.rhino.Token.OR: return Token.OR; case com.google.javascript.jscomp.mozilla.rhino.Token.AND: return Token.AND;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.INC: return Token.INC; case com.google.javascript.jscomp.mozilla.rhino.Token.DEC: return Token.DEC; case com.google.javascript.jscomp.mozilla.rhino.Token.DOT: return Token.DOT; case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION: return Token.FUNCTION; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT: return Token.EXPORT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT: return Token.IMPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IF: return Token.IF; case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE: return Token.ELSE; case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH: return Token.SWITCH; case com.google.javascript.jscomp.mozilla.rhino.Token.CASE: return Token.CASE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT: return Token.DEFAULT; case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE: return Token.WHILE; case com.google.javascript.jscomp.mozilla.rhino.Token.DO: return Token.DO; case com.google.javascript.jscomp.mozilla.rhino.Token.FOR: return Token.FOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK: return Token.BREAK;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE: return Token.CONTINUE; case com.google.javascript.jscomp.mozilla.rhino.Token.VAR: return Token.VAR; case com.google.javascript.jscomp.mozilla.rhino.Token.WITH: return Token.WITH; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH: return Token.CATCH; case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY: return Token.FINALLY;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.VOID: return Token.VOID; case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED: return Token.RESERVED; case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY: return Token.EMPTY; case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK: return Token.BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL: return Token.LABEL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET: return Token.TARGET; case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP: return Token.LOOP; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID: case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.JSR: return Token.JSR; case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:"
      },
      {
        "txt": "return Token.SCRIPT; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME: return Token.TYPEOFNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK: return Token.USE_STACK; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP: return Token.SETPROP_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP: return Token.SETELEM_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK:"
      },
      {
        "txt": "return Token.LOCAL_BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP: return Token.SET_REF_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT: return Token.DOTDOT; case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON: return Token.COLONCOLON; case com.google.javascript.jscomp.mozilla.rhino.Token.XML: return Token.XML; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY:"
      },
      {
        "txt": "return Token.DOTQUERY; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR: return Token.XMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND: return Token.XMLEND; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT: return Token.TO_OBJECT; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE: return Token.TO_DOUBLE; case com.google.javascript.jscomp.mozilla.rhino.Token.GET:"
      },
      {
        "txt": "return Token.GET; case com.google.javascript.jscomp.mozilla.rhino.Token.SET: return Token.SET; case com.google.javascript.jscomp.mozilla.rhino.Token.CONST: return Token.CONST; case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST: return Token.SETCONST; case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER: return Token.DEBUGGER; }"
      },
      {
        "txt": "throw new IllegalStateException(String.valueOf(token)); } private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode);"
      },
      {
        "txt": "} private Node newNode(int type, Node child1, Node child2, Node child3) { return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return Node.newString(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) { return Node.newString(type, value).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newNumberNode(Double value) { return Node.newNumber(value).clonePropsFrom(templateNode); }"
      }
    ]
  },
  {
    "id": 731,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 353,
    "end-bug-line": 353,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment; import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode; import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot; import com.google.javascript.jscomp.mozilla.rhino.ast.Block; import com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet; import com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Label; import com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Name; import com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet; import com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Scope; import com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer; import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Set;"
      },
      {
        "txt": "public class IRFactory { private final String sourceString; private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher; private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\"); private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\");"
      },
      {
        "txt": "private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords; Node rootNodeJsDocHolder = new Node(Token.SCRIPT); Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null;"
      },
      {
        "txt": "private Node templateNode; private IRFactory(String sourceString, String sourceName, Config config, ErrorReporter errorReporter) { this.sourceString = sourceString; this.sourceName = sourceName; this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher();"
      },
      {
        "txt": "this.templateNode = createTemplateNode(); switch (config.languageMode) { case ECMASCRIPT3: reservedKeywords = null; break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS; break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS;"
      },
      {
        "txt": "break; default: throw new IllegalStateException(\"unknown language mode\"); } } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; }"
      },
      {
        "txt": "public static Node transformTree(AstRoot node, String sourceString, Config config, ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(), config, errorReporter); Node irNode = irFactory.transform(node); if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == JSDOC && !comment.isParsed()) {"
      },
      {
        "txt": "irFactory.handlePossibleFileOverviewJsDoc(comment); } } } irFactory.setFileOverviewJsDoc(irNode); return irNode; } private void setFileOverviewJsDoc(Node irNode) { irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo()); if (fileOverviewInfo != null) {"
      },
      {
        "txt": "if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); } } private Node transformBlock(AstNode node) { Node irNode = transform(node); if (irNode.getType() != Token.BLOCK) {"
      },
      {
        "txt": "if (irNode.getType() == Token.EMPTY) { irNode.setType(Token.BLOCK); irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode); newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno()); irNode = newBlock; } }"
      },
      {
        "txt": "return irNode; } private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) { if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true; } return false; }"
      },
      {
        "txt": "private void handlePossibleFileOverviewJsDoc(Comment comment) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); handlePossibleFileOverviewJsDoc(jsDocParser); } private JSDocInfo handleJsDoc(AstNode node) { Comment comment = node.getJsDocNode(); if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true);"
      },
      {
        "txt": "if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo(); } } return null; } private Node transform(AstNode node) { JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = justTransform(node); if (jsDocInfo != null) {"
      },
      {
        "txt": "irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node); return irNode; } private Node transformNameAsString(Name node) { JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = transformDispatcher.processName(node, true); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo);"
      },
      {
        "txt": "} setSourceInfo(irNode, node); return irNode; } private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getType() == Token.FUNCTION && irNode.getFirstChild().getLineno() != -1) { irNode.setLineno(irNode.getFirstChild().getLineno()); irNode.setCharno(irNode.getFirstChild().getCharno()); } else {"
      },
      {
        "txt": "if (irNode.getLineno() == -1) { int lineno = node.getLineno(); irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); } } } private JsDocInfoParser createJsDocInfoParser(Comment node) { String comment = node.getValue();"
      },
      {
        "txt": "int lineno = node.getLineno(); int position = node.getAbsolutePosition(); int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars), node, sourceName,"
      },
      {
        "txt": "config, errorReporter); jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser; } private int position2charno(int position) { int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) {"
      },
      {
        "txt": "return position; } else { return position - lineIndex - 1; } } private Node justTransform(AstNode node) { return transformDispatcher.process(node); } private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric("
      },
      {
        "txt": "com.google.javascript.jscomp.mozilla.rhino.Node n) { Node node = newNode(transformTokenType(n.getType())); for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node; } private Node transformAsString(AstNode n) { Node ret; if (n instanceof Name) {"
      },
      {
        "txt": "} else { ret = transform(n); Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); <extra_id_0> } return ret; } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) {"
      },
      {
        "txt": "Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT); for (AstNode child : literalNode.getElements()) { Node c = transform(child); node.addChildToBack(c); } return node;"
      },
      {
        "txt": "} @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0);"
      },
      {
        "txt": "} return assign; } @Override Node processAstRoot(AstRoot rootNode) { Node node = newNode(Token.SCRIPT); for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node);"
      },
      {
        "txt": "return node; } private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) { String directive = node.removeFirstChild().getFirstChild().getString(); if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive);"
      },
      {
        "txt": "} } if (directives != null) { node.setDirectives(directives); } } private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&"
      },
      {
        "txt": "n.getFirstChild().getType() == Token.STRING && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); } @Override Node processBlock(Block blockNode) { return processGeneric(blockNode); } @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK);"
      },
      {
        "txt": "if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node; } @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName();"
      },
      {
        "txt": "Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) { errorReporter.error( \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0); } node.addChildToBack(transformBlock(clauseNode.getBody())); return node; }"
      },
      {
        "txt": "@Override Node processConditionalExpression(ConditionalExpression exprNode) { return newNode( Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) {"
      },
      {
        "txt": "Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) { Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node; } @Override Node processDoLoop(DoLoop loopNode) {"
      },
      {
        "txt": "return newNode( Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); } @Override Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()),"
      },
      {
        "txt": "transform(getNode.getElement())); } @Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY); return node; } @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType()));"
      },
      {
        "txt": "node.addChildToBack(transform(statementNode.getExpression())); return node; } @Override Node processForInLoop(ForInLoop loopNode) { return newNode( Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));"
      },
      {
        "txt": "} @Override Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()), transform(loopNode.getCondition()), transform(loopNode.getIncrement())); node.addChildToBack(transformBlock(loopNode.getBody())); return node;"
      },
      {
        "txt": "} @Override Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) { node.addChildToBack(transform(child)); } int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp(); node.setLineno(callNode.getLineno());"
      },
      {
        "txt": "node.setCharno(position2charno(leftParamPos)); return node; } @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) {"
      },
      {
        "txt": "errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); } name = new Name(); name.setIdentifier(\"\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION);"
      },
      {
        "txt": "Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); } node.addChildToBack(newName); Node lp = newNode(Token.LP); Name fnName = functionNode.getFunctionName();"
      },
      {
        "txt": "if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param));"
      },
      {
        "txt": "} node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node; } @Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF);"
      },
      {
        "txt": "node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart())); if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node; } @Override Node processInfixExpression(InfixExpression exprNode) { Node n = newNode("
      },
      {
        "txt": "transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition() + exprNode.getOperatorPosition())); return n; } @Override Node processKeywordLiteral(KeywordLiteral literalNode) {"
      },
      {
        "txt": "return newNode(transformTokenType(literalNode.getType())); } @Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); } @Override Node processLabeledStatement(LabeledStatement statementNode) { Node node = newNode(Token.LABEL); Node prev = null;"
      },
      {
        "txt": "Node cur = node; for (Label label : statementNode.getLabels()) { if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label)); cur.setLineno(label.getLineno()); int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition);"
      },
      {
        "txt": "prev = cur; cur = newNode(Token.LABEL); } prev.addChildToBack(transform(statementNode.getStatement())); return node; } @Override Node processName(Name nameNode) { return processName(nameNode, false); }"
      },
      {
        "txt": "Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error( \"identifier is a reserved word\", sourceName, nameNode.getLineno(), \"\", 0); }"
      },
      {
        "txt": "return newStringNode(Token.NAME, nameNode.getIdentifier()); } } private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); } @Override Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); }"
      },
      {
        "txt": "@Override Node processNumberLiteral(NumberLiteral literalNode) { return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT);"
      },
      {
        "txt": "for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) { if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) { reportSetter(el); continue; } }"
      },
      {
        "txt": "Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight()); if (el.isGetter()) { key.setType(Token.GET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (getFnParamNode(value).hasChildren()) { reportGetterParam(el.getLeft()); } } else if (el.isSetter()) { key.setType(Token.SET);"
      },
      {
        "txt": "Preconditions.checkState(value.getType() == Token.FUNCTION); if (!getFnParamNode(value).hasOneChild()) { reportSetterParam(el.getLeft()); } } key.addChildToFront(value); node.addChildToBack(key); } return node; }"
      },
      {
        "txt": "Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) { return processInfixExpression(propertyNode); } @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) {"
      },
      {
        "txt": "Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return node; } @Override Node processPropertyGet(PropertyGet getNode) { return newNode( Token.GETPROP, transform(getNode.getTarget()), transformAsString(getNode.getProperty()));"
      },
      {
        "txt": "} @Override Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue()); literalStringNode.setLineno(literalNode.getLineno()); Node node = newNode(Token.REGEXP, literalStringNode); String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno());"
      },
      {
        "txt": "node.addChildToBack(flagsNode); } return node; } @Override Node processReturnStatement(ReturnStatement statementNode) { Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); }"
      },
      {
        "txt": "return node; } @Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); } @Override Node processStringLiteral(StringLiteral literalNode) { Node n = newStringNode(literalNode.getValue()); return n;"
      },
      {
        "txt": "} @Override Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT); } else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); }"
      },
      {
        "txt": "Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) { block.addChildToBack(transform(child)); } } node.addChildToBack(block);"
      },
      {
        "txt": "return node; } @Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression())); for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); } return node;"
      },
      {
        "txt": "} @Override Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); } @Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));"
      },
      {
        "txt": "Node block = newNode(Token.BLOCK); boolean lineSet = false; for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); lineSet = true; } block.addChildToBack(transform(cc)); } node.addChildToBack(block);"
      },
      {
        "txt": "AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) { node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno()); } return node; } @Override"
      },
      {
        "txt": "Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType()); Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.getType() == Token.NUMBER) { operand.setDouble(-operand.getDouble()); return operand; } else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC)"
      },
      {
        "txt": "? \"invalid increment target\" : \"invalid decrement target\"; errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0); } } Node node = newNode(type, operand); if (exprNode.isPostfix()) {"
      },
      {
        "txt": "node.putBooleanProp(Node.INCRDECR_PROP, true); } return node; } } private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM:"
      },
      {
        "txt": "return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) { if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.jscomp.mozilla.rhino.Token.CONST) { processIllegalToken(declarationNode); }"
      },
      {
        "txt": "Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) { node.addChildToBack(transform(child)); } return node; } @Override Node processVariableInitializer(VariableInitializer initializerNode) { Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) {"
      },
      {
        "txt": "node.addChildToBack(transform(initializerNode.getInitializer())); node.setLineno(node.getLineno()); } return node; } @Override Node processWhileLoop(WhileLoop loopNode) { return newNode( Token.WHILE, transform(loopNode.getCondition()),"
      },
      {
        "txt": "transformBlock(loopNode.getBody())); } @Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement())); } @Override"
      },
      {
        "txt": "Node processIllegalToken(AstNode node) { errorReporter.error( \"Unsupported syntax: \" + com.google.javascript.jscomp.mozilla.rhino.Token.typeToName( node.getType()), sourceName, node.getLineno(), \"\", 0); return newNode(Token.EMPTY); } void reportDestructuringAssign(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"destructuring assignment forbidden\", sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) { errorReporter.error( \"getters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} void reportSetter(AstNode node) { errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportGetterParam(AstNode node) { errorReporter.error( \"getters may not have parameters\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\", sourceName, node.getLineno(), \"\", 0); } }"
      },
      {
        "txt": "private static int transformTokenType(int token) { switch (token) { case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR: return Token.ERROR; case com.google.javascript.jscomp.mozilla.rhino.Token.EOF: return Token.EOF; case com.google.javascript.jscomp.mozilla.rhino.Token.EOL: return Token.EOL; case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH: return Token.ENTERWITH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH: return Token.LEAVEWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN: return Token.RETURN; case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO: return Token.GOTO; case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ: return Token.IFEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE: return Token.IFNE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME: return Token.SETNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR: return Token.BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR: return Token.BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND: return Token.BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.EQ: return Token.EQ;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NE: return Token.NE; case com.google.javascript.jscomp.mozilla.rhino.Token.LT: return Token.LT; case com.google.javascript.jscomp.mozilla.rhino.Token.LE: return Token.LE; case com.google.javascript.jscomp.mozilla.rhino.Token.GT: return Token.GT; case com.google.javascript.jscomp.mozilla.rhino.Token.GE: return Token.GE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LSH: return Token.LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.RSH: return Token.RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.URSH: return Token.URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ADD: return Token.ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.SUB: return Token.SUB;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.MUL: return Token.MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.DIV: return Token.DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.MOD: return Token.MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.NOT: return Token.NOT; case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT: return Token.BITNOT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.POS: return Token.POS; case com.google.javascript.jscomp.mozilla.rhino.Token.NEG: return Token.NEG; case com.google.javascript.jscomp.mozilla.rhino.Token.NEW: return Token.NEW; case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP: return Token.DELPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF: return Token.TYPEOF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP: return Token.GETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP: return Token.SETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM: return Token.GETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM: return Token.SETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.CALL: return Token.CALL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NAME: return Token.NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER: return Token.NUMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.STRING: return Token.STRING; case com.google.javascript.jscomp.mozilla.rhino.Token.NULL: return Token.NULL; case com.google.javascript.jscomp.mozilla.rhino.Token.THIS: return Token.THIS;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE: return Token.FALSE; case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE: return Token.TRUE; case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ: return Token.SHEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE: return Token.SHNE; case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP: return Token.REGEXP;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME: return Token.BINDNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.THROW: return Token.THROW; case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW: return Token.RETHROW; case com.google.javascript.jscomp.mozilla.rhino.Token.IN: return Token.IN; case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF: return Token.INSTANCEOF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD: return Token.LOCAL_LOAD; case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR: return Token.GETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR: return Token.SETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE: return Token.CATCH_SCOPE; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS: return Token.ENUM_INIT_KEYS;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES: return Token.ENUM_INIT_VALUES; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT: return Token.ENUM_NEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID: return Token.ENUM_ID; case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN: return Token.THISFN; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT: return Token.RETURN_RESULT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT: return Token.ARRAYLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT: return Token.OBJECTLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF: return Token.GET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF: return Token.SET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF: return Token.DEL_REF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL: return Token.REF_CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL: return Token.REF_SPECIAL; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE: return Token.DEFAULTNAMESPACE; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT: return Token.ESCXMLTEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR: return Token.ESCXMLATTR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER: return Token.REF_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER: return Token.REF_NS_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME: return Token.REF_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME: return Token.REF_NS_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.TRY: return Token.TRY;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI: return Token.SEMI; case com.google.javascript.jscomp.mozilla.rhino.Token.LB: return Token.LB; case com.google.javascript.jscomp.mozilla.rhino.Token.RB: return Token.RB; case com.google.javascript.jscomp.mozilla.rhino.Token.LC: return Token.LC; case com.google.javascript.jscomp.mozilla.rhino.Token.RC: return Token.RC;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LP: return Token.LP; case com.google.javascript.jscomp.mozilla.rhino.Token.RP: return Token.RP; case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA: return Token.COMMA; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH: return Token.ASSIGN_LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH: return Token.ASSIGN_URSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD: return Token.ASSIGN_ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL: return Token.ASSIGN_MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD: return Token.ASSIGN_MOD;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK: return Token.HOOK; case com.google.javascript.jscomp.mozilla.rhino.Token.COLON: return Token.COLON; case com.google.javascript.jscomp.mozilla.rhino.Token.OR: return Token.OR; case com.google.javascript.jscomp.mozilla.rhino.Token.AND: return Token.AND; case com.google.javascript.jscomp.mozilla.rhino.Token.INC: return Token.INC;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DEC: return Token.DEC; case com.google.javascript.jscomp.mozilla.rhino.Token.DOT: return Token.DOT; case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION: return Token.FUNCTION; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT: return Token.EXPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT: return Token.IMPORT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.IF: return Token.IF; case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE: return Token.ELSE; case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH: return Token.SWITCH; case com.google.javascript.jscomp.mozilla.rhino.Token.CASE: return Token.CASE; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT: return Token.DEFAULT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE: return Token.WHILE; case com.google.javascript.jscomp.mozilla.rhino.Token.DO: return Token.DO; case com.google.javascript.jscomp.mozilla.rhino.Token.FOR: return Token.FOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK: return Token.BREAK; case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE: return Token.CONTINUE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.VAR: return Token.VAR; case com.google.javascript.jscomp.mozilla.rhino.Token.WITH: return Token.WITH; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH: return Token.CATCH; case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY: return Token.FINALLY; case com.google.javascript.jscomp.mozilla.rhino.Token.VOID: return Token.VOID;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED: return Token.RESERVED; case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY: return Token.EMPTY; case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK: return Token.BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL: return Token.LABEL; case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET: return Token.TARGET;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP: return Token.LOOP; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID: case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.JSR: return Token.JSR; case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT: return Token.SCRIPT; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME:"
      },
      {
        "txt": "return Token.TYPEOFNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK: return Token.USE_STACK; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP: return Token.SETPROP_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP: return Token.SETELEM_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK: return Token.LOCAL_BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP:"
      },
      {
        "txt": "return Token.SET_REF_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT: return Token.DOTDOT; case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON: return Token.COLONCOLON; case com.google.javascript.jscomp.mozilla.rhino.Token.XML: return Token.XML; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY: return Token.DOTQUERY; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR:"
      },
      {
        "txt": "return Token.XMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND: return Token.XMLEND; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT: return Token.TO_OBJECT; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE: return Token.TO_DOUBLE; case com.google.javascript.jscomp.mozilla.rhino.Token.GET: return Token.GET; case com.google.javascript.jscomp.mozilla.rhino.Token.SET:"
      },
      {
        "txt": "return Token.SET; case com.google.javascript.jscomp.mozilla.rhino.Token.CONST: return Token.CONST; case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST: return Token.SETCONST; case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER: return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token)); }"
      },
      {
        "txt": "private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2, Node child3) {"
      },
      {
        "txt": "return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); } private Node newStringNode(String value) { return Node.newString(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) { return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) { return Node.newNumber(value).clonePropsFrom(templateNode);"
      }
    ]
  },
  {
    "id": 732,
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
    "start-bug-line": 355,
    "end-bug-line": 355,
    "bug": "",
    "fix": "Preconditions.checkState(ret.getType() == Token.STRING);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment; import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode; import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot; import com.google.javascript.jscomp.mozilla.rhino.ast.Block; import com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause; import com.google.javascript.jscomp.mozilla.rhino.ast.Comment; import com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet; import com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall; import com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode; import com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.Label; import com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Name; import com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty; import com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.Scope; import com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase; import com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement; import com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression; import com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration;"
      },
      {
        "txt": "import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer; import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop; import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Set; public class IRFactory { private final String sourceString;"
      },
      {
        "txt": "private final String sourceName; private final Config config; private final ErrorReporter errorReporter; private final TransformDispatcher transformDispatcher; private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\"); private static final Set<String> ES5_RESERVED_KEYWORDS = ImmutableSet.of( \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\"); private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS = ImmutableSet.of("
      },
      {
        "txt": "\"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"); private final Set<String> reservedKeywords; Node rootNodeJsDocHolder = new Node(Token.SCRIPT); Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = rootNodeJsDocHolder.getJsDocBuilderForNode(); JSDocInfo fileOverviewInfo = null; private Node templateNode; private IRFactory(String sourceString,"
      },
      {
        "txt": "String sourceName, Config config, ErrorReporter errorReporter) { this.sourceString = sourceString; this.sourceName = sourceName; this.config = config; this.errorReporter = errorReporter; this.transformDispatcher = new TransformDispatcher(); this.templateNode = createTemplateNode(); switch (config.languageMode) {"
      },
      {
        "txt": "case ECMASCRIPT3: reservedKeywords = null; break; case ECMASCRIPT5: reservedKeywords = ES5_RESERVED_KEYWORDS; break; case ECMASCRIPT5_STRICT: reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; break; default:"
      },
      {
        "txt": "throw new IllegalStateException(\"unknown language mode\"); } } private Node createTemplateNode() { Node templateNode = new Node(Token.SCRIPT); templateNode.putProp(Node.SOURCENAME_PROP, sourceName); return templateNode; } public static Node transformTree(AstRoot node, String sourceString,"
      },
      {
        "txt": "Config config, ErrorReporter errorReporter) { IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(), config, errorReporter); Node irNode = irFactory.transform(node); if (node.getComments() != null) { for (Comment comment : node.getComments()) { if (comment.getCommentType() == JSDOC && !comment.isParsed()) { irFactory.handlePossibleFileOverviewJsDoc(comment); }"
      },
      {
        "txt": "} } irFactory.setFileOverviewJsDoc(irNode); return irNode; } private void setFileOverviewJsDoc(Node irNode) { irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo()); if (fileOverviewInfo != null) { if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) {"
      },
      {
        "txt": "fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); } irNode.setJSDocInfo(fileOverviewInfo); } } private Node transformBlock(AstNode node) { Node irNode = transform(node); if (irNode.getType() != Token.BLOCK) { if (irNode.getType() == Token.EMPTY) { irNode.setType(Token.BLOCK);"
      },
      {
        "txt": "irNode.setWasEmptyNode(true); } else { Node newBlock = newNode(Token.BLOCK, irNode); newBlock.setLineno(irNode.getLineno()); newBlock.setCharno(irNode.getCharno()); irNode = newBlock; } } return irNode; }"
      },
      {
        "txt": "private boolean handlePossibleFileOverviewJsDoc( JsDocInfoParser jsDocParser) { if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); return true; } return false; } private void handlePossibleFileOverviewJsDoc(Comment comment) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);"
      },
      {
        "txt": "comment.setParsed(true); handlePossibleFileOverviewJsDoc(jsDocParser); } private JSDocInfo handleJsDoc(AstNode node) { Comment comment = node.getJsDocNode(); if (comment != null) { JsDocInfoParser jsDocParser = createJsDocInfoParser(comment); comment.setParsed(true); if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { return jsDocParser.retrieveAndResetParsedJSDocInfo();"
      },
      {
        "txt": "} } return null; } private Node transform(AstNode node) { JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = justTransform(node); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); }"
      },
      {
        "txt": "setSourceInfo(irNode, node); return irNode; } private Node transformNameAsString(Name node) { JSDocInfo jsDocInfo = handleJsDoc(node); Node irNode = transformDispatcher.processName(node, true); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, node);"
      },
      {
        "txt": "return irNode; } private void setSourceInfo(Node irNode, AstNode node) { if (irNode.getType() == Token.FUNCTION && irNode.getFirstChild().getLineno() != -1) { irNode.setLineno(irNode.getFirstChild().getLineno()); irNode.setCharno(irNode.getFirstChild().getCharno()); } else { if (irNode.getLineno() == -1) { int lineno = node.getLineno();"
      },
      {
        "txt": "irNode.setLineno(lineno); int charno = position2charno(node.getAbsolutePosition()); irNode.setCharno(charno); } } } private JsDocInfoParser createJsDocInfoParser(Comment node) { String comment = node.getValue(); int lineno = node.getLineno(); int position = node.getAbsolutePosition();"
      },
      {
        "txt": "int numOpeningChars = 3; JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars), node, sourceName, config, errorReporter);"
      },
      {
        "txt": "jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); jsdocParser.parse(); return jsdocParser; } private int position2charno(int position) { int lineIndex = sourceString.lastIndexOf('\\n', position); if (lineIndex == -1) { return position; } else {"
      },
      {
        "txt": "return position - lineIndex - 1; } } private Node justTransform(AstNode node) { return transformDispatcher.process(node); } private class TransformDispatcher extends TypeSafeDispatcher<Node> { private Node processGeneric( com.google.javascript.jscomp.mozilla.rhino.Node n) { Node node = newNode(transformTokenType(n.getType()));"
      },
      {
        "txt": "for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) { node.addChildToBack(transform((AstNode)child)); } return node; } private Node transformAsString(AstNode n) { Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else {"
      },
      {
        "txt": "Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); } } <extra_id_0> } @Override Node processArrayLiteral(ArrayLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); }"
      },
      {
        "txt": "reportDestructuringAssign(literalNode); } Node node = newNode(Token.ARRAYLIT); for (AstNode child : literalNode.getElements()) { Node c = transform(child); node.addChildToBack(c); } return node; } @Override"
      },
      {
        "txt": "Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( \"invalid assignment target\", sourceName, target.getLineno(), \"\", 0); } return assign;"
      },
      {
        "txt": "} @Override Node processAstRoot(AstRoot rootNode) { Node node = newNode(Token.SCRIPT); for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) { node.addChildToBack(transform((AstNode)child)); } parseDirectives(node); return node; }"
      },
      {
        "txt": "private void parseDirectives(Node node) { Set<String> directives = null; while (isDirective(node.getFirstChild())) { String directive = node.removeFirstChild().getFirstChild().getString(); if (directives == null) { directives = Sets.newHashSet(directive); } else { directives.add(directive); } }"
      },
      {
        "txt": "if (directives != null) { node.setDirectives(directives); } } private boolean isDirective(Node n) { if (n == null) return false; int nType = n.getType(); return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) && n.getFirstChild().getType() == Token.STRING && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());"
      },
      {
        "txt": "} @Override Node processBlock(Block blockNode) { return processGeneric(blockNode); } @Override Node processBreakStatement(BreakStatement statementNode) { Node node = newNode(Token.BREAK); if (statementNode.getBreakLabel() != null) { Node labelName = transform(statementNode.getBreakLabel());"
      },
      {
        "txt": "labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node; } @Override Node processCatchClause(CatchClause clauseNode) { AstNode catchVar = clauseNode.getVarName(); Node node = newNode(Token.CATCH, transform(catchVar)); if (clauseNode.getCatchCondition() != null) {"
      },
      {
        "txt": "errorReporter.error( \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0); } node.addChildToBack(transformBlock(clauseNode.getBody())); return node; } @Override Node processConditionalExpression(ConditionalExpression exprNode) {"
      },
      {
        "txt": "return newNode( Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression())); } @Override Node processContinueStatement(ContinueStatement statementNode) { Node node = newNode(Token.CONTINUE); if (statementNode.getLabel() != null) {"
      },
      {
        "txt": "Node labelName = transform(statementNode.getLabel()); labelName.setType(Token.LABEL_NAME); node.addChildToBack(labelName); } return node; } @Override Node processDoLoop(DoLoop loopNode) { return newNode( Token.DO,"
      },
      {
        "txt": "transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); } @Override Node processElementGet(ElementGet getNode) { return newNode( Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); }"
      },
      {
        "txt": "@Override Node processEmptyExpression(EmptyExpression exprNode) { Node node = newNode(Token.EMPTY); return node; } @Override Node processExpressionStatement(ExpressionStatement statementNode) { Node node = newNode(transformTokenType(statementNode.getType())); node.addChildToBack(transform(statementNode.getExpression())); return node;"
      },
      {
        "txt": "} @Override Node processForInLoop(ForInLoop loopNode) { return newNode( Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } @Override"
      },
      {
        "txt": "Node processForLoop(ForLoop loopNode) { Node node = newNode( Token.FOR, transform(loopNode.getInitializer()), transform(loopNode.getCondition()), transform(loopNode.getIncrement())); node.addChildToBack(transformBlock(loopNode.getBody())); return node; } @Override"
      },
      {
        "txt": "Node processFunctionCall(FunctionCall callNode) { Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); for (AstNode child : callNode.getArguments()) { node.addChildToBack(transform(child)); } int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp(); node.setLineno(callNode.getLineno()); node.setCharno(position2charno(leftParamPos)); return node;"
      },
      {
        "txt": "} @Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\","
      },
      {
        "txt": "sourceName, functionNode.getLineno(), \"\", 0); } name = new Name(); name.setIdentifier(\"\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) {"
      },
      {
        "txt": "newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); } node.addChildToBack(newName); Node lp = newNode(Token.LP); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno());"
      },
      {
        "txt": "} else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp);"
      },
      {
        "txt": "Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node; } @Override Node processIfStatement(IfStatement statementNode) { Node node = newNode(Token.IF); node.addChildToBack(transform(statementNode.getCondition())); node.addChildToBack(transformBlock(statementNode.getThenPart()));"
      },
      {
        "txt": "if (statementNode.getElsePart() != null) { node.addChildToBack(transformBlock(statementNode.getElsePart())); } return node; } @Override Node processInfixExpression(InfixExpression exprNode) { Node n = newNode( transformTokenType(exprNode.getType()), transform(exprNode.getLeft()),"
      },
      {
        "txt": "transform(exprNode.getRight())); n.setLineno(exprNode.getLineno()); n.setCharno(position2charno(exprNode.getAbsolutePosition() + exprNode.getOperatorPosition())); return n; } @Override Node processKeywordLiteral(KeywordLiteral literalNode) { return newNode(transformTokenType(literalNode.getType())); }"
      },
      {
        "txt": "@Override Node processLabel(Label labelNode) { return newStringNode(Token.LABEL_NAME, labelNode.getName()); } @Override Node processLabeledStatement(LabeledStatement statementNode) { Node node = newNode(Token.LABEL); Node prev = null; Node cur = node; for (Label label : statementNode.getLabels()) {"
      },
      {
        "txt": "if (prev != null) { prev.addChildToBack(cur); } cur.addChildToBack(transform(label)); cur.setLineno(label.getLineno()); int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); cur.setCharno(clauseAbsolutePosition); prev = cur; cur = newNode(Token.LABEL);"
      },
      {
        "txt": "} prev.addChildToBack(transform(statementNode.getStatement())); return node; } @Override Node processName(Name nameNode) { return processName(nameNode, false); } Node processName(Name nameNode, boolean asString) { if (asString) {"
      },
      {
        "txt": "return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error( \"identifier is a reserved word\", sourceName, nameNode.getLineno(), \"\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); }"
      },
      {
        "txt": "} private boolean isReservedKeyword(String identifier) { return reservedKeywords != null && reservedKeywords.contains(identifier); } @Override Node processNewExpression(NewExpression exprNode) { return processFunctionCall(exprNode); } @Override Node processNumberLiteral(NumberLiteral literalNode) {"
      },
      {
        "txt": "return newNumberNode(literalNode.getNumber()); } @Override Node processObjectLiteral(ObjectLiteral literalNode) { if (literalNode.isDestructuring()) { reportDestructuringAssign(literalNode); } Node node = newNode(Token.OBJECTLIT); for (ObjectProperty el : literalNode.getElements()) { if (config.languageMode == LanguageMode.ECMASCRIPT3) {"
      },
      {
        "txt": "if (el.isGetter()) { reportGetter(el); continue; } else if (el.isSetter()) { reportSetter(el); continue; } } Node key = transformAsString(el.getLeft()); Node value = transform(el.getRight());"
      },
      {
        "txt": "if (el.isGetter()) { key.setType(Token.GET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (getFnParamNode(value).hasChildren()) { reportGetterParam(el.getLeft()); } } else if (el.isSetter()) { key.setType(Token.SET); Preconditions.checkState(value.getType() == Token.FUNCTION); if (!getFnParamNode(value).hasOneChild()) {"
      },
      {
        "txt": "reportSetterParam(el.getLeft()); } } key.addChildToFront(value); node.addChildToBack(key); } return node; } Node getFnParamNode(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);"
      },
      {
        "txt": "return fnNode.getFirstChild().getNext(); } @Override Node processObjectProperty(ObjectProperty propertyNode) { return processInfixExpression(propertyNode); } @Override Node processParenthesizedExpression(ParenthesizedExpression exprNode) { Node node = transform(exprNode.getExpression()); node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);"
      },
      {
        "txt": "return node; } @Override Node processPropertyGet(PropertyGet getNode) { return newNode( Token.GETPROP, transform(getNode.getTarget()), transformAsString(getNode.getProperty())); } @Override"
      },
      {
        "txt": "Node processRegExpLiteral(RegExpLiteral literalNode) { Node literalStringNode = newStringNode(literalNode.getValue()); literalStringNode.setLineno(literalNode.getLineno()); Node node = newNode(Token.REGEXP, literalStringNode); String flags = literalNode.getFlags(); if (flags != null && !flags.isEmpty()) { Node flagsNode = newStringNode(flags); flagsNode.setLineno(literalNode.getLineno()); node.addChildToBack(flagsNode); }"
      },
      {
        "txt": "return node; } @Override Node processReturnStatement(ReturnStatement statementNode) { Node node = newNode(Token.RETURN); if (statementNode.getReturnValue() != null) { node.addChildToBack(transform(statementNode.getReturnValue())); } return node; }"
      },
      {
        "txt": "@Override Node processScope(Scope scopeNode) { return processGeneric(scopeNode); } @Override Node processStringLiteral(StringLiteral literalNode) { Node n = newStringNode(literalNode.getValue()); return n; } @Override"
      },
      {
        "txt": "Node processSwitchCase(SwitchCase caseNode) { Node node; if (caseNode.isDefault()) { node = newNode(Token.DEFAULT); } else { AstNode expr = caseNode.getExpression(); node = newNode(Token.CASE, transform(expr)); } Node block = newNode(Token.BLOCK); block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);"
      },
      {
        "txt": "block.setLineno(caseNode.getLineno()); block.setCharno(position2charno(caseNode.getAbsolutePosition())); if (caseNode.getStatements() != null) { for (AstNode child : caseNode.getStatements()) { block.addChildToBack(transform(child)); } } node.addChildToBack(block); return node; }"
      },
      {
        "txt": "@Override Node processSwitchStatement(SwitchStatement statementNode) { Node node = newNode(Token.SWITCH, transform(statementNode.getExpression())); for (AstNode child : statementNode.getCases()) { node.addChildToBack(transform(child)); } return node; } @Override"
      },
      {
        "txt": "Node processThrowStatement(ThrowStatement statementNode) { return newNode(Token.THROW, transform(statementNode.getExpression())); } @Override Node processTryStatement(TryStatement statementNode) { Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock())); Node block = newNode(Token.BLOCK); boolean lineSet = false;"
      },
      {
        "txt": "for (CatchClause cc : statementNode.getCatchClauses()) { if (lineSet == false) { block.setLineno(cc.getLineno()); lineSet = true; } block.addChildToBack(transform(cc)); } node.addChildToBack(block); AstNode finallyBlock = statementNode.getFinallyBlock(); if (finallyBlock != null) {"
      },
      {
        "txt": "node.addChildToBack(transformBlock(finallyBlock)); } if ((lineSet == false) && (finallyBlock != null)) { block.setLineno(finallyBlock.getLineno()); } return node; } @Override Node processUnaryExpression(UnaryExpression exprNode) { int type = transformTokenType(exprNode.getType());"
      },
      {
        "txt": "Node operand = transform(exprNode.getOperand()); if (type == Token.NEG && operand.getType() == Token.NUMBER) { operand.setDouble(-operand.getDouble()); return operand; } else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? \"invalid increment target\" : \"invalid decrement target\";"
      },
      {
        "txt": "errorReporter.error( msg, sourceName, operand.getLineno(), \"\", 0); } } Node node = newNode(type, operand); if (exprNode.isPostfix()) { node.putBooleanProp(Node.INCRDECR_PROP, true); }"
      },
      {
        "txt": "return node; } } private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; }"
      },
      {
        "txt": "return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) { if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.jscomp.mozilla.rhino.Token.CONST) { processIllegalToken(declarationNode); } Node node = newNode(Token.VAR); for (VariableInitializer child : declarationNode.getVariables()) {"
      },
      {
        "txt": "node.addChildToBack(transform(child)); } return node; } @Override Node processVariableInitializer(VariableInitializer initializerNode) { Node node = transform(initializerNode.getTarget()); if (initializerNode.getInitializer() != null) { node.addChildToBack(transform(initializerNode.getInitializer())); node.setLineno(node.getLineno());"
      },
      {
        "txt": "} return node; } @Override Node processWhileLoop(WhileLoop loopNode) { return newNode( Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); }"
      },
      {
        "txt": "@Override Node processWithStatement(WithStatement statementNode) { return newNode( Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement())); } @Override Node processIllegalToken(AstNode node) { errorReporter.error("
      },
      {
        "txt": "\"Unsupported syntax: \" + com.google.javascript.jscomp.mozilla.rhino.Token.typeToName( node.getType()), sourceName, node.getLineno(), \"\", 0); return newNode(Token.EMPTY); } void reportDestructuringAssign(AstNode node) { errorReporter.error( \"destructuring assignment forbidden\","
      },
      {
        "txt": "sourceName, node.getLineno(), \"\", 0); } void reportGetter(AstNode node) { errorReporter.error( \"getters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportSetter(AstNode node) {"
      },
      {
        "txt": "errorReporter.error( \"setters are not supported in Internet Explorer\", sourceName, node.getLineno(), \"\", 0); } void reportGetterParam(AstNode node) { errorReporter.error( \"getters may not have parameters\", sourceName, node.getLineno(), \"\", 0);"
      },
      {
        "txt": "} void reportSetterParam(AstNode node) { errorReporter.error( \"setters must have exactly one parameter\", sourceName, node.getLineno(), \"\", 0); } } private static int transformTokenType(int token) { switch (token) {"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR: return Token.ERROR; case com.google.javascript.jscomp.mozilla.rhino.Token.EOF: return Token.EOF; case com.google.javascript.jscomp.mozilla.rhino.Token.EOL: return Token.EOL; case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH: return Token.ENTERWITH; case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH: return Token.LEAVEWITH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN: return Token.RETURN; case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO: return Token.GOTO; case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ: return Token.IFEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE: return Token.IFNE; case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME: return Token.SETNAME;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR: return Token.BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR: return Token.BITXOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND: return Token.BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.EQ: return Token.EQ; case com.google.javascript.jscomp.mozilla.rhino.Token.NE: return Token.NE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LT: return Token.LT; case com.google.javascript.jscomp.mozilla.rhino.Token.LE: return Token.LE; case com.google.javascript.jscomp.mozilla.rhino.Token.GT: return Token.GT; case com.google.javascript.jscomp.mozilla.rhino.Token.GE: return Token.GE; case com.google.javascript.jscomp.mozilla.rhino.Token.LSH: return Token.LSH;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RSH: return Token.RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.URSH: return Token.URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ADD: return Token.ADD; case com.google.javascript.jscomp.mozilla.rhino.Token.SUB: return Token.SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.MUL: return Token.MUL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DIV: return Token.DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.MOD: return Token.MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.NOT: return Token.NOT; case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT: return Token.BITNOT; case com.google.javascript.jscomp.mozilla.rhino.Token.POS: return Token.POS;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NEG: return Token.NEG; case com.google.javascript.jscomp.mozilla.rhino.Token.NEW: return Token.NEW; case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP: return Token.DELPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF: return Token.TYPEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP: return Token.GETPROP;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP: return Token.SETPROP; case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM: return Token.GETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM: return Token.SETELEM; case com.google.javascript.jscomp.mozilla.rhino.Token.CALL: return Token.CALL; case com.google.javascript.jscomp.mozilla.rhino.Token.NAME: return Token.NAME;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER: return Token.NUMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.STRING: return Token.STRING; case com.google.javascript.jscomp.mozilla.rhino.Token.NULL: return Token.NULL; case com.google.javascript.jscomp.mozilla.rhino.Token.THIS: return Token.THIS; case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE: return Token.FALSE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE: return Token.TRUE; case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ: return Token.SHEQ; case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE: return Token.SHNE; case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP: return Token.REGEXP; case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME: return Token.BINDNAME;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.THROW: return Token.THROW; case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW: return Token.RETHROW; case com.google.javascript.jscomp.mozilla.rhino.Token.IN: return Token.IN; case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF: return Token.INSTANCEOF; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD: return Token.LOCAL_LOAD;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR: return Token.GETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR: return Token.SETVAR; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE: return Token.CATCH_SCOPE; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS: return Token.ENUM_INIT_KEYS; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES: return Token.ENUM_INIT_VALUES;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT: return Token.ENUM_NEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID: return Token.ENUM_ID; case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN: return Token.THISFN; case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT: return Token.RETURN_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT: return Token.ARRAYLIT;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT: return Token.OBJECTLIT; case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF: return Token.GET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF: return Token.SET_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF: return Token.DEL_REF; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL: return Token.REF_CALL;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL: return Token.REF_SPECIAL; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE: return Token.DEFAULTNAMESPACE; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT: return Token.ESCXMLTEXT; case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR: return Token.ESCXMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER: return Token.REF_MEMBER;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER: return Token.REF_NS_MEMBER; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME: return Token.REF_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME: return Token.REF_NS_NAME; case com.google.javascript.jscomp.mozilla.rhino.Token.TRY: return Token.TRY; case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI: return Token.SEMI;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.LB: return Token.LB; case com.google.javascript.jscomp.mozilla.rhino.Token.RB: return Token.RB; case com.google.javascript.jscomp.mozilla.rhino.Token.LC: return Token.LC; case com.google.javascript.jscomp.mozilla.rhino.Token.RC: return Token.RC; case com.google.javascript.jscomp.mozilla.rhino.Token.LP: return Token.LP;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.RP: return Token.RP; case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA: return Token.COMMA; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN: return Token.ASSIGN; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR: return Token.ASSIGN_BITOR; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR: return Token.ASSIGN_BITXOR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND: return Token.ASSIGN_BITAND; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH: return Token.ASSIGN_LSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH: return Token.ASSIGN_RSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH: return Token.ASSIGN_URSH; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD: return Token.ASSIGN_ADD;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB: return Token.ASSIGN_SUB; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL: return Token.ASSIGN_MUL; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV: return Token.ASSIGN_DIV; case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD: return Token.ASSIGN_MOD; case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK: return Token.HOOK;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.COLON: return Token.COLON; case com.google.javascript.jscomp.mozilla.rhino.Token.OR: return Token.OR; case com.google.javascript.jscomp.mozilla.rhino.Token.AND: return Token.AND; case com.google.javascript.jscomp.mozilla.rhino.Token.INC: return Token.INC; case com.google.javascript.jscomp.mozilla.rhino.Token.DEC: return Token.DEC;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DOT: return Token.DOT; case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION: return Token.FUNCTION; case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT: return Token.EXPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT: return Token.IMPORT; case com.google.javascript.jscomp.mozilla.rhino.Token.IF: return Token.IF;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE: return Token.ELSE; case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH: return Token.SWITCH; case com.google.javascript.jscomp.mozilla.rhino.Token.CASE: return Token.CASE; case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT: return Token.DEFAULT; case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE: return Token.WHILE;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.DO: return Token.DO; case com.google.javascript.jscomp.mozilla.rhino.Token.FOR: return Token.FOR; case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK: return Token.BREAK; case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE: return Token.CONTINUE; case com.google.javascript.jscomp.mozilla.rhino.Token.VAR: return Token.VAR;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.WITH: return Token.WITH; case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH: return Token.CATCH; case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY: return Token.FINALLY; case com.google.javascript.jscomp.mozilla.rhino.Token.VOID: return Token.VOID; case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED: return Token.RESERVED;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY: return Token.EMPTY; case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK: return Token.BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL: return Token.LABEL; case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET: return Token.TARGET; case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP: return Token.LOOP;"
      },
      {
        "txt": "case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID: case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT: return Token.EXPR_RESULT; case com.google.javascript.jscomp.mozilla.rhino.Token.JSR: return Token.JSR; case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT: return Token.SCRIPT; case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME: return Token.TYPEOFNAME; case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK:"
      },
      {
        "txt": "return Token.USE_STACK; case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP: return Token.SETPROP_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP: return Token.SETELEM_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK: return Token.LOCAL_BLOCK; case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP: return Token.SET_REF_OP; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT:"
      },
      {
        "txt": "return Token.DOTDOT; case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON: return Token.COLONCOLON; case com.google.javascript.jscomp.mozilla.rhino.Token.XML: return Token.XML; case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY: return Token.DOTQUERY; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR: return Token.XMLATTR; case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND:"
      },
      {
        "txt": "return Token.XMLEND; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT: return Token.TO_OBJECT; case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE: return Token.TO_DOUBLE; case com.google.javascript.jscomp.mozilla.rhino.Token.GET: return Token.GET; case com.google.javascript.jscomp.mozilla.rhino.Token.SET: return Token.SET; case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:"
      },
      {
        "txt": "return Token.CONST; case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST: return Token.SETCONST; case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER: return Token.DEBUGGER; } throw new IllegalStateException(String.valueOf(token)); } private Node newNode(int type) { return new Node(type).clonePropsFrom(templateNode);"
      },
      {
        "txt": "} private Node newNode(int type, Node child1) { return new Node(type, child1).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2) { return new Node(type, child1, child2).clonePropsFrom(templateNode); } private Node newNode(int type, Node child1, Node child2, Node child3) { return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); }"
      },
      {
        "txt": "private Node newStringNode(String value) { return Node.newString(value).clonePropsFrom(templateNode); } private Node newStringNode(int type, String value) { return Node.newString(type, value).clonePropsFrom(templateNode); } private Node newNumberNode(Double value) { return Node.newNumber(value).clonePropsFrom(templateNode); }"
      }
    ]
  }
]