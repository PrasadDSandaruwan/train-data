[
  {
    "id": 262,
    "file_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
    "start-bug-line": 157,
    "end-bug-line": 157,
    "bug": "(new NodeTraversal(compiler, this)).traverse(root);",
    "fix": "(new NodeTraversal(compiler, this)).traverseRoots(externs, root);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; class FlowSensitiveInlineVariables extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback { private final AbstractCompiler compiler; private ControlFlowGraph<Node> cfg;"
      },
      {
        "txt": "private List<Candidate> candidates; private MustBeReachingVariableDef reachingDef; private MaybeReachingVariableUse reachingUses; private static final Predicate<Node> SIDE_EFFECT_PREDICATE = new Predicate<Node>() { @Override public boolean apply(Node n) { if (n == null) { return false; }"
      },
      {
        "txt": "if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; }"
      },
      {
        "txt": "} return false; } }; public FlowSensitiveInlineVariables(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) {"
      },
      {
        "txt": "return; // Don't even brother. All global variables are likely escaped. } if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) { return; } ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); Preconditions.checkState(t.getScopeRoot().isFunction()); cfa.process(null, t.getScopeRoot().getLastChild()); cfg = cfa.getCfg();"
      },
      {
        "txt": "reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler); reachingDef.analyze(); candidates = Lists.newLinkedList(); new NodeTraversal(compiler, new GatherCandiates()).traverse( t.getScopeRoot().getLastChild()); reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { if (c.canInline()) { c.inlineVariable();"
      },
      {
        "txt": "} } @Override public void exitScope(NodeTraversal t) {} @Override public void process(Node externs, Node root) { <extra_id_0> } @Override public void visit(NodeTraversal t, Node n, Node parent) { } private class GatherCandiates extends AbstractShallowCallback { @Override"
      },
      {
        "txt": "private class GatherCandiates extends AbstractShallowCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n); if (graphNode == null) { return; } FlowState<MustDef> state = graphNode.getAnnotation(); final MustDef defs = state.getIn(); final Node cfgNode = n;"
      },
      {
        "txt": "AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName()) { if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.isVar() || parent.isInc() || parent.isDec() || parent.isParamList() || parent.isCatch()) { return;"
      },
      {
        "txt": "} String name = n.getString(); if (compiler.getCodingConvention().isExported(name)) { return; } Node defNode = reachingDef.getDef(name, cfgNode); if (defNode != null && !reachingDef.dependsOnOuterScopeVars(name, cfgNode)) { candidates.add(new Candidate(name, defNode, n, cfgNode)); }"
      },
      {
        "txt": "} } }; NodeTraversal.traverse(compiler, cfgNode, gatherCb); } } private class Candidate { private final String varName; private Node def; private final Node defCfgNode;"
      },
      {
        "txt": "private final Node use; private final Node useCfgNode; private int numUseWithinUseCfgNode; Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) { Preconditions.checkArgument(use.isName()); this.varName = varName; this.defCfgNode = defCfgNode; this.use = use; this.useCfgNode = useCfgNode; }"
      },
      {
        "txt": "private boolean canInline() { if (defCfgNode.isFunction()) { return false; } getDefinition(defCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) { return false; } if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {"
      },
      {
        "txt": "return false; } if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) { return false; } if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) { return false; } if (NodeUtil.mayHaveSideEffects(def.getLastChild())) { return false;"
      },
      {
        "txt": "} if (numUseWithinUseCfgNode != 1) { return false; } if (NodeUtil.isWithinLoop(use)) { return false; } Collection<Node> uses = reachingUses.getUses(varName, defCfgNode); if (uses.size() != 1) { return false;"
      },
      {
        "txt": "} if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() { @Override public boolean apply(Node input) { switch (input.getType()) { case Token.GETELEM: case Token.GETPROP: case Token.ARRAYLIT: case Token.OBJECTLIT:"
      },
      {
        "txt": "case Token.REGEXP: case Token.NEW: return true; } return false; } }, new Predicate<Node>() { @Override public boolean apply(Node input) {"
      },
      {
        "txt": "return !input.isFunction(); } })) { return false; } if (NodeUtil.isStatementBlock(defCfgNode.getParent()) && defCfgNode.getNext() != useCfgNode) { CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>( cfg,"
      },
      {
        "txt": "cfg.getDirectedGraphNode(defCfgNode), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates. <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false); if (pathCheck.somePathsSatisfyPredicate()) { return false; } }"
      },
      {
        "txt": "return true; } private void inlineVariable() { Node defParent = def.getParent(); Node useParent = use.getParent(); if (def.isAssign()) { Node rhs = def.getLastChild(); rhs.detachFromParent(); Preconditions.checkState(defParent.isExprResult()); while (defParent.getParent().isLabel()) {"
      },
      {
        "txt": "defParent = defParent.getParent(); } defParent.detachFromParent(); useParent.replaceChild(use, rhs); } else if (defParent.isVar()) { Node rhs = def.getLastChild(); def.removeChild(rhs); useParent.replaceChild(use, rhs); } else { Preconditions.checkState(false, \"No other definitions can be inlined.\");"
      },
      {
        "txt": "} compiler.reportCodeChange(); } private void getDefinition(Node n, Node parent) { AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NAME:"
      },
      {
        "txt": "if (n.getString().equals(varName) && n.hasChildren()) { def = n; } return; case Token.ASSIGN: Node lhs = n.getFirstChild(); if (lhs.isName() && lhs.getString().equals(varName)) { def = n; } return;"
      },
      {
        "txt": "} } }; NodeTraversal.traverse(compiler, n, gatherCb); } private void getNumUseInUseCfgNode(Node n, Node parant) { AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isName() && n.getString().equals(varName) && !(parent.isAssign() && (parent.getFirstChild() == n))) { numUseWithinUseCfgNode++; } } }; NodeTraversal.traverse(compiler, n, gatherCb); } }"
      },
      {
        "txt": "private static boolean checkRightOf( Node n, Node expressionRoot, Predicate<Node> predicate) { for (Node p = n; p != expressionRoot; p = p.getParent()) { for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) { if (predicate.apply(cur)) { return true; } } } return false;"
      },
      {
        "txt": "} private static boolean checkLeftOf( Node n, Node expressionRoot, Predicate<Node> predicate) { for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) { for (Node cur = p.getParent().getFirstChild(); cur != p; cur = cur.getNext()) { if (predicate.apply(cur)) { return true; } }"
      },
      {
        "txt": "} return false; }"
      }
    ]
  },
  {
    "id": 263,
    "file_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
    "start-bug-line": 71,
    "end-bug-line": 71,
    "bug": "",
    "fix": "private boolean unknownDependencies = false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.LatticeElement; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set;"
      },
      {
        "txt": "import javax.annotation.Nullable; final class MustBeReachingVariableDef extends DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> { private final Scope jsScope; private final AbstractCompiler compiler; private final Set<Var> escaped; MustBeReachingVariableDef( ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) { super(cfg, new MustDefJoin()); this.jsScope = jsScope;"
      },
      {
        "txt": "this.escaped = Sets.newHashSet(); computeEscaped(jsScope, escaped, compiler); } private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); <extra_id_0> Definition(Node node) { this.node = node; } @Override public boolean equals(Object other) { if (!(other instanceof Definition)) {"
      },
      {
        "txt": "public boolean equals(Object other) { if (!(other instanceof Definition)) { return false; } Definition otherDef = (Definition) other; return otherDef.node == node; } } static final class MustDef implements LatticeElement { final Map<Var, Definition> reachingDef;"
      },
      {
        "txt": "public MustDef() { reachingDef = Maps.newHashMap(); } public MustDef(Iterator<Var> vars) { this(); while(vars.hasNext()) { Var var = vars.next(); reachingDef.put(var, new Definition(var.scope.getRootNode())); } }"
      },
      {
        "txt": "public MustDef(MustDef other) { reachingDef = Maps.newHashMap(other.reachingDef); } @Override public boolean equals(Object other) { return (other instanceof MustDef) && ((MustDef) other).reachingDef.equals(this.reachingDef); } } private static class MustDefJoin extends JoinOp.BinaryJoinOp<MustDef> {"
      },
      {
        "txt": "@Override public MustDef apply(MustDef a, MustDef b) { MustDef result = new MustDef(); Map<Var, Definition> resultMap = result.reachingDef; for (Map.Entry<Var, Definition> varEntry : a.reachingDef.entrySet()) { Var var = varEntry.getKey(); Definition aDef = varEntry.getValue(); if (aDef == null) { resultMap.put(var, null); continue;"
      },
      {
        "txt": "} Node aNode = aDef.node; if (b.reachingDef.containsKey(var)) { Definition bDef = b.reachingDef.get(var); if (aDef.equals(bDef)) { resultMap.put(var, aDef); } else { resultMap.put(var, null); } } else {"
      },
      {
        "txt": "resultMap.put(var, aDef); } } for (Map.Entry<Var, Definition> entry : b.reachingDef.entrySet()) { Var var = entry.getKey(); if (!a.reachingDef.containsKey(var)) { resultMap.put(var, entry.getValue()); } } return result;"
      },
      {
        "txt": "} } @Override boolean isForward() { return true; } @Override MustDef createEntryLattice() { return new MustDef(jsScope.getVars()); }"
      },
      {
        "txt": "@Override MustDef createInitialEstimateLattice() { return new MustDef(); } @Override MustDef flowThrough(Node n, MustDef input) { MustDef output = new MustDef(input); computeMustDef(n, n, output, false); return output; }"
      },
      {
        "txt": "private void computeMustDef( Node n, Node cfgNode, MustDef output, boolean conditional) { switch (n.getType()) { case Token.BLOCK: case Token.FUNCTION: return; case Token.WHILE: case Token.DO: case Token.IF: computeMustDef("
      },
      {
        "txt": "NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) { computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); } else { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (lhs.isVar()) {"
      },
      {
        "txt": "lhs = lhs.getLastChild(); // for(var x in y) {...} } if (lhs.isName()) { addToDefIfLocal(lhs.getString(), cfgNode, rhs, output); } } return; case Token.AND: case Token.OR: computeMustDef(n.getFirstChild(), cfgNode, output, conditional);"
      },
      {
        "txt": "computeMustDef(n.getLastChild(), cfgNode, output, true); return; case Token.HOOK: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true); computeMustDef(n.getLastChild(), cfgNode, output, true); return; case Token.VAR: for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.hasChildren()) {"
      },
      {
        "txt": "computeMustDef(c.getFirstChild(), cfgNode, output, conditional); addToDefIfLocal(c.getString(), conditional ? null : cfgNode, c.getFirstChild(), output); } } return; default: if (NodeUtil.isAssignmentOp(n)) { if (n.getFirstChild().isName()) { Node name = n.getFirstChild();"
      },
      {
        "txt": "computeMustDef(name.getNext(), cfgNode, output, conditional); addToDefIfLocal(name.getString(), conditional ? null : cfgNode, n.getLastChild(), output); return; } else if (NodeUtil.isGet(n.getFirstChild())) { Node obj = n.getFirstChild().getFirstChild(); if (obj.isName() && \"arguments\".equals(obj.getString())) { escapeParameters(output); } }"
      },
      {
        "txt": "} if (n.isName() && \"arguments\".equals(n.getString())) { escapeParameters(output); } if (n.isDec() || n.isInc()) { Node target = n.getFirstChild(); if (target.isName()) { addToDefIfLocal(target.getString(), conditional ? null : cfgNode, null, output); return;"
      },
      {
        "txt": "} } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { computeMustDef(c, cfgNode, output, conditional); } } } private void addToDefIfLocal( String name, @Nullable Node node, @Nullable Node rValue, MustDef def) { Var var = jsScope.getVar(name);"
      },
      {
        "txt": "if (var == null || var.scope != jsScope) { return; } for (Var other : def.reachingDef.keySet()) { Definition otherDef = def.reachingDef.get(other); if (otherDef == null) { continue; } if (otherDef.depends.contains(var)) { def.reachingDef.put(other, null);"
      },
      {
        "txt": "} } if (!escaped.contains(var)) { if (node == null) { def.reachingDef.put(var, null); } else { Definition definition = new Definition(node); if (rValue != null) { computeDependence(definition, rValue); }"
      },
      {
        "txt": "def.reachingDef.put(var, definition); } } } private void escapeParameters(MustDef output) { for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) { Var v = i.next(); if (isParameter(v)) { output.reachingDef.put(v, null); }"
      },
      {
        "txt": "} for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) { Definition value = pair.getValue(); if (value == null) { continue; } for (Var dep : value.depends) { if (isParameter(dep)) { output.reachingDef.put(pair.getKey(), null); }"
      },
      {
        "txt": "} } } private boolean isParameter(Var v) { return v.getParentNode().isParamList(); } private void computeDependence(final Definition def, Node rValue) { NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() { @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && jsScope.isDeclared(n.getString(), true)) { Var dep = jsScope.getVar(n.getString()); def.depends.add(dep); } } }); } Node getDef(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode));"
      },
      {
        "txt": "GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); if (def == null) { return null; } else { return def.node; } } boolean dependsOnOuterScopeVars(String name, Node useNode) {"
      },
      {
        "txt": "Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); for (Var s : def.depends) { if (s.scope != jsScope) { return true; } } return false;"
      }
    ]
  },
  {
    "id": 264,
    "file_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
    "start-bug-line": 396,
    "end-bug-line": 396,
    "bug": "if (n.isName() && jsScope.isDeclared(n.getString(), true)) {",
    "fix": "if (n.isName()) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.LatticeElement; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import javax.annotation.Nullable; final class MustBeReachingVariableDef extends DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> { private final Scope jsScope; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final Set<Var> escaped; MustBeReachingVariableDef( ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) { super(cfg, new MustDefJoin()); this.jsScope = jsScope; this.compiler = compiler; this.escaped = Sets.newHashSet(); computeEscaped(jsScope, escaped, compiler); } private static class Definition {"
      },
      {
        "txt": "final Node node; final Set<Var> depends = Sets.newHashSet(); Definition(Node node) { this.node = node; } @Override public boolean equals(Object other) { if (!(other instanceof Definition)) { return false; }"
      },
      {
        "txt": "Definition otherDef = (Definition) other; return otherDef.node == node; } } static final class MustDef implements LatticeElement { final Map<Var, Definition> reachingDef; public MustDef() { reachingDef = Maps.newHashMap(); } public MustDef(Iterator<Var> vars) {"
      },
      {
        "txt": "this(); while(vars.hasNext()) { Var var = vars.next(); reachingDef.put(var, new Definition(var.scope.getRootNode())); } } public MustDef(MustDef other) { reachingDef = Maps.newHashMap(other.reachingDef); } @Override"
      },
      {
        "txt": "public boolean equals(Object other) { return (other instanceof MustDef) && ((MustDef) other).reachingDef.equals(this.reachingDef); } } private static class MustDefJoin extends JoinOp.BinaryJoinOp<MustDef> { @Override public MustDef apply(MustDef a, MustDef b) { MustDef result = new MustDef(); Map<Var, Definition> resultMap = result.reachingDef;"
      },
      {
        "txt": "for (Map.Entry<Var, Definition> varEntry : a.reachingDef.entrySet()) { Var var = varEntry.getKey(); Definition aDef = varEntry.getValue(); if (aDef == null) { resultMap.put(var, null); continue; } Node aNode = aDef.node; if (b.reachingDef.containsKey(var)) { Definition bDef = b.reachingDef.get(var);"
      },
      {
        "txt": "if (aDef.equals(bDef)) { resultMap.put(var, aDef); } else { resultMap.put(var, null); } } else { resultMap.put(var, aDef); } } for (Map.Entry<Var, Definition> entry : b.reachingDef.entrySet()) {"
      },
      {
        "txt": "Var var = entry.getKey(); if (!a.reachingDef.containsKey(var)) { resultMap.put(var, entry.getValue()); } } return result; } } @Override boolean isForward() {"
      },
      {
        "txt": "return true; } @Override MustDef createEntryLattice() { return new MustDef(jsScope.getVars()); } @Override MustDef createInitialEstimateLattice() { return new MustDef(); }"
      },
      {
        "txt": "@Override MustDef flowThrough(Node n, MustDef input) { MustDef output = new MustDef(input); computeMustDef(n, n, output, false); return output; } private void computeMustDef( Node n, Node cfgNode, MustDef output, boolean conditional) { switch (n.getType()) { case Token.BLOCK:"
      },
      {
        "txt": "case Token.FUNCTION: return; case Token.WHILE: case Token.DO: case Token.IF: computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) {"
      },
      {
        "txt": "computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); } else { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (lhs.isVar()) { lhs = lhs.getLastChild(); // for(var x in y) {...} } if (lhs.isName()) { addToDefIfLocal(lhs.getString(), cfgNode, rhs, output);"
      },
      {
        "txt": "} } return; case Token.AND: case Token.OR: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getLastChild(), cfgNode, output, true); return; case Token.HOOK: computeMustDef(n.getFirstChild(), cfgNode, output, conditional);"
      },
      {
        "txt": "computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true); computeMustDef(n.getLastChild(), cfgNode, output, true); return; case Token.VAR: for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.hasChildren()) { computeMustDef(c.getFirstChild(), cfgNode, output, conditional); addToDefIfLocal(c.getString(), conditional ? null : cfgNode, c.getFirstChild(), output); }"
      },
      {
        "txt": "} return; default: if (NodeUtil.isAssignmentOp(n)) { if (n.getFirstChild().isName()) { Node name = n.getFirstChild(); computeMustDef(name.getNext(), cfgNode, output, conditional); addToDefIfLocal(name.getString(), conditional ? null : cfgNode, n.getLastChild(), output); return;"
      },
      {
        "txt": "} else if (NodeUtil.isGet(n.getFirstChild())) { Node obj = n.getFirstChild().getFirstChild(); if (obj.isName() && \"arguments\".equals(obj.getString())) { escapeParameters(output); } } } if (n.isName() && \"arguments\".equals(n.getString())) { escapeParameters(output); }"
      },
      {
        "txt": "if (n.isDec() || n.isInc()) { Node target = n.getFirstChild(); if (target.isName()) { addToDefIfLocal(target.getString(), conditional ? null : cfgNode, null, output); return; } } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { computeMustDef(c, cfgNode, output, conditional);"
      },
      {
        "txt": "} } } private void addToDefIfLocal( String name, @Nullable Node node, @Nullable Node rValue, MustDef def) { Var var = jsScope.getVar(name); if (var == null || var.scope != jsScope) { return; } for (Var other : def.reachingDef.keySet()) {"
      },
      {
        "txt": "Definition otherDef = def.reachingDef.get(other); if (otherDef == null) { continue; } if (otherDef.depends.contains(var)) { def.reachingDef.put(other, null); } } if (!escaped.contains(var)) { if (node == null) {"
      },
      {
        "txt": "def.reachingDef.put(var, null); } else { Definition definition = new Definition(node); if (rValue != null) { computeDependence(definition, rValue); } def.reachingDef.put(var, definition); } } }"
      },
      {
        "txt": "private void escapeParameters(MustDef output) { for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) { Var v = i.next(); if (isParameter(v)) { output.reachingDef.put(v, null); } } for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) { Definition value = pair.getValue(); if (value == null) {"
      },
      {
        "txt": "continue; } for (Var dep : value.depends) { if (isParameter(dep)) { output.reachingDef.put(pair.getKey(), null); } } } } private boolean isParameter(Var v) {"
      },
      {
        "txt": "} private void computeDependence(final Definition def, Node rValue) { NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { <extra_id_0> Var dep = jsScope.getVar(n.getString()); def.depends.add(dep); } } }); }"
      },
      {
        "txt": "}); } Node getDef(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); if (def == null) { return null; } else {"
      },
      {
        "txt": "return def.node; } } boolean dependsOnOuterScopeVars(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); for (Var s : def.depends) { if (s.scope != jsScope) {"
      },
      {
        "txt": "return true; } } return false; }"
      }
    ]
  },
  {
    "id": 265,
    "file_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
    "start-bug-line": 398,
    "end-bug-line": 398,
    "bug": "",
    "fix": "if (dep == null) { def.unknownDependencies = true; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.LatticeElement; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.Map; import java.util.Map.Entry; import java.util.Set; import javax.annotation.Nullable; final class MustBeReachingVariableDef extends DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> { private final Scope jsScope; private final AbstractCompiler compiler; private final Set<Var> escaped; MustBeReachingVariableDef("
      },
      {
        "txt": "ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) { super(cfg, new MustDefJoin()); this.jsScope = jsScope; this.compiler = compiler; this.escaped = Sets.newHashSet(); computeEscaped(jsScope, escaped, compiler); } private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet();"
      },
      {
        "txt": "Definition(Node node) { this.node = node; } @Override public boolean equals(Object other) { if (!(other instanceof Definition)) { return false; } Definition otherDef = (Definition) other; return otherDef.node == node;"
      },
      {
        "txt": "} } static final class MustDef implements LatticeElement { final Map<Var, Definition> reachingDef; public MustDef() { reachingDef = Maps.newHashMap(); } public MustDef(Iterator<Var> vars) { this(); while(vars.hasNext()) {"
      },
      {
        "txt": "Var var = vars.next(); reachingDef.put(var, new Definition(var.scope.getRootNode())); } } public MustDef(MustDef other) { reachingDef = Maps.newHashMap(other.reachingDef); } @Override public boolean equals(Object other) { return (other instanceof MustDef) &&"
      },
      {
        "txt": "((MustDef) other).reachingDef.equals(this.reachingDef); } } private static class MustDefJoin extends JoinOp.BinaryJoinOp<MustDef> { @Override public MustDef apply(MustDef a, MustDef b) { MustDef result = new MustDef(); Map<Var, Definition> resultMap = result.reachingDef; for (Map.Entry<Var, Definition> varEntry : a.reachingDef.entrySet()) { Var var = varEntry.getKey();"
      },
      {
        "txt": "Definition aDef = varEntry.getValue(); if (aDef == null) { resultMap.put(var, null); continue; } Node aNode = aDef.node; if (b.reachingDef.containsKey(var)) { Definition bDef = b.reachingDef.get(var); if (aDef.equals(bDef)) { resultMap.put(var, aDef);"
      },
      {
        "txt": "} else { resultMap.put(var, null); } } else { resultMap.put(var, aDef); } } for (Map.Entry<Var, Definition> entry : b.reachingDef.entrySet()) { Var var = entry.getKey(); if (!a.reachingDef.containsKey(var)) {"
      },
      {
        "txt": "resultMap.put(var, entry.getValue()); } } return result; } } @Override boolean isForward() { return true; }"
      },
      {
        "txt": "@Override MustDef createEntryLattice() { return new MustDef(jsScope.getVars()); } @Override MustDef createInitialEstimateLattice() { return new MustDef(); } @Override MustDef flowThrough(Node n, MustDef input) {"
      },
      {
        "txt": "MustDef output = new MustDef(input); computeMustDef(n, n, output, false); return output; } private void computeMustDef( Node n, Node cfgNode, MustDef output, boolean conditional) { switch (n.getType()) { case Token.BLOCK: case Token.FUNCTION: return;"
      },
      {
        "txt": "case Token.WHILE: case Token.DO: case Token.IF: computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) { computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional);"
      },
      {
        "txt": "} else { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (lhs.isVar()) { lhs = lhs.getLastChild(); // for(var x in y) {...} } if (lhs.isName()) { addToDefIfLocal(lhs.getString(), cfgNode, rhs, output); } }"
      },
      {
        "txt": "return; case Token.AND: case Token.OR: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getLastChild(), cfgNode, output, true); return; case Token.HOOK: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true); computeMustDef(n.getLastChild(), cfgNode, output, true);"
      },
      {
        "txt": "return; case Token.VAR: for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.hasChildren()) { computeMustDef(c.getFirstChild(), cfgNode, output, conditional); addToDefIfLocal(c.getString(), conditional ? null : cfgNode, c.getFirstChild(), output); } } return;"
      },
      {
        "txt": "default: if (NodeUtil.isAssignmentOp(n)) { if (n.getFirstChild().isName()) { Node name = n.getFirstChild(); computeMustDef(name.getNext(), cfgNode, output, conditional); addToDefIfLocal(name.getString(), conditional ? null : cfgNode, n.getLastChild(), output); return; } else if (NodeUtil.isGet(n.getFirstChild())) { Node obj = n.getFirstChild().getFirstChild();"
      },
      {
        "txt": "if (obj.isName() && \"arguments\".equals(obj.getString())) { escapeParameters(output); } } } if (n.isName() && \"arguments\".equals(n.getString())) { escapeParameters(output); } if (n.isDec() || n.isInc()) { Node target = n.getFirstChild();"
      },
      {
        "txt": "if (target.isName()) { addToDefIfLocal(target.getString(), conditional ? null : cfgNode, null, output); return; } } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { computeMustDef(c, cfgNode, output, conditional); } }"
      },
      {
        "txt": "} private void addToDefIfLocal( String name, @Nullable Node node, @Nullable Node rValue, MustDef def) { Var var = jsScope.getVar(name); if (var == null || var.scope != jsScope) { return; } for (Var other : def.reachingDef.keySet()) { Definition otherDef = def.reachingDef.get(other); if (otherDef == null) {"
      },
      {
        "txt": "continue; } if (otherDef.depends.contains(var)) { def.reachingDef.put(other, null); } } if (!escaped.contains(var)) { if (node == null) { def.reachingDef.put(var, null); } else {"
      },
      {
        "txt": "Definition definition = new Definition(node); if (rValue != null) { computeDependence(definition, rValue); } def.reachingDef.put(var, definition); } } } private void escapeParameters(MustDef output) { for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {"
      },
      {
        "txt": "Var v = i.next(); if (isParameter(v)) { output.reachingDef.put(v, null); } } for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) { Definition value = pair.getValue(); if (value == null) { continue; }"
      },
      {
        "txt": "for (Var dep : value.depends) { if (isParameter(dep)) { output.reachingDef.put(pair.getKey(), null); } } } } private boolean isParameter(Var v) { return v.getParentNode().isParamList(); }"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && jsScope.isDeclared(n.getString(), true)) { Var dep = jsScope.getVar(n.getString()); <extra_id_0> } } }); } Node getDef(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode));"
      },
      {
        "txt": "Node getDef(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); if (def == null) { return null; } else { return def.node; }"
      },
      {
        "txt": "} boolean dependsOnOuterScopeVars(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); for (Var s : def.depends) { if (s.scope != jsScope) { return true; }"
      },
      {
        "txt": "} return false; }"
      }
    ]
  },
  {
    "id": 266,
    "file_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
    "start-bug-line": 399,
    "end-bug-line": 399,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.LatticeElement; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.Map;"
      },
      {
        "txt": "import java.util.Map.Entry; import java.util.Set; import javax.annotation.Nullable; final class MustBeReachingVariableDef extends DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> { private final Scope jsScope; private final AbstractCompiler compiler; private final Set<Var> escaped; MustBeReachingVariableDef( ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {"
      },
      {
        "txt": "super(cfg, new MustDefJoin()); this.jsScope = jsScope; this.compiler = compiler; this.escaped = Sets.newHashSet(); computeEscaped(jsScope, escaped, compiler); } private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); Definition(Node node) {"
      },
      {
        "txt": "this.node = node; } @Override public boolean equals(Object other) { if (!(other instanceof Definition)) { return false; } Definition otherDef = (Definition) other; return otherDef.node == node; }"
      },
      {
        "txt": "} static final class MustDef implements LatticeElement { final Map<Var, Definition> reachingDef; public MustDef() { reachingDef = Maps.newHashMap(); } public MustDef(Iterator<Var> vars) { this(); while(vars.hasNext()) { Var var = vars.next();"
      },
      {
        "txt": "reachingDef.put(var, new Definition(var.scope.getRootNode())); } } public MustDef(MustDef other) { reachingDef = Maps.newHashMap(other.reachingDef); } @Override public boolean equals(Object other) { return (other instanceof MustDef) && ((MustDef) other).reachingDef.equals(this.reachingDef);"
      },
      {
        "txt": "} } private static class MustDefJoin extends JoinOp.BinaryJoinOp<MustDef> { @Override public MustDef apply(MustDef a, MustDef b) { MustDef result = new MustDef(); Map<Var, Definition> resultMap = result.reachingDef; for (Map.Entry<Var, Definition> varEntry : a.reachingDef.entrySet()) { Var var = varEntry.getKey(); Definition aDef = varEntry.getValue();"
      },
      {
        "txt": "if (aDef == null) { resultMap.put(var, null); continue; } Node aNode = aDef.node; if (b.reachingDef.containsKey(var)) { Definition bDef = b.reachingDef.get(var); if (aDef.equals(bDef)) { resultMap.put(var, aDef); } else {"
      },
      {
        "txt": "resultMap.put(var, null); } } else { resultMap.put(var, aDef); } } for (Map.Entry<Var, Definition> entry : b.reachingDef.entrySet()) { Var var = entry.getKey(); if (!a.reachingDef.containsKey(var)) { resultMap.put(var, entry.getValue());"
      },
      {
        "txt": "} } return result; } } @Override boolean isForward() { return true; } @Override"
      },
      {
        "txt": "MustDef createEntryLattice() { return new MustDef(jsScope.getVars()); } @Override MustDef createInitialEstimateLattice() { return new MustDef(); } @Override MustDef flowThrough(Node n, MustDef input) { MustDef output = new MustDef(input);"
      },
      {
        "txt": "computeMustDef(n, n, output, false); return output; } private void computeMustDef( Node n, Node cfgNode, MustDef output, boolean conditional) { switch (n.getType()) { case Token.BLOCK: case Token.FUNCTION: return; case Token.WHILE:"
      },
      {
        "txt": "case Token.DO: case Token.IF: computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) { computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); } else {"
      },
      {
        "txt": "Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (lhs.isVar()) { lhs = lhs.getLastChild(); // for(var x in y) {...} } if (lhs.isName()) { addToDefIfLocal(lhs.getString(), cfgNode, rhs, output); } } return;"
      },
      {
        "txt": "case Token.AND: case Token.OR: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getLastChild(), cfgNode, output, true); return; case Token.HOOK: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true); computeMustDef(n.getLastChild(), cfgNode, output, true); return;"
      },
      {
        "txt": "case Token.VAR: for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.hasChildren()) { computeMustDef(c.getFirstChild(), cfgNode, output, conditional); addToDefIfLocal(c.getString(), conditional ? null : cfgNode, c.getFirstChild(), output); } } return; default:"
      },
      {
        "txt": "if (NodeUtil.isAssignmentOp(n)) { if (n.getFirstChild().isName()) { Node name = n.getFirstChild(); computeMustDef(name.getNext(), cfgNode, output, conditional); addToDefIfLocal(name.getString(), conditional ? null : cfgNode, n.getLastChild(), output); return; } else if (NodeUtil.isGet(n.getFirstChild())) { Node obj = n.getFirstChild().getFirstChild(); if (obj.isName() && \"arguments\".equals(obj.getString())) {"
      },
      {
        "txt": "escapeParameters(output); } } } if (n.isName() && \"arguments\".equals(n.getString())) { escapeParameters(output); } if (n.isDec() || n.isInc()) { Node target = n.getFirstChild(); if (target.isName()) {"
      },
      {
        "txt": "addToDefIfLocal(target.getString(), conditional ? null : cfgNode, null, output); return; } } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { computeMustDef(c, cfgNode, output, conditional); } } }"
      },
      {
        "txt": "private void addToDefIfLocal( String name, @Nullable Node node, @Nullable Node rValue, MustDef def) { Var var = jsScope.getVar(name); if (var == null || var.scope != jsScope) { return; } for (Var other : def.reachingDef.keySet()) { Definition otherDef = def.reachingDef.get(other); if (otherDef == null) { continue;"
      },
      {
        "txt": "} if (otherDef.depends.contains(var)) { def.reachingDef.put(other, null); } } if (!escaped.contains(var)) { if (node == null) { def.reachingDef.put(var, null); } else { Definition definition = new Definition(node);"
      },
      {
        "txt": "if (rValue != null) { computeDependence(definition, rValue); } def.reachingDef.put(var, definition); } } } private void escapeParameters(MustDef output) { for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) { Var v = i.next();"
      },
      {
        "txt": "if (isParameter(v)) { output.reachingDef.put(v, null); } } for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) { Definition value = pair.getValue(); if (value == null) { continue; } for (Var dep : value.depends) {"
      },
      {
        "txt": "if (isParameter(dep)) { output.reachingDef.put(pair.getKey(), null); } } } } private boolean isParameter(Var v) { return v.getParentNode().isParamList(); } private void computeDependence(final Definition def, Node rValue) {"
      },
      {
        "txt": "new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && jsScope.isDeclared(n.getString(), true)) { Var dep = jsScope.getVar(n.getString()); def.depends.add(dep); <extra_id_0> } }); } Node getDef(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode);"
      },
      {
        "txt": "Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); if (def == null) { return null; } else { return def.node; } }"
      },
      {
        "txt": "boolean dependsOnOuterScopeVars(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); for (Var s : def.depends) { if (s.scope != jsScope) { return true; } }"
      },
      {
        "txt": "return false; }"
      }
    ]
  },
  {
    "id": 267,
    "file_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
    "start-bug-line": 430,
    "end-bug-line": 430,
    "bug": "",
    "fix": "if (def.unknownDependencies) { return true; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.LatticeElement; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.Map;"
      },
      {
        "txt": "import java.util.Map.Entry; import java.util.Set; import javax.annotation.Nullable; final class MustBeReachingVariableDef extends DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> { private final Scope jsScope; private final AbstractCompiler compiler; private final Set<Var> escaped; MustBeReachingVariableDef( ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {"
      },
      {
        "txt": "super(cfg, new MustDefJoin()); this.jsScope = jsScope; this.compiler = compiler; this.escaped = Sets.newHashSet(); computeEscaped(jsScope, escaped, compiler); } private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); Definition(Node node) {"
      },
      {
        "txt": "this.node = node; } @Override public boolean equals(Object other) { if (!(other instanceof Definition)) { return false; } Definition otherDef = (Definition) other; return otherDef.node == node; }"
      },
      {
        "txt": "} static final class MustDef implements LatticeElement { final Map<Var, Definition> reachingDef; public MustDef() { reachingDef = Maps.newHashMap(); } public MustDef(Iterator<Var> vars) { this(); while(vars.hasNext()) { Var var = vars.next();"
      },
      {
        "txt": "reachingDef.put(var, new Definition(var.scope.getRootNode())); } } public MustDef(MustDef other) { reachingDef = Maps.newHashMap(other.reachingDef); } @Override public boolean equals(Object other) { return (other instanceof MustDef) && ((MustDef) other).reachingDef.equals(this.reachingDef);"
      },
      {
        "txt": "} } private static class MustDefJoin extends JoinOp.BinaryJoinOp<MustDef> { @Override public MustDef apply(MustDef a, MustDef b) { MustDef result = new MustDef(); Map<Var, Definition> resultMap = result.reachingDef; for (Map.Entry<Var, Definition> varEntry : a.reachingDef.entrySet()) { Var var = varEntry.getKey(); Definition aDef = varEntry.getValue();"
      },
      {
        "txt": "if (aDef == null) { resultMap.put(var, null); continue; } Node aNode = aDef.node; if (b.reachingDef.containsKey(var)) { Definition bDef = b.reachingDef.get(var); if (aDef.equals(bDef)) { resultMap.put(var, aDef); } else {"
      },
      {
        "txt": "resultMap.put(var, null); } } else { resultMap.put(var, aDef); } } for (Map.Entry<Var, Definition> entry : b.reachingDef.entrySet()) { Var var = entry.getKey(); if (!a.reachingDef.containsKey(var)) { resultMap.put(var, entry.getValue());"
      },
      {
        "txt": "} } return result; } } @Override boolean isForward() { return true; } @Override"
      },
      {
        "txt": "MustDef createEntryLattice() { return new MustDef(jsScope.getVars()); } @Override MustDef createInitialEstimateLattice() { return new MustDef(); } @Override MustDef flowThrough(Node n, MustDef input) { MustDef output = new MustDef(input);"
      },
      {
        "txt": "computeMustDef(n, n, output, false); return output; } private void computeMustDef( Node n, Node cfgNode, MustDef output, boolean conditional) { switch (n.getType()) { case Token.BLOCK: case Token.FUNCTION: return; case Token.WHILE:"
      },
      {
        "txt": "case Token.DO: case Token.IF: computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) { computeMustDef( NodeUtil.getConditionExpression(n), cfgNode, output, conditional); } else {"
      },
      {
        "txt": "Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (lhs.isVar()) { lhs = lhs.getLastChild(); // for(var x in y) {...} } if (lhs.isName()) { addToDefIfLocal(lhs.getString(), cfgNode, rhs, output); } } return;"
      },
      {
        "txt": "case Token.AND: case Token.OR: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getLastChild(), cfgNode, output, true); return; case Token.HOOK: computeMustDef(n.getFirstChild(), cfgNode, output, conditional); computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true); computeMustDef(n.getLastChild(), cfgNode, output, true); return;"
      },
      {
        "txt": "case Token.VAR: for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.hasChildren()) { computeMustDef(c.getFirstChild(), cfgNode, output, conditional); addToDefIfLocal(c.getString(), conditional ? null : cfgNode, c.getFirstChild(), output); } } return; default:"
      },
      {
        "txt": "if (NodeUtil.isAssignmentOp(n)) { if (n.getFirstChild().isName()) { Node name = n.getFirstChild(); computeMustDef(name.getNext(), cfgNode, output, conditional); addToDefIfLocal(name.getString(), conditional ? null : cfgNode, n.getLastChild(), output); return; } else if (NodeUtil.isGet(n.getFirstChild())) { Node obj = n.getFirstChild().getFirstChild(); if (obj.isName() && \"arguments\".equals(obj.getString())) {"
      },
      {
        "txt": "escapeParameters(output); } } } if (n.isName() && \"arguments\".equals(n.getString())) { escapeParameters(output); } if (n.isDec() || n.isInc()) { Node target = n.getFirstChild(); if (target.isName()) {"
      },
      {
        "txt": "addToDefIfLocal(target.getString(), conditional ? null : cfgNode, null, output); return; } } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { computeMustDef(c, cfgNode, output, conditional); } } }"
      },
      {
        "txt": "private void addToDefIfLocal( String name, @Nullable Node node, @Nullable Node rValue, MustDef def) { Var var = jsScope.getVar(name); if (var == null || var.scope != jsScope) { return; } for (Var other : def.reachingDef.keySet()) { Definition otherDef = def.reachingDef.get(other); if (otherDef == null) { continue;"
      },
      {
        "txt": "} if (otherDef.depends.contains(var)) { def.reachingDef.put(other, null); } } if (!escaped.contains(var)) { if (node == null) { def.reachingDef.put(var, null); } else { Definition definition = new Definition(node);"
      },
      {
        "txt": "if (rValue != null) { computeDependence(definition, rValue); } def.reachingDef.put(var, definition); } } } private void escapeParameters(MustDef output) { for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) { Var v = i.next();"
      },
      {
        "txt": "if (isParameter(v)) { output.reachingDef.put(v, null); } } for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) { Definition value = pair.getValue(); if (value == null) { continue; } for (Var dep : value.depends) {"
      },
      {
        "txt": "if (isParameter(dep)) { output.reachingDef.put(pair.getKey(), null); } } } } private boolean isParameter(Var v) { return v.getParentNode().isParamList(); } private void computeDependence(final Definition def, Node rValue) {"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && jsScope.isDeclared(n.getString(), true)) { Var dep = jsScope.getVar(n.getString()); def.depends.add(dep); } } });"
      },
      {
        "txt": "} Node getDef(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); if (def == null) { return null; } else { return def.node;"
      },
      {
        "txt": "} boolean dependsOnOuterScopeVars(String name, Node useNode) { Preconditions.checkArgument(getCfg().hasNode(useNode)); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); <extra_id_0> for (Var s : def.depends) { if (s.scope != jsScope) { return true; } } return false;"
      },
      {
        "txt": "} return false; }"
      }
    ]
  }
]