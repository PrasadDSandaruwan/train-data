[
  {
    "id": 587,
    "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
    "start-bug-line": 182,
    "end-bug-line": 182,
    "bug": "",
    "fix": "case Token.VOID: typeNameString = \"undefined\"; break;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.List; public class PeepholeFoldConstants extends AbstractPeepholeOptimization { static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error( \"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"); static final DiagnosticType INVALID_GETELEM_INDEX_ERROR ="
      },
      {
        "txt": "DiagnosticType.error( \"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error( \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error( \"JSC_NEGATING_A_NON_NUMBER_ERROR\","
      },
      {
        "txt": "\"Can't negate non-numeric value: {0}\"); static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\", \"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error( \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error( \"JSC_FRACTIONAL_BITWISE_OPERAND\","
      },
      {
        "txt": "\"Fractional bitwise operand: {0}\"); private static final double MAX_FOLD_NUMBER = Math.pow(2, 53); @Override Node optimizeSubtree(Node subtree) { switch(subtree.getType()) { case Token.CALL: return tryFoldKnownMethods(subtree); case Token.TYPEOF: return tryFoldTypeof(subtree); case Token.NOT:"
      },
      {
        "txt": "case Token.NEG: case Token.BITNOT: return tryFoldUnaryOperator(subtree); default: return tryFoldBinaryOperator(subtree); } } private Node tryFoldBinaryOperator(Node subtree) { Node left = subtree.getFirstChild(); if (left == null) {"
      },
      {
        "txt": "return subtree; } Node right = left.getNext(); if (right == null) { return subtree; } switch(subtree.getType()) { case Token.GETPROP: return tryFoldGetProp(subtree, left, right); case Token.GETELEM:"
      },
      {
        "txt": "return tryFoldGetElem(subtree, left, right); case Token.INSTANCEOF: return tryFoldInstanceof(subtree, left, right); case Token.AND: case Token.OR: return tryFoldAndOr(subtree, left, right); case Token.BITAND: case Token.BITOR: return tryFoldBitAndOr(subtree, left, right); case Token.LSH:"
      },
      {
        "txt": "case Token.RSH: case Token.URSH: return tryFoldShift(subtree, left, right); case Token.ASSIGN: return tryFoldAssign(subtree, left, right); case Token.ADD: return tryFoldAdd(subtree, left, right); case Token.SUB: case Token.MUL: case Token.DIV:"
      },
      {
        "txt": "return tryFoldArithmetic(subtree, left, right); case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: return tryFoldComparison(subtree, left, right);"
      },
      {
        "txt": "default: return subtree; } } private Node tryFoldTypeof(Node originalTypeofNode) { Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF); Node argumentNode = originalTypeofNode.getFirstChild(); if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) { return originalTypeofNode; }"
      },
      {
        "txt": "String typeNameString = null; switch (argumentNode.getType()) { case Token.STRING: typeNameString = \"string\"; break; case Token.NUMBER: typeNameString = \"number\"; break; case Token.TRUE: case Token.FALSE:"
      },
      {
        "txt": "break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: typeNameString = \"object\"; break; <extra_id_0> if (\"undefined\".equals(argumentNode.getString())) { typeNameString = \"undefined\"; } break; } if (typeNameString != null) {"
      },
      {
        "txt": "} if (typeNameString != null) { Node newNode = Node.newString(typeNameString); originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode); reportCodeChange(); return newNode; } return originalTypeofNode; } private Node tryFoldUnaryOperator(Node n) {"
      },
      {
        "txt": "Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, n.removeFirstChild()); reportCodeChange(); return null;"
      },
      {
        "txt": "} TernaryValue leftVal = NodeUtil.getBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT: int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode);"
      },
      {
        "txt": "reportCodeChange(); return replacementNode; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) { return n; } else if (left.getString().equals(\"NaN\")) { n.removeChild(left); parent.replaceChild(n, left);"
      },
      {
        "txt": "reportCodeChange(); return left; } } double negNum = -left.getDouble(); Node negNumNode = Node.newNumber(negNum); parent.replaceChild(n, negNumNode); reportCodeChange(); return negNumNode; } catch (UnsupportedOperationException ex) {"
      },
      {
        "txt": "error(NEGATING_A_NON_NUMBER_ERROR, left); return n; } case Token.BITNOT: try { double val = left.getDouble(); if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val; if (intVal == val) { Node notIntValNode = Node.newNumber(~intVal);"
      },
      {
        "txt": "parent.replaceChild(n, notIntValNode); reportCodeChange(); return notIntValNode; } else { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } } else { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n;"
      },
      {
        "txt": "} } catch (UnsupportedOperationException ex) { error(NEGATING_A_NON_NUMBER_ERROR, left); return n; } default: return n; } } private Node tryFoldInstanceof(Node n, Node left, Node right) {"
      },
      {
        "txt": "Preconditions.checkArgument(n.getType() == Token.INSTANCEOF); if (NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) { Node replacementNode = null; if (NodeUtil.isImmutableValue(left)) { replacementNode = new Node(Token.FALSE); } else if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) { replacementNode = new Node(Token.TRUE); }"
      },
      {
        "txt": "if (replacementNode != null) { n.getParent().replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; } } return n; } private Node tryFoldAssign(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN);"
      },
      {
        "txt": "if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return n; } if (NodeUtil.mayHaveSideEffects(left)) { return n; } Node leftChild = right.getFirstChild(); if (!areNodesEqualForInlining(left, leftChild)) { return n;"
      },
      {
        "txt": "} int newType = -1; switch (right.getType()) { case Token.ADD: newType = Token.ASSIGN_ADD; break; case Token.BITAND: newType = Token.ASSIGN_BITAND; break; case Token.BITOR:"
      },
      {
        "txt": "newType = Token.ASSIGN_BITOR; break; case Token.BITXOR: newType = Token.ASSIGN_BITXOR; break; case Token.DIV: newType = Token.ASSIGN_DIV; break; case Token.LSH: newType = Token.ASSIGN_LSH;"
      },
      {
        "txt": "break; case Token.MOD: newType = Token.ASSIGN_MOD; break; case Token.MUL: newType = Token.ASSIGN_MUL; break; case Token.RSH: newType = Token.ASSIGN_RSH; break;"
      },
      {
        "txt": "case Token.SUB: newType = Token.ASSIGN_SUB; break; case Token.URSH: newType = Token.ASSIGN_URSH; break; default: return n; } Node newNode = new Node(newType,"
      },
      {
        "txt": "left.detachFromParent(), right.getLastChild().detachFromParent()); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } private Node tryFoldAndOr(Node n, Node left, Node right) { Node parent = n.getParent(); Node result = null; int type = n.getType(); TernaryValue leftVal = NodeUtil.getBooleanValue(left);"
      },
      {
        "txt": "if (leftVal != TernaryValue.UNKNOWN) { boolean lval = leftVal.toBoolean(true); if (lval && type == Token.OR || !lval && type == Token.AND) { result = left; } else { result = right; } } else { TernaryValue rightVal = NodeUtil.getBooleanValue(right);"
      },
      {
        "txt": "if (rightVal != TernaryValue.UNKNOWN) { int pt = parent.getType(); if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) { boolean rval = rightVal.toBoolean(true); if (type == Token.OR && !rval || type == Token.AND && rval) { result = left; } else {"
      },
      {
        "txt": "if (!NodeUtil.mayHaveSideEffects(left)) { result = right; } } } } } if (result != null) { n.removeChild(result); parent.replaceChild(n, result);"
      },
      {
        "txt": "reportCodeChange(); return result; } else { return n; } } private Node tryFoldLeftChildAdd(Node n, Node left, Node right) { if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) {"
      },
      {
        "txt": "Node ll = left.getFirstChild(); Node lr = ll.getNext(); if (lr.getType() != Token.STRING) { return n; } String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { left.removeChild(ll); String result = leftString + rightString;"
      },
      {
        "txt": "n.replaceChild(left, ll); n.replaceChild(right, Node.newString(result)); reportCodeChange(); } } return n; } private Node tryFoldAddConstant(Node n, Node left, Node right) { if (left.getType() == Token.STRING || right.getType() == Token.STRING) {"
      },
      {
        "txt": "String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { Node newStringNode = Node.newString(leftString + rightString); n.getParent().replaceChild(n, newStringNode); reportCodeChange(); return newStringNode; } } else { return tryFoldArithmetic(n, left, right);"
      },
      {
        "txt": "} return n; } private Node tryFoldArithmetic(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); switch (n.getType()) {"
      },
      {
        "txt": "case Token.ADD: result = lval + rval; break; case Token.SUB: result = lval - rval; break; case Token.MUL: result = lval * rval; break; case Token.DIV:"
      },
      {
        "txt": "if (rval == 0) { error(DIVIDE_BY_0_ERROR, right); return n; } result = lval / rval; break; default: throw new Error(\"Unknown arithmetic operator\"); } if (String.valueOf(result).length() <="
      },
      {
        "txt": "String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && Math.abs(result) <= MAX_FOLD_NUMBER) { Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } } return n; }"
      },
      {
        "txt": "private Node tryFoldAdd(Node node, Node left, Node right) { Preconditions.checkArgument(node.getType() == Token.ADD); if (NodeUtil.isLiteralValue(left) && NodeUtil.isLiteralValue(right)) { return tryFoldAddConstant(node, left, right); } else { return tryFoldLeftChildAdd(node, left, right); } } private Node tryFoldBitAndOr(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.BITAND"
      },
      {
        "txt": "|| n.getType() == Token.BITOR); if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double resultDouble; double lval = left.getDouble(); double rval = right.getDouble(); if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) { return n; }"
      },
      {
        "txt": "int lvalInt = (int) lval; if (lvalInt != lval) { return n; } int rvalInt = (int) rval; if (rvalInt != rval) { return n; } switch (n.getType()) { case Token.BITAND:"
      },
      {
        "txt": "resultDouble = lvalInt & rvalInt; break; case Token.BITOR: resultDouble = lvalInt | rvalInt; break; default: throw new Error(\"Unknown bitwise operator\"); } Node newNumber = Node.newNumber(resultDouble); n.getParent().replaceChild(n, newNumber);"
      },
      {
        "txt": "reportCodeChange(); } return n; } private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble();"
      },
      {
        "txt": "if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt != lval) {"
      },
      {
        "txt": "error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt != rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH:"
      },
      {
        "txt": "result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: result = lvalInt >>> rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" +"
      },
      {
        "txt": "Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } @SuppressWarnings(\"fallthrough\")"
      },
      {
        "txt": "private Node tryFoldComparison(Node n, Node left, Node right) { if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) { if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } } int op = n.getType(); boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right); boolean undefinedRight = ((Token.NAME == right.getType()"
      },
      {
        "txt": "&& right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild()))); switch (left.getType()) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild())) { return n; } else if (!rightLiteral) { return n; } else {"
      },
      {
        "txt": "boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ: result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ:"
      },
      {
        "txt": "result = undefinedRight; break; case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false;"
      },
      {
        "txt": "break; default: return n; } } break; case Token.NULL: if (undefinedRight) { result = (op == Token.EQ); break;"
      },
      {
        "txt": "} case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = false; break; } case Token.THIS: int tt = right.getType(); if (tt != Token.THIS &&"
      },
      {
        "txt": "tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = left.getType() == right.getType(); break;"
      },
      {
        "txt": "case Token.SHNE: case Token.NE: result = left.getType() != right.getType(); break; default: return n; // we only handle == and != here } break; case Token.STRING: if (undefinedRight) {"
      },
      {
        "txt": "result = false; break; } if (Token.STRING != right.getType()) { return n; // Only eval if they are the same type } switch (op) { case Token.SHEQ: case Token.EQ: result = left.getString().equals(right.getString());"
      },
      {
        "txt": "break; case Token.SHNE: case Token.NE: result = !left.getString().equals(right.getString()); break; default: return n; // we only handle == and != here } break; case Token.NUMBER:"
      },
      {
        "txt": "if (undefinedRight) { result = false; break; } if (Token.NUMBER != right.getType()) { return n; // Only eval if they are the same type } double lv = left.getDouble(); double rv = right.getDouble(); switch (op) {"
      },
      {
        "txt": "case Token.SHEQ: case Token.EQ: result = lv == rv; break; case Token.SHNE: case Token.NE: result = lv != rv; break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break; case Token.GT: result = lv > rv; break; default: return n; // don't handle that op"
      },
      {
        "txt": "} break; case Token.NAME: if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ:"
      },
      {
        "txt": "result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break; case Token.SHNE: result = !undefinedRight;"
      },
      {
        "txt": "break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break; default: return n; }"
      },
      {
        "txt": "break; } } if (Token.NAME != right.getType()) { return n; // Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return n; // Not the same value name."
      },
      {
        "txt": "} switch (op) { case Token.LT: case Token.GT: result = false; break; default: return n; // don't handle that op } break;"
      },
      {
        "txt": "default: return n; } Node newNode = new Node(result ? Token.TRUE : Token.FALSE); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } private Node tryFoldKnownMethods(Node subtree) { subtree = tryFoldStringJoin(subtree);"
      },
      {
        "txt": "if (subtree.getType() == Token.CALL) { subtree = tryFoldStringIndexOf(subtree); } return subtree; } private Node tryFoldStringIndexOf(Node n) { Preconditions.checkArgument(n.getType() == Token.CALL); Node left = n.getFirstChild(); if (left == null) { return n;"
      },
      {
        "txt": "} Node right = left.getNext(); if (right == null) { return n; } if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return n; } Node lstringNode = left.getFirstChild(); Node functionName = lstringNode.getNext();"
      },
      {
        "txt": "if ((lstringNode.getType() != Token.STRING) || (!functionName.getString().equals(\"indexOf\") && !functionName.getString().equals(\"lastIndexOf\"))) { return n; } String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.getString().equals(\"indexOf\"); Node firstArg = right; Node secondArg = right.getNext(); String searchValue = NodeUtil.getStringValue(firstArg);"
      },
      {
        "txt": "if (searchValue == null) { return n; } int fromIndex = isIndexOf ? 0 : lstring.length(); if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) { return n; } else { fromIndex = (int) secondArg.getDouble();"
      },
      {
        "txt": "} } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex); Node newNode = Node.newNumber(indexVal); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } private Node tryFoldStringJoin(Node n) {"
      },
      {
        "txt": "Node left = n.getFirstChild(); if (left == null) { return n; } Node right = left.getNext(); if (right == null) { return n; } if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return n;"
      },
      {
        "txt": "} Node arrayNode = left.getFirstChild(); Node functionName = arrayNode.getNext(); if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) { return n; } String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = null;"
      },
      {
        "txt": "int foldedSize = 0; Node prev = null; Node elem = arrayNode.getFirstChild(); while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb == null) { sb = new StringBuilder(); } else { sb.append(joinString); }"
      },
      {
        "txt": "sb.append(NodeUtil.getStringValue(elem)); } else { if (sb != null) { Preconditions.checkNotNull(prev); foldedSize += sb.length() + 2; arrayFoldedChildren.add( Node.newString(sb.toString()).copyInformationFrom(prev)); sb = null; } foldedSize += InlineCostEstimator.getCost(elem);"
      },
      {
        "txt": "arrayFoldedChildren.add(elem); } prev = elem; elem = elem.getNext(); } if (sb != null) { Preconditions.checkNotNull(prev); foldedSize += sb.length() + 2; arrayFoldedChildren.add( Node.newString(sb.toString()).copyInformationFrom(prev));"
      },
      {
        "txt": "} foldedSize += arrayFoldedChildren.size() - 1; int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0: Node emptyStringNode = Node.newString(\"\"); n.getParent().replaceChild(n, emptyStringNode); reportCodeChange(); return emptyStringNode; case 1:"
      },
      {
        "txt": "Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) { return n; } arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) { Node replacement = new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode); foldedStringNode = replacement;"
      },
      {
        "txt": "} n.getParent().replaceChild(n, foldedStringNode); reportCodeChange(); return foldedStringNode; default: if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { return n; } int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead;"
      },
      {
        "txt": "foldedSize += InlineCostEstimator.getCost(right); if (foldedSize > originalSize) { return n; } arrayNode.detachChildren(); for (Node node : arrayFoldedChildren) { arrayNode.addChildToBack(node); } reportCodeChange(); break;"
      },
      {
        "txt": "} return n; } private Node tryFoldGetElem(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.GETELEM); if (left.getType() == Token.ARRAYLIT) { if (right.getType() != Token.NUMBER) { return n; } double index = right.getDouble();"
      },
      {
        "txt": "int intIndex = (int) index; if (intIndex != index) { error(INVALID_GETELEM_INDEX_ERROR, right); return n; } if (intIndex < 0) { error(INDEX_OUT_OF_BOUNDS_ERROR, right); return n; } Node elem = left.getFirstChild();"
      },
      {
        "txt": "for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext(); } if (elem == null) { error(INDEX_OUT_OF_BOUNDS_ERROR, right); return n; } left.removeChild(elem); n.getParent().replaceChild(n, elem); reportCodeChange();"
      },
      {
        "txt": "return elem; } return n; } private Node tryFoldGetProp(Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.GETPROP); if (right.getType() == Token.STRING && right.getString().equals(\"length\")) { int knownLength = -1; switch (left.getType()) {"
      },
      {
        "txt": "case Token.ARRAYLIT: if (NodeUtil.mayHaveSideEffects(left)) { return n; } knownLength = left.getChildCount(); break; case Token.STRING: knownLength = left.getString().length(); break; default:"
      },
      {
        "txt": "return n; } Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); n.getParent().replaceChild(n, lengthNode); reportCodeChange(); return lengthNode; } return n; }"
      }
    ]
  },
  {
    "id": 588,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 41,
    "end-bug-line": 41,
    "bug": "",
    "fix": "private final static int UNMAPPED = -1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { <extra_id_0> static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition;"
      },
      {
        "txt": "Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex()));"
      },
      {
        "txt": "if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; }"
      },
      {
        "txt": "String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno());"
      },
      {
        "txt": "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; }"
      },
      {
        "txt": "if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping);"
      },
      {
        "txt": "} void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++;"
      },
      {
        "txt": "} } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0);"
      },
      {
        "txt": "prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) {"
      },
      {
        "txt": "out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out;"
      },
      {
        "txt": "private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty());"
      },
      {
        "txt": "openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m);"
      },
      {
        "txt": "} while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true;"
      },
      {
        "txt": "} private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); }"
      },
      {
        "txt": "out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex();"
      },
      {
        "txt": "} private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED;"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine();"
      },
      {
        "txt": "} line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 589,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 50,
    "end-bug-line": 50,
    "bug": "int id;",
    "fix": "int id = UNMAPPED;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { <extra_id_0> String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\");"
      },
      {
        "txt": "out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value);"
      },
      {
        "txt": "} private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\""
      },
      {
        "txt": "lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) {"
      },
      {
        "txt": "mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0;"
      },
      {
        "txt": "} mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) {"
      },
      {
        "txt": "int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } }"
      },
      {
        "txt": "prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); }"
      },
      {
        "txt": "private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine();"
      },
      {
        "txt": "out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); }"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 590,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 85,
    "end-bug-line": 85,
    "bug": "",
    "fix": "boolean used = false; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap {"
      },
      {
        "txt": "int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; <extra_id_0> void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\");"
      },
      {
        "txt": "out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } }"
      },
      {
        "txt": "private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);"
      },
      {
        "txt": "if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping();"
      },
      {
        "txt": "mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex();"
      },
      {
        "txt": "if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition ="
      },
      {
        "txt": "new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++;"
      },
      {
        "txt": "prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); }"
      },
      {
        "txt": "void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine);"
      },
      {
        "txt": "} return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\");"
      },
      {
        "txt": "(new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); }"
      },
      {
        "txt": "} private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out;"
      },
      {
        "txt": "} void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); }"
      },
      {
        "txt": "private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false;"
      },
      {
        "txt": "} else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber();"
      },
      {
        "txt": "int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2;"
      },
      {
        "txt": "} private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);"
      },
      {
        "txt": "if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break;"
      },
      {
        "txt": "} closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 591,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 86,
    "end-bug-line": 86,
    "bug": "",
    "fix": "private class MappingWriter {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap {"
      },
      {
        "txt": "int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; <extra_id_0> void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\");"
      },
      {
        "txt": "out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } }"
      },
      {
        "txt": "private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);"
      },
      {
        "txt": "if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping();"
      },
      {
        "txt": "mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex();"
      },
      {
        "txt": "if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition ="
      },
      {
        "txt": "new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++;"
      },
      {
        "txt": "prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); }"
      },
      {
        "txt": "void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine);"
      },
      {
        "txt": "} return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\");"
      },
      {
        "txt": "(new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); }"
      },
      {
        "txt": "} private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out;"
      },
      {
        "txt": "} void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); }"
      },
      {
        "txt": "private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false;"
      },
      {
        "txt": "} else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber();"
      },
      {
        "txt": "int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2;"
      },
      {
        "txt": "} private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);"
      },
      {
        "txt": "if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break;"
      },
      {
        "txt": "} closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 592,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 89,
    "end-bug-line": 89,
    "bug": "",
    "fix": "private String lastSourceFile = null; private String lastSourceFileEscaped = null; private int lastLine = 0; private String lastLineString = String.valueOf(0);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap {"
      },
      {
        "txt": "int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; <extra_id_0> void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\");"
      },
      {
        "txt": "out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } }"
      },
      {
        "txt": "private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);"
      },
      {
        "txt": "if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping();"
      },
      {
        "txt": "mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex();"
      },
      {
        "txt": "if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition ="
      },
      {
        "txt": "new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++;"
      },
      {
        "txt": "prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); }"
      },
      {
        "txt": "void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine);"
      },
      {
        "txt": "} return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\");"
      },
      {
        "txt": "(new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); }"
      },
      {
        "txt": "} private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out;"
      },
      {
        "txt": "} void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); }"
      },
      {
        "txt": "private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false;"
      },
      {
        "txt": "} else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber();"
      },
      {
        "txt": "int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2;"
      },
      {
        "txt": "} private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);"
      },
      {
        "txt": "if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break;"
      },
      {
        "txt": "} closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 593,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 93,
    "end-bug-line": 93,
    "bug": "void appendTo(Appendable out) throws IOException {",
    "fix": "private void appendMappingTo( Mapping m, Appendable out) throws IOException {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap {"
      },
      {
        "txt": "int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; <extra_id_0> out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex()));"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList();"
      },
      {
        "txt": "private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) {"
      },
      {
        "txt": "return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size();"
      },
      {
        "txt": "mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0;"
      },
      {
        "txt": "} else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() {"
      },
      {
        "txt": "mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); }"
      },
      {
        "txt": "return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings();"
      },
      {
        "txt": "out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } }"
      },
      {
        "txt": "private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; }"
      },
      {
        "txt": "void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek();"
      },
      {
        "txt": "writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else {"
      },
      {
        "txt": "out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex();"
      },
      {
        "txt": "return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; }"
      },
      {
        "txt": "private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) {"
      },
      {
        "txt": "return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; }"
      },
      {
        "txt": "closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 594,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 96,
    "end-bug-line": 96,
    "bug": "out.append(sourceFile);",
    "fix": "String sourceFile = m.sourceFile;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id;"
      },
      {
        "txt": "Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); <extra_id_0> out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\");"
      },
      {
        "txt": "if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; }"
      },
      {
        "txt": "String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno());"
      },
      {
        "txt": "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; }"
      },
      {
        "txt": "if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping);"
      },
      {
        "txt": "} void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++;"
      },
      {
        "txt": "} } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0);"
      },
      {
        "txt": "prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) {"
      },
      {
        "txt": "out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out;"
      },
      {
        "txt": "private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty());"
      },
      {
        "txt": "openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m);"
      },
      {
        "txt": "} while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true;"
      },
      {
        "txt": "} private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); }"
      },
      {
        "txt": "out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex();"
      },
      {
        "txt": "} private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED;"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine();"
      },
      {
        "txt": "} line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 595,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 98,
    "end-bug-line": 98,
    "bug": "",
    "fix": "String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2) lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile;"
      },
      {
        "txt": "Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); <extra_id_0> out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\");"
      },
      {
        "txt": "if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; }"
      },
      {
        "txt": "String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno());"
      },
      {
        "txt": "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; }"
      },
      {
        "txt": "if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping);"
      },
      {
        "txt": "} void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++;"
      },
      {
        "txt": "} } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0);"
      },
      {
        "txt": "prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) {"
      },
      {
        "txt": "out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out;"
      },
      {
        "txt": "private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty());"
      },
      {
        "txt": "openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m);"
      },
      {
        "txt": "} while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true;"
      },
      {
        "txt": "} private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); }"
      },
      {
        "txt": "out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex();"
      },
      {
        "txt": "} private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED;"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine();"
      },
      {
        "txt": "} line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 596,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 99,
    "end-bug-line": 99,
    "bug": "",
    "fix": "out.append(escapedSourceFile);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile;"
      },
      {
        "txt": "Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); <extra_id_0> out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName);"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }"
      },
      {
        "txt": "while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; }"
      },
      {
        "txt": "private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id);"
      },
      {
        "txt": "} private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); }"
      },
      {
        "txt": "private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition);"
      },
      {
        "txt": "if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id);"
      },
      {
        "txt": "} private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);"
      },
      {
        "txt": "for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }"
      },
      {
        "txt": "line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 597,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 101,
    "end-bug-line": 101,
    "bug": "",
    "fix": "int line = m.originalPosition.getLineNumber(); if (line != lastLine) { lastLineString = String.valueOf(line); } String lineValue = lastLineString;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); <extra_id_0> out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName);"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }"
      },
      {
        "txt": "while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; }"
      },
      {
        "txt": "private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id);"
      },
      {
        "txt": "} private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); }"
      },
      {
        "txt": "private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition);"
      },
      {
        "txt": "if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id);"
      },
      {
        "txt": "} private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);"
      },
      {
        "txt": "for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }"
      },
      {
        "txt": "line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 598,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 102,
    "end-bug-line": 102,
    "bug": "out.append(String.valueOf(originalPosition.getLineNumber()));",
    "fix": "out.append(lineValue);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); <extra_id_0> out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value);"
      },
      {
        "txt": "} private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\""
      },
      {
        "txt": "lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) {"
      },
      {
        "txt": "mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0;"
      },
      {
        "txt": "} mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) {"
      },
      {
        "txt": "int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } }"
      },
      {
        "txt": "prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); }"
      },
      {
        "txt": "private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine();"
      },
      {
        "txt": "out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); }"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 599,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 105,
    "end-bug-line": 105,
    "bug": "out.append(String.valueOf(originalPosition.getCharacterIndex()));",
    "fix": "out.append(String.valueOf( m.originalPosition.getCharacterIndex()));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition;"
      },
      {
        "txt": "void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); <extra_id_0> if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {"
      },
      {
        "txt": "Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m);"
      },
      {
        "txt": "} closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); }"
      },
      {
        "txt": "private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber();"
      },
      {
        "txt": "} private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber();"
      },
      {
        "txt": "int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); }"
      },
      {
        "txt": "} private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id)"
      },
      {
        "txt": "throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) {"
      },
      {
        "txt": "addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol; }"
      }
    ]
  },
  {
    "id": 600,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 107,
    "end-bug-line": 107,
    "bug": "if (originalName != null) {",
    "fix": "if (m.originalName != null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName;"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); <extra_id_0> out.append(\",\"); out.append(originalName); } out.append(\"]\"); } }"
      },
      {
        "txt": "} } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null;"
      },
      {
        "txt": "void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); }"
      },
      {
        "txt": "escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber();"
      },
      {
        "txt": "int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) {"
      },
      {
        "txt": "if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) {"
      },
      {
        "txt": "offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) {"
      },
      {
        "txt": "int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \");"
      },
      {
        "txt": "out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out);"
      },
      {
        "txt": "out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1;"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 601,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 109,
    "end-bug-line": 109,
    "bug": "out.append(originalName);",
    "fix": "out.append(escapeString(m.originalName));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\");"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); <extra_id_0> } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0);"
      },
      {
        "txt": "private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);"
      },
      {
        "txt": "if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping();"
      },
      {
        "txt": "mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex();"
      },
      {
        "txt": "if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition ="
      },
      {
        "txt": "new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++;"
      },
      {
        "txt": "prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); }"
      },
      {
        "txt": "void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine);"
      },
      {
        "txt": "} return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\");"
      },
      {
        "txt": "(new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); }"
      },
      {
        "txt": "} private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out;"
      },
      {
        "txt": "} void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); }"
      },
      {
        "txt": "private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false;"
      },
      {
        "txt": "} else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber();"
      },
      {
        "txt": "int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2;"
      },
      {
        "txt": "} private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);"
      },
      {
        "txt": "if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break;"
      },
      {
        "txt": "} closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 602,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 112,
    "end-bug-line": 112,
    "bug": "out.append(\"]\");",
    "fix": "out.append(\"]\\n\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping {"
      },
      {
        "txt": "int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\");"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } <extra_id_0> } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return;"
      },
      {
        "txt": "} String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile;"
      },
      {
        "txt": "mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0;"
      },
      {
        "txt": "} if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);"
      },
      {
        "txt": "mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else {"
      },
      {
        "txt": "prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList();"
      },
      {
        "txt": "offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber();"
      },
      {
        "txt": "} public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\");"
      },
      {
        "txt": "for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper {"
      },
      {
        "txt": "private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m);"
      },
      {
        "txt": "stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\");"
      },
      {
        "txt": "this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\");"
      },
      {
        "txt": "} out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0)"
      },
      {
        "txt": "? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition);"
      },
      {
        "txt": "int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return;"
      },
      {
        "txt": "} String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine();"
      },
      {
        "txt": "openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 603,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 114,
    "end-bug-line": 114,
    "bug": "",
    "fix": "",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile;"
      },
      {
        "txt": "Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\");"
      },
      {
        "txt": "if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } <extra_id_0> } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value);"
      },
      {
        "txt": "private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; }"
      },
      {
        "txt": "String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno());"
      },
      {
        "txt": "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; }"
      },
      {
        "txt": "if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping);"
      },
      {
        "txt": "} void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++;"
      },
      {
        "txt": "} } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0);"
      },
      {
        "txt": "prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) {"
      },
      {
        "txt": "out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out;"
      },
      {
        "txt": "private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty());"
      },
      {
        "txt": "openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m);"
      },
      {
        "txt": "} while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true;"
      },
      {
        "txt": "} private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); }"
      },
      {
        "txt": "out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex();"
      },
      {
        "txt": "} private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED;"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine();"
      },
      {
        "txt": "} line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 604,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 117,
    "end-bug-line": 117,
    "bug": "",
    "fix": "void appendMappings(Appendable out) throws IOException { for (Mapping m : mappings) { if (m.used) { appendMappingTo(m, out); } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile;"
      },
      {
        "txt": "Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\");"
      },
      {
        "txt": "if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } <extra_id_0> private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); }"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }"
      },
      {
        "txt": "while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; }"
      },
      {
        "txt": "private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id);"
      },
      {
        "txt": "} private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); }"
      },
      {
        "txt": "private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition);"
      },
      {
        "txt": "if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id);"
      },
      {
        "txt": "} private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);"
      },
      {
        "txt": "for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }"
      },
      {
        "txt": "line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 605,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 143,
    "end-bug-line": 144,
    "bug": "private String lastSourceFile = null; private String lastSourceFileEscaped = null;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap {"
      },
      {
        "txt": "static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile);"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); }"
      },
      {
        "txt": "private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } <extra_id_0> void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "} String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile;"
      },
      {
        "txt": "mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0;"
      },
      {
        "txt": "} if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);"
      },
      {
        "txt": "mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else {"
      },
      {
        "txt": "prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList();"
      },
      {
        "txt": "offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber();"
      },
      {
        "txt": "} public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\");"
      },
      {
        "txt": "for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper {"
      },
      {
        "txt": "private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m);"
      },
      {
        "txt": "stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\");"
      },
      {
        "txt": "this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\");"
      },
      {
        "txt": "} out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0)"
      },
      {
        "txt": "? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition);"
      },
      {
        "txt": "int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return;"
      },
      {
        "txt": "} String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine();"
      },
      {
        "txt": "openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 606,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 163,
    "end-bug-line": 168,
    "bug": "String escapedSourceFile; if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName;"
      },
      {
        "txt": "void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName);"
      },
      {
        "txt": "} out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); }"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } <extra_id_0> Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) {"
      },
      {
        "txt": "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; }"
      },
      {
        "txt": "if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping);"
      },
      {
        "txt": "} void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++;"
      },
      {
        "txt": "} } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0);"
      },
      {
        "txt": "prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) {"
      },
      {
        "txt": "out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out;"
      },
      {
        "txt": "private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty());"
      },
      {
        "txt": "openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m);"
      },
      {
        "txt": "} while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true;"
      },
      {
        "txt": "} private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); }"
      },
      {
        "txt": "out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex();"
      },
      {
        "txt": "} private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED;"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine();"
      },
      {
        "txt": "} line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 607,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 171,
    "end-bug-line": 172,
    "bug": "mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile;",
    "fix": "mapping.sourceFile = sourceFile;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition;"
      },
      {
        "txt": "Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex()));"
      },
      {
        "txt": "if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; }"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); <extra_id_0> mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber();"
      },
      {
        "txt": "} int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; }"
      },
      {
        "txt": "mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0;"
      },
      {
        "txt": "int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex);"
      },
      {
        "txt": "} void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() {"
      },
      {
        "txt": "int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");"
      },
      {
        "txt": "out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\");"
      },
      {
        "txt": "for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true;"
      },
      {
        "txt": "private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) {"
      },
      {
        "txt": "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\");"
      },
      {
        "txt": "} private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) {"
      },
      {
        "txt": "return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber();"
      },
      {
        "txt": "int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id);"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo("
      },
      {
        "txt": "int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 608,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 177,
    "end-bug-line": 177,
    "bug": "mapping.originalName = escapeString(originalName);",
    "fix": "mapping.originalName = originalName;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\");"
      },
      {
        "txt": "out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\");"
      },
      {
        "txt": "} } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null;"
      },
      {
        "txt": "void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); }"
      },
      {
        "txt": "Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { <extra_id_0> } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0;"
      },
      {
        "txt": "if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition ="
      },
      {
        "txt": "new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++;"
      },
      {
        "txt": "prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); }"
      },
      {
        "txt": "void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine);"
      },
      {
        "txt": "} return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\");"
      },
      {
        "txt": "(new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); }"
      },
      {
        "txt": "} private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out;"
      },
      {
        "txt": "} void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); }"
      },
      {
        "txt": "private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false;"
      },
      {
        "txt": "} else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber();"
      },
      {
        "txt": "int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2;"
      },
      {
        "txt": "} private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);"
      },
      {
        "txt": "if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break;"
      },
      {
        "txt": "} closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 609,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 180,
    "end-bug-line": 180,
    "bug": "",
    "fix": "if (offsetPosition.getLineNumber() == 0 && offsetPosition.getCharacterIndex() == 0) { mapping.startPosition = startPosition; mapping.endPosition = endPosition; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping {"
      },
      {
        "txt": "int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\");"
      },
      {
        "txt": "out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } }"
      },
      {
        "txt": "private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);"
      },
      {
        "txt": "if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping();"
      },
      {
        "txt": "mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } <extra_id_0> int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; }"
      },
      {
        "txt": "startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0;"
      },
      {
        "txt": "} else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() {"
      },
      {
        "txt": "mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); }"
      },
      {
        "txt": "return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings();"
      },
      {
        "txt": "out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } }"
      },
      {
        "txt": "private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; }"
      },
      {
        "txt": "void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek();"
      },
      {
        "txt": "writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else {"
      },
      {
        "txt": "out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex();"
      },
      {
        "txt": "return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; }"
      },
      {
        "txt": "private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) {"
      },
      {
        "txt": "return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; }"
      },
      {
        "txt": "closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 610,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 203,
    "end-bug-line": 203,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition;"
      },
      {
        "txt": "String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\");"
      },
      {
        "txt": "out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value);"
      },
      {
        "txt": "} private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\""
      },
      {
        "txt": "lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) {"
      },
      {
        "txt": "mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0;"
      },
      {
        "txt": "mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); <extra_id_0> mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) {"
      },
      {
        "txt": "int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex);"
      },
      {
        "txt": "} void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() {"
      },
      {
        "txt": "int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");"
      },
      {
        "txt": "out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\");"
      },
      {
        "txt": "for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true;"
      },
      {
        "txt": "private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) {"
      },
      {
        "txt": "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\");"
      },
      {
        "txt": "} private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) {"
      },
      {
        "txt": "return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber();"
      },
      {
        "txt": "int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id);"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo("
      },
      {
        "txt": "int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 611,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 257,
    "end-bug-line": 264,
    "bug": "private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\");"
      },
      {
        "txt": "out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\");"
      },
      {
        "txt": "} } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null;"
      },
      {
        "txt": "void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); }"
      },
      {
        "txt": "escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber();"
      },
      {
        "txt": "int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) {"
      },
      {
        "txt": "if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) {"
      },
      {
        "txt": "} void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } <extra_id_0> public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {"
      },
      {
        "txt": "Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m);"
      },
      {
        "txt": "} closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); }"
      },
      {
        "txt": "private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber();"
      },
      {
        "txt": "} private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber();"
      },
      {
        "txt": "int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); }"
      },
      {
        "txt": "} private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id)"
      },
      {
        "txt": "throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) {"
      },
      {
        "txt": "addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol; }"
      }
    ]
  },
  {
    "id": 612,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 304,
    "end-bug-line": 304,
    "bug": "int maxLine = findLastLine();",
    "fix": "int maxLine = prepMappings();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { <extra_id_0> out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings();"
      },
      {
        "txt": "out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\");"
      },
      {
        "txt": "} } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) {"
      },
      {
        "txt": "this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous);"
      },
      {
        "txt": "} Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine();"
      },
      {
        "txt": "} private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) {"
      },
      {
        "txt": "firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) {"
      },
      {
        "txt": "int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex();"
      },
      {
        "txt": "return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next)"
      },
      {
        "txt": "throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\");"
      },
      {
        "txt": "Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); }"
      },
      {
        "txt": "break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 613,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 326,
    "end-bug-line": 329,
    "bug": "for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); }",
    "fix": "(new MappingWriter()).appendMappings(out);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap {"
      },
      {
        "txt": "static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile);"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); }"
      },
      {
        "txt": "} private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) {"
      },
      {
        "txt": "String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped;"
      },
      {
        "txt": "Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex();"
      },
      {
        "txt": "int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);"
      },
      {
        "txt": "mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') {"
      },
      {
        "txt": "prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex);"
      },
      {
        "txt": "} void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber();"
      },
      {
        "txt": "maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1));"
      },
      {
        "txt": "(new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); <extra_id_0> } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true;"
      },
      {
        "txt": "private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }"
      },
      {
        "txt": "while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; }"
      },
      {
        "txt": "private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id);"
      },
      {
        "txt": "} private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); }"
      },
      {
        "txt": "private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition);"
      },
      {
        "txt": "if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id);"
      },
      {
        "txt": "} private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);"
      },
      {
        "txt": "for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }"
      },
      {
        "txt": "line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 614,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 335,
    "end-bug-line": 335,
    "bug": "",
    "fix": "private int prepMappings() throws IOException {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } <extra_id_0> private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 615,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 336,
    "end-bug-line": 336,
    "bug": "",
    "fix": "(new MappingTraversal()).traverse(new UsedMappingCheck());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } <extra_id_0> private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 616,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 338,
    "end-bug-line": 338,
    "bug": "",
    "fix": "int id = 0; int maxLine = 0; for (Mapping m : mappings) { if (m.used) { m.id = id++; int endPositionLine = m.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } <extra_id_0> private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 617,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 340,
    "end-bug-line": 340,
    "bug": "",
    "fix": "return maxLine + prefixPosition.getLineNumber(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } <extra_id_0> private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 618,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 341,
    "end-bug-line": 341,
    "bug": "private class LineMapper {",
    "fix": "private class LineMapper implements MappingVisitor {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } <extra_id_0> private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1;"
      },
      {
        "txt": "private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) {"
      },
      {
        "txt": "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\");"
      },
      {
        "txt": "} private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) {"
      },
      {
        "txt": "return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber();"
      },
      {
        "txt": "int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id);"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo("
      },
      {
        "txt": "int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 619,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 344,
    "end-bug-line": 345,
    "bug": "private int line; private int col;",
    "fix": "",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName;"
      },
      {
        "txt": "void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName);"
      },
      {
        "txt": "} out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); }"
      },
      {
        "txt": "private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile;"
      },
      {
        "txt": "lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName);"
      },
      {
        "txt": "} int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; }"
      },
      {
        "txt": "mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0;"
      },
      {
        "txt": "int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex);"
      },
      {
        "txt": "} void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() {"
      },
      {
        "txt": "int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");"
      },
      {
        "txt": "out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\");"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; <extra_id_0> private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; }"
      },
      {
        "txt": "this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous);"
      },
      {
        "txt": "} Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine();"
      },
      {
        "txt": "} private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) {"
      },
      {
        "txt": "firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) {"
      },
      {
        "txt": "int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex();"
      },
      {
        "txt": "return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next)"
      },
      {
        "txt": "throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\");"
      },
      {
        "txt": "Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); }"
      },
      {
        "txt": "break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 620,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 351,
    "end-bug-line": 351,
    "bug": "private final static int UNMAPPED = -1;",
    "fix": "private int lastId = UNMAPPED; private String lastIdString = UNMAPPED_STRING;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping {"
      },
      {
        "txt": "int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\");"
      },
      {
        "txt": "out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } }"
      },
      {
        "txt": "private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);"
      },
      {
        "txt": "if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping();"
      },
      {
        "txt": "mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex();"
      },
      {
        "txt": "if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition ="
      },
      {
        "txt": "new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++;"
      },
      {
        "txt": "prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); }"
      },
      {
        "txt": "void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine);"
      },
      {
        "txt": "} return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\");"
      },
      {
        "txt": "(new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); }"
      },
      {
        "txt": "private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; <extra_id_0> LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m);"
      },
      {
        "txt": "stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\");"
      },
      {
        "txt": "this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\");"
      },
      {
        "txt": "} out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0)"
      },
      {
        "txt": "? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException {"
      },
      {
        "txt": "int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition);"
      },
      {
        "txt": "int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return;"
      },
      {
        "txt": "} String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine();"
      },
      {
        "txt": "openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 621,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 360,
    "end-bug-line": 360,
    "bug": "",
    "fix": "public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } <extra_id_0> void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 622,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 361,
    "end-bug-line": 361,
    "bug": "",
    "fix": "int id = (m != null) ? m.id : UNMAPPED; if (lastId != id) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } <extra_id_0> void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 623,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 363,
    "end-bug-line": 363,
    "bug": "",
    "fix": "lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); lastId = id; } String idString = lastIdString;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } <extra_id_0> void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 624,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 364,
    "end-bug-line": 364,
    "bug": "",
    "fix": "for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } <extra_id_0> void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 625,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 365,
    "end-bug-line": 365,
    "bug": "",
    "fix": "closeLine(); openLine(); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } <extra_id_0> void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) {"
      },
      {
        "txt": "if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine;"
      },
      {
        "txt": "col = nextCol; } }"
      }
    ]
  },
  {
    "id": 626,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 373,
    "end-bug-line": 373,
    "bug": "",
    "fix": "(new MappingTraversal()).traverse(this);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 627,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 375,
    "end-bug-line": 375,
    "bug": "",
    "fix": "closeLine(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 628,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 379,
    "end-bug-line": 379,
    "bug": "",
    "fix": "private void openLine() throws IOException { if (out != null) { out.append(\"[\"); this.firstChar = true; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 629,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 383,
    "end-bug-line": 383,
    "bug": "",
    "fix": "private void closeLine() throws IOException { if (out != null) { out.append(\"]\\n\"); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 630,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 388,
    "end-bug-line": 388,
    "bug": "",
    "fix": "private void addCharEntry(String id) throws IOException { if (out != null) { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 631,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 392,
    "end-bug-line": 392,
    "bug": "",
    "fix": "private class UsedMappingCheck implements MappingVisitor {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 632,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 395,
    "end-bug-line": 395,
    "bug": "",
    "fix": "@Override public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { if (m != null) { m.used = true; } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 633,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 396,
    "end-bug-line": 396,
    "bug": "",
    "fix": "private interface MappingVisitor {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 634,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 405,
    "end-bug-line": 405,
    "bug": "",
    "fix": "void visit(Mapping m, int line, int col, int endLine, int endCol) throws IOException; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 635,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 410,
    "end-bug-line": 410,
    "bug": "",
    "fix": "private class MappingTraversal {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 636,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 411,
    "end-bug-line": 411,
    "bug": "",
    "fix": "private int line; private int col;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 637,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 412,
    "end-bug-line": 412,
    "bug": "",
    "fix": "MappingTraversal() { }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 638,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 414,
    "end-bug-line": 414,
    "bug": "",
    "fix": "void traverse(MappingVisitor v) throws IOException { Preconditions.checkState(!mappings.isEmpty());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque;"
      },
      {
        "txt": "import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); }"
      },
      {
        "txt": "out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null;"
      },
      {
        "txt": "private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile);"
      },
      {
        "txt": "} escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); }"
      },
      {
        "txt": "int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition ="
      },
      {
        "txt": "new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0;"
      },
      {
        "txt": "for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); }"
      },
      {
        "txt": "void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0;"
      },
      {
        "txt": "for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name));"
      },
      {
        "txt": "out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) {"
      },
      {
        "txt": "mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\";"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); <extra_id_0> Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); }"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 639,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 426,
    "end-bug-line": 426,
    "bug": "writeClosedMapping(previous);",
    "fix": "maybeVisit(v, previous);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id;"
      },
      {
        "txt": "String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber()));"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList();"
      },
      {
        "txt": "private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) {"
      },
      {
        "txt": "return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size();"
      },
      {
        "txt": "mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0;"
      },
      {
        "txt": "} else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() {"
      },
      {
        "txt": "mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); }"
      },
      {
        "txt": "return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings();"
      },
      {
        "txt": "out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } }"
      },
      {
        "txt": "private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; }"
      },
      {
        "txt": "Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); <extra_id_0> } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "} while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true;"
      },
      {
        "txt": "} private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); }"
      },
      {
        "txt": "out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex();"
      },
      {
        "txt": "} private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition);"
      },
      {
        "txt": "int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED;"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine();"
      },
      {
        "txt": "} line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 640,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 432,
    "end-bug-line": 432,
    "bug": "writeCharsBetween(parent, m);",
    "fix": "maybeVisitParent(v, parent, m);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); <extra_id_0> stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\");"
      },
      {
        "txt": "} private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) {"
      },
      {
        "txt": "return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber();"
      },
      {
        "txt": "int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id);"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo("
      },
      {
        "txt": "int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 641,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 441,
    "end-bug-line": 456,
    "bug": "writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\");",
    "fix": "maybeVisit(v, m);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap {"
      },
      {
        "txt": "static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile);"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); }"
      },
      {
        "txt": "} private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) {"
      },
      {
        "txt": "String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped;"
      },
      {
        "txt": "Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex();"
      },
      {
        "txt": "int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);"
      },
      {
        "txt": "mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') {"
      },
      {
        "txt": "prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex);"
      },
      {
        "txt": "} void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber();"
      },
      {
        "txt": "maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1));"
      },
      {
        "txt": "out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\");"
      },
      {
        "txt": "} } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) {"
      },
      {
        "txt": "this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous);"
      },
      {
        "txt": "Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); <extra_id_0> } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber();"
      },
      {
        "txt": "int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id);"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo("
      },
      {
        "txt": "int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 642,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 458,
    "end-bug-line": 458,
    "bug": "out.append(id);",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName;"
      },
      {
        "txt": "void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName);"
      },
      {
        "txt": "} out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); }"
      },
      {
        "txt": "private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile;"
      },
      {
        "txt": "lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName);"
      },
      {
        "txt": "} int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; }"
      },
      {
        "txt": "mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0;"
      },
      {
        "txt": "int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex);"
      },
      {
        "txt": "} void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() {"
      },
      {
        "txt": "int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");"
      },
      {
        "txt": "out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\");"
      },
      {
        "txt": "for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true;"
      },
      {
        "txt": "private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) {"
      },
      {
        "txt": "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\");"
      },
      {
        "txt": "private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } <extra_id_0> } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber();"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 643,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 496,
    "end-bug-line": 496,
    "bug": "private void writeClosedMapping(Mapping m) throws IOException {",
    "fix": "private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }"
      },
      {
        "txt": "while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; }"
      },
      {
        "txt": "private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id);"
      },
      {
        "txt": "} private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); }"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } <extra_id_0> int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo("
      },
      {
        "txt": "int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 644,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 502,
    "end-bug-line": 502,
    "bug": "writeCharsUpTo(nextLine, nextCol, m.id);",
    "fix": "visit(v, m, nextLine, nextCol);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\");"
      },
      {
        "txt": "out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\");"
      },
      {
        "txt": "} } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null;"
      },
      {
        "txt": "void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); }"
      },
      {
        "txt": "escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber();"
      },
      {
        "txt": "int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) {"
      },
      {
        "txt": "if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) {"
      },
      {
        "txt": "offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) {"
      },
      {
        "txt": "int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \");"
      },
      {
        "txt": "out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out);"
      },
      {
        "txt": "out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1;"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { <extra_id_0> } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition);"
      },
      {
        "txt": "int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);"
      },
      {
        "txt": "if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break;"
      },
      {
        "txt": "} closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 645,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 509,
    "end-bug-line": 509,
    "bug": "private void writeCharsBetween(Mapping prev, Mapping next)",
    "fix": "private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id;"
      },
      {
        "txt": "String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber()));"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList();"
      },
      {
        "txt": "private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) {"
      },
      {
        "txt": "return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size();"
      },
      {
        "txt": "mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0;"
      },
      {
        "txt": "} else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() {"
      },
      {
        "txt": "mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); }"
      },
      {
        "txt": "return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings();"
      },
      {
        "txt": "out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } }"
      },
      {
        "txt": "private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; }"
      },
      {
        "txt": "void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek();"
      },
      {
        "txt": "writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else {"
      },
      {
        "txt": "out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex();"
      },
      {
        "txt": "return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; }"
      },
      {
        "txt": "int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } <extra_id_0> throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); }"
      },
      {
        "txt": "writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine();"
      },
      {
        "txt": "} line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 646,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 511,
    "end-bug-line": 512,
    "bug": "int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition);",
    "fix": "int nextLine = getAdjustedLine(m.startPosition); int nextCol = getAdjustedCol(m.startPosition);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition;"
      },
      {
        "txt": "Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex()));"
      },
      {
        "txt": "if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; }"
      },
      {
        "txt": "String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno());"
      },
      {
        "txt": "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; }"
      },
      {
        "txt": "if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping);"
      },
      {
        "txt": "} void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++;"
      },
      {
        "txt": "} } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0);"
      },
      {
        "txt": "prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) {"
      },
      {
        "txt": "out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out;"
      },
      {
        "txt": "private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty());"
      },
      {
        "txt": "openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m);"
      },
      {
        "txt": "} while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true;"
      },
      {
        "txt": "} private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); }"
      },
      {
        "txt": "out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex();"
      },
      {
        "txt": "} private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition);"
      },
      {
        "txt": "if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { <extra_id_0> int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException {"
      },
      {
        "txt": "int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 647,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 514,
    "end-bug-line": 515,
    "bug": "int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id);",
    "fix": "Preconditions.checkState(line < nextLine || col <= nextCol); if (line < nextLine || (line == nextLine && col < nextCol)) { visit(v, parent, nextLine, nextCol); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition;"
      },
      {
        "txt": "String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\");"
      },
      {
        "txt": "out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value);"
      },
      {
        "txt": "} private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\""
      },
      {
        "txt": "lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) {"
      },
      {
        "txt": "mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0;"
      },
      {
        "txt": "} mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) {"
      },
      {
        "txt": "int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } }"
      },
      {
        "txt": "prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); }"
      },
      {
        "txt": "private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine();"
      },
      {
        "txt": "out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); }"
      },
      {
        "txt": "out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col;"
      },
      {
        "txt": "private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>();"
      },
      {
        "txt": "for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) {"
      },
      {
        "txt": "Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException {"
      },
      {
        "txt": "out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); }"
      },
      {
        "txt": "private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) {"
      },
      {
        "txt": "int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) {"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); <extra_id_0> } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);"
      },
      {
        "txt": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "} break; } closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 648,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 522,
    "end-bug-line": 523,
    "bug": "private void writeCharsUpTo( int nextLine, int nextCol, int id)",
    "fix": "private void visit(MappingVisitor v, Mapping m, int nextLine, int nextCol)",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List;"
      },
      {
        "txt": "public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\");"
      },
      {
        "txt": "out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\");"
      },
      {
        "txt": "} } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null;"
      },
      {
        "txt": "void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); }"
      },
      {
        "txt": "escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber();"
      },
      {
        "txt": "int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) {"
      },
      {
        "txt": "if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) {"
      },
      {
        "txt": "offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) {"
      },
      {
        "txt": "int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \");"
      },
      {
        "txt": "out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out);"
      },
      {
        "txt": "out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1;"
      },
      {
        "txt": "LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); }"
      },
      {
        "txt": "closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException {"
      },
      {
        "txt": "if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); }"
      },
      {
        "txt": "private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex();"
      },
      {
        "txt": "int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } }"
      },
      {
        "txt": "throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } <extra_id_0> throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; }"
      },
      {
        "txt": "return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; }"
      },
      {
        "txt": "closeLine(); openLine(); } line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 649,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 525,
    "end-bug-line": 526,
    "bug": "Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol);",
    "fix": "Preconditions.checkState(line <= nextLine); Preconditions.checkState(line < nextLine || col < nextCol);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id;"
      },
      {
        "txt": "String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber()));"
      },
      {
        "txt": "out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList();"
      },
      {
        "txt": "private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) {"
      },
      {
        "txt": "return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size();"
      },
      {
        "txt": "mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine,"
      },
      {
        "txt": "endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0;"
      },
      {
        "txt": "} else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() {"
      },
      {
        "txt": "mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); }"
      },
      {
        "txt": "return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings();"
      },
      {
        "txt": "out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } }"
      },
      {
        "txt": "private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; }"
      },
      {
        "txt": "void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek();"
      },
      {
        "txt": "writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException {"
      },
      {
        "txt": "out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else {"
      },
      {
        "txt": "out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex();"
      },
      {
        "txt": "return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; }"
      },
      {
        "txt": "private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition);"
      },
      {
        "txt": "int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { <extra_id_0> if (line == nextLine && col == nextCol) { return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) {"
      },
      {
        "txt": "for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }"
      },
      {
        "txt": "line = nextLine; col = nextCol; } }"
      }
    ]
  },
  {
    "id": 650,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 530,
    "end-bug-line": 530,
    "bug": "",
    "fix": "Preconditions.checkState(false);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import java.io.IOException; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition;"
      },
      {
        "txt": "Position endPosition; String originalName; void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) {"
      },
      {
        "txt": "out.append(\",\"); out.append(originalName); } out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) {"
      },
      {
        "txt": "return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile;"
      },
      {
        "txt": "if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);"
      },
      {
        "txt": "if (originalName != null) { mapping.originalName = escapeString(originalName); } int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) {"
      },
      {
        "txt": "endOffsetPosition = 0; } mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }"
      },
      {
        "txt": "void setWrapperPrefix(String prefix) { int prefixLine = 0; int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; }"
      },
      {
        "txt": "} prefixPosition = new Position(prefixLine, prefixIndex); } void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0);"
      },
      {
        "txt": "} private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException {"
      },
      {
        "txt": "int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \"); out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\");"
      },
      {
        "txt": "} out.append(\"/** Begin mapping definitions. **/\\n\"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line;"
      },
      {
        "txt": "private int col; private boolean firstChar = true; private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine();"
      },
      {
        "txt": "Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) { while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }"
      },
      {
        "txt": "while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; }"
      },
      {
        "txt": "private void closeLine() throws IOException { out.append(\"]\\n\"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id);"
      },
      {
        "txt": "} private int getAdjustedLine(Position p) { return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); }"
      },
      {
        "txt": "private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber(); int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition);"
      },
      {
        "txt": "if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id);"
      },
      {
        "txt": "private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { <extra_id_0> } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString);"
      },
      {
        "txt": "for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 651,
    "file_path": "src/com/google/javascript/jscomp/SourceMap.java",
    "start-bug-line": 533,
    "end-bug-line": 543,
    "bug": "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }",
    "fix": "v.visit(m, line, col, nextLine, nextCol);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import java.io.IOException; import java.util.ArrayDeque;"
      },
      {
        "txt": "import java.util.Deque; import java.util.List; public class SourceMap { static class Mapping { int id; String sourceFile; Position originalPosition; Position startPosition; Position endPosition; String originalName;"
      },
      {
        "txt": "void appendTo(Appendable out) throws IOException { out.append(\"[\"); out.append(sourceFile); out.append(\",\"); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(\",\"); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(\",\"); out.append(originalName);"
      },
      {
        "txt": "} out.append(\"]\"); } } private List<Mapping> mappings = Lists.newArrayList(); private Position offsetPosition = new Position(0, 0); private Position prefixPosition = new Position(0, 0); private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); }"
      },
      {
        "txt": "private String lastSourceFile = null; private String lastSourceFileEscaped = null; void addMapping(Node node, Position startPosition, Position endPosition) { String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP); if (sourceFile == null || node.getLineno() < 0) { return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, \"s1 != s2\" not \"!s1.equals(s2)\" lastSourceFile = sourceFile;"
      },
      {
        "txt": "lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName);"
      },
      {
        "txt": "} int offsetLine = offsetPosition.getLineNumber(); int startOffsetPosition = offsetPosition.getCharacterIndex(); int endOffsetPosition = offsetPosition.getCharacterIndex(); if (startPosition.getLineNumber() > 0) { startOffsetPosition = 0; } if (endPosition.getLineNumber() > 0) { endOffsetPosition = 0; }"
      },
      {
        "txt": "mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition); mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); } void setWrapperPrefix(String prefix) { int prefixLine = 0;"
      },
      {
        "txt": "int prefixIndex = 0; for (int i = 0; i < prefix.length(); ++i) { if (prefix.charAt(i) == '\\n') { prefixLine++; prefixIndex = 0; } else { prefixIndex++; } } prefixPosition = new Position(prefixLine, prefixIndex);"
      },
      {
        "txt": "} void setStartingPosition(int offsetLine, int offsetIndex) { offsetPosition = new Position(offsetLine, offsetIndex); } void reset() { mappings = Lists.newArrayList(); offsetPosition = new Position(0, 0); prefixPosition = new Position(0, 0); } private int findLastLine() {"
      },
      {
        "txt": "int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } public void appendTo(Appendable out, String name) throws IOException { int maxLine = findLastLine(); out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");"
      },
      {
        "txt": "out.append(escapeString(name)); out.append(\", \\\"count\\\": \"); out.append(String.valueOf(maxLine + 1)); out.append(\" }\\n\"); (new LineMapper(out)).appendLineMappings(); out.append(\"/** Begin file information. **/\\n\"); for (int i = 0; i <= maxLine; ++i) { out.append(\"[]\\n\"); } out.append(\"/** Begin mapping definitions. **/\\n\");"
      },
      {
        "txt": "for (Mapping mapping : mappings) { mapping.appendTo(out); out.append(\"\\n\"); } } private class LineMapper { private final Appendable out; private int line; private int col; private boolean firstChar = true;"
      },
      {
        "txt": "private final static String UNMAPPED_STRING = \"-1\"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out; } void appendLineMappings() throws IOException { Preconditions.checkState(!mappings.isEmpty()); openLine(); Deque<Mapping> stack = new ArrayDeque<Mapping>(); for (Mapping m : mappings) {"
      },
      {
        "txt": "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); } while (!stack.isEmpty()) { Mapping m = stack.pop();"
      },
      {
        "txt": "writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append(\"[\"); this.firstChar = true; } private void closeLine() throws IOException { out.append(\"]\\n\");"
      },
      {
        "txt": "} private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(\",\"); } out.append(id); } private int getAdjustedLine(Position p) {"
      },
      {
        "txt": "return p.getLineNumber() + prefixPosition.getLineNumber(); } private int getAdjustedCol(Position p) { int rawLine = p.getLineNumber(); int rawCol = p.getCharacterIndex(); return (rawLine != 0) ? rawCol : rawCol + prefixPosition.getCharacterIndex(); } private boolean isOverlapped(Mapping m1, Mapping m2) { int l1 = m1.endPosition.getLineNumber();"
      },
      {
        "txt": "int l2 = m2.startPosition.getLineNumber(); int c1 = m1.endPosition.getCharacterIndex(); int c2 = m2.startPosition.getCharacterIndex(); return (l1 == l2 && c1 >= c2) || l1 > l2; } private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id);"
      },
      {
        "txt": "} } private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } private void writeCharsUpTo("
      },
      {
        "txt": "throws IOException { Preconditions.checkState(line <= nextLine, \"\"); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { return; } <extra_id_0> line = nextLine; col = nextCol; } } }"
      }
    ]
  }
]