[
  {
    "id": 689,
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java",
    "start-bug-line": 199,
    "end-bug-line": 199,
    "bug": "",
    "fix": "boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior; import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class InlineVariables implements CompilerPass { private final AbstractCompiler compiler; enum Mode { CONSTANTS_ONLY, LOCALS_ONLY, ALL } private final Mode mode;"
      },
      {
        "txt": "private final boolean inlineAllStrings; private final IdentifyConstants identifyConstants = new IdentifyConstants(); InlineVariables( AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { this.compiler = compiler; this.mode = mode; this.inlineAllStrings = inlineAllStrings; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); callback.process(externs, root); } private Predicate<Var> getFilterForMode() { switch (mode) { case ALL: return Predicates.<Var>alwaysTrue();"
      },
      {
        "txt": "case LOCALS_ONLY: return new IdentifyLocals(); case CONSTANTS_ONLY: return new IdentifyConstants(); default: throw new IllegalStateException(); } } private class IdentifyConstants implements Predicate<Var> { @Override"
      },
      {
        "txt": "public boolean apply(Var var) { return var.isConst(); } } private class IdentifyLocals implements Predicate<Var> { @Override public boolean apply(Var var) { return var.scope.isLocal(); } }"
      },
      {
        "txt": "private static class AliasCandidate { private final Var alias; private final ReferenceCollection refInfo; AliasCandidate(Var alias, ReferenceCollection refInfo) { this.alias = alias; this.refInfo = refInfo; } } private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet();"
      },
      {
        "txt": "final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap(); @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { collectAliasCandidates(t, referenceMap); doInlinesForScope(t, referenceMap); } private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) {"
      },
      {
        "txt": "for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference(); Node value = init.getAssignedValue(); if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));"
      },
      {
        "txt": "} } } } private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { <extra_id_0> Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null || isVarInlineForbidden(v)) { continue; } else if (isInlineableDeclaredConstant(v, referenceInfo)) { Reference init = referenceInfo.getInitializingReferenceForConstants();"
      },
      {
        "txt": "} else if (isInlineableDeclaredConstant(v, referenceInfo)) { Reference init = referenceInfo.getInitializingReferenceForConstants(); Node value = init.getAssignedValue(); inlineDeclaredConstant(v, value, referenceInfo.references); staleVars.add(v); } else if (mode == Mode.CONSTANTS_ONLY) { continue; } else { inlineNonConstants(v, referenceInfo); }"
      },
      {
        "txt": "} } private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3; if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {"
      },
      {
        "txt": "Node value; if (init != null) { value = init.getAssignedValue(); } else { Node srcLocation = declaration.getNameNode(); value = NodeUtil.newUndefinedNode(srcLocation); } Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v);"
      },
      {
        "txt": "} else if (refCount == firstRefAfterInit) { Reference reference = referenceInfo.references.get( firstRefAfterInit - 1); if (canInline(declaration, init, reference)) { inline(v, declaration, init, reference); staleVars.add(v); } } else if (declaration != init && refCount == 2) { if (isValidDeclaration(declaration) && isValidInitialization(init)) { Node value = init.getAssignedValue();"
      },
      {
        "txt": "Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } } if ( !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) {"
      },
      {
        "txt": "Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) { AliasCandidate candidate = aliasCandidates.get(nameNode); if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { Reference aliasInit; aliasInit = candidate.refInfo.getInitializingReference(); Node value = aliasInit.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(candidate.alias,"
      },
      {
        "txt": "value, candidate.refInfo.references); staleVars.add(candidate.alias); } } } } } private void blacklistVarReferencesInTree(Node root, Scope scope) { for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "blacklistVarReferencesInTree(c, scope); } if (root.getType() == Token.NAME) { staleVars.add(scope.getVar(root.getString())); } } private boolean isVarInlineForbidden(Var var) { return compiler.getCodingConvention().isExported(var.name) || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var);"
      },
      {
        "txt": "} private void inline(Var v, Reference declaration, Reference init, Reference reference) { Node value = init.getAssignedValue(); Preconditions.checkState(value != null); boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value); inlineValue(v, reference, value.detachFromParent()); if (declaration != init) { Node expressRoot = init.getGrandparent(); Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT);"
      },
      {
        "txt": "NodeUtil.removeChild(expressRoot.getParent(), expressRoot); } if (!isFunctionDeclaration) { removeDeclaration(declaration); } else { compiler.reportCodeChange(); } } private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) {"
      },
      {
        "txt": "Reference decl = refSet.get(0); for (int i = 1; i < refSet.size(); i++) { inlineValue(v, refSet.get(i), value.cloneTree()); } removeDeclaration(decl); } private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) { Reference decl = null; for (Reference r : refSet) {"
      },
      {
        "txt": "if (r.getNameNode() == v.getNameNode()) { decl = r; } else { inlineValue(v, r, value.cloneTree()); } } removeDeclaration(decl); } private void removeDeclaration(Reference declaration) { Node varNode = declaration.getParent();"
      },
      {
        "txt": "varNode.removeChild(declaration.getNameNode()); if (!varNode.hasChildren()) { Preconditions.checkState(varNode.getType() == Token.VAR); Node grandparent = declaration.getGrandparent(); NodeUtil.removeChild(grandparent, varNode); } compiler.reportCodeChange(); } private void inlineValue(Var v, Reference ref, Node value) { if (ref.isSimpleAssignmentToName()) {"
      },
      {
        "txt": "ref.getGrandparent().replaceChild(ref.getParent(), value); } else { ref.getParent().replaceChild(ref.getNameNode(), value); } blacklistVarReferencesInTree(value, v.scope); compiler.reportCodeChange(); } private boolean isInlineableDeclaredConstant(Var var, ReferenceCollection refInfo) { if (!identifyConstants.apply(var)) {"
      },
      {
        "txt": "return false; } if (!refInfo.isAssignedOnceInLifetime()) { return false; } Reference init = refInfo.getInitializingReferenceForConstants(); if (init == null) { return false; } Node value = init.getAssignedValue();"
      },
      {
        "txt": "if (value == null) { return false; } if (!NodeUtil.isImmutableValue(value)) { return false; } return value.getType() != Token.STRING || isStringWorthInlining(var, refInfo.references); } private boolean isStringWorthInlining(Var var, List<Reference> refs) {"
      },
      {
        "txt": "if (!inlineAllStrings && !var.isDefine()) { int len = var.getInitialValue().getString().length() + \"''\".length(); int noInlineBytes = \"var xx=;\".length() + len + 4 * (refs.size() - 1); int inlineBytes = (len - 1) * (refs.size() - 1); return noInlineBytes >= inlineBytes; } return true; } private boolean canInline("
      },
      {
        "txt": "Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) { return false; } if (declaration != initialization && initialization.getGrandparent().getType() != Token.EXPR_RESULT) {"
      },
      {
        "txt": "return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.getType() == Token.GETPROP && reference.getParent().getType() == Token.CALL"
      },
      {
        "txt": "&& reference.getParent().getFirstChild() == reference.getNameNode()) { return false; } if (value.getType() == Token.FUNCTION) { Node callNode = reference.getParent(); if (reference.getParent().getType() == Token.CALL) { SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(callNode); if (relationship != null) { return false;"
      },
      {
        "txt": "} } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); } private boolean canMoveAggressively(Node value) { return NodeUtil.isLiteralValue(value, true) || value.getType() == Token.FUNCTION; }"
      },
      {
        "txt": "private boolean canMoveModerately( Reference initialization, Reference reference) { Iterator<Node> it; if (initialization.getParent().getType() == Token.VAR) { it = NodeIterators.LocalVarMotion.forVar( initialization.getNameNode(), // NAME initialization.getParent(), // VAR initialization.getGrandparent()); // VAR container } else if (initialization.getParent().getType() == Token.ASSIGN) {"
      },
      {
        "txt": "Preconditions.checkState( initialization.getGrandparent().getType() == Token.EXPR_RESULT); it = NodeIterators.LocalVarMotion.forAssign( initialization.getNameNode(), // NAME initialization.getParent(), // ASSIGN initialization.getGrandparent(), // EXPR_RESULT initialization.getGrandparent().getParent()); // EXPR container } else { throw new IllegalStateException(\"Unexpected initialization parent \" + initialization.getParent().toStringTree());"
      },
      {
        "txt": "} Node targetName = reference.getNameNode(); while (it.hasNext()) { Node curNode = it.next(); if (curNode == targetName) { return true; } } return false; }"
      },
      {
        "txt": "private boolean isValidDeclaration(Reference declaration) { return (declaration.getParent().getType() == Token.VAR && declaration.getGrandparent().getType() != Token.FOR) || NodeUtil.isFunctionDeclaration(declaration.getParent()); } private boolean isValidInitialization(Reference initialization) { if (initialization == null) { return false; } else if (initialization.isDeclaration()) { return NodeUtil.isFunctionDeclaration(initialization.getParent())"
      },
      {
        "txt": "|| initialization.getNameNode().getFirstChild() != null; } else { Node parent = initialization.getParent(); Preconditions.checkState( parent.getType() == Token.ASSIGN && parent.getFirstChild() == initialization.getNameNode()); return true; } } private boolean isValidReference(Reference reference) {"
      },
      {
        "txt": "return !reference.isDeclaration() && !reference.isLvalue(); } private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) { List<Reference> refSet = refInfo.references; int startingReadRef = 1; Reference refDecl = refSet.get(0); if (!isValidDeclaration(refDecl)) { return false; }"
      },
      {
        "txt": "boolean isNeverAssigned = refInfo.isNeverAssigned(); if (!isNeverAssigned) { Reference refInit = refInfo.getInitializingReference(); if (!isValidInitialization(refInit)) { return false; } if (refDecl != refInit) { Preconditions.checkState(refInit == refSet.get(1)); startingReadRef = 2; }"
      },
      {
        "txt": "if (!refInfo.isWellDefined()) { return false; } Node value = refInit.getAssignedValue(); Preconditions.checkNotNull(value); boolean isImmutableValueWorthInlining = NodeUtil.isImmutableValue(value) && (value.getType() != Token.STRING || isStringWorthInlining(v, refInfo.references)); boolean isInlinableThisAlias ="
      },
      {
        "txt": "value.getType() == Token.THIS && !refInfo.isEscaped(); if (!isImmutableValueWorthInlining && !isInlinableThisAlias) { return false; } } for (int i = startingReadRef; i < refSet.size(); i++) { Reference ref = refSet.get(i); if (!isValidReference(ref)) { return false;"
      },
      {
        "txt": "} } return true; } }"
      }
    ]
  },
  {
    "id": 690,
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java",
    "start-bug-line": 220,
    "end-bug-line": 220,
    "bug": "inlineNonConstants(v, referenceInfo);",
    "fix": "inlineNonConstants(v, referenceInfo, maybeModifiedArguments);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;"
      },
      {
        "txt": "import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class InlineVariables implements CompilerPass {"
      },
      {
        "txt": "private final AbstractCompiler compiler; enum Mode { CONSTANTS_ONLY, LOCALS_ONLY, ALL } private final Mode mode; private final boolean inlineAllStrings; private final IdentifyConstants identifyConstants = new IdentifyConstants(); InlineVariables("
      },
      {
        "txt": "AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { this.compiler = compiler; this.mode = mode; this.inlineAllStrings = inlineAllStrings; } @Override public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback("
      },
      {
        "txt": "compiler, new InliningBehavior(), getFilterForMode()); callback.process(externs, root); } private Predicate<Var> getFilterForMode() { switch (mode) { case ALL: return Predicates.<Var>alwaysTrue(); case LOCALS_ONLY: return new IdentifyLocals(); case CONSTANTS_ONLY:"
      },
      {
        "txt": "return new IdentifyConstants(); default: throw new IllegalStateException(); } } private class IdentifyConstants implements Predicate<Var> { @Override public boolean apply(Var var) { return var.isConst(); }"
      },
      {
        "txt": "} private class IdentifyLocals implements Predicate<Var> { @Override public boolean apply(Var var) { return var.scope.isLocal(); } } private static class AliasCandidate { private final Var alias; private final ReferenceCollection refInfo;"
      },
      {
        "txt": "AliasCandidate(Var alias, ReferenceCollection refInfo) { this.alias = alias; this.refInfo = refInfo; } } private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet(); final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap(); @Override public void afterExitScope(NodeTraversal t,"
      },
      {
        "txt": "Map<Var, ReferenceCollection> referenceMap) { collectAliasCandidates(t, referenceMap); doInlinesForScope(t, referenceMap); } private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v);"
      },
      {
        "txt": "if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference(); Node value = init.getAssignedValue(); if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo)); } } }"
      },
      {
        "txt": "} } private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null || isVarInlineForbidden(v)) { continue; } else if (isInlineableDeclaredConstant(v, referenceInfo)) {"
      },
      {
        "txt": "Node value = init.getAssignedValue(); inlineDeclaredConstant(v, value, referenceInfo.references); staleVars.add(v); } else if (mode == Mode.CONSTANTS_ONLY) { continue; } else { <extra_id_0> } } } private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size();"
      },
      {
        "txt": "Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3; if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) { Node value; if (init != null) { value = init.getAssignedValue();"
      },
      {
        "txt": "} else { Node srcLocation = declaration.getNameNode(); value = NodeUtil.newUndefinedNode(srcLocation); } Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } else if (refCount == firstRefAfterInit) { Reference reference = referenceInfo.references.get( firstRefAfterInit - 1);"
      },
      {
        "txt": "if (canInline(declaration, init, reference)) { inline(v, declaration, init, reference); staleVars.add(v); } } else if (declaration != init && refCount == 2) { if (isValidDeclaration(declaration) && isValidInitialization(init)) { Node value = init.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v);"
      },
      {
        "txt": "} } if ( !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) { AliasCandidate candidate = aliasCandidates.get(nameNode);"
      },
      {
        "txt": "if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { Reference aliasInit; aliasInit = candidate.refInfo.getInitializingReference(); Node value = aliasInit.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references); staleVars.add(candidate.alias);"
      },
      {
        "txt": "} } } } } private void blacklistVarReferencesInTree(Node root, Scope scope) { for (Node c = root.getFirstChild(); c != null; c = c.getNext()) { blacklistVarReferencesInTree(c, scope); } if (root.getType() == Token.NAME) {"
      },
      {
        "txt": "staleVars.add(scope.getVar(root.getString())); } } private boolean isVarInlineForbidden(Var var) { return compiler.getCodingConvention().isExported(var.name) || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var); } private void inline(Var v, Reference declaration, Reference init, Reference reference) {"
      },
      {
        "txt": "Node value = init.getAssignedValue(); Preconditions.checkState(value != null); boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value); inlineValue(v, reference, value.detachFromParent()); if (declaration != init) { Node expressRoot = init.getGrandparent(); Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT); NodeUtil.removeChild(expressRoot.getParent(), expressRoot); } if (!isFunctionDeclaration) {"
      },
      {
        "txt": "removeDeclaration(declaration); } else { compiler.reportCodeChange(); } } private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) { Reference decl = refSet.get(0); for (int i = 1; i < refSet.size(); i++) { inlineValue(v, refSet.get(i), value.cloneTree());"
      },
      {
        "txt": "} removeDeclaration(decl); } private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) { Reference decl = null; for (Reference r : refSet) { if (r.getNameNode() == v.getNameNode()) { decl = r; } else {"
      },
      {
        "txt": "inlineValue(v, r, value.cloneTree()); } } removeDeclaration(decl); } private void removeDeclaration(Reference declaration) { Node varNode = declaration.getParent(); varNode.removeChild(declaration.getNameNode()); if (!varNode.hasChildren()) { Preconditions.checkState(varNode.getType() == Token.VAR);"
      },
      {
        "txt": "Node grandparent = declaration.getGrandparent(); NodeUtil.removeChild(grandparent, varNode); } compiler.reportCodeChange(); } private void inlineValue(Var v, Reference ref, Node value) { if (ref.isSimpleAssignmentToName()) { ref.getGrandparent().replaceChild(ref.getParent(), value); } else { ref.getParent().replaceChild(ref.getNameNode(), value);"
      },
      {
        "txt": "} blacklistVarReferencesInTree(value, v.scope); compiler.reportCodeChange(); } private boolean isInlineableDeclaredConstant(Var var, ReferenceCollection refInfo) { if (!identifyConstants.apply(var)) { return false; } if (!refInfo.isAssignedOnceInLifetime()) {"
      },
      {
        "txt": "return false; } Reference init = refInfo.getInitializingReferenceForConstants(); if (init == null) { return false; } Node value = init.getAssignedValue(); if (value == null) { return false; }"
      },
      {
        "txt": "if (!NodeUtil.isImmutableValue(value)) { return false; } return value.getType() != Token.STRING || isStringWorthInlining(var, refInfo.references); } private boolean isStringWorthInlining(Var var, List<Reference> refs) { if (!inlineAllStrings && !var.isDefine()) { int len = var.getInitialValue().getString().length() + \"''\".length(); int noInlineBytes = \"var xx=;\".length() + len +"
      },
      {
        "txt": "4 * (refs.size() - 1); int inlineBytes = (len - 1) * (refs.size() - 1); return noInlineBytes >= inlineBytes; } return true; } private boolean canInline( Reference declaration, Reference initialization, Reference reference) {"
      },
      {
        "txt": "if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) { return false; } if (declaration != initialization && initialization.getGrandparent().getType() != Token.EXPR_RESULT) { return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock()"
      },
      {
        "txt": "|| declaration.getBasicBlock() != reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.getType() == Token.GETPROP && reference.getParent().getType() == Token.CALL && reference.getParent().getFirstChild() == reference.getNameNode()) { return false; }"
      },
      {
        "txt": "if (value.getType() == Token.FUNCTION) { Node callNode = reference.getParent(); if (reference.getParent().getType() == Token.CALL) { SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(callNode); if (relationship != null) { return false; } } }"
      },
      {
        "txt": "return canMoveAggressively(value) || canMoveModerately(initialization, reference); } private boolean canMoveAggressively(Node value) { return NodeUtil.isLiteralValue(value, true) || value.getType() == Token.FUNCTION; } private boolean canMoveModerately( Reference initialization, Reference reference) {"
      },
      {
        "txt": "Iterator<Node> it; if (initialization.getParent().getType() == Token.VAR) { it = NodeIterators.LocalVarMotion.forVar( initialization.getNameNode(), // NAME initialization.getParent(), // VAR initialization.getGrandparent()); // VAR container } else if (initialization.getParent().getType() == Token.ASSIGN) { Preconditions.checkState( initialization.getGrandparent().getType() == Token.EXPR_RESULT); it = NodeIterators.LocalVarMotion.forAssign("
      },
      {
        "txt": "initialization.getNameNode(), // NAME initialization.getParent(), // ASSIGN initialization.getGrandparent(), // EXPR_RESULT initialization.getGrandparent().getParent()); // EXPR container } else { throw new IllegalStateException(\"Unexpected initialization parent \" + initialization.getParent().toStringTree()); } Node targetName = reference.getNameNode(); while (it.hasNext()) {"
      },
      {
        "txt": "Node curNode = it.next(); if (curNode == targetName) { return true; } } return false; } private boolean isValidDeclaration(Reference declaration) { return (declaration.getParent().getType() == Token.VAR && declaration.getGrandparent().getType() != Token.FOR)"
      },
      {
        "txt": "|| NodeUtil.isFunctionDeclaration(declaration.getParent()); } private boolean isValidInitialization(Reference initialization) { if (initialization == null) { return false; } else if (initialization.isDeclaration()) { return NodeUtil.isFunctionDeclaration(initialization.getParent()) || initialization.getNameNode().getFirstChild() != null; } else { Node parent = initialization.getParent();"
      },
      {
        "txt": "Preconditions.checkState( parent.getType() == Token.ASSIGN && parent.getFirstChild() == initialization.getNameNode()); return true; } } private boolean isValidReference(Reference reference) { return !reference.isDeclaration() && !reference.isLvalue(); } private boolean isImmutableAndWellDefinedVariable(Var v,"
      },
      {
        "txt": "ReferenceCollection refInfo) { List<Reference> refSet = refInfo.references; int startingReadRef = 1; Reference refDecl = refSet.get(0); if (!isValidDeclaration(refDecl)) { return false; } boolean isNeverAssigned = refInfo.isNeverAssigned(); if (!isNeverAssigned) { Reference refInit = refInfo.getInitializingReference();"
      },
      {
        "txt": "if (!isValidInitialization(refInit)) { return false; } if (refDecl != refInit) { Preconditions.checkState(refInit == refSet.get(1)); startingReadRef = 2; } if (!refInfo.isWellDefined()) { return false; }"
      },
      {
        "txt": "Node value = refInit.getAssignedValue(); Preconditions.checkNotNull(value); boolean isImmutableValueWorthInlining = NodeUtil.isImmutableValue(value) && (value.getType() != Token.STRING || isStringWorthInlining(v, refInfo.references)); boolean isInlinableThisAlias = value.getType() == Token.THIS && !refInfo.isEscaped(); if (!isImmutableValueWorthInlining && !isInlinableThisAlias) {"
      },
      {
        "txt": "return false; } } for (int i = startingReadRef; i < refSet.size(); i++) { Reference ref = refSet.get(i); if (!isValidReference(ref)) { return false; } } return true;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 691,
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java",
    "start-bug-line": 225,
    "end-bug-line": 225,
    "bug": "",
    "fix": "private boolean maybeEscapedOrModifiedArguments( Scope scope, Map<Var, ReferenceCollection> referenceMap) { if (scope.isLocal()) { Var arguments = scope.getArgumentsVar(); ReferenceCollection refs = referenceMap.get(arguments); if (refs != null && !refs.references.isEmpty()) { for (Reference ref : refs.references) { Node refNode = ref.getNameNode(); Node refParent = ref.getParent();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior; import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class InlineVariables implements CompilerPass { private final AbstractCompiler compiler; enum Mode { CONSTANTS_ONLY, LOCALS_ONLY,"
      },
      {
        "txt": "ALL } private final Mode mode; private final boolean inlineAllStrings; private final IdentifyConstants identifyConstants = new IdentifyConstants(); InlineVariables( AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { this.compiler = compiler;"
      },
      {
        "txt": "this.mode = mode; this.inlineAllStrings = inlineAllStrings; } @Override public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); callback.process(externs, root); } private Predicate<Var> getFilterForMode() {"
      },
      {
        "txt": "switch (mode) { case ALL: return Predicates.<Var>alwaysTrue(); case LOCALS_ONLY: return new IdentifyLocals(); case CONSTANTS_ONLY: return new IdentifyConstants(); default: throw new IllegalStateException(); }"
      },
      {
        "txt": "} private class IdentifyConstants implements Predicate<Var> { @Override public boolean apply(Var var) { return var.isConst(); } } private class IdentifyLocals implements Predicate<Var> { @Override public boolean apply(Var var) {"
      },
      {
        "txt": "return var.scope.isLocal(); } } private static class AliasCandidate { private final Var alias; private final ReferenceCollection refInfo; AliasCandidate(Var alias, ReferenceCollection refInfo) { this.alias = alias; this.refInfo = refInfo; }"
      },
      {
        "txt": "} private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet(); final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap(); @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { collectAliasCandidates(t, referenceMap); doInlinesForScope(t, referenceMap); }"
      },
      {
        "txt": "private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference();"
      },
      {
        "txt": "Node value = init.getAssignedValue(); if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo)); } } } } } private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {"
      },
      {
        "txt": "for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null || isVarInlineForbidden(v)) { continue; } else if (isInlineableDeclaredConstant(v, referenceInfo)) { Reference init = referenceInfo.getInitializingReferenceForConstants(); Node value = init.getAssignedValue(); inlineDeclaredConstant(v, value, referenceInfo.references); staleVars.add(v);"
      },
      {
        "txt": "continue; } else { inlineNonConstants(v, referenceInfo); } } } <extra_id_0> private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3;"
      },
      {
        "txt": "Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3; if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) { Node value; if (init != null) { value = init.getAssignedValue(); } else { Node srcLocation = declaration.getNameNode(); value = NodeUtil.newUndefinedNode(srcLocation);"
      },
      {
        "txt": "} Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } else if (refCount == firstRefAfterInit) { Reference reference = referenceInfo.references.get( firstRefAfterInit - 1); if (canInline(declaration, init, reference)) { inline(v, declaration, init, reference); staleVars.add(v);"
      },
      {
        "txt": "} } else if (declaration != init && refCount == 2) { if (isValidDeclaration(declaration) && isValidInitialization(init)) { Node value = init.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } } if ("
      },
      {
        "txt": "!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) { AliasCandidate candidate = aliasCandidates.get(nameNode); if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { Reference aliasInit;"
      },
      {
        "txt": "aliasInit = candidate.refInfo.getInitializingReference(); Node value = aliasInit.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references); staleVars.add(candidate.alias); } } }"
      },
      {
        "txt": "} } private void blacklistVarReferencesInTree(Node root, Scope scope) { for (Node c = root.getFirstChild(); c != null; c = c.getNext()) { blacklistVarReferencesInTree(c, scope); } if (root.getType() == Token.NAME) { staleVars.add(scope.getVar(root.getString())); } }"
      },
      {
        "txt": "private boolean isVarInlineForbidden(Var var) { return compiler.getCodingConvention().isExported(var.name) || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var); } private void inline(Var v, Reference declaration, Reference init, Reference reference) { Node value = init.getAssignedValue(); Preconditions.checkState(value != null); boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);"
      },
      {
        "txt": "inlineValue(v, reference, value.detachFromParent()); if (declaration != init) { Node expressRoot = init.getGrandparent(); Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT); NodeUtil.removeChild(expressRoot.getParent(), expressRoot); } if (!isFunctionDeclaration) { removeDeclaration(declaration); } else { compiler.reportCodeChange();"
      },
      {
        "txt": "} } private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) { Reference decl = refSet.get(0); for (int i = 1; i < refSet.size(); i++) { inlineValue(v, refSet.get(i), value.cloneTree()); } removeDeclaration(decl); }"
      },
      {
        "txt": "private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) { Reference decl = null; for (Reference r : refSet) { if (r.getNameNode() == v.getNameNode()) { decl = r; } else { inlineValue(v, r, value.cloneTree()); } }"
      },
      {
        "txt": "removeDeclaration(decl); } private void removeDeclaration(Reference declaration) { Node varNode = declaration.getParent(); varNode.removeChild(declaration.getNameNode()); if (!varNode.hasChildren()) { Preconditions.checkState(varNode.getType() == Token.VAR); Node grandparent = declaration.getGrandparent(); NodeUtil.removeChild(grandparent, varNode); }"
      },
      {
        "txt": "compiler.reportCodeChange(); } private void inlineValue(Var v, Reference ref, Node value) { if (ref.isSimpleAssignmentToName()) { ref.getGrandparent().replaceChild(ref.getParent(), value); } else { ref.getParent().replaceChild(ref.getNameNode(), value); } blacklistVarReferencesInTree(value, v.scope); compiler.reportCodeChange();"
      },
      {
        "txt": "} private boolean isInlineableDeclaredConstant(Var var, ReferenceCollection refInfo) { if (!identifyConstants.apply(var)) { return false; } if (!refInfo.isAssignedOnceInLifetime()) { return false; } Reference init = refInfo.getInitializingReferenceForConstants();"
      },
      {
        "txt": "if (init == null) { return false; } Node value = init.getAssignedValue(); if (value == null) { return false; } if (!NodeUtil.isImmutableValue(value)) { return false; }"
      },
      {
        "txt": "return value.getType() != Token.STRING || isStringWorthInlining(var, refInfo.references); } private boolean isStringWorthInlining(Var var, List<Reference> refs) { if (!inlineAllStrings && !var.isDefine()) { int len = var.getInitialValue().getString().length() + \"''\".length(); int noInlineBytes = \"var xx=;\".length() + len + 4 * (refs.size() - 1); int inlineBytes = (len - 1) * (refs.size() - 1); return noInlineBytes >= inlineBytes;"
      },
      {
        "txt": "} return true; } private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {"
      },
      {
        "txt": "return false; } if (declaration != initialization && initialization.getGrandparent().getType() != Token.EXPR_RESULT) { return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; }"
      },
      {
        "txt": "Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.getType() == Token.GETPROP && reference.getParent().getType() == Token.CALL && reference.getParent().getFirstChild() == reference.getNameNode()) { return false; } if (value.getType() == Token.FUNCTION) { Node callNode = reference.getParent(); if (reference.getParent().getType() == Token.CALL) {"
      },
      {
        "txt": "SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(callNode); if (relationship != null) { return false; } } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }"
      },
      {
        "txt": "private boolean canMoveAggressively(Node value) { return NodeUtil.isLiteralValue(value, true) || value.getType() == Token.FUNCTION; } private boolean canMoveModerately( Reference initialization, Reference reference) { Iterator<Node> it; if (initialization.getParent().getType() == Token.VAR) { it = NodeIterators.LocalVarMotion.forVar("
      },
      {
        "txt": "initialization.getNameNode(), // NAME initialization.getParent(), // VAR initialization.getGrandparent()); // VAR container } else if (initialization.getParent().getType() == Token.ASSIGN) { Preconditions.checkState( initialization.getGrandparent().getType() == Token.EXPR_RESULT); it = NodeIterators.LocalVarMotion.forAssign( initialization.getNameNode(), // NAME initialization.getParent(), // ASSIGN initialization.getGrandparent(), // EXPR_RESULT"
      },
      {
        "txt": "initialization.getGrandparent().getParent()); // EXPR container } else { throw new IllegalStateException(\"Unexpected initialization parent \" + initialization.getParent().toStringTree()); } Node targetName = reference.getNameNode(); while (it.hasNext()) { Node curNode = it.next(); if (curNode == targetName) { return true;"
      },
      {
        "txt": "} } return false; } private boolean isValidDeclaration(Reference declaration) { return (declaration.getParent().getType() == Token.VAR && declaration.getGrandparent().getType() != Token.FOR) || NodeUtil.isFunctionDeclaration(declaration.getParent()); } private boolean isValidInitialization(Reference initialization) {"
      },
      {
        "txt": "if (initialization == null) { return false; } else if (initialization.isDeclaration()) { return NodeUtil.isFunctionDeclaration(initialization.getParent()) || initialization.getNameNode().getFirstChild() != null; } else { Node parent = initialization.getParent(); Preconditions.checkState( parent.getType() == Token.ASSIGN && parent.getFirstChild() == initialization.getNameNode());"
      },
      {
        "txt": "return true; } } private boolean isValidReference(Reference reference) { return !reference.isDeclaration() && !reference.isLvalue(); } private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) { List<Reference> refSet = refInfo.references; int startingReadRef = 1;"
      },
      {
        "txt": "Reference refDecl = refSet.get(0); if (!isValidDeclaration(refDecl)) { return false; } boolean isNeverAssigned = refInfo.isNeverAssigned(); if (!isNeverAssigned) { Reference refInit = refInfo.getInitializingReference(); if (!isValidInitialization(refInit)) { return false; }"
      },
      {
        "txt": "if (refDecl != refInit) { Preconditions.checkState(refInit == refSet.get(1)); startingReadRef = 2; } if (!refInfo.isWellDefined()) { return false; } Node value = refInit.getAssignedValue(); Preconditions.checkNotNull(value); boolean isImmutableValueWorthInlining ="
      },
      {
        "txt": "NodeUtil.isImmutableValue(value) && (value.getType() != Token.STRING || isStringWorthInlining(v, refInfo.references)); boolean isInlinableThisAlias = value.getType() == Token.THIS && !refInfo.isEscaped(); if (!isImmutableValueWorthInlining && !isInlinableThisAlias) { return false; } }"
      },
      {
        "txt": "for (int i = startingReadRef; i < refSet.size(); i++) { Reference ref = refSet.get(i); if (!isValidReference(ref)) { return false; } } return true; } }"
      }
    ]
  },
  {
    "id": 692,
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java",
    "start-bug-line": 227,
    "end-bug-line": 227,
    "bug": "",
    "fix": "if (!(NodeUtil.isGet(refParent) && refNode == ref.getParent().getFirstChild() && !isLValue(refParent))) { return true; } } } } return false; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior; import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class InlineVariables implements CompilerPass { private final AbstractCompiler compiler; enum Mode { CONSTANTS_ONLY, LOCALS_ONLY,"
      },
      {
        "txt": "ALL } private final Mode mode; private final boolean inlineAllStrings; private final IdentifyConstants identifyConstants = new IdentifyConstants(); InlineVariables( AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { this.compiler = compiler;"
      },
      {
        "txt": "this.mode = mode; this.inlineAllStrings = inlineAllStrings; } @Override public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); callback.process(externs, root); } private Predicate<Var> getFilterForMode() {"
      },
      {
        "txt": "switch (mode) { case ALL: return Predicates.<Var>alwaysTrue(); case LOCALS_ONLY: return new IdentifyLocals(); case CONSTANTS_ONLY: return new IdentifyConstants(); default: throw new IllegalStateException(); }"
      },
      {
        "txt": "} private class IdentifyConstants implements Predicate<Var> { @Override public boolean apply(Var var) { return var.isConst(); } } private class IdentifyLocals implements Predicate<Var> { @Override public boolean apply(Var var) {"
      },
      {
        "txt": "return var.scope.isLocal(); } } private static class AliasCandidate { private final Var alias; private final ReferenceCollection refInfo; AliasCandidate(Var alias, ReferenceCollection refInfo) { this.alias = alias; this.refInfo = refInfo; }"
      },
      {
        "txt": "} private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet(); final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap(); @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { collectAliasCandidates(t, referenceMap); doInlinesForScope(t, referenceMap); }"
      },
      {
        "txt": "private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference();"
      },
      {
        "txt": "Node value = init.getAssignedValue(); if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo)); } } } } } private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {"
      },
      {
        "txt": "for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null || isVarInlineForbidden(v)) { continue; } else if (isInlineableDeclaredConstant(v, referenceInfo)) { Reference init = referenceInfo.getInitializingReferenceForConstants(); Node value = init.getAssignedValue(); inlineDeclaredConstant(v, value, referenceInfo.references); staleVars.add(v);"
      },
      {
        "txt": "continue; } else { inlineNonConstants(v, referenceInfo); } } } <extra_id_0> private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3;"
      },
      {
        "txt": "Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3; if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) { Node value; if (init != null) { value = init.getAssignedValue(); } else { Node srcLocation = declaration.getNameNode(); value = NodeUtil.newUndefinedNode(srcLocation);"
      },
      {
        "txt": "} Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } else if (refCount == firstRefAfterInit) { Reference reference = referenceInfo.references.get( firstRefAfterInit - 1); if (canInline(declaration, init, reference)) { inline(v, declaration, init, reference); staleVars.add(v);"
      },
      {
        "txt": "} } else if (declaration != init && refCount == 2) { if (isValidDeclaration(declaration) && isValidInitialization(init)) { Node value = init.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } } if ("
      },
      {
        "txt": "!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) { AliasCandidate candidate = aliasCandidates.get(nameNode); if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { Reference aliasInit;"
      },
      {
        "txt": "aliasInit = candidate.refInfo.getInitializingReference(); Node value = aliasInit.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references); staleVars.add(candidate.alias); } } }"
      },
      {
        "txt": "} } private void blacklistVarReferencesInTree(Node root, Scope scope) { for (Node c = root.getFirstChild(); c != null; c = c.getNext()) { blacklistVarReferencesInTree(c, scope); } if (root.getType() == Token.NAME) { staleVars.add(scope.getVar(root.getString())); } }"
      },
      {
        "txt": "private boolean isVarInlineForbidden(Var var) { return compiler.getCodingConvention().isExported(var.name) || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var); } private void inline(Var v, Reference declaration, Reference init, Reference reference) { Node value = init.getAssignedValue(); Preconditions.checkState(value != null); boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);"
      },
      {
        "txt": "inlineValue(v, reference, value.detachFromParent()); if (declaration != init) { Node expressRoot = init.getGrandparent(); Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT); NodeUtil.removeChild(expressRoot.getParent(), expressRoot); } if (!isFunctionDeclaration) { removeDeclaration(declaration); } else { compiler.reportCodeChange();"
      },
      {
        "txt": "} } private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) { Reference decl = refSet.get(0); for (int i = 1; i < refSet.size(); i++) { inlineValue(v, refSet.get(i), value.cloneTree()); } removeDeclaration(decl); }"
      },
      {
        "txt": "private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) { Reference decl = null; for (Reference r : refSet) { if (r.getNameNode() == v.getNameNode()) { decl = r; } else { inlineValue(v, r, value.cloneTree()); } }"
      },
      {
        "txt": "removeDeclaration(decl); } private void removeDeclaration(Reference declaration) { Node varNode = declaration.getParent(); varNode.removeChild(declaration.getNameNode()); if (!varNode.hasChildren()) { Preconditions.checkState(varNode.getType() == Token.VAR); Node grandparent = declaration.getGrandparent(); NodeUtil.removeChild(grandparent, varNode); }"
      },
      {
        "txt": "compiler.reportCodeChange(); } private void inlineValue(Var v, Reference ref, Node value) { if (ref.isSimpleAssignmentToName()) { ref.getGrandparent().replaceChild(ref.getParent(), value); } else { ref.getParent().replaceChild(ref.getNameNode(), value); } blacklistVarReferencesInTree(value, v.scope); compiler.reportCodeChange();"
      },
      {
        "txt": "} private boolean isInlineableDeclaredConstant(Var var, ReferenceCollection refInfo) { if (!identifyConstants.apply(var)) { return false; } if (!refInfo.isAssignedOnceInLifetime()) { return false; } Reference init = refInfo.getInitializingReferenceForConstants();"
      },
      {
        "txt": "if (init == null) { return false; } Node value = init.getAssignedValue(); if (value == null) { return false; } if (!NodeUtil.isImmutableValue(value)) { return false; }"
      },
      {
        "txt": "return value.getType() != Token.STRING || isStringWorthInlining(var, refInfo.references); } private boolean isStringWorthInlining(Var var, List<Reference> refs) { if (!inlineAllStrings && !var.isDefine()) { int len = var.getInitialValue().getString().length() + \"''\".length(); int noInlineBytes = \"var xx=;\".length() + len + 4 * (refs.size() - 1); int inlineBytes = (len - 1) * (refs.size() - 1); return noInlineBytes >= inlineBytes;"
      },
      {
        "txt": "} return true; } private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {"
      },
      {
        "txt": "return false; } if (declaration != initialization && initialization.getGrandparent().getType() != Token.EXPR_RESULT) { return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; }"
      },
      {
        "txt": "Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.getType() == Token.GETPROP && reference.getParent().getType() == Token.CALL && reference.getParent().getFirstChild() == reference.getNameNode()) { return false; } if (value.getType() == Token.FUNCTION) { Node callNode = reference.getParent(); if (reference.getParent().getType() == Token.CALL) {"
      },
      {
        "txt": "SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(callNode); if (relationship != null) { return false; } } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }"
      },
      {
        "txt": "private boolean canMoveAggressively(Node value) { return NodeUtil.isLiteralValue(value, true) || value.getType() == Token.FUNCTION; } private boolean canMoveModerately( Reference initialization, Reference reference) { Iterator<Node> it; if (initialization.getParent().getType() == Token.VAR) { it = NodeIterators.LocalVarMotion.forVar("
      },
      {
        "txt": "initialization.getNameNode(), // NAME initialization.getParent(), // VAR initialization.getGrandparent()); // VAR container } else if (initialization.getParent().getType() == Token.ASSIGN) { Preconditions.checkState( initialization.getGrandparent().getType() == Token.EXPR_RESULT); it = NodeIterators.LocalVarMotion.forAssign( initialization.getNameNode(), // NAME initialization.getParent(), // ASSIGN initialization.getGrandparent(), // EXPR_RESULT"
      },
      {
        "txt": "initialization.getGrandparent().getParent()); // EXPR container } else { throw new IllegalStateException(\"Unexpected initialization parent \" + initialization.getParent().toStringTree()); } Node targetName = reference.getNameNode(); while (it.hasNext()) { Node curNode = it.next(); if (curNode == targetName) { return true;"
      },
      {
        "txt": "} } return false; } private boolean isValidDeclaration(Reference declaration) { return (declaration.getParent().getType() == Token.VAR && declaration.getGrandparent().getType() != Token.FOR) || NodeUtil.isFunctionDeclaration(declaration.getParent()); } private boolean isValidInitialization(Reference initialization) {"
      },
      {
        "txt": "if (initialization == null) { return false; } else if (initialization.isDeclaration()) { return NodeUtil.isFunctionDeclaration(initialization.getParent()) || initialization.getNameNode().getFirstChild() != null; } else { Node parent = initialization.getParent(); Preconditions.checkState( parent.getType() == Token.ASSIGN && parent.getFirstChild() == initialization.getNameNode());"
      },
      {
        "txt": "return true; } } private boolean isValidReference(Reference reference) { return !reference.isDeclaration() && !reference.isLvalue(); } private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) { List<Reference> refSet = refInfo.references; int startingReadRef = 1;"
      },
      {
        "txt": "Reference refDecl = refSet.get(0); if (!isValidDeclaration(refDecl)) { return false; } boolean isNeverAssigned = refInfo.isNeverAssigned(); if (!isNeverAssigned) { Reference refInit = refInfo.getInitializingReference(); if (!isValidInitialization(refInit)) { return false; }"
      },
      {
        "txt": "if (refDecl != refInit) { Preconditions.checkState(refInit == refSet.get(1)); startingReadRef = 2; } if (!refInfo.isWellDefined()) { return false; } Node value = refInit.getAssignedValue(); Preconditions.checkNotNull(value); boolean isImmutableValueWorthInlining ="
      },
      {
        "txt": "NodeUtil.isImmutableValue(value) && (value.getType() != Token.STRING || isStringWorthInlining(v, refInfo.references)); boolean isInlinableThisAlias = value.getType() == Token.THIS && !refInfo.isEscaped(); if (!isImmutableValueWorthInlining && !isInlinableThisAlias) { return false; } }"
      },
      {
        "txt": "for (int i = startingReadRef; i < refSet.size(); i++) { Reference ref = refSet.get(i); if (!isValidReference(ref)) { return false; } } return true; } }"
      }
    ]
  },
  {
    "id": 693,
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java",
    "start-bug-line": 228,
    "end-bug-line": 228,
    "bug": "",
    "fix": "private boolean isLValue(Node n) { Node parent = n.getParent(); return (parent.getType() == Token.INC || parent.getType() == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior; import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class InlineVariables implements CompilerPass { private final AbstractCompiler compiler; enum Mode { CONSTANTS_ONLY, LOCALS_ONLY,"
      },
      {
        "txt": "ALL } private final Mode mode; private final boolean inlineAllStrings; private final IdentifyConstants identifyConstants = new IdentifyConstants(); InlineVariables( AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { this.compiler = compiler;"
      },
      {
        "txt": "this.mode = mode; this.inlineAllStrings = inlineAllStrings; } @Override public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); callback.process(externs, root); } private Predicate<Var> getFilterForMode() {"
      },
      {
        "txt": "switch (mode) { case ALL: return Predicates.<Var>alwaysTrue(); case LOCALS_ONLY: return new IdentifyLocals(); case CONSTANTS_ONLY: return new IdentifyConstants(); default: throw new IllegalStateException(); }"
      },
      {
        "txt": "} private class IdentifyConstants implements Predicate<Var> { @Override public boolean apply(Var var) { return var.isConst(); } } private class IdentifyLocals implements Predicate<Var> { @Override public boolean apply(Var var) {"
      },
      {
        "txt": "return var.scope.isLocal(); } } private static class AliasCandidate { private final Var alias; private final ReferenceCollection refInfo; AliasCandidate(Var alias, ReferenceCollection refInfo) { this.alias = alias; this.refInfo = refInfo; }"
      },
      {
        "txt": "} private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet(); final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap(); @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { collectAliasCandidates(t, referenceMap); doInlinesForScope(t, referenceMap); }"
      },
      {
        "txt": "private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference();"
      },
      {
        "txt": "Node value = init.getAssignedValue(); if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo)); } } } } } private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {"
      },
      {
        "txt": "for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null || isVarInlineForbidden(v)) { continue; } else if (isInlineableDeclaredConstant(v, referenceInfo)) { Reference init = referenceInfo.getInitializingReferenceForConstants(); Node value = init.getAssignedValue(); inlineDeclaredConstant(v, value, referenceInfo.references); staleVars.add(v);"
      },
      {
        "txt": "continue; } else { inlineNonConstants(v, referenceInfo); } } } <extra_id_0> private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3;"
      },
      {
        "txt": "Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3; if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) { Node value; if (init != null) { value = init.getAssignedValue(); } else { Node srcLocation = declaration.getNameNode(); value = NodeUtil.newUndefinedNode(srcLocation);"
      },
      {
        "txt": "} Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } else if (refCount == firstRefAfterInit) { Reference reference = referenceInfo.references.get( firstRefAfterInit - 1); if (canInline(declaration, init, reference)) { inline(v, declaration, init, reference); staleVars.add(v);"
      },
      {
        "txt": "} } else if (declaration != init && refCount == 2) { if (isValidDeclaration(declaration) && isValidInitialization(init)) { Node value = init.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } } if ("
      },
      {
        "txt": "!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) { AliasCandidate candidate = aliasCandidates.get(nameNode); if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { Reference aliasInit;"
      },
      {
        "txt": "aliasInit = candidate.refInfo.getInitializingReference(); Node value = aliasInit.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references); staleVars.add(candidate.alias); } } }"
      },
      {
        "txt": "} } private void blacklistVarReferencesInTree(Node root, Scope scope) { for (Node c = root.getFirstChild(); c != null; c = c.getNext()) { blacklistVarReferencesInTree(c, scope); } if (root.getType() == Token.NAME) { staleVars.add(scope.getVar(root.getString())); } }"
      },
      {
        "txt": "private boolean isVarInlineForbidden(Var var) { return compiler.getCodingConvention().isExported(var.name) || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var); } private void inline(Var v, Reference declaration, Reference init, Reference reference) { Node value = init.getAssignedValue(); Preconditions.checkState(value != null); boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);"
      },
      {
        "txt": "inlineValue(v, reference, value.detachFromParent()); if (declaration != init) { Node expressRoot = init.getGrandparent(); Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT); NodeUtil.removeChild(expressRoot.getParent(), expressRoot); } if (!isFunctionDeclaration) { removeDeclaration(declaration); } else { compiler.reportCodeChange();"
      },
      {
        "txt": "} } private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) { Reference decl = refSet.get(0); for (int i = 1; i < refSet.size(); i++) { inlineValue(v, refSet.get(i), value.cloneTree()); } removeDeclaration(decl); }"
      },
      {
        "txt": "private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) { Reference decl = null; for (Reference r : refSet) { if (r.getNameNode() == v.getNameNode()) { decl = r; } else { inlineValue(v, r, value.cloneTree()); } }"
      },
      {
        "txt": "removeDeclaration(decl); } private void removeDeclaration(Reference declaration) { Node varNode = declaration.getParent(); varNode.removeChild(declaration.getNameNode()); if (!varNode.hasChildren()) { Preconditions.checkState(varNode.getType() == Token.VAR); Node grandparent = declaration.getGrandparent(); NodeUtil.removeChild(grandparent, varNode); }"
      },
      {
        "txt": "compiler.reportCodeChange(); } private void inlineValue(Var v, Reference ref, Node value) { if (ref.isSimpleAssignmentToName()) { ref.getGrandparent().replaceChild(ref.getParent(), value); } else { ref.getParent().replaceChild(ref.getNameNode(), value); } blacklistVarReferencesInTree(value, v.scope); compiler.reportCodeChange();"
      },
      {
        "txt": "} private boolean isInlineableDeclaredConstant(Var var, ReferenceCollection refInfo) { if (!identifyConstants.apply(var)) { return false; } if (!refInfo.isAssignedOnceInLifetime()) { return false; } Reference init = refInfo.getInitializingReferenceForConstants();"
      },
      {
        "txt": "if (init == null) { return false; } Node value = init.getAssignedValue(); if (value == null) { return false; } if (!NodeUtil.isImmutableValue(value)) { return false; }"
      },
      {
        "txt": "return value.getType() != Token.STRING || isStringWorthInlining(var, refInfo.references); } private boolean isStringWorthInlining(Var var, List<Reference> refs) { if (!inlineAllStrings && !var.isDefine()) { int len = var.getInitialValue().getString().length() + \"''\".length(); int noInlineBytes = \"var xx=;\".length() + len + 4 * (refs.size() - 1); int inlineBytes = (len - 1) * (refs.size() - 1); return noInlineBytes >= inlineBytes;"
      },
      {
        "txt": "} return true; } private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {"
      },
      {
        "txt": "return false; } if (declaration != initialization && initialization.getGrandparent().getType() != Token.EXPR_RESULT) { return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; }"
      },
      {
        "txt": "Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.getType() == Token.GETPROP && reference.getParent().getType() == Token.CALL && reference.getParent().getFirstChild() == reference.getNameNode()) { return false; } if (value.getType() == Token.FUNCTION) { Node callNode = reference.getParent(); if (reference.getParent().getType() == Token.CALL) {"
      },
      {
        "txt": "SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(callNode); if (relationship != null) { return false; } } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }"
      },
      {
        "txt": "private boolean canMoveAggressively(Node value) { return NodeUtil.isLiteralValue(value, true) || value.getType() == Token.FUNCTION; } private boolean canMoveModerately( Reference initialization, Reference reference) { Iterator<Node> it; if (initialization.getParent().getType() == Token.VAR) { it = NodeIterators.LocalVarMotion.forVar("
      },
      {
        "txt": "initialization.getNameNode(), // NAME initialization.getParent(), // VAR initialization.getGrandparent()); // VAR container } else if (initialization.getParent().getType() == Token.ASSIGN) { Preconditions.checkState( initialization.getGrandparent().getType() == Token.EXPR_RESULT); it = NodeIterators.LocalVarMotion.forAssign( initialization.getNameNode(), // NAME initialization.getParent(), // ASSIGN initialization.getGrandparent(), // EXPR_RESULT"
      },
      {
        "txt": "initialization.getGrandparent().getParent()); // EXPR container } else { throw new IllegalStateException(\"Unexpected initialization parent \" + initialization.getParent().toStringTree()); } Node targetName = reference.getNameNode(); while (it.hasNext()) { Node curNode = it.next(); if (curNode == targetName) { return true;"
      },
      {
        "txt": "} } return false; } private boolean isValidDeclaration(Reference declaration) { return (declaration.getParent().getType() == Token.VAR && declaration.getGrandparent().getType() != Token.FOR) || NodeUtil.isFunctionDeclaration(declaration.getParent()); } private boolean isValidInitialization(Reference initialization) {"
      },
      {
        "txt": "if (initialization == null) { return false; } else if (initialization.isDeclaration()) { return NodeUtil.isFunctionDeclaration(initialization.getParent()) || initialization.getNameNode().getFirstChild() != null; } else { Node parent = initialization.getParent(); Preconditions.checkState( parent.getType() == Token.ASSIGN && parent.getFirstChild() == initialization.getNameNode());"
      },
      {
        "txt": "return true; } } private boolean isValidReference(Reference reference) { return !reference.isDeclaration() && !reference.isLvalue(); } private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) { List<Reference> refSet = refInfo.references; int startingReadRef = 1;"
      },
      {
        "txt": "Reference refDecl = refSet.get(0); if (!isValidDeclaration(refDecl)) { return false; } boolean isNeverAssigned = refInfo.isNeverAssigned(); if (!isNeverAssigned) { Reference refInit = refInfo.getInitializingReference(); if (!isValidInitialization(refInit)) { return false; }"
      },
      {
        "txt": "if (refDecl != refInit) { Preconditions.checkState(refInit == refSet.get(1)); startingReadRef = 2; } if (!refInfo.isWellDefined()) { return false; } Node value = refInit.getAssignedValue(); Preconditions.checkNotNull(value); boolean isImmutableValueWorthInlining ="
      },
      {
        "txt": "NodeUtil.isImmutableValue(value) && (value.getType() != Token.STRING || isStringWorthInlining(v, refInfo.references)); boolean isInlinableThisAlias = value.getType() == Token.THIS && !refInfo.isEscaped(); if (!isImmutableValueWorthInlining && !isInlinableThisAlias) { return false; } }"
      },
      {
        "txt": "for (int i = startingReadRef; i < refSet.size(); i++) { Reference ref = refSet.get(i); if (!isValidReference(ref)) { return false; } } return true; } }"
      }
    ]
  },
  {
    "id": 694,
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java",
    "start-bug-line": 230,
    "end-bug-line": 230,
    "bug": "Var v, ReferenceCollection referenceInfo) {",
    "fix": "Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior; import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class InlineVariables implements CompilerPass { private final AbstractCompiler compiler; enum Mode { CONSTANTS_ONLY, LOCALS_ONLY, ALL"
      },
      {
        "txt": "} private final Mode mode; private final boolean inlineAllStrings; private final IdentifyConstants identifyConstants = new IdentifyConstants(); InlineVariables( AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { this.compiler = compiler; this.mode = mode;"
      },
      {
        "txt": "this.inlineAllStrings = inlineAllStrings; } @Override public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); callback.process(externs, root); } private Predicate<Var> getFilterForMode() { switch (mode) {"
      },
      {
        "txt": "case ALL: return Predicates.<Var>alwaysTrue(); case LOCALS_ONLY: return new IdentifyLocals(); case CONSTANTS_ONLY: return new IdentifyConstants(); default: throw new IllegalStateException(); } }"
      },
      {
        "txt": "private class IdentifyConstants implements Predicate<Var> { @Override public boolean apply(Var var) { return var.isConst(); } } private class IdentifyLocals implements Predicate<Var> { @Override public boolean apply(Var var) { return var.scope.isLocal();"
      },
      {
        "txt": "} } private static class AliasCandidate { private final Var alias; private final ReferenceCollection refInfo; AliasCandidate(Var alias, ReferenceCollection refInfo) { this.alias = alias; this.refInfo = refInfo; } }"
      },
      {
        "txt": "private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet(); final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap(); @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { collectAliasCandidates(t, referenceMap); doInlinesForScope(t, referenceMap); } private void collectAliasCandidates(NodeTraversal t,"
      },
      {
        "txt": "Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference(); Node value = init.getAssignedValue();"
      },
      {
        "txt": "if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo)); } } } } } private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {"
      },
      {
        "txt": "Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null || isVarInlineForbidden(v)) { continue; } else if (isInlineableDeclaredConstant(v, referenceInfo)) { Reference init = referenceInfo.getInitializingReferenceForConstants(); Node value = init.getAssignedValue(); inlineDeclaredConstant(v, value, referenceInfo.references); staleVars.add(v); } else if (mode == Mode.CONSTANTS_ONLY) {"
      },
      {
        "txt": "} else { inlineNonConstants(v, referenceInfo); } } } private void inlineNonConstants( <extra_id_0> int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3; if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {"
      },
      {
        "txt": "if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) { Node value; if (init != null) { value = init.getAssignedValue(); } else { Node srcLocation = declaration.getNameNode(); value = NodeUtil.newUndefinedNode(srcLocation); } Preconditions.checkNotNull(value);"
      },
      {
        "txt": "inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } else if (refCount == firstRefAfterInit) { Reference reference = referenceInfo.references.get( firstRefAfterInit - 1); if (canInline(declaration, init, reference)) { inline(v, declaration, init, reference); staleVars.add(v); } } else if (declaration != init && refCount == 2) {"
      },
      {
        "txt": "if (isValidDeclaration(declaration) && isValidInitialization(init)) { Node value = init.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } } if ( !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {"
      },
      {
        "txt": "List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) { AliasCandidate candidate = aliasCandidates.get(nameNode); if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { Reference aliasInit; aliasInit = candidate.refInfo.getInitializingReference(); Node value = aliasInit.getAssignedValue();"
      },
      {
        "txt": "Preconditions.checkNotNull(value); inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references); staleVars.add(candidate.alias); } } } } }"
      },
      {
        "txt": "private void blacklistVarReferencesInTree(Node root, Scope scope) { for (Node c = root.getFirstChild(); c != null; c = c.getNext()) { blacklistVarReferencesInTree(c, scope); } if (root.getType() == Token.NAME) { staleVars.add(scope.getVar(root.getString())); } } private boolean isVarInlineForbidden(Var var) { return compiler.getCodingConvention().isExported(var.name)"
      },
      {
        "txt": "|| RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var); } private void inline(Var v, Reference declaration, Reference init, Reference reference) { Node value = init.getAssignedValue(); Preconditions.checkState(value != null); boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value); inlineValue(v, reference, value.detachFromParent()); if (declaration != init) {"
      },
      {
        "txt": "Node expressRoot = init.getGrandparent(); Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT); NodeUtil.removeChild(expressRoot.getParent(), expressRoot); } if (!isFunctionDeclaration) { removeDeclaration(declaration); } else { compiler.reportCodeChange(); } }"
      },
      {
        "txt": "private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) { Reference decl = refSet.get(0); for (int i = 1; i < refSet.size(); i++) { inlineValue(v, refSet.get(i), value.cloneTree()); } removeDeclaration(decl); } private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) {"
      },
      {
        "txt": "Reference decl = null; for (Reference r : refSet) { if (r.getNameNode() == v.getNameNode()) { decl = r; } else { inlineValue(v, r, value.cloneTree()); } } removeDeclaration(decl); }"
      },
      {
        "txt": "private void removeDeclaration(Reference declaration) { Node varNode = declaration.getParent(); varNode.removeChild(declaration.getNameNode()); if (!varNode.hasChildren()) { Preconditions.checkState(varNode.getType() == Token.VAR); Node grandparent = declaration.getGrandparent(); NodeUtil.removeChild(grandparent, varNode); } compiler.reportCodeChange(); }"
      },
      {
        "txt": "private void inlineValue(Var v, Reference ref, Node value) { if (ref.isSimpleAssignmentToName()) { ref.getGrandparent().replaceChild(ref.getParent(), value); } else { ref.getParent().replaceChild(ref.getNameNode(), value); } blacklistVarReferencesInTree(value, v.scope); compiler.reportCodeChange(); } private boolean isInlineableDeclaredConstant(Var var,"
      },
      {
        "txt": "ReferenceCollection refInfo) { if (!identifyConstants.apply(var)) { return false; } if (!refInfo.isAssignedOnceInLifetime()) { return false; } Reference init = refInfo.getInitializingReferenceForConstants(); if (init == null) { return false;"
      },
      {
        "txt": "} Node value = init.getAssignedValue(); if (value == null) { return false; } if (!NodeUtil.isImmutableValue(value)) { return false; } return value.getType() != Token.STRING || isStringWorthInlining(var, refInfo.references);"
      },
      {
        "txt": "} private boolean isStringWorthInlining(Var var, List<Reference> refs) { if (!inlineAllStrings && !var.isDefine()) { int len = var.getInitialValue().getString().length() + \"''\".length(); int noInlineBytes = \"var xx=;\".length() + len + 4 * (refs.size() - 1); int inlineBytes = (len - 1) * (refs.size() - 1); return noInlineBytes >= inlineBytes; } return true;"
      },
      {
        "txt": "} private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) { return false; }"
      },
      {
        "txt": "if (declaration != initialization && initialization.getGrandparent().getType() != Token.EXPR_RESULT) { return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null);"
      },
      {
        "txt": "if (value.getType() == Token.GETPROP && reference.getParent().getType() == Token.CALL && reference.getParent().getFirstChild() == reference.getNameNode()) { return false; } if (value.getType() == Token.FUNCTION) { Node callNode = reference.getParent(); if (reference.getParent().getType() == Token.CALL) { SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(callNode);"
      },
      {
        "txt": "if (relationship != null) { return false; } } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); } private boolean canMoveAggressively(Node value) { return NodeUtil.isLiteralValue(value, true)"
      },
      {
        "txt": "|| value.getType() == Token.FUNCTION; } private boolean canMoveModerately( Reference initialization, Reference reference) { Iterator<Node> it; if (initialization.getParent().getType() == Token.VAR) { it = NodeIterators.LocalVarMotion.forVar( initialization.getNameNode(), // NAME initialization.getParent(), // VAR"
      },
      {
        "txt": "initialization.getGrandparent()); // VAR container } else if (initialization.getParent().getType() == Token.ASSIGN) { Preconditions.checkState( initialization.getGrandparent().getType() == Token.EXPR_RESULT); it = NodeIterators.LocalVarMotion.forAssign( initialization.getNameNode(), // NAME initialization.getParent(), // ASSIGN initialization.getGrandparent(), // EXPR_RESULT initialization.getGrandparent().getParent()); // EXPR container } else {"
      },
      {
        "txt": "throw new IllegalStateException(\"Unexpected initialization parent \" + initialization.getParent().toStringTree()); } Node targetName = reference.getNameNode(); while (it.hasNext()) { Node curNode = it.next(); if (curNode == targetName) { return true; } }"
      },
      {
        "txt": "return false; } private boolean isValidDeclaration(Reference declaration) { return (declaration.getParent().getType() == Token.VAR && declaration.getGrandparent().getType() != Token.FOR) || NodeUtil.isFunctionDeclaration(declaration.getParent()); } private boolean isValidInitialization(Reference initialization) { if (initialization == null) { return false;"
      },
      {
        "txt": "} else if (initialization.isDeclaration()) { return NodeUtil.isFunctionDeclaration(initialization.getParent()) || initialization.getNameNode().getFirstChild() != null; } else { Node parent = initialization.getParent(); Preconditions.checkState( parent.getType() == Token.ASSIGN && parent.getFirstChild() == initialization.getNameNode()); return true; }"
      },
      {
        "txt": "} private boolean isValidReference(Reference reference) { return !reference.isDeclaration() && !reference.isLvalue(); } private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) { List<Reference> refSet = refInfo.references; int startingReadRef = 1; Reference refDecl = refSet.get(0); if (!isValidDeclaration(refDecl)) {"
      },
      {
        "txt": "return false; } boolean isNeverAssigned = refInfo.isNeverAssigned(); if (!isNeverAssigned) { Reference refInit = refInfo.getInitializingReference(); if (!isValidInitialization(refInit)) { return false; } if (refDecl != refInit) { Preconditions.checkState(refInit == refSet.get(1));"
      },
      {
        "txt": "startingReadRef = 2; } if (!refInfo.isWellDefined()) { return false; } Node value = refInit.getAssignedValue(); Preconditions.checkNotNull(value); boolean isImmutableValueWorthInlining = NodeUtil.isImmutableValue(value) && (value.getType() != Token.STRING ||"
      },
      {
        "txt": "isStringWorthInlining(v, refInfo.references)); boolean isInlinableThisAlias = value.getType() == Token.THIS && !refInfo.isEscaped(); if (!isImmutableValueWorthInlining && !isInlinableThisAlias) { return false; } } for (int i = startingReadRef; i < refSet.size(); i++) { Reference ref = refSet.get(i);"
      },
      {
        "txt": "if (!isValidReference(ref)) { return false; } } return true; } }"
      }
    ]
  },
  {
    "id": 695,
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java",
    "start-bug-line": 275,
    "end-bug-line": 275,
    "bug": "if (",
    "fix": "if (!maybeModifiedArguments &&",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior; import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class InlineVariables implements CompilerPass { private final AbstractCompiler compiler; enum Mode { CONSTANTS_ONLY, LOCALS_ONLY, ALL } private final Mode mode;"
      },
      {
        "txt": "private final boolean inlineAllStrings; private final IdentifyConstants identifyConstants = new IdentifyConstants(); InlineVariables( AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { this.compiler = compiler; this.mode = mode; this.inlineAllStrings = inlineAllStrings; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); callback.process(externs, root); } private Predicate<Var> getFilterForMode() { switch (mode) { case ALL: return Predicates.<Var>alwaysTrue();"
      },
      {
        "txt": "case LOCALS_ONLY: return new IdentifyLocals(); case CONSTANTS_ONLY: return new IdentifyConstants(); default: throw new IllegalStateException(); } } private class IdentifyConstants implements Predicate<Var> { @Override"
      },
      {
        "txt": "public boolean apply(Var var) { return var.isConst(); } } private class IdentifyLocals implements Predicate<Var> { @Override public boolean apply(Var var) { return var.scope.isLocal(); } }"
      },
      {
        "txt": "private static class AliasCandidate { private final Var alias; private final ReferenceCollection refInfo; AliasCandidate(Var alias, ReferenceCollection refInfo) { this.alias = alias; this.refInfo = refInfo; } } private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet();"
      },
      {
        "txt": "final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap(); @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { collectAliasCandidates(t, referenceMap); doInlinesForScope(t, referenceMap); } private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) {"
      },
      {
        "txt": "for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference(); Node value = init.getAssignedValue(); if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));"
      },
      {
        "txt": "} } } } } private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v);"
      },
      {
        "txt": "if (referenceInfo == null || isVarInlineForbidden(v)) { continue; } else if (isInlineableDeclaredConstant(v, referenceInfo)) { Reference init = referenceInfo.getInitializingReferenceForConstants(); Node value = init.getAssignedValue(); inlineDeclaredConstant(v, value, referenceInfo.references); staleVars.add(v); } else if (mode == Mode.CONSTANTS_ONLY) { continue; } else {"
      },
      {
        "txt": "inlineNonConstants(v, referenceInfo); } } } private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference(); int firstRefAfterInit = (declaration == init) ? 2 : 3;"
      },
      {
        "txt": "if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) { Node value; if (init != null) { value = init.getAssignedValue(); } else { Node srcLocation = declaration.getNameNode(); value = NodeUtil.newUndefinedNode(srcLocation); } Preconditions.checkNotNull(value);"
      },
      {
        "txt": "inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } else if (refCount == firstRefAfterInit) { Reference reference = referenceInfo.references.get( firstRefAfterInit - 1); if (canInline(declaration, init, reference)) { inline(v, declaration, init, reference); staleVars.add(v); } } else if (declaration != init && refCount == 2) {"
      },
      {
        "txt": "Node value = init.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(v, value, referenceInfo.references); staleVars.add(v); } } <extra_id_0> !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) {"
      },
      {
        "txt": "Node nameNode = refs.get(i).getNameNode(); if (aliasCandidates.containsKey(nameNode)) { AliasCandidate candidate = aliasCandidates.get(nameNode); if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { Reference aliasInit; aliasInit = candidate.refInfo.getInitializingReference(); Node value = aliasInit.getAssignedValue(); Preconditions.checkNotNull(value); inlineWellDefinedVariable(candidate.alias,"
      },
      {
        "txt": "value, candidate.refInfo.references); staleVars.add(candidate.alias); } } } } } private void blacklistVarReferencesInTree(Node root, Scope scope) { for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "blacklistVarReferencesInTree(c, scope); } if (root.getType() == Token.NAME) { staleVars.add(scope.getVar(root.getString())); } } private boolean isVarInlineForbidden(Var var) { return compiler.getCodingConvention().isExported(var.name) || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var);"
      },
      {
        "txt": "} private void inline(Var v, Reference declaration, Reference init, Reference reference) { Node value = init.getAssignedValue(); Preconditions.checkState(value != null); boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value); inlineValue(v, reference, value.detachFromParent()); if (declaration != init) { Node expressRoot = init.getGrandparent(); Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT);"
      },
      {
        "txt": "NodeUtil.removeChild(expressRoot.getParent(), expressRoot); } if (!isFunctionDeclaration) { removeDeclaration(declaration); } else { compiler.reportCodeChange(); } } private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) {"
      },
      {
        "txt": "Reference decl = refSet.get(0); for (int i = 1; i < refSet.size(); i++) { inlineValue(v, refSet.get(i), value.cloneTree()); } removeDeclaration(decl); } private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) { Reference decl = null; for (Reference r : refSet) {"
      },
      {
        "txt": "if (r.getNameNode() == v.getNameNode()) { decl = r; } else { inlineValue(v, r, value.cloneTree()); } } removeDeclaration(decl); } private void removeDeclaration(Reference declaration) { Node varNode = declaration.getParent();"
      },
      {
        "txt": "varNode.removeChild(declaration.getNameNode()); if (!varNode.hasChildren()) { Preconditions.checkState(varNode.getType() == Token.VAR); Node grandparent = declaration.getGrandparent(); NodeUtil.removeChild(grandparent, varNode); } compiler.reportCodeChange(); } private void inlineValue(Var v, Reference ref, Node value) { if (ref.isSimpleAssignmentToName()) {"
      },
      {
        "txt": "ref.getGrandparent().replaceChild(ref.getParent(), value); } else { ref.getParent().replaceChild(ref.getNameNode(), value); } blacklistVarReferencesInTree(value, v.scope); compiler.reportCodeChange(); } private boolean isInlineableDeclaredConstant(Var var, ReferenceCollection refInfo) { if (!identifyConstants.apply(var)) {"
      },
      {
        "txt": "return false; } if (!refInfo.isAssignedOnceInLifetime()) { return false; } Reference init = refInfo.getInitializingReferenceForConstants(); if (init == null) { return false; } Node value = init.getAssignedValue();"
      },
      {
        "txt": "if (value == null) { return false; } if (!NodeUtil.isImmutableValue(value)) { return false; } return value.getType() != Token.STRING || isStringWorthInlining(var, refInfo.references); } private boolean isStringWorthInlining(Var var, List<Reference> refs) {"
      },
      {
        "txt": "if (!inlineAllStrings && !var.isDefine()) { int len = var.getInitialValue().getString().length() + \"''\".length(); int noInlineBytes = \"var xx=;\".length() + len + 4 * (refs.size() - 1); int inlineBytes = (len - 1) * (refs.size() - 1); return noInlineBytes >= inlineBytes; } return true; } private boolean canInline("
      },
      {
        "txt": "Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) { return false; } if (declaration != initialization && initialization.getGrandparent().getType() != Token.EXPR_RESULT) {"
      },
      {
        "txt": "return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.getType() == Token.GETPROP && reference.getParent().getType() == Token.CALL"
      },
      {
        "txt": "&& reference.getParent().getFirstChild() == reference.getNameNode()) { return false; } if (value.getType() == Token.FUNCTION) { Node callNode = reference.getParent(); if (reference.getParent().getType() == Token.CALL) { SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(callNode); if (relationship != null) { return false;"
      },
      {
        "txt": "} } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); } private boolean canMoveAggressively(Node value) { return NodeUtil.isLiteralValue(value, true) || value.getType() == Token.FUNCTION; }"
      },
      {
        "txt": "private boolean canMoveModerately( Reference initialization, Reference reference) { Iterator<Node> it; if (initialization.getParent().getType() == Token.VAR) { it = NodeIterators.LocalVarMotion.forVar( initialization.getNameNode(), // NAME initialization.getParent(), // VAR initialization.getGrandparent()); // VAR container } else if (initialization.getParent().getType() == Token.ASSIGN) {"
      },
      {
        "txt": "Preconditions.checkState( initialization.getGrandparent().getType() == Token.EXPR_RESULT); it = NodeIterators.LocalVarMotion.forAssign( initialization.getNameNode(), // NAME initialization.getParent(), // ASSIGN initialization.getGrandparent(), // EXPR_RESULT initialization.getGrandparent().getParent()); // EXPR container } else { throw new IllegalStateException(\"Unexpected initialization parent \" + initialization.getParent().toStringTree());"
      },
      {
        "txt": "} Node targetName = reference.getNameNode(); while (it.hasNext()) { Node curNode = it.next(); if (curNode == targetName) { return true; } } return false; }"
      },
      {
        "txt": "private boolean isValidDeclaration(Reference declaration) { return (declaration.getParent().getType() == Token.VAR && declaration.getGrandparent().getType() != Token.FOR) || NodeUtil.isFunctionDeclaration(declaration.getParent()); } private boolean isValidInitialization(Reference initialization) { if (initialization == null) { return false; } else if (initialization.isDeclaration()) { return NodeUtil.isFunctionDeclaration(initialization.getParent())"
      },
      {
        "txt": "|| initialization.getNameNode().getFirstChild() != null; } else { Node parent = initialization.getParent(); Preconditions.checkState( parent.getType() == Token.ASSIGN && parent.getFirstChild() == initialization.getNameNode()); return true; } } private boolean isValidReference(Reference reference) {"
      },
      {
        "txt": "return !reference.isDeclaration() && !reference.isLvalue(); } private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) { List<Reference> refSet = refInfo.references; int startingReadRef = 1; Reference refDecl = refSet.get(0); if (!isValidDeclaration(refDecl)) { return false; }"
      },
      {
        "txt": "boolean isNeverAssigned = refInfo.isNeverAssigned(); if (!isNeverAssigned) { Reference refInit = refInfo.getInitializingReference(); if (!isValidInitialization(refInit)) { return false; } if (refDecl != refInit) { Preconditions.checkState(refInit == refSet.get(1)); startingReadRef = 2; }"
      },
      {
        "txt": "if (!refInfo.isWellDefined()) { return false; } Node value = refInit.getAssignedValue(); Preconditions.checkNotNull(value); boolean isImmutableValueWorthInlining = NodeUtil.isImmutableValue(value) && (value.getType() != Token.STRING || isStringWorthInlining(v, refInfo.references)); boolean isInlinableThisAlias ="
      },
      {
        "txt": "value.getType() == Token.THIS && !refInfo.isEscaped(); if (!isImmutableValueWorthInlining && !isInlinableThisAlias) { return false; } } for (int i = startingReadRef; i < refSet.size(); i++) { Reference ref = refSet.get(i); if (!isValidReference(ref)) { return false;"
      },
      {
        "txt": "} } return true; } }"
      }
    ]
  },
  {
    "id": 696,
    "file_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
    "start-bug-line": 123,
    "end-bug-line": 123,
    "bug": "Var v = t.getScope().getVar(n.getString());",
    "fix": "Var v; if (n.getString().equals(\"arguments\")) { v = t.getScope().getArgumentsVar(); } else { v = t.getScope().getVar(n.getString()); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "class ReferenceCollectingCallback implements ScopedCallback, CompilerPass { private final Map<Var, ReferenceCollection> referenceMap = Maps.newHashMap(); private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>(); private final Behavior behavior; private final AbstractCompiler compiler; private final Predicate<Var> varFilter; ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) { this(compiler, behavior, Predicates.<Var>alwaysTrue()); }"
      },
      {
        "txt": "ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior, Predicate<Var> varFilter) { this.compiler = compiler; this.behavior = behavior; this.varFilter = varFilter; } public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); } public Set<Var> getReferencedVariables() {"
      },
      {
        "txt": "} public ReferenceCollection getReferenceCollection(Var v) { return referenceMap.get(v); } public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { <extra_id_0> if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek())); } } if (isBlockBoundary(n, parent)) {"
      },
      {
        "txt": "} if (isBlockBoundary(n, parent)) { blockStack.pop(); } } public void enterScope(NodeTraversal t) { Node n = t.getScope().getRootNode(); BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek(); blockStack.push(new BasicBlock(parent, n)); }"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { blockStack.pop(); behavior.afterExitScope(t, referenceMap); } public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (isBlockBoundary(n, parent)) { blockStack.push(new BasicBlock(blockStack.peek(), n)); } return true;"
      },
      {
        "txt": "} private static boolean isBlockBoundary(Node n, Node parent) { if (parent != null) { switch (parent.getType()) { case Token.DO: case Token.FOR: case Token.TRY: case Token.WHILE: case Token.WITH: return true;"
      },
      {
        "txt": "case Token.AND: case Token.HOOK: case Token.IF: case Token.OR: return n != parent.getFirstChild(); } } return n.getType() == Token.CASE; } private void addReference(NodeTraversal t, Var v, Reference reference) {"
      },
      {
        "txt": "ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null) { referenceInfo = new ReferenceCollection(); referenceMap.put(v, referenceInfo); } referenceInfo.add(reference, t, v); } interface Behavior { void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap);"
      },
      {
        "txt": "} static Behavior DO_NOTHING_BEHAVIOR = new Behavior() { @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {} }; static class ReferenceCollection { List<Reference> references = Lists.newArrayList(); void add(Reference reference, NodeTraversal t, Var v) { references.add(reference);"
      },
      {
        "txt": "} protected boolean isWellDefined() { int size = references.size(); if (size == 0) { return false; } Reference init = getInitializingReference(); if (init == null) { return false; }"
      },
      {
        "txt": "Preconditions.checkState(references.get(0).isDeclaration()); BasicBlock initBlock = init.getBasicBlock(); for (int i = 1; i < size; i++) { if (!initBlock.provablyExecutesBefore( references.get(i).getBasicBlock())) { return false; } } return true; }"
      },
      {
        "txt": "boolean isEscaped() { Scope scope = null; for (Reference ref : references) { if (scope == null) { scope = ref.scope; } else if (scope != ref.scope) { return true; } } return false;"
      },
      {
        "txt": "} private boolean isInitializingDeclarationAt(int index) { Reference maybeInit = references.get(index); if (maybeInit.isInitializingDeclaration()) { return true; } return false; } private boolean isInitializingAssignmentAt(int index) { if (index < references.size() && index > 0) {"
      },
      {
        "txt": "Reference maybeDecl = references.get(index-1); if (maybeDecl.isVarDeclaration()) { Preconditions.checkState(!maybeDecl.isInitializingDeclaration()); Reference maybeInit = references.get(index); if (maybeInit.isSimpleAssignmentToName()) { return true; } } } return false;"
      },
      {
        "txt": "} Reference getInitializingReference() { if (isInitializingDeclarationAt(0)) { return references.get(0); } else if (isInitializingAssignmentAt(1)) { return references.get(1); } return null; } Reference getInitializingReferenceForConstants() {"
      },
      {
        "txt": "int size = references.size(); for (int i = 0; i < size; i++) { if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) { return references.get(i); } } return null; } boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment();"
      },
      {
        "txt": "if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false; }"
      },
      {
        "txt": "} return true; } private Reference getOneAndOnlyAssignment() { Reference assignment = null; int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { if (assignment == null) {"
      },
      {
        "txt": "assignment = ref; } else { return null; } } } return assignment; } boolean isNeverAssigned() { int size = references.size();"
      },
      {
        "txt": "for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { return false; } } return true; } boolean firstReferenceIsAssigningDeclaration() { int size = references.size();"
      },
      {
        "txt": "if (size > 0 && references.get(0).isInitializingDeclaration()) { return true; } return false; } } static final class Reference { private static final Set<Integer> DECLARATION_PARENTS = ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH); private final Node nameNode;"
      },
      {
        "txt": "private final Node parent; private final Node grandparent; private final BasicBlock basicBlock; private final Scope scope; private final String sourceName; Reference(Node nameNode, Node parent, NodeTraversal t, BasicBlock basicBlock) { this(nameNode, parent, parent.getParent(), basicBlock, t.getScope(), t.getSourceName()); }"
      },
      {
        "txt": "static Reference newBleedingFunction(NodeTraversal t, BasicBlock basicBlock, Node func) { return new Reference(func.getFirstChild(), func, func.getParent(), basicBlock, t.getScope(), t.getSourceName()); } private Reference(Node nameNode, Node parent, Node grandparent, BasicBlock basicBlock, Scope scope, String sourceName) { this.nameNode = nameNode; this.parent = parent; this.grandparent = grandparent;"
      },
      {
        "txt": "this.basicBlock = basicBlock; this.scope = scope; this.sourceName = sourceName; } boolean isDeclaration() { return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() == Token.LP && grandparent.getType() == Token.FUNCTION; } boolean isVarDeclaration() {"
      },
      {
        "txt": "return parent.getType() == Token.VAR; } boolean isHoistedFunction() { return NodeUtil.isHoistedFunctionDeclaration(parent); } boolean isInitializingDeclaration() { return isDeclaration() && (parent.getType() != Token.VAR || nameNode.getFirstChild() != null); } Node getAssignedValue() {"
      },
      {
        "txt": "return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); } BasicBlock getBasicBlock() { return basicBlock; } Node getParent() { return parent; } Node getNameNode() {"
      },
      {
        "txt": "return nameNode; } Node getGrandparent() { return grandparent; } private static boolean isLhsOfForInExpression(Node n) { Node parent = n.getParent(); if (parent.getType() == Token.VAR) { return isLhsOfForInExpression(parent); }"
      },
      {
        "txt": "return NodeUtil.isForIn(parent) && parent.getFirstChild() == n; } boolean isSimpleAssignmentToName() { return parent.getType() == Token.ASSIGN && parent.getFirstChild() == nameNode; } boolean isLvalue() { int parentType = parent.getType(); return (parentType == Token.VAR && nameNode.getFirstChild() != null) || parentType == Token.INC"
      },
      {
        "txt": "|| parentType == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == nameNode) || isLhsOfForInExpression(nameNode); } Scope getScope() { return scope; } public String getSourceName() { return sourceName;"
      },
      {
        "txt": "} } static final class BasicBlock { private final BasicBlock parent; private final boolean isHoisted; private final boolean isFunction; private final boolean isLoop; BasicBlock(BasicBlock parent, Node root) { this.parent = parent; this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);"
      },
      {
        "txt": "this.isFunction = root.getType() == Token.FUNCTION; if (root.getParent() != null) { int pType = root.getParent().getType(); this.isLoop = pType == Token.DO || pType == Token.WHILE || pType == Token.FOR; } else { this.isLoop = false; } }"
      },
      {
        "txt": "BasicBlock getParent() { return parent; } boolean provablyExecutesBefore(BasicBlock thatBlock) { BasicBlock currentBlock; for (currentBlock = thatBlock; currentBlock != null && currentBlock != this; currentBlock = currentBlock.getParent()) { if (currentBlock.isHoisted) { return false;"
      },
      {
        "txt": "} } return currentBlock == this; } }"
      }
    ]
  },
  {
    "id": 697,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 63,
    "end-bug-line": 63,
    "bug": "",
    "fix": "private Var arguments;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import com.google.common.base.Preconditions; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map;"
      },
      {
        "txt": "private final Map<String, Var> vars = new LinkedHashMap<String, Var>(); private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; <extra_id_0> public static class Var implements StaticSlot<JSType> { final String name; final Node nameNode; private JSType type; private final JSDocInfo info; private final boolean typeInferred;"
      },
      {
        "txt": "private final JSDocInfo info; private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine, JSDocInfo info) { this.name = name;"
      },
      {
        "txt": "this.nameNode = nameNode; this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred; } public String getName() {"
      },
      {
        "txt": "return name; } public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); } Scope getScope() { return scope;"
      },
      {
        "txt": "} public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() { return input == null || input.isExtern(); }"
      },
      {
        "txt": "public boolean isConst() { return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode(); int pType = parent.getType(); if (pType == Token.FUNCTION) {"
      },
      {
        "txt": "return parent; } else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; } } public JSType getType() {"
      },
      {
        "txt": "return type; } public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info; } void setType(JSType type) { Preconditions.checkState(isTypeInferred());"
      },
      {
        "txt": "this.type = type; } void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } } public boolean isTypeInferred() { return typeInferred; }"
      },
      {
        "txt": "public String getInputName() { if (input == null) return \"<non-file>\"; else return input.getName(); } public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true; } else {"
      },
      {
        "txt": "return false; } } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false; } Var otherVar = (Var) other; return otherVar.nameNode == nameNode; }"
      },
      {
        "txt": "@Override public int hashCode() { return nameNode.hashCode(); } @Override public String toString() { return \"Scope.Var \" + name; } } Scope(Scope parent, Node rootNode) { Preconditions.checkNotNull(parent);"
      },
      {
        "txt": "Preconditions.checkArgument(rootNode != parent.rootNode); this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType instanceof FunctionType) { thisType = ((FunctionType) nodeType).getTypeOfThis(); } else { thisType = parent.thisType; } this.isBottom = false;"
      },
      {
        "txt": "this.depth = parent.depth + 1; } Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; } Scope(Node rootNode, ObjectType thisType) {"
      },
      {
        "txt": "this.parent = null; this.rootNode = rootNode; this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; } boolean isBottom() {"
      },
      {
        "txt": "return isBottom; } public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() { Scope result = this;"
      },
      {
        "txt": "while (result.getParent() != null) { result = result.getParent(); } return result; } @Override public StaticScope<JSType> getParentScope() { return parent; } public ObjectType getTypeOfThis() {"
      },
      {
        "txt": "return thisType; } Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null); JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);"
      },
      {
        "txt": "Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info); vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name); }"
      },
      {
        "txt": "public StaticSlot<JSType> getSlot(String name) { return getVar(name); } public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) { Var var = vars.get(name); if (var != null) { return var;"
      },
      {
        "txt": "} else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name); } else { return null; } } public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true;"
      },
      {
        "txt": "if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse); } return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } public int getVarCount() { return vars.size();"
      },
      {
        "txt": "} public boolean isGlobal() { return parent == null; } public boolean isLocal() { return !isGlobal(); }"
      }
    ]
  },
  {
    "id": 698,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 290,
    "end-bug-line": 290,
    "bug": "",
    "fix": "public static class Arguments extends Var { Arguments(Scope scope) { super( false, // no inferred \"arguments\", // always arguments null,  // no declaration node",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import com.google.common.base.Preconditions; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; public class Scope implements StaticScope<JSType> { private final Map<String, Var> vars = new LinkedHashMap<String, Var>();"
      },
      {
        "txt": "private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; public static class Var implements StaticSlot<JSType> { final String name; final Node nameNode; private JSType type; private final JSDocInfo info;"
      },
      {
        "txt": "private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine, JSDocInfo info) { this.name = name; this.nameNode = nameNode;"
      },
      {
        "txt": "this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred; } public String getName() { return name;"
      },
      {
        "txt": "} public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); } Scope getScope() { return scope; }"
      },
      {
        "txt": "public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() { return input == null || input.isExtern(); } public boolean isConst() {"
      },
      {
        "txt": "return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode(); int pType = parent.getType(); if (pType == Token.FUNCTION) { return parent;"
      },
      {
        "txt": "} else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; } } public JSType getType() { return type;"
      },
      {
        "txt": "} public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info; } void setType(JSType type) { Preconditions.checkState(isTypeInferred()); this.type = type;"
      },
      {
        "txt": "} void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } } public boolean isTypeInferred() { return typeInferred; } public String getInputName() {"
      },
      {
        "txt": "if (input == null) return \"<non-file>\"; else return input.getName(); } public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true; } else { return false;"
      },
      {
        "txt": "} } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false; } Var otherVar = (Var) other; return otherVar.nameNode == nameNode; } @Override public int hashCode() {"
      },
      {
        "txt": "} @Override public String toString() { return \"Scope.Var \" + name; } } <extra_id_0> Scope(Scope parent, Node rootNode) { Preconditions.checkNotNull(parent); Preconditions.checkArgument(rootNode != parent.rootNode); this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType();"
      },
      {
        "txt": "this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType instanceof FunctionType) { thisType = ((FunctionType) nodeType).getTypeOfThis(); } else { thisType = parent.thisType; } this.isBottom = false; this.depth = parent.depth + 1; }"
      },
      {
        "txt": "Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; } Scope(Node rootNode, ObjectType thisType) { this.parent = null; this.rootNode = rootNode;"
      },
      {
        "txt": "this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; } boolean isBottom() { return isBottom; }"
      },
      {
        "txt": "public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() { Scope result = this; while (result.getParent() != null) { result = result.getParent();"
      },
      {
        "txt": "} return result; } @Override public StaticScope<JSType> getParentScope() { return parent; } public ObjectType getTypeOfThis() { return thisType; }"
      },
      {
        "txt": "Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null); JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode); Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info);"
      },
      {
        "txt": "vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name); } public StaticSlot<JSType> getSlot(String name) { return getVar(name);"
      },
      {
        "txt": "} public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) { Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name);"
      },
      {
        "txt": "} else { return null; } } public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true; if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse);"
      },
      {
        "txt": "} return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } public int getVarCount() { return vars.size(); } public boolean isGlobal() {"
      },
      {
        "txt": "return parent == null; } public boolean isLocal() { return !isGlobal(); }"
      }
    ]
  },
  {
    "id": 699,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 291,
    "end-bug-line": 291,
    "bug": "",
    "fix": "null,  // no type info scope, -1,    // no variable index null,  // input, false, // not a define null   // no jsdoc ); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import com.google.common.base.Preconditions; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; public class Scope implements StaticScope<JSType> { private final Map<String, Var> vars = new LinkedHashMap<String, Var>();"
      },
      {
        "txt": "private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; public static class Var implements StaticSlot<JSType> { final String name; final Node nameNode; private JSType type; private final JSDocInfo info;"
      },
      {
        "txt": "private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine, JSDocInfo info) { this.name = name; this.nameNode = nameNode;"
      },
      {
        "txt": "this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred; } public String getName() { return name;"
      },
      {
        "txt": "} public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); } Scope getScope() { return scope; }"
      },
      {
        "txt": "public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() { return input == null || input.isExtern(); } public boolean isConst() {"
      },
      {
        "txt": "return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode(); int pType = parent.getType(); if (pType == Token.FUNCTION) { return parent;"
      },
      {
        "txt": "} else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; } } public JSType getType() { return type;"
      },
      {
        "txt": "} public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info; } void setType(JSType type) { Preconditions.checkState(isTypeInferred()); this.type = type;"
      },
      {
        "txt": "} void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } } public boolean isTypeInferred() { return typeInferred; } public String getInputName() {"
      },
      {
        "txt": "if (input == null) return \"<non-file>\"; else return input.getName(); } public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true; } else { return false;"
      },
      {
        "txt": "} } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false; } Var otherVar = (Var) other; return otherVar.nameNode == nameNode; } @Override public int hashCode() {"
      },
      {
        "txt": "} @Override public String toString() { return \"Scope.Var \" + name; } } <extra_id_0> Scope(Scope parent, Node rootNode) { Preconditions.checkNotNull(parent); Preconditions.checkArgument(rootNode != parent.rootNode); this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType();"
      },
      {
        "txt": "this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType instanceof FunctionType) { thisType = ((FunctionType) nodeType).getTypeOfThis(); } else { thisType = parent.thisType; } this.isBottom = false; this.depth = parent.depth + 1; }"
      },
      {
        "txt": "Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; } Scope(Node rootNode, ObjectType thisType) { this.parent = null; this.rootNode = rootNode;"
      },
      {
        "txt": "this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; } boolean isBottom() { return isBottom; }"
      },
      {
        "txt": "public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() { Scope result = this; while (result.getParent() != null) { result = result.getParent();"
      },
      {
        "txt": "} return result; } @Override public StaticScope<JSType> getParentScope() { return parent; } public ObjectType getTypeOfThis() { return thisType; }"
      },
      {
        "txt": "Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null); JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode); Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info);"
      },
      {
        "txt": "vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name); } public StaticSlot<JSType> getSlot(String name) { return getVar(name);"
      },
      {
        "txt": "} public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) { Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name);"
      },
      {
        "txt": "} else { return null; } } public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true; if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse);"
      },
      {
        "txt": "} return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } public int getVarCount() { return vars.size(); } public boolean isGlobal() {"
      },
      {
        "txt": "return parent == null; } public boolean isLocal() { return !isGlobal(); }"
      }
    ]
  },
  {
    "id": 700,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 292,
    "end-bug-line": 292,
    "bug": "",
    "fix": "@Override public boolean equals(Object other) { if (!(other instanceof Arguments)) { return false; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import com.google.common.base.Preconditions; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; public class Scope implements StaticScope<JSType> { private final Map<String, Var> vars = new LinkedHashMap<String, Var>();"
      },
      {
        "txt": "private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; public static class Var implements StaticSlot<JSType> { final String name; final Node nameNode; private JSType type; private final JSDocInfo info;"
      },
      {
        "txt": "private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine, JSDocInfo info) { this.name = name; this.nameNode = nameNode;"
      },
      {
        "txt": "this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred; } public String getName() { return name;"
      },
      {
        "txt": "} public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); } Scope getScope() { return scope; }"
      },
      {
        "txt": "public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() { return input == null || input.isExtern(); } public boolean isConst() {"
      },
      {
        "txt": "return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode(); int pType = parent.getType(); if (pType == Token.FUNCTION) { return parent;"
      },
      {
        "txt": "} else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; } } public JSType getType() { return type;"
      },
      {
        "txt": "} public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info; } void setType(JSType type) { Preconditions.checkState(isTypeInferred()); this.type = type;"
      },
      {
        "txt": "} void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } } public boolean isTypeInferred() { return typeInferred; } public String getInputName() {"
      },
      {
        "txt": "if (input == null) return \"<non-file>\"; else return input.getName(); } public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true; } else { return false;"
      },
      {
        "txt": "} } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false; } Var otherVar = (Var) other; return otherVar.nameNode == nameNode; } @Override public int hashCode() {"
      },
      {
        "txt": "} @Override public String toString() { return \"Scope.Var \" + name; } } <extra_id_0> Scope(Scope parent, Node rootNode) { Preconditions.checkNotNull(parent); Preconditions.checkArgument(rootNode != parent.rootNode); this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType();"
      },
      {
        "txt": "this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType instanceof FunctionType) { thisType = ((FunctionType) nodeType).getTypeOfThis(); } else { thisType = parent.thisType; } this.isBottom = false; this.depth = parent.depth + 1; }"
      },
      {
        "txt": "Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; } Scope(Node rootNode, ObjectType thisType) { this.parent = null; this.rootNode = rootNode;"
      },
      {
        "txt": "this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; } boolean isBottom() { return isBottom; }"
      },
      {
        "txt": "public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() { Scope result = this; while (result.getParent() != null) { result = result.getParent();"
      },
      {
        "txt": "} return result; } @Override public StaticScope<JSType> getParentScope() { return parent; } public ObjectType getTypeOfThis() { return thisType; }"
      },
      {
        "txt": "Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null); JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode); Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info);"
      },
      {
        "txt": "vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name); } public StaticSlot<JSType> getSlot(String name) { return getVar(name);"
      },
      {
        "txt": "} public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) { Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name);"
      },
      {
        "txt": "} else { return null; } } public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true; if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse);"
      },
      {
        "txt": "} return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } public int getVarCount() { return vars.size(); } public boolean isGlobal() {"
      },
      {
        "txt": "return parent == null; } public boolean isLocal() { return !isGlobal(); }"
      }
    ]
  },
  {
    "id": 701,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 293,
    "end-bug-line": 293,
    "bug": "",
    "fix": "Arguments otherVar = (Arguments) other; return otherVar.scope.getRootNode() == scope.getRootNode(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import com.google.common.base.Preconditions; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; public class Scope implements StaticScope<JSType> { private final Map<String, Var> vars = new LinkedHashMap<String, Var>();"
      },
      {
        "txt": "private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; public static class Var implements StaticSlot<JSType> { final String name; final Node nameNode; private JSType type; private final JSDocInfo info;"
      },
      {
        "txt": "private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine, JSDocInfo info) { this.name = name; this.nameNode = nameNode;"
      },
      {
        "txt": "this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred; } public String getName() { return name;"
      },
      {
        "txt": "} public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); } Scope getScope() { return scope; }"
      },
      {
        "txt": "public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() { return input == null || input.isExtern(); } public boolean isConst() {"
      },
      {
        "txt": "return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode(); int pType = parent.getType(); if (pType == Token.FUNCTION) { return parent;"
      },
      {
        "txt": "} else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; } } public JSType getType() { return type;"
      },
      {
        "txt": "} public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info; } void setType(JSType type) { Preconditions.checkState(isTypeInferred()); this.type = type;"
      },
      {
        "txt": "} void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } } public boolean isTypeInferred() { return typeInferred; } public String getInputName() {"
      },
      {
        "txt": "if (input == null) return \"<non-file>\"; else return input.getName(); } public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true; } else { return false;"
      },
      {
        "txt": "} } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false; } Var otherVar = (Var) other; return otherVar.nameNode == nameNode; } @Override public int hashCode() {"
      },
      {
        "txt": "} @Override public String toString() { return \"Scope.Var \" + name; } } <extra_id_0> Scope(Scope parent, Node rootNode) { Preconditions.checkNotNull(parent); Preconditions.checkArgument(rootNode != parent.rootNode); this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType();"
      },
      {
        "txt": "this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType instanceof FunctionType) { thisType = ((FunctionType) nodeType).getTypeOfThis(); } else { thisType = parent.thisType; } this.isBottom = false; this.depth = parent.depth + 1; }"
      },
      {
        "txt": "Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; } Scope(Node rootNode, ObjectType thisType) { this.parent = null; this.rootNode = rootNode;"
      },
      {
        "txt": "this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; } boolean isBottom() { return isBottom; }"
      },
      {
        "txt": "public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() { Scope result = this; while (result.getParent() != null) { result = result.getParent();"
      },
      {
        "txt": "} return result; } @Override public StaticScope<JSType> getParentScope() { return parent; } public ObjectType getTypeOfThis() { return thisType; }"
      },
      {
        "txt": "Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null); JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode); Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info);"
      },
      {
        "txt": "vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name); } public StaticSlot<JSType> getSlot(String name) { return getVar(name);"
      },
      {
        "txt": "} public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) { Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name);"
      },
      {
        "txt": "} else { return null; } } public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true; if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse);"
      },
      {
        "txt": "} return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } public int getVarCount() { return vars.size(); } public boolean isGlobal() {"
      },
      {
        "txt": "return parent == null; } public boolean isLocal() { return !isGlobal(); }"
      }
    ]
  },
  {
    "id": 702,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 294,
    "end-bug-line": 294,
    "bug": "",
    "fix": "@Override public int hashCode() { return System.identityHashCode(this); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import com.google.common.base.Preconditions; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; public class Scope implements StaticScope<JSType> { private final Map<String, Var> vars = new LinkedHashMap<String, Var>();"
      },
      {
        "txt": "private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; public static class Var implements StaticSlot<JSType> { final String name; final Node nameNode; private JSType type; private final JSDocInfo info;"
      },
      {
        "txt": "private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine, JSDocInfo info) { this.name = name; this.nameNode = nameNode;"
      },
      {
        "txt": "this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred; } public String getName() { return name;"
      },
      {
        "txt": "} public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); } Scope getScope() { return scope; }"
      },
      {
        "txt": "public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() { return input == null || input.isExtern(); } public boolean isConst() {"
      },
      {
        "txt": "return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode(); int pType = parent.getType(); if (pType == Token.FUNCTION) { return parent;"
      },
      {
        "txt": "} else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; } } public JSType getType() { return type;"
      },
      {
        "txt": "} public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info; } void setType(JSType type) { Preconditions.checkState(isTypeInferred()); this.type = type;"
      },
      {
        "txt": "} void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } } public boolean isTypeInferred() { return typeInferred; } public String getInputName() {"
      },
      {
        "txt": "if (input == null) return \"<non-file>\"; else return input.getName(); } public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true; } else { return false;"
      },
      {
        "txt": "} } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false; } Var otherVar = (Var) other; return otherVar.nameNode == nameNode; } @Override public int hashCode() {"
      },
      {
        "txt": "} @Override public String toString() { return \"Scope.Var \" + name; } } <extra_id_0> Scope(Scope parent, Node rootNode) { Preconditions.checkNotNull(parent); Preconditions.checkArgument(rootNode != parent.rootNode); this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType();"
      },
      {
        "txt": "this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType instanceof FunctionType) { thisType = ((FunctionType) nodeType).getTypeOfThis(); } else { thisType = parent.thisType; } this.isBottom = false; this.depth = parent.depth + 1; }"
      },
      {
        "txt": "Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; } Scope(Node rootNode, ObjectType thisType) { this.parent = null; this.rootNode = rootNode;"
      },
      {
        "txt": "this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; } boolean isBottom() { return isBottom; }"
      },
      {
        "txt": "public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() { Scope result = this; while (result.getParent() != null) { result = result.getParent();"
      },
      {
        "txt": "} return result; } @Override public StaticScope<JSType> getParentScope() { return parent; } public ObjectType getTypeOfThis() { return thisType; }"
      },
      {
        "txt": "Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null); JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode); Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info);"
      },
      {
        "txt": "vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name); } public StaticSlot<JSType> getSlot(String name) { return getVar(name);"
      },
      {
        "txt": "} public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) { Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name);"
      },
      {
        "txt": "} else { return null; } } public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true; if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse);"
      },
      {
        "txt": "} return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } public int getVarCount() { return vars.size(); } public boolean isGlobal() {"
      },
      {
        "txt": "return parent == null; } public boolean isLocal() { return !isGlobal(); }"
      }
    ]
  },
  {
    "id": 703,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 459,
    "end-bug-line": 459,
    "bug": "",
    "fix": "public Var getArgumentsVar() { if (arguments == null) { arguments = new Arguments(this); } return arguments; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS; import com.google.common.base.Preconditions; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map;"
      },
      {
        "txt": "public class Scope implements StaticScope<JSType> { private final Map<String, Var> vars = new LinkedHashMap<String, Var>(); private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; public static class Var implements StaticSlot<JSType> { final String name; final Node nameNode;"
      },
      {
        "txt": "private JSType type; private final JSDocInfo info; private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine, JSDocInfo info) {"
      },
      {
        "txt": "this.name = name; this.nameNode = nameNode; this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred; }"
      },
      {
        "txt": "public String getName() { return name; } public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); } Scope getScope() {"
      },
      {
        "txt": "return scope; } public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() { return input == null || input.isExtern();"
      },
      {
        "txt": "} public boolean isConst() { return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode(); int pType = parent.getType();"
      },
      {
        "txt": "if (pType == Token.FUNCTION) { return parent; } else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; } }"
      },
      {
        "txt": "public JSType getType() { return type; } public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info; } void setType(JSType type) {"
      },
      {
        "txt": "Preconditions.checkState(isTypeInferred()); this.type = type; } void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } } public boolean isTypeInferred() { return typeInferred;"
      },
      {
        "txt": "} public String getInputName() { if (input == null) return \"<non-file>\"; else return input.getName(); } public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true;"
      },
      {
        "txt": "} else { return false; } } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false; } Var otherVar = (Var) other; return otherVar.nameNode == nameNode;"
      },
      {
        "txt": "} @Override public int hashCode() { return nameNode.hashCode(); } @Override public String toString() { return \"Scope.Var \" + name; } } Scope(Scope parent, Node rootNode) {"
      },
      {
        "txt": "Preconditions.checkNotNull(parent); Preconditions.checkArgument(rootNode != parent.rootNode); this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType instanceof FunctionType) { thisType = ((FunctionType) nodeType).getTypeOfThis(); } else { thisType = parent.thisType; }"
      },
      {
        "txt": "this.isBottom = false; this.depth = parent.depth + 1; } Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; }"
      },
      {
        "txt": "Scope(Node rootNode, ObjectType thisType) { this.parent = null; this.rootNode = rootNode; this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; }"
      },
      {
        "txt": "boolean isBottom() { return isBottom; } public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() {"
      },
      {
        "txt": "Scope result = this; while (result.getParent() != null) { result = result.getParent(); } return result; } @Override public StaticScope<JSType> getParentScope() { return parent; }"
      },
      {
        "txt": "public ObjectType getTypeOfThis() { return thisType; } Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null);"
      },
      {
        "txt": "JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode); Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info); vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name);"
      },
      {
        "txt": "} public StaticSlot<JSType> getSlot(String name) { return getVar(name); } public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) { Var var = vars.get(name); if (var != null) {"
      },
      {
        "txt": "} else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name); } else { return null; } } <extra_id_0> public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true; if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse);"
      },
      {
        "txt": "if (scope.parent != null && recurse) { return scope.parent.isDeclared(name, recurse); } return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } public int getVarCount() { return vars.size();"
      },
      {
        "txt": "} public boolean isGlobal() { return parent == null; } public boolean isLocal() { return !isGlobal(); }"
      }
    ]
  }
]