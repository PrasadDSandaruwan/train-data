[
  {
    "id": 408,
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
    "start-bug-line": 329,
    "end-bug-line": 329,
    "bug": "",
    "fix": "case Token.ADD:",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Maps; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.TernaryValue;"
      },
      {
        "txt": "import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; public final class NodeUtil { private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS ="
      },
      {
        "txt": "new HashSet<String>(Arrays.asList( \"Array\", \"Date\", \"Error\", \"Object\", \"RegExp\", \"XMLHttpRequest\")); private NodeUtil() {} static TernaryValue getExpressionBooleanValue(Node n) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.ASSIGN: case Token.COMMA: return getExpressionBooleanValue(n.getLastChild()); case Token.NOT: TernaryValue value = getExpressionBooleanValue(n.getLastChild()); return value.not(); case Token.AND: { TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild()); TernaryValue rhs = getExpressionBooleanValue(n.getLastChild()); return lhs.and(rhs);"
      },
      {
        "txt": "} case Token.OR: { TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild()); TernaryValue rhs = getExpressionBooleanValue(n.getLastChild()); return lhs.or(rhs); } case Token.HOOK: { TernaryValue trueValue = getExpressionBooleanValue( n.getFirstChild().getNext()); TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());"
      },
      {
        "txt": "if (trueValue.equals(falseValue)) { return trueValue; } else { return TernaryValue.UNKNOWN; } } default: return getBooleanValue(n); } }"
      },
      {
        "txt": "static TernaryValue getBooleanValue(Node n) { switch (n.getType()) { case Token.STRING: return TernaryValue.forBoolean(n.getString().length() > 0); case Token.NUMBER: return TernaryValue.forBoolean(n.getDouble() != 0); case Token.NULL: case Token.FALSE: case Token.VOID: return TernaryValue.FALSE;"
      },
      {
        "txt": "case Token.NAME: String name = n.getString(); if (\"undefined\".equals(name) || \"NaN\".equals(name)) { return TernaryValue.FALSE; } else if (\"Infinity\".equals(name)) { return TernaryValue.TRUE; } break; case Token.TRUE:"
      },
      {
        "txt": "case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: return TernaryValue.TRUE; } return TernaryValue.UNKNOWN; } static String getStringValue(Node n) { switch (n.getType()) { case Token.NAME:"
      },
      {
        "txt": "case Token.STRING: return n.getString(); case Token.NUMBER: double value = n.getDouble(); long longValue = (long) value; if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(n.getDouble()); }"
      },
      {
        "txt": "case Token.FALSE: case Token.TRUE: case Token.NULL: return Node.tokenToName(n.getType()); case Token.VOID: return \"undefined\"; } return null; } static String getFunctionName(Node n) {"
      },
      {
        "txt": "Node parent = n.getParent(); String name = n.getFirstChild().getString(); switch (parent.getType()) { case Token.NAME: return parent.getString(); case Token.ASSIGN: return parent.getFirstChild().getQualifiedName(); default: return name != null && name.length() != 0 ? name : null; }"
      },
      {
        "txt": "} static String getNearestFunctionName(Node n) { String name = getFunctionName(n); if (name != null) { return name; } Node parent = n.getParent(); switch (parent.getType()) { case Token.OBJECTLIT: return getStringValue(parent.getFirstChild());"
      },
      {
        "txt": "} return null; } static boolean isImmutableValue(Node n) { switch (n.getType()) { case Token.STRING: case Token.NUMBER: case Token.NULL: case Token.TRUE: case Token.FALSE:"
      },
      {
        "txt": "return true; case Token.VOID: case Token.NEG: return isImmutableValue(n.getFirstChild()); case Token.NAME: String name = n.getString(); return \"undefined\".equals(name) || \"Infinity\".equals(name) || \"NaN\".equals(name); }"
      },
      {
        "txt": "return false; } static boolean isLiteralValue(Node n, boolean includeFunctions) { switch (n.getType()) { case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!isLiteralValue(child, includeFunctions)) {"
      },
      {
        "txt": "return false; } } return true; case Token.FUNCTION: return includeFunctions && !NodeUtil.isFunctionDeclaration(n); default: return isImmutableValue(n); } }"
      },
      {
        "txt": "switch (val.getType()) { case Token.STRING: case Token.NUMBER: case Token.TRUE: case Token.FALSE: return true; <extra_id_0> case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.NOT: case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines);"
      },
      {
        "txt": "case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines); case Token.NAME: case Token.GETPROP: if (val.isQualifiedName()) { return defines.contains(val.getQualifiedName()); } } return false; }"
      },
      {
        "txt": "static boolean isEmptyBlock(Node block) { if (block.getType() != Token.BLOCK) { return false; } for (Node n = block.getFirstChild(); n != null; n = n.getNext()) { if (n.getType() != Token.EMPTY) { return false; } } return true;"
      },
      {
        "txt": "} static boolean isSimpleOperator(Node n) { return isSimpleOperatorType(n.getType()); } static boolean isSimpleOperatorType(int type) { switch (type) { case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR:"
      },
      {
        "txt": "case Token.BITXOR: case Token.COMMA: case Token.DIV: case Token.EQ: case Token.GE: case Token.GETELEM: case Token.GETPROP: case Token.GT: case Token.INSTANCEOF: case Token.LE:"
      },
      {
        "txt": "case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.NOT: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB:"
      },
      {
        "txt": "case Token.TYPEOF: case Token.VOID: case Token.POS: case Token.NEG: case Token.URSH: return true; default: return false; } }"
      },
      {
        "txt": "public static Node newExpr(Node child) { Node expr = new Node(Token.EXPR_RESULT, child) .copyInformationFrom(child); return expr; } static boolean mayEffectMutableState(Node n) { return mayEffectMutableState(n, null); } static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) { return checkForStateChangeHelper(n, true, compiler);"
      },
      {
        "txt": "} static boolean mayHaveSideEffects(Node n) { return mayHaveSideEffects(n, null); } static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) { return checkForStateChangeHelper(n, false, compiler); } private static boolean checkForStateChangeHelper( Node n, boolean checkForNewObjects, AbstractCompiler compiler) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.AND: case Token.BLOCK: case Token.EXPR_RESULT: case Token.HOOK: case Token.IF: case Token.IN: case Token.LP: case Token.NUMBER: case Token.OR: case Token.THIS:"
      },
      {
        "txt": "case Token.TRUE: case Token.FALSE: case Token.NULL: case Token.STRING: case Token.SWITCH: case Token.TRY: case Token.EMPTY: break; case Token.THROW: return true;"
      },
      {
        "txt": "case Token.OBJECTLIT: case Token.ARRAYLIT: case Token.REGEXP: if (checkForNewObjects) { return true; } break; case Token.VAR: // empty var statement (no declaration) case Token.NAME: // variable by itself if (n.getFirstChild() != null) {"
      },
      {
        "txt": "return true; } break; case Token.FUNCTION: return checkForNewObjects || !isFunctionExpression(n); case Token.NEW: if (checkForNewObjects) { return true; } if (!constructorCallHasSideEffects(n)) {"
      },
      {
        "txt": "break; } return true; case Token.CALL: if (!functionCallHasSideEffects(n, compiler)) { break; } return true; default: if (isSimpleOperatorType(n.getType())) {"
      },
      {
        "txt": "break; } if (isAssignmentOp(n)) { Node assignTarget = n.getFirstChild(); if (isName(assignTarget)) { return true; } if (checkForStateChangeHelper( n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper("
      },
      {
        "txt": "n.getLastChild(), checkForNewObjects, compiler)) { return true; } if (isGet(assignTarget)) { Node current = assignTarget.getFirstChild(); if (evaluatesToLocalValue(current)) { return false; } while (isGet(current)) { current = current.getFirstChild();"
      },
      {
        "txt": "} return !isLiteralValue(current, true); } else { return !isLiteralValue(assignTarget, true); } } return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {"
      },
      {
        "txt": "return true; } } return false; } static boolean constructorCallHasSideEffects(Node callNode) { return constructorCallHasSideEffects(callNode, null); } static boolean constructorCallHasSideEffects( Node callNode, AbstractCompiler compiler) {"
      },
      {
        "txt": "Preconditions.checkArgument( callNode.getType() == Token.NEW, \"Expected NEW node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) { return false;"
      },
      {
        "txt": "} return true; } private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS = ImmutableSet.of( \"Object\", \"Array\", \"String\", \"Number\", \"Boolean\", \"RegExp\", \"Error\"); private static final Set<String> REGEXP_METHODS = ImmutableSet.of(\"test\", \"exec\"); private static final Set<String> STRING_REGEXP_METHODS = ImmutableSet.of(\"match\", \"replace\", \"search\", \"split\");"
      },
      {
        "txt": "static boolean functionCallHasSideEffects( Node callNode) { return functionCallHasSideEffects(callNode, null); } static boolean functionCallHasSideEffects( Node callNode, @Nullable AbstractCompiler compiler) { Preconditions.checkArgument( callNode.getType() == Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) {"
      },
      {
        "txt": "return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { String name = nameNode.getString(); if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) { return false; } } else if (nameNode.getType() == Token.GETPROP) { if (callNode.isOnlyModifiesThisCall()"
      },
      {
        "txt": "&& evaluatesToLocalValue(nameNode.getFirstChild())) { return false; } if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false; } } if (compiler != null && !compiler.hasRegExpGlobalReferences()) {"
      },
      {
        "txt": "if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) { return false; } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains( nameNode.getLastChild().getString())) { Node param = nameNode.getNext(); if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))"
      },
      {
        "txt": "return false; } } } return true; } static boolean callHasLocalResult(Node n) { Preconditions.checkState(n.getType() == Token.CALL); return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0; }"
      },
      {
        "txt": "static boolean nodeTypeMayHaveSideEffects(Node n) { return nodeTypeMayHaveSideEffects(n, null); } static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) { if (isAssignmentOp(n)) { return true; } switch(n.getType()) { case Token.DELPROP: case Token.DEC:"
      },
      {
        "txt": "case Token.INC: case Token.THROW: return true; case Token.CALL: return NodeUtil.functionCallHasSideEffects(n, compiler); case Token.NEW: return NodeUtil.constructorCallHasSideEffects(n, compiler); case Token.NAME: return n.hasChildren(); default:"
      },
      {
        "txt": "return false; } } static boolean canBeSideEffected(Node n) { Set<String> emptySet = Collections.emptySet(); return canBeSideEffected(n, emptySet); } static boolean canBeSideEffected(Node n, Set<String> knownConstants) { switch (n.getType()) { case Token.CALL:"
      },
      {
        "txt": "case Token.NEW: return true; case Token.NAME: return !isConstantName(n) && !knownConstants.contains(n.getString()); case Token.GETPROP: case Token.GETELEM: return true; case Token.FUNCTION: Preconditions.checkState(isFunctionExpression(n));"
      },
      {
        "txt": "return false; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (canBeSideEffected(c, knownConstants)) { return true; } } return false; } static int precedence(int type) {"
      },
      {
        "txt": "switch (type) { case Token.COMMA: return 0; case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB:"
      },
      {
        "txt": "case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN: return 1; case Token.HOOK: return 2; // ?: operator case Token.OR: return 3; case Token.AND: return 4; case Token.BITOR: return 5; case Token.BITXOR: return 6; case Token.BITAND: return 7;"
      },
      {
        "txt": "case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: return 8; case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.INSTANCEOF: case Token.IN: return 9;"
      },
      {
        "txt": "case Token.LSH: case Token.RSH: case Token.URSH: return 10; case Token.SUB: case Token.ADD: return 11; case Token.MUL: case Token.MOD: case Token.DIV: return 12; case Token.INC: case Token.DEC:"
      },
      {
        "txt": "case Token.NEW: case Token.DELPROP: case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: case Token.NEG: return 13; case Token.ARRAYLIT: case Token.CALL:"
      },
      {
        "txt": "case Token.EMPTY: case Token.FALSE: case Token.FUNCTION: case Token.GETELEM: case Token.GETPROP: case Token.GET_REF: case Token.IF: case Token.LP: case Token.NAME: case Token.NULL:"
      },
      {
        "txt": "case Token.NUMBER: case Token.OBJECTLIT: case Token.REGEXP: case Token.RETURN: case Token.STRING: case Token.THIS: case Token.TRUE: return 15; default: throw new Error(\"Unknown precedence for \" + Node.tokenToName(type) +"
      },
      {
        "txt": "\" (type \" + type + \")\"); } } static boolean isAssociative(int type) { switch (type) { case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITAND:"
      },
      {
        "txt": "return true; default: return false; } } static boolean isAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR:"
      },
      {
        "txt": "case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: return true;"
      },
      {
        "txt": "} return false; } static int getOpFromAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN_BITOR: return Token.BITOR; case Token.ASSIGN_BITXOR: return Token.BITXOR; case Token.ASSIGN_BITAND:"
      },
      {
        "txt": "return Token.BITAND; case Token.ASSIGN_LSH: return Token.LSH; case Token.ASSIGN_RSH: return Token.RSH; case Token.ASSIGN_URSH: return Token.URSH; case Token.ASSIGN_ADD: return Token.ADD; case Token.ASSIGN_SUB:"
      },
      {
        "txt": "return Token.SUB; case Token.ASSIGN_MUL: return Token.MUL; case Token.ASSIGN_DIV: return Token.DIV; case Token.ASSIGN_MOD: return Token.MOD; } throw new IllegalArgumentException(\"Not an assiment op\"); }"
      },
      {
        "txt": "static boolean isExpressionNode(Node n) { return n.getType() == Token.EXPR_RESULT; } static boolean containsFunction(Node n) { return containsType(n, Token.FUNCTION); } static boolean referencesThis(Node n) { return containsType(n, Token.THIS, new MatchNotFunction()); } static boolean isGet(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.GETPROP || n.getType() == Token.GETELEM; } static boolean isGetProp(Node n) { return n.getType() == Token.GETPROP; } static boolean isName(Node n) { return n.getType() == Token.NAME; } static boolean isNew(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.NEW; } static boolean isVar(Node n) { return n.getType() == Token.VAR; } static boolean isVarDeclaration(Node n) { return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR; } static Node getAssignedValue(Node n) { Preconditions.checkState(isName(n));"
      },
      {
        "txt": "Node parent = n.getParent(); if (isVar(parent)) { return n.getFirstChild(); } else if (isAssign(parent) && parent.getFirstChild() == n) { return n.getNext(); } else { return null; } } static boolean isString(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.STRING; } static boolean isExprAssign(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.ASSIGN; } static boolean isAssign(Node n) { return n.getType() == Token.ASSIGN; } static boolean isExprCall(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.CALL; } static boolean isForIn(Node n) { return n.getType() == Token.FOR && n.getChildCount() == 3; } static boolean isLoopStructure(Node n) { switch (n.getType()) { case Token.FOR:"
      },
      {
        "txt": "case Token.DO: case Token.WHILE: return true; default: return false; } } static Node getLoopCodeBlock(Node n) { switch (n.getType()) { case Token.FOR:"
      },
      {
        "txt": "case Token.WHILE: return n.getLastChild(); case Token.DO: return n.getFirstChild(); default: return null; } } static boolean isWithinLoop(Node n) { for (Node parent : n.getAncestors()) {"
      },
      {
        "txt": "if (NodeUtil.isLoopStructure(parent)) { return true; } if (NodeUtil.isFunction(parent)) { break; } } return false; } static boolean isControlStructure(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: case Token.WITH: case Token.IF: case Token.LABEL: case Token.TRY: case Token.CATCH: case Token.SWITCH:"
      },
      {
        "txt": "case Token.CASE: case Token.DEFAULT: return true; default: return false; } } static boolean isControlStructureCodeBlock(Node parent, Node n) { switch (parent.getType()) { case Token.FOR:"
      },
      {
        "txt": "case Token.WHILE: case Token.LABEL: case Token.WITH: return parent.getLastChild() == n; case Token.DO: return parent.getFirstChild() == n; case Token.IF: return parent.getFirstChild() != n; case Token.TRY: return parent.getFirstChild() == n || parent.getLastChild() == n;"
      },
      {
        "txt": "case Token.CATCH: return parent.getLastChild() == n; case Token.SWITCH: case Token.CASE: return parent.getFirstChild() != n; case Token.DEFAULT: return true; default: Preconditions.checkState(isControlStructure(parent)); return false;"
      },
      {
        "txt": "} } static Node getConditionExpression(Node n) { switch (n.getType()) { case Token.IF: case Token.WHILE: return n.getFirstChild(); case Token.DO: return n.getLastChild(); case Token.FOR:"
      },
      {
        "txt": "switch (n.getChildCount()) { case 3: return null; case 4: return n.getFirstChild().getNext(); } throw new IllegalArgumentException(\"malformed 'for' statement \" + n); case Token.CASE: return null; }"
      },
      {
        "txt": "throw new IllegalArgumentException(n + \" does not have a condition.\"); } static boolean isStatementBlock(Node n) { return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK; } static boolean isStatement(Node n) { Node parent = n.getParent(); Preconditions.checkState(parent != null); switch (parent.getType()) { case Token.SCRIPT:"
      },
      {
        "txt": "case Token.BLOCK: case Token.LABEL: return true; default: return false; } } static boolean isSwitchCase(Node n) { return n.getType() == Token.CASE || n.getType() == Token.DEFAULT; }"
      },
      {
        "txt": "static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty(); } static boolean isLabelName(Node n) { return (n != null && n.getType() == Token.LABEL_NAME); } static boolean isTryFinallyNode(Node parent, Node child) { return parent.getType() == Token.TRY && parent.getChildCount() == 3 && child == parent.getLastChild(); }"
      },
      {
        "txt": "static void removeChild(Node parent, Node node) { if (isStatementBlock(parent) || isSwitchCase(node) || isTryFinallyNode(parent, node)) { parent.removeChild(node); } else if (parent.getType() == Token.VAR) { if (parent.hasMoreThanOneChild()) { parent.removeChild(node); } else { parent.removeChild(node);"
      },
      {
        "txt": "removeChild(parent.getParent(), parent); } } else if (node.getType() == Token.BLOCK) { node.detachChildren(); } else if (parent.getType() == Token.LABEL && node == parent.getLastChild()) { parent.removeChild(node); removeChild(parent.getParent(), parent); } else if (parent.getType() == Token.FOR && parent.getChildCount() == 4) {"
      },
      {
        "txt": "parent.replaceChild(node, new Node(Token.EMPTY)); } else { throw new IllegalStateException(\"Invalid attempt to remove node: \" + node.toString() + \" of \"+ parent.toString()); } } static boolean tryMergeBlock(Node block) { Preconditions.checkState(block.getType() == Token.BLOCK); Node parent = block.getParent(); if (isStatementBlock(parent)) {"
      },
      {
        "txt": "Node previous = block; while (block.hasChildren()) { Node child = block.removeFirstChild(); parent.addChildAfter(child, previous); previous = child; } parent.removeChild(block); return true; } else { return false;"
      },
      {
        "txt": "} } static boolean isCall(Node n) { return n.getType() == Token.CALL; } static boolean isFunction(Node n) { return n.getType() == Token.FUNCTION; } static Node getFunctionBody(Node fn) { Preconditions.checkArgument(isFunction(fn));"
      },
      {
        "txt": "return fn.getLastChild(); } static boolean isThis(Node node) { return node.getType() == Token.THIS; } static boolean containsCall(Node n) { return containsType(n, Token.CALL); } static boolean isFunctionDeclaration(Node n) { return n.getType() == Token.FUNCTION && isStatement(n);"
      },
      {
        "txt": "} static boolean isHoistedFunctionDeclaration(Node n) { return isFunctionDeclaration(n) && (n.getParent().getType() == Token.SCRIPT || n.getParent().getParent().getType() == Token.FUNCTION); } static boolean isFunctionExpression(Node n) { return n.getType() == Token.FUNCTION && !isStatement(n); } static boolean isEmptyFunctionExpression(Node node) {"
      },
      {
        "txt": "return isFunctionExpression(node) && isEmptyBlock(node.getLastChild()); } static boolean isVarArgsFunction(Node function) { Preconditions.checkArgument(isFunction(function)); return isNameReferenced( function.getLastChild(), \"arguments\", new MatchNotFunction()); } static boolean isObjectCallMethod(Node callNode, String methodName) {"
      },
      {
        "txt": "if (callNode.getType() == Token.CALL) { Node functionIndentifyingExpression = callNode.getFirstChild(); if (isGet(functionIndentifyingExpression)) { Node last = functionIndentifyingExpression.getLastChild(); if (last != null && last.getType() == Token.STRING) { String propName = last.getString(); return (propName.equals(methodName)); } } }"
      },
      {
        "txt": "return false; } static boolean isFunctionObjectCall(Node callNode) { return isObjectCallMethod(callNode, \"call\"); } static boolean isFunctionObjectApply(Node callNode) { return isObjectCallMethod(callNode, \"apply\"); } static boolean isSimpleFunctionObjectCall(Node callNode) { if (isFunctionObjectCall(callNode)) {"
      },
      {
        "txt": "if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) { return true; } } return false; } static boolean isLhs(Node n, Node parent) { return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) || parent.getType() == Token.VAR; }"
      },
      {
        "txt": "static boolean isObjectLitKey(Node node, Node parent) { if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) { int index = 0; for (Node current = parent.getFirstChild(); current != null; current = current.getNext()) { if (current == node) { return index % 2 == 0; } index++;"
      },
      {
        "txt": "} } return false; } static String opToStr(int operator) { switch (operator) { case Token.BITOR: return \"|\"; case Token.OR: return \"||\"; case Token.BITXOR: return \"^\"; case Token.AND: return \"&&\";"
      },
      {
        "txt": "case Token.BITAND: return \"&\"; case Token.SHEQ: return \"===\"; case Token.EQ: return \"==\"; case Token.NOT: return \"!\"; case Token.NE: return \"!=\"; case Token.SHNE: return \"!==\"; case Token.LSH: return \"<<\"; case Token.IN: return \"in\"; case Token.LE: return \"<=\"; case Token.LT: return \"<\";"
      },
      {
        "txt": "case Token.URSH: return \">>>\"; case Token.RSH: return \">>\"; case Token.GE: return \">=\"; case Token.GT: return \">\"; case Token.MUL: return \"*\"; case Token.DIV: return \"/\"; case Token.MOD: return \"%\"; case Token.BITNOT: return \"~\"; case Token.ADD: return \"+\"; case Token.SUB: return \"-\";"
      },
      {
        "txt": "case Token.POS: return \"+\"; case Token.NEG: return \"-\"; case Token.ASSIGN: return \"=\"; case Token.ASSIGN_BITOR: return \"|=\"; case Token.ASSIGN_BITXOR: return \"^=\"; case Token.ASSIGN_BITAND: return \"&=\"; case Token.ASSIGN_LSH: return \"<<=\"; case Token.ASSIGN_RSH: return \">>=\"; case Token.ASSIGN_URSH: return \">>>=\"; case Token.ASSIGN_ADD: return \"+=\";"
      },
      {
        "txt": "case Token.ASSIGN_SUB: return \"-=\"; case Token.ASSIGN_MUL: return \"*=\"; case Token.ASSIGN_DIV: return \"/=\"; case Token.ASSIGN_MOD: return \"%=\"; case Token.VOID: return \"void\"; case Token.TYPEOF: return \"typeof\"; case Token.INSTANCEOF: return \"instanceof\"; default: return null; } }"
      },
      {
        "txt": "static String opToStrNoFail(int operator) { String res = opToStr(operator); if (res == null) { throw new Error(\"Unknown op \" + operator + \": \" + Token.name(operator)); } return res; } static boolean containsType(Node node, int type,"
      },
      {
        "txt": "Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static boolean containsType(Node node, int type) { return containsType(node, type, Predicates.<Node>alwaysTrue()); } static void redeclareVarsInsideBranch(Node branch) { Collection<Node> vars = getVarsDeclaredInBranch(branch); if (vars.isEmpty()) { return;"
      },
      {
        "txt": "} Node parent = getAddingRoot(branch); for (Node nameNode : vars) { Node var = new Node( Token.VAR, Node.newString(Token.NAME, nameNode.getString()) .copyInformationFrom(nameNode)) .copyInformationFrom(nameNode); copyNameAnnotations(nameNode, var.getFirstChild()); parent.addChildToFront(var);"
      },
      {
        "txt": "} } static void copyNameAnnotations(Node source, Node destination) { if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) { destination.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } private static Node getAddingRoot(Node n) { Node addingRoot = null; Node ancestor = n;"
      },
      {
        "txt": "while (null != (ancestor = ancestor.getParent())) { int type = ancestor.getType(); if (type == Token.SCRIPT) { addingRoot = ancestor; break; } else if (type == Token.FUNCTION) { addingRoot = ancestor.getLastChild(); break; } }"
      },
      {
        "txt": "Preconditions.checkState(addingRoot.getType() == Token.BLOCK || addingRoot.getType() == Token.SCRIPT); Preconditions.checkState(addingRoot.getFirstChild() == null || addingRoot.getFirstChild().getType() != Token.SCRIPT); return addingRoot; } public static Node newFunctionNode(String name, List<Node> params, Node body, int lineno, int charno) { Node parameterParen = new Node(Token.LP, lineno, charno); for (Node param : params) {"
      },
      {
        "txt": "parameterParen.addChildToBack(param); } Node function = new Node(Token.FUNCTION, lineno, charno); function.addChildrenToBack( Node.newString(Token.NAME, name, lineno, charno)); function.addChildToBack(parameterParen); function.addChildToBack(body); return function; } public static Node newQualifiedNameNode(String name, int lineno, int charno) {"
      },
      {
        "txt": "int endPos = name.indexOf('.'); if (endPos == -1) { return Node.newString(Token.NAME, name, lineno, charno); } Node node = Node.newString(Token.NAME, name.substring(0, endPos), lineno, charno); int startPos; do { startPos = endPos + 1; endPos = name.indexOf('.', startPos);"
      },
      {
        "txt": "String part = (endPos == -1 ? name.substring(startPos) : name.substring(startPos, endPos)); node = new Node(Token.GETPROP, node, Node.newString(Token.STRING, part, lineno, charno), lineno, charno); } while (endPos != -1); return node; } static Node newQualifiedNameNode(String name, Node basisNode,"
      },
      {
        "txt": "String originalName) { Node node = newQualifiedNameNode(name, -1, -1); setDebugInformation(node, basisNode, originalName); return node; } static Node getRootOfQualifiedName(Node qName) { for (Node current = qName; true; current = current.getFirstChild()) { int type = current.getType(); if (type == Token.NAME || type == Token.THIS) {"
      },
      {
        "txt": "return current; } Preconditions.checkState(type == Token.GETPROP); } } static void setDebugInformation(Node node, Node basisNode, String originalName) { node.copyInformationFromForTree(basisNode); node.putProp(Node.ORIGINALNAME_PROP, originalName); }"
      },
      {
        "txt": "static Node newName(String name, Node basisNode) { Node nameNode = Node.newString(Token.NAME, name); nameNode.copyInformationFrom(basisNode); return nameNode; } static Node newName(String name, Node basisNode, String originalName) { Node nameNode = newName(name, basisNode); nameNode.putProp(Node.ORIGINALNAME_PROP, originalName); return nameNode; }"
      },
      {
        "txt": "static boolean isLatin(String s) { char LARGEST_BASIC_LATIN = 0x7f; int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c > LARGEST_BASIC_LATIN) { return false; } } return true;"
      },
      {
        "txt": "} static boolean isValidPropertyName(String name) { return TokenStream.isJSIdentifier(name) && !TokenStream.isKeyword(name) && isLatin(name); } private static class VarCollector implements Visitor { final Map<String, Node> vars = Maps.newLinkedHashMap(); public void visit(Node n) { if (n.getType() == Token.NAME) {"
      },
      {
        "txt": "Node parent = n.getParent(); if (parent != null && parent.getType() == Token.VAR) { String name = n.getString(); if (!vars.containsKey(name)) { vars.put(name, n); } } } } }"
      },
      {
        "txt": "public static Collection<Node> getVarsDeclaredInBranch(Node root) { VarCollector collector = new VarCollector(); visitPreOrder( root, collector, new MatchNotFunction()); return collector.vars.values(); } static boolean isPrototypePropertyDeclaration(Node n) { if (!isExprAssign(n)) {"
      },
      {
        "txt": "return false; } return isPrototypeProperty(n.getFirstChild().getFirstChild()); } static boolean isPrototypeProperty(Node n) { String lhsString = n.getQualifiedName(); if (lhsString == null) { return false; } int prototypeIdx = lhsString.indexOf(\".prototype.\");"
      },
      {
        "txt": "return prototypeIdx != -1; } static Node getPrototypeClassName(Node qName) { Node cur = qName; while (isGetProp(cur)) { if (cur.getLastChild().getString().equals(\"prototype\")) { return cur.getFirstChild(); } else { cur = cur.getFirstChild(); }"
      },
      {
        "txt": "} return null; } static String getPrototypePropertyName(Node qName) { String qNameStr = qName.getQualifiedName(); int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\"); int memberIndex = prototypeIdx + \".prototype\".length() + 1; return qNameStr.substring(memberIndex); } static Node newUndefinedNode(Node srcReferenceNode) {"
      },
      {
        "txt": "Node node = new Node(Token.VOID, Node.newNumber(0)); if (srcReferenceNode != null) { node.copyInformationFromForTree(srcReferenceNode); } return node; } static Node newVarNode(String name, Node value) { Node nodeName = Node.newString(Token.NAME, name); if (value != null) { Preconditions.checkState(value.getNext() == null);"
      },
      {
        "txt": "nodeName.addChildToBack(value); nodeName.copyInformationFrom(value); } Node var = new Node(Token.VAR, nodeName) .copyInformationFrom(nodeName); return var; } private static class MatchNameNode implements Predicate<Node>{ final String name; MatchNameNode(String name){"
      },
      {
        "txt": "this.name = name; } public boolean apply(Node n) { return n.getType() == Token.NAME && n.getString().equals(name); } } static class MatchNodeType implements Predicate<Node>{ final int type; MatchNodeType(int type){"
      },
      {
        "txt": "this.type = type; } public boolean apply(Node n) { return n.getType() == type; } } static class MatchDeclaration implements Predicate<Node> { public boolean apply(Node n) { return isFunctionDeclaration(n) || n.getType() == Token.VAR; }"
      },
      {
        "txt": "} static class MatchNotFunction implements Predicate<Node>{ public boolean apply(Node n) { return !isFunction(n); } } static class MatchShallowStatement implements Predicate<Node>{ public boolean apply(Node n) { Node parent = n.getParent(); return n.getType() == Token.BLOCK"
      },
      {
        "txt": "|| (!isFunction(n) && (parent == null || isControlStructure(parent) || isStatementBlock(parent))); } } static int getNodeTypeReferenceCount( Node node, int type, Predicate<Node> traverseChildrenPred) { return getCount(node, new MatchNodeType(type), traverseChildrenPred); } static boolean isNameReferenced(Node node,"
      },
      {
        "txt": "String name, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNameNode(name), traverseChildrenPred); } static boolean isNameReferenced(Node node, String name) { return isNameReferenced(node, name, Predicates.<Node>alwaysTrue()); } static int getNameReferenceCount(Node node, String name) { return getCount( node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());"
      },
      {
        "txt": "} static boolean has(Node node, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { if (pred.apply(node)) { return true; } if (!traverseChildrenPred.apply(node)) { return false; }"
      },
      {
        "txt": "for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { if (has(c, pred, traverseChildrenPred)) { return true; } } return false; } static int getCount( Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { int total = 0;"
      },
      {
        "txt": "if (pred.apply(n)) { total++; } if (traverseChildrenPred.apply(n)) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { total += getCount(c, pred, traverseChildrenPred); } } return total; }"
      },
      {
        "txt": "static interface Visitor { void visit(Node node); } static void visitPreOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) { vistor.visit(node); if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPreOrder(c, vistor, traverseChildrenPred);"
      },
      {
        "txt": "} } } static void visitPostOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) { if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPostOrder(c, vistor, traverseChildrenPred); }"
      },
      {
        "txt": "} vistor.visit(node); } static boolean hasFinally(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getChildCount() == 3; } static Node getCatchBlock(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getFirstChild().getNext();"
      },
      {
        "txt": "} static boolean hasCatchHandler(Node n) { Preconditions.checkArgument(n.getType() == Token.BLOCK); return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH; } static Node getFnParameters(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } static boolean isConstantName(Node node) {"
      },
      {
        "txt": "return node.getBooleanProp(Node.IS_CONSTANT_NAME); } static boolean isConstantByConvention( CodingConvention convention, Node node, Node parent) { String name = node.getString(); if (parent.getType() == Token.GETPROP && node == parent.getLastChild()) { return convention.isConstantKey(name); } else if (isObjectLitKey(node, parent)) { return convention.isConstantKey(name);"
      },
      {
        "txt": "} else { return convention.isConstant(name); } } static JSDocInfo getInfoForNameNode(Node nameNode) { JSDocInfo info = null; Node parent = null; if (nameNode != null) { info = nameNode.getJSDocInfo(); parent = nameNode.getParent();"
      },
      {
        "txt": "} if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) || parent.getType() == Token.FUNCTION)) { info = parent.getJSDocInfo(); } return info; } static JSDocInfo getFunctionInfo(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION);"
      },
      {
        "txt": "JSDocInfo fnInfo = n.getJSDocInfo(); if (fnInfo == null && NodeUtil.isFunctionExpression(n)) { Node parent = n.getParent(); if (parent.getType() == Token.ASSIGN) { fnInfo = parent.getJSDocInfo(); } else if (parent.getType() == Token.NAME) { fnInfo = parent.getParent().getJSDocInfo(); } } return fnInfo;"
      },
      {
        "txt": "} static String getSourceName(Node n) { String sourceName = null; while (sourceName == null && n != null) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); n = n.getParent(); } return sourceName; } static Node newCallNode(Node callTarget, Node... parameters) {"
      },
      {
        "txt": "boolean isFreeCall = isName(callTarget); Node call = new Node(Token.CALL, callTarget); call.putBooleanProp(Node.FREE_CALL, isFreeCall); for (Node parameter : parameters) { call.addChildToBack(parameter); } return call; } static boolean evaluatesToLocalValue(Node value) { return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());"
      },
      {
        "txt": "} static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND:"
      },
      {
        "txt": "case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals);"
      },
      {
        "txt": "} else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value);"
      },
      {
        "txt": "case Token.CALL: return callHasLocalResult(value) || locals.apply(value); case Token.NEW: return true; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN:"
      },
      {
        "txt": "return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 409,
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
    "start-bug-line": 333,
    "end-bug-line": 333,
    "bug": "",
    "fix": "case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; public final class NodeUtil { private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS = new HashSet<String>(Arrays.asList( \"Array\", \"Date\", \"Error\","
      },
      {
        "txt": "\"Object\", \"RegExp\", \"XMLHttpRequest\")); private NodeUtil() {} static TernaryValue getExpressionBooleanValue(Node n) { switch (n.getType()) { case Token.ASSIGN: case Token.COMMA: return getExpressionBooleanValue(n.getLastChild()); case Token.NOT:"
      },
      {
        "txt": "TernaryValue value = getExpressionBooleanValue(n.getLastChild()); return value.not(); case Token.AND: { TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild()); TernaryValue rhs = getExpressionBooleanValue(n.getLastChild()); return lhs.and(rhs); } case Token.OR: { TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild()); TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());"
      },
      {
        "txt": "return lhs.or(rhs); } case Token.HOOK: { TernaryValue trueValue = getExpressionBooleanValue( n.getFirstChild().getNext()); TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild()); if (trueValue.equals(falseValue)) { return trueValue; } else { return TernaryValue.UNKNOWN;"
      },
      {
        "txt": "} } default: return getBooleanValue(n); } } static TernaryValue getBooleanValue(Node n) { switch (n.getType()) { case Token.STRING: return TernaryValue.forBoolean(n.getString().length() > 0);"
      },
      {
        "txt": "case Token.NUMBER: return TernaryValue.forBoolean(n.getDouble() != 0); case Token.NULL: case Token.FALSE: case Token.VOID: return TernaryValue.FALSE; case Token.NAME: String name = n.getString(); if (\"undefined\".equals(name) || \"NaN\".equals(name)) {"
      },
      {
        "txt": "return TernaryValue.FALSE; } else if (\"Infinity\".equals(name)) { return TernaryValue.TRUE; } break; case Token.TRUE: case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: return TernaryValue.TRUE;"
      },
      {
        "txt": "} return TernaryValue.UNKNOWN; } static String getStringValue(Node n) { switch (n.getType()) { case Token.NAME: case Token.STRING: return n.getString(); case Token.NUMBER: double value = n.getDouble();"
      },
      {
        "txt": "long longValue = (long) value; if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(n.getDouble()); } case Token.FALSE: case Token.TRUE: case Token.NULL: return Node.tokenToName(n.getType());"
      },
      {
        "txt": "case Token.VOID: return \"undefined\"; } return null; } static String getFunctionName(Node n) { Node parent = n.getParent(); String name = n.getFirstChild().getString(); switch (parent.getType()) { case Token.NAME:"
      },
      {
        "txt": "return parent.getString(); case Token.ASSIGN: return parent.getFirstChild().getQualifiedName(); default: return name != null && name.length() != 0 ? name : null; } } static String getNearestFunctionName(Node n) { String name = getFunctionName(n); if (name != null) {"
      },
      {
        "txt": "return name; } Node parent = n.getParent(); switch (parent.getType()) { case Token.OBJECTLIT: return getStringValue(parent.getFirstChild()); } return null; } static boolean isImmutableValue(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.STRING: case Token.NUMBER: case Token.NULL: case Token.TRUE: case Token.FALSE: return true; case Token.VOID: case Token.NEG: return isImmutableValue(n.getFirstChild());"
      },
      {
        "txt": "case Token.NAME: String name = n.getString(); return \"undefined\".equals(name) || \"Infinity\".equals(name) || \"NaN\".equals(name); } return false; } static boolean isLiteralValue(Node n, boolean includeFunctions) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!isLiteralValue(child, includeFunctions)) { return false; } } return true;"
      },
      {
        "txt": "case Token.FUNCTION: return includeFunctions && !NodeUtil.isFunctionDeclaration(n); default: return isImmutableValue(n); } } static boolean isValidDefineValue(Node val, Set<String> defines) { switch (val.getType()) { case Token.STRING: case Token.NUMBER:"
      },
      {
        "txt": "case Token.FALSE: return true; case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: <extra_id_0> case Token.NOT: case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines); case Token.NAME: case Token.GETPROP: if (val.isQualifiedName()) {"
      },
      {
        "txt": "case Token.GETPROP: if (val.isQualifiedName()) { return defines.contains(val.getQualifiedName()); } } return false; } static boolean isEmptyBlock(Node block) { if (block.getType() != Token.BLOCK) { return false;"
      },
      {
        "txt": "} for (Node n = block.getFirstChild(); n != null; n = n.getNext()) { if (n.getType() != Token.EMPTY) { return false; } } return true; } static boolean isSimpleOperator(Node n) { return isSimpleOperatorType(n.getType());"
      },
      {
        "txt": "} static boolean isSimpleOperatorType(int type) { switch (type) { case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.COMMA: case Token.DIV:"
      },
      {
        "txt": "case Token.EQ: case Token.GE: case Token.GETELEM: case Token.GETPROP: case Token.GT: case Token.INSTANCEOF: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD:"
      },
      {
        "txt": "case Token.MUL: case Token.NE: case Token.NOT: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.TYPEOF: case Token.VOID: case Token.POS:"
      },
      {
        "txt": "case Token.NEG: case Token.URSH: return true; default: return false; } } public static Node newExpr(Node child) { Node expr = new Node(Token.EXPR_RESULT, child) .copyInformationFrom(child);"
      },
      {
        "txt": "return expr; } static boolean mayEffectMutableState(Node n) { return mayEffectMutableState(n, null); } static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) { return checkForStateChangeHelper(n, true, compiler); } static boolean mayHaveSideEffects(Node n) { return mayHaveSideEffects(n, null);"
      },
      {
        "txt": "} static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) { return checkForStateChangeHelper(n, false, compiler); } private static boolean checkForStateChangeHelper( Node n, boolean checkForNewObjects, AbstractCompiler compiler) { switch (n.getType()) { case Token.AND: case Token.BLOCK: case Token.EXPR_RESULT:"
      },
      {
        "txt": "case Token.HOOK: case Token.IF: case Token.IN: case Token.LP: case Token.NUMBER: case Token.OR: case Token.THIS: case Token.TRUE: case Token.FALSE: case Token.NULL:"
      },
      {
        "txt": "case Token.STRING: case Token.SWITCH: case Token.TRY: case Token.EMPTY: break; case Token.THROW: return true; case Token.OBJECTLIT: case Token.ARRAYLIT: case Token.REGEXP:"
      },
      {
        "txt": "if (checkForNewObjects) { return true; } break; case Token.VAR: // empty var statement (no declaration) case Token.NAME: // variable by itself if (n.getFirstChild() != null) { return true; } break;"
      },
      {
        "txt": "case Token.FUNCTION: return checkForNewObjects || !isFunctionExpression(n); case Token.NEW: if (checkForNewObjects) { return true; } if (!constructorCallHasSideEffects(n)) { break; } return true;"
      },
      {
        "txt": "case Token.CALL: if (!functionCallHasSideEffects(n, compiler)) { break; } return true; default: if (isSimpleOperatorType(n.getType())) { break; } if (isAssignmentOp(n)) {"
      },
      {
        "txt": "Node assignTarget = n.getFirstChild(); if (isName(assignTarget)) { return true; } if (checkForStateChangeHelper( n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper( n.getLastChild(), checkForNewObjects, compiler)) { return true; }"
      },
      {
        "txt": "if (isGet(assignTarget)) { Node current = assignTarget.getFirstChild(); if (evaluatesToLocalValue(current)) { return false; } while (isGet(current)) { current = current.getFirstChild(); } return !isLiteralValue(current, true); } else {"
      },
      {
        "txt": "return !isLiteralValue(assignTarget, true); } } return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) { return true; } }"
      },
      {
        "txt": "return false; } static boolean constructorCallHasSideEffects(Node callNode) { return constructorCallHasSideEffects(callNode, null); } static boolean constructorCallHasSideEffects( Node callNode, AbstractCompiler compiler) { Preconditions.checkArgument( callNode.getType() == Token.NEW, \"Expected NEW node, got \" + Token.name(callNode.getType()));"
      },
      {
        "txt": "if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) { return false; } return true; }"
      },
      {
        "txt": "private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS = ImmutableSet.of( \"Object\", \"Array\", \"String\", \"Number\", \"Boolean\", \"RegExp\", \"Error\"); private static final Set<String> REGEXP_METHODS = ImmutableSet.of(\"test\", \"exec\"); private static final Set<String> STRING_REGEXP_METHODS = ImmutableSet.of(\"match\", \"replace\", \"search\", \"split\"); static boolean functionCallHasSideEffects( Node callNode) { return functionCallHasSideEffects(callNode, null);"
      },
      {
        "txt": "} static boolean functionCallHasSideEffects( Node callNode, @Nullable AbstractCompiler compiler) { Preconditions.checkArgument( callNode.getType() == Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild();"
      },
      {
        "txt": "if (nameNode.getType() == Token.NAME) { String name = nameNode.getString(); if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) { return false; } } else if (nameNode.getType() == Token.GETPROP) { if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) { return false; }"
      },
      {
        "txt": "if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false; } } if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) { return false;"
      },
      {
        "txt": "} else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains( nameNode.getLastChild().getString())) { Node param = nameNode.getNext(); if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP)) return false; } }"
      },
      {
        "txt": "} return true; } static boolean callHasLocalResult(Node n) { Preconditions.checkState(n.getType() == Token.CALL); return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0; } static boolean nodeTypeMayHaveSideEffects(Node n) { return nodeTypeMayHaveSideEffects(n, null); }"
      },
      {
        "txt": "static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) { if (isAssignmentOp(n)) { return true; } switch(n.getType()) { case Token.DELPROP: case Token.DEC: case Token.INC: case Token.THROW: return true;"
      },
      {
        "txt": "case Token.CALL: return NodeUtil.functionCallHasSideEffects(n, compiler); case Token.NEW: return NodeUtil.constructorCallHasSideEffects(n, compiler); case Token.NAME: return n.hasChildren(); default: return false; } }"
      },
      {
        "txt": "static boolean canBeSideEffected(Node n) { Set<String> emptySet = Collections.emptySet(); return canBeSideEffected(n, emptySet); } static boolean canBeSideEffected(Node n, Set<String> knownConstants) { switch (n.getType()) { case Token.CALL: case Token.NEW: return true; case Token.NAME:"
      },
      {
        "txt": "return !isConstantName(n) && !knownConstants.contains(n.getString()); case Token.GETPROP: case Token.GETELEM: return true; case Token.FUNCTION: Preconditions.checkState(isFunctionExpression(n)); return false; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "if (canBeSideEffected(c, knownConstants)) { return true; } } return false; } static int precedence(int type) { switch (type) { case Token.COMMA: return 0; case Token.ASSIGN_BITOR:"
      },
      {
        "txt": "case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD:"
      },
      {
        "txt": "case Token.ASSIGN: return 1; case Token.HOOK: return 2; // ?: operator case Token.OR: return 3; case Token.AND: return 4; case Token.BITOR: return 5; case Token.BITXOR: return 6; case Token.BITAND: return 7; case Token.EQ: case Token.NE: case Token.SHEQ:"
      },
      {
        "txt": "case Token.SHNE: return 8; case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.INSTANCEOF: case Token.IN: return 9; case Token.LSH: case Token.RSH: case Token.URSH: return 10;"
      },
      {
        "txt": "case Token.SUB: case Token.ADD: return 11; case Token.MUL: case Token.MOD: case Token.DIV: return 12; case Token.INC: case Token.DEC: case Token.NEW: case Token.DELPROP: case Token.TYPEOF:"
      },
      {
        "txt": "case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: case Token.NEG: return 13; case Token.ARRAYLIT: case Token.CALL: case Token.EMPTY: case Token.FALSE: case Token.FUNCTION:"
      },
      {
        "txt": "case Token.GETELEM: case Token.GETPROP: case Token.GET_REF: case Token.IF: case Token.LP: case Token.NAME: case Token.NULL: case Token.NUMBER: case Token.OBJECTLIT: case Token.REGEXP:"
      },
      {
        "txt": "case Token.RETURN: case Token.STRING: case Token.THIS: case Token.TRUE: return 15; default: throw new Error(\"Unknown precedence for \" + Node.tokenToName(type) + \" (type \" + type + \")\"); } }"
      },
      {
        "txt": "static boolean isAssociative(int type) { switch (type) { case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITAND: return true; default: return false;"
      },
      {
        "txt": "} } static boolean isAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH:"
      },
      {
        "txt": "case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: return true; } return false; }"
      },
      {
        "txt": "static int getOpFromAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN_BITOR: return Token.BITOR; case Token.ASSIGN_BITXOR: return Token.BITXOR; case Token.ASSIGN_BITAND: return Token.BITAND; case Token.ASSIGN_LSH: return Token.LSH;"
      },
      {
        "txt": "case Token.ASSIGN_RSH: return Token.RSH; case Token.ASSIGN_URSH: return Token.URSH; case Token.ASSIGN_ADD: return Token.ADD; case Token.ASSIGN_SUB: return Token.SUB; case Token.ASSIGN_MUL: return Token.MUL;"
      },
      {
        "txt": "case Token.ASSIGN_DIV: return Token.DIV; case Token.ASSIGN_MOD: return Token.MOD; } throw new IllegalArgumentException(\"Not an assiment op\"); } static boolean isExpressionNode(Node n) { return n.getType() == Token.EXPR_RESULT; }"
      },
      {
        "txt": "static boolean containsFunction(Node n) { return containsType(n, Token.FUNCTION); } static boolean referencesThis(Node n) { return containsType(n, Token.THIS, new MatchNotFunction()); } static boolean isGet(Node n) { return n.getType() == Token.GETPROP || n.getType() == Token.GETELEM; }"
      },
      {
        "txt": "static boolean isGetProp(Node n) { return n.getType() == Token.GETPROP; } static boolean isName(Node n) { return n.getType() == Token.NAME; } static boolean isNew(Node n) { return n.getType() == Token.NEW; } static boolean isVar(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.VAR; } static boolean isVarDeclaration(Node n) { return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR; } static Node getAssignedValue(Node n) { Preconditions.checkState(isName(n)); Node parent = n.getParent(); if (isVar(parent)) { return n.getFirstChild();"
      },
      {
        "txt": "} else if (isAssign(parent) && parent.getFirstChild() == n) { return n.getNext(); } else { return null; } } static boolean isString(Node n) { return n.getType() == Token.STRING; } static boolean isExprAssign(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.ASSIGN; } static boolean isAssign(Node n) { return n.getType() == Token.ASSIGN; } static boolean isExprCall(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.CALL; }"
      },
      {
        "txt": "static boolean isForIn(Node n) { return n.getType() == Token.FOR && n.getChildCount() == 3; } static boolean isLoopStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: return true;"
      },
      {
        "txt": "default: return false; } } static Node getLoopCodeBlock(Node n) { switch (n.getType()) { case Token.FOR: case Token.WHILE: return n.getLastChild(); case Token.DO:"
      },
      {
        "txt": "return n.getFirstChild(); default: return null; } } static boolean isWithinLoop(Node n) { for (Node parent : n.getAncestors()) { if (NodeUtil.isLoopStructure(parent)) { return true; }"
      },
      {
        "txt": "if (NodeUtil.isFunction(parent)) { break; } } return false; } static boolean isControlStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO:"
      },
      {
        "txt": "case Token.WHILE: case Token.WITH: case Token.IF: case Token.LABEL: case Token.TRY: case Token.CATCH: case Token.SWITCH: case Token.CASE: case Token.DEFAULT: return true;"
      },
      {
        "txt": "default: return false; } } static boolean isControlStructureCodeBlock(Node parent, Node n) { switch (parent.getType()) { case Token.FOR: case Token.WHILE: case Token.LABEL: case Token.WITH:"
      },
      {
        "txt": "return parent.getLastChild() == n; case Token.DO: return parent.getFirstChild() == n; case Token.IF: return parent.getFirstChild() != n; case Token.TRY: return parent.getFirstChild() == n || parent.getLastChild() == n; case Token.CATCH: return parent.getLastChild() == n; case Token.SWITCH:"
      },
      {
        "txt": "case Token.CASE: return parent.getFirstChild() != n; case Token.DEFAULT: return true; default: Preconditions.checkState(isControlStructure(parent)); return false; } } static Node getConditionExpression(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.IF: case Token.WHILE: return n.getFirstChild(); case Token.DO: return n.getLastChild(); case Token.FOR: switch (n.getChildCount()) { case 3: return null;"
      },
      {
        "txt": "case 4: return n.getFirstChild().getNext(); } throw new IllegalArgumentException(\"malformed 'for' statement \" + n); case Token.CASE: return null; } throw new IllegalArgumentException(n + \" does not have a condition.\"); } static boolean isStatementBlock(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK; } static boolean isStatement(Node n) { Node parent = n.getParent(); Preconditions.checkState(parent != null); switch (parent.getType()) { case Token.SCRIPT: case Token.BLOCK: case Token.LABEL: return true;"
      },
      {
        "txt": "default: return false; } } static boolean isSwitchCase(Node n) { return n.getType() == Token.CASE || n.getType() == Token.DEFAULT; } static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty(); }"
      },
      {
        "txt": "static boolean isLabelName(Node n) { return (n != null && n.getType() == Token.LABEL_NAME); } static boolean isTryFinallyNode(Node parent, Node child) { return parent.getType() == Token.TRY && parent.getChildCount() == 3 && child == parent.getLastChild(); } static void removeChild(Node parent, Node node) { if (isStatementBlock(parent) || isSwitchCase(node)"
      },
      {
        "txt": "|| isTryFinallyNode(parent, node)) { parent.removeChild(node); } else if (parent.getType() == Token.VAR) { if (parent.hasMoreThanOneChild()) { parent.removeChild(node); } else { parent.removeChild(node); removeChild(parent.getParent(), parent); } } else if (node.getType() == Token.BLOCK) {"
      },
      {
        "txt": "node.detachChildren(); } else if (parent.getType() == Token.LABEL && node == parent.getLastChild()) { parent.removeChild(node); removeChild(parent.getParent(), parent); } else if (parent.getType() == Token.FOR && parent.getChildCount() == 4) { parent.replaceChild(node, new Node(Token.EMPTY)); } else { throw new IllegalStateException(\"Invalid attempt to remove node: \" +"
      },
      {
        "txt": "node.toString() + \" of \"+ parent.toString()); } } static boolean tryMergeBlock(Node block) { Preconditions.checkState(block.getType() == Token.BLOCK); Node parent = block.getParent(); if (isStatementBlock(parent)) { Node previous = block; while (block.hasChildren()) { Node child = block.removeFirstChild();"
      },
      {
        "txt": "parent.addChildAfter(child, previous); previous = child; } parent.removeChild(block); return true; } else { return false; } } static boolean isCall(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.CALL; } static boolean isFunction(Node n) { return n.getType() == Token.FUNCTION; } static Node getFunctionBody(Node fn) { Preconditions.checkArgument(isFunction(fn)); return fn.getLastChild(); } static boolean isThis(Node node) {"
      },
      {
        "txt": "return node.getType() == Token.THIS; } static boolean containsCall(Node n) { return containsType(n, Token.CALL); } static boolean isFunctionDeclaration(Node n) { return n.getType() == Token.FUNCTION && isStatement(n); } static boolean isHoistedFunctionDeclaration(Node n) { return isFunctionDeclaration(n)"
      },
      {
        "txt": "&& (n.getParent().getType() == Token.SCRIPT || n.getParent().getParent().getType() == Token.FUNCTION); } static boolean isFunctionExpression(Node n) { return n.getType() == Token.FUNCTION && !isStatement(n); } static boolean isEmptyFunctionExpression(Node node) { return isFunctionExpression(node) && isEmptyBlock(node.getLastChild()); } static boolean isVarArgsFunction(Node function) {"
      },
      {
        "txt": "Preconditions.checkArgument(isFunction(function)); return isNameReferenced( function.getLastChild(), \"arguments\", new MatchNotFunction()); } static boolean isObjectCallMethod(Node callNode, String methodName) { if (callNode.getType() == Token.CALL) { Node functionIndentifyingExpression = callNode.getFirstChild(); if (isGet(functionIndentifyingExpression)) {"
      },
      {
        "txt": "Node last = functionIndentifyingExpression.getLastChild(); if (last != null && last.getType() == Token.STRING) { String propName = last.getString(); return (propName.equals(methodName)); } } } return false; } static boolean isFunctionObjectCall(Node callNode) {"
      },
      {
        "txt": "return isObjectCallMethod(callNode, \"call\"); } static boolean isFunctionObjectApply(Node callNode) { return isObjectCallMethod(callNode, \"apply\"); } static boolean isSimpleFunctionObjectCall(Node callNode) { if (isFunctionObjectCall(callNode)) { if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) { return true; }"
      },
      {
        "txt": "} return false; } static boolean isLhs(Node n, Node parent) { return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) || parent.getType() == Token.VAR; } static boolean isObjectLitKey(Node node, Node parent) { if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) { int index = 0;"
      },
      {
        "txt": "for (Node current = parent.getFirstChild(); current != null; current = current.getNext()) { if (current == node) { return index % 2 == 0; } index++; } } return false;"
      },
      {
        "txt": "} static String opToStr(int operator) { switch (operator) { case Token.BITOR: return \"|\"; case Token.OR: return \"||\"; case Token.BITXOR: return \"^\"; case Token.AND: return \"&&\"; case Token.BITAND: return \"&\"; case Token.SHEQ: return \"===\"; case Token.EQ: return \"==\";"
      },
      {
        "txt": "case Token.NOT: return \"!\"; case Token.NE: return \"!=\"; case Token.SHNE: return \"!==\"; case Token.LSH: return \"<<\"; case Token.IN: return \"in\"; case Token.LE: return \"<=\"; case Token.LT: return \"<\"; case Token.URSH: return \">>>\"; case Token.RSH: return \">>\"; case Token.GE: return \">=\";"
      },
      {
        "txt": "case Token.GT: return \">\"; case Token.MUL: return \"*\"; case Token.DIV: return \"/\"; case Token.MOD: return \"%\"; case Token.BITNOT: return \"~\"; case Token.ADD: return \"+\"; case Token.SUB: return \"-\"; case Token.POS: return \"+\"; case Token.NEG: return \"-\"; case Token.ASSIGN: return \"=\";"
      },
      {
        "txt": "case Token.ASSIGN_BITOR: return \"|=\"; case Token.ASSIGN_BITXOR: return \"^=\"; case Token.ASSIGN_BITAND: return \"&=\"; case Token.ASSIGN_LSH: return \"<<=\"; case Token.ASSIGN_RSH: return \">>=\"; case Token.ASSIGN_URSH: return \">>>=\"; case Token.ASSIGN_ADD: return \"+=\"; case Token.ASSIGN_SUB: return \"-=\"; case Token.ASSIGN_MUL: return \"*=\"; case Token.ASSIGN_DIV: return \"/=\";"
      },
      {
        "txt": "case Token.ASSIGN_MOD: return \"%=\"; case Token.VOID: return \"void\"; case Token.TYPEOF: return \"typeof\"; case Token.INSTANCEOF: return \"instanceof\"; default: return null; } } static String opToStrNoFail(int operator) { String res = opToStr(operator); if (res == null) {"
      },
      {
        "txt": "throw new Error(\"Unknown op \" + operator + \": \" + Token.name(operator)); } return res; } static boolean containsType(Node node, int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); }"
      },
      {
        "txt": "static boolean containsType(Node node, int type) { return containsType(node, type, Predicates.<Node>alwaysTrue()); } static void redeclareVarsInsideBranch(Node branch) { Collection<Node> vars = getVarsDeclaredInBranch(branch); if (vars.isEmpty()) { return; } Node parent = getAddingRoot(branch); for (Node nameNode : vars) {"
      },
      {
        "txt": "Node var = new Node( Token.VAR, Node.newString(Token.NAME, nameNode.getString()) .copyInformationFrom(nameNode)) .copyInformationFrom(nameNode); copyNameAnnotations(nameNode, var.getFirstChild()); parent.addChildToFront(var); } } static void copyNameAnnotations(Node source, Node destination) {"
      },
      {
        "txt": "if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) { destination.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } private static Node getAddingRoot(Node n) { Node addingRoot = null; Node ancestor = n; while (null != (ancestor = ancestor.getParent())) { int type = ancestor.getType(); if (type == Token.SCRIPT) {"
      },
      {
        "txt": "addingRoot = ancestor; break; } else if (type == Token.FUNCTION) { addingRoot = ancestor.getLastChild(); break; } } Preconditions.checkState(addingRoot.getType() == Token.BLOCK || addingRoot.getType() == Token.SCRIPT); Preconditions.checkState(addingRoot.getFirstChild() == null ||"
      },
      {
        "txt": "addingRoot.getFirstChild().getType() != Token.SCRIPT); return addingRoot; } public static Node newFunctionNode(String name, List<Node> params, Node body, int lineno, int charno) { Node parameterParen = new Node(Token.LP, lineno, charno); for (Node param : params) { parameterParen.addChildToBack(param); } Node function = new Node(Token.FUNCTION, lineno, charno);"
      },
      {
        "txt": "function.addChildrenToBack( Node.newString(Token.NAME, name, lineno, charno)); function.addChildToBack(parameterParen); function.addChildToBack(body); return function; } public static Node newQualifiedNameNode(String name, int lineno, int charno) { int endPos = name.indexOf('.'); if (endPos == -1) { return Node.newString(Token.NAME, name, lineno, charno);"
      },
      {
        "txt": "} Node node = Node.newString(Token.NAME, name.substring(0, endPos), lineno, charno); int startPos; do { startPos = endPos + 1; endPos = name.indexOf('.', startPos); String part = (endPos == -1 ? name.substring(startPos) : name.substring(startPos, endPos));"
      },
      {
        "txt": "node = new Node(Token.GETPROP, node, Node.newString(Token.STRING, part, lineno, charno), lineno, charno); } while (endPos != -1); return node; } static Node newQualifiedNameNode(String name, Node basisNode, String originalName) { Node node = newQualifiedNameNode(name, -1, -1); setDebugInformation(node, basisNode, originalName);"
      },
      {
        "txt": "return node; } static Node getRootOfQualifiedName(Node qName) { for (Node current = qName; true; current = current.getFirstChild()) { int type = current.getType(); if (type == Token.NAME || type == Token.THIS) { return current; } Preconditions.checkState(type == Token.GETPROP);"
      },
      {
        "txt": "} } static void setDebugInformation(Node node, Node basisNode, String originalName) { node.copyInformationFromForTree(basisNode); node.putProp(Node.ORIGINALNAME_PROP, originalName); } static Node newName(String name, Node basisNode) { Node nameNode = Node.newString(Token.NAME, name); nameNode.copyInformationFrom(basisNode);"
      },
      {
        "txt": "return nameNode; } static Node newName(String name, Node basisNode, String originalName) { Node nameNode = newName(name, basisNode); nameNode.putProp(Node.ORIGINALNAME_PROP, originalName); return nameNode; } static boolean isLatin(String s) { char LARGEST_BASIC_LATIN = 0x7f; int len = s.length();"
      },
      {
        "txt": "for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c > LARGEST_BASIC_LATIN) { return false; } } return true; } static boolean isValidPropertyName(String name) { return TokenStream.isJSIdentifier(name) &&"
      },
      {
        "txt": "!TokenStream.isKeyword(name) && isLatin(name); } private static class VarCollector implements Visitor { final Map<String, Node> vars = Maps.newLinkedHashMap(); public void visit(Node n) { if (n.getType() == Token.NAME) { Node parent = n.getParent(); if (parent != null && parent.getType() == Token.VAR) { String name = n.getString();"
      },
      {
        "txt": "if (!vars.containsKey(name)) { vars.put(name, n); } } } } } public static Collection<Node> getVarsDeclaredInBranch(Node root) { VarCollector collector = new VarCollector(); visitPreOrder("
      },
      {
        "txt": "root, collector, new MatchNotFunction()); return collector.vars.values(); } static boolean isPrototypePropertyDeclaration(Node n) { if (!isExprAssign(n)) { return false; } return isPrototypeProperty(n.getFirstChild().getFirstChild());"
      },
      {
        "txt": "} static boolean isPrototypeProperty(Node n) { String lhsString = n.getQualifiedName(); if (lhsString == null) { return false; } int prototypeIdx = lhsString.indexOf(\".prototype.\"); return prototypeIdx != -1; } static Node getPrototypeClassName(Node qName) {"
      },
      {
        "txt": "Node cur = qName; while (isGetProp(cur)) { if (cur.getLastChild().getString().equals(\"prototype\")) { return cur.getFirstChild(); } else { cur = cur.getFirstChild(); } } return null; }"
      },
      {
        "txt": "static String getPrototypePropertyName(Node qName) { String qNameStr = qName.getQualifiedName(); int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\"); int memberIndex = prototypeIdx + \".prototype\".length() + 1; return qNameStr.substring(memberIndex); } static Node newUndefinedNode(Node srcReferenceNode) { Node node = new Node(Token.VOID, Node.newNumber(0)); if (srcReferenceNode != null) { node.copyInformationFromForTree(srcReferenceNode);"
      },
      {
        "txt": "} return node; } static Node newVarNode(String name, Node value) { Node nodeName = Node.newString(Token.NAME, name); if (value != null) { Preconditions.checkState(value.getNext() == null); nodeName.addChildToBack(value); nodeName.copyInformationFrom(value); }"
      },
      {
        "txt": "Node var = new Node(Token.VAR, nodeName) .copyInformationFrom(nodeName); return var; } private static class MatchNameNode implements Predicate<Node>{ final String name; MatchNameNode(String name){ this.name = name; } public boolean apply(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.NAME && n.getString().equals(name); } } static class MatchNodeType implements Predicate<Node>{ final int type; MatchNodeType(int type){ this.type = type; } public boolean apply(Node n) {"
      },
      {
        "txt": "return n.getType() == type; } } static class MatchDeclaration implements Predicate<Node> { public boolean apply(Node n) { return isFunctionDeclaration(n) || n.getType() == Token.VAR; } } static class MatchNotFunction implements Predicate<Node>{ public boolean apply(Node n) {"
      },
      {
        "txt": "return !isFunction(n); } } static class MatchShallowStatement implements Predicate<Node>{ public boolean apply(Node n) { Node parent = n.getParent(); return n.getType() == Token.BLOCK || (!isFunction(n) && (parent == null || isControlStructure(parent) || isStatementBlock(parent)));"
      },
      {
        "txt": "} } static int getNodeTypeReferenceCount( Node node, int type, Predicate<Node> traverseChildrenPred) { return getCount(node, new MatchNodeType(type), traverseChildrenPred); } static boolean isNameReferenced(Node node, String name, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNameNode(name), traverseChildrenPred);"
      },
      {
        "txt": "} static boolean isNameReferenced(Node node, String name) { return isNameReferenced(node, name, Predicates.<Node>alwaysTrue()); } static int getNameReferenceCount(Node node, String name) { return getCount( node, new MatchNameNode(name), Predicates.<Node>alwaysTrue()); } static boolean has(Node node, Predicate<Node> pred,"
      },
      {
        "txt": "Predicate<Node> traverseChildrenPred) { if (pred.apply(node)) { return true; } if (!traverseChildrenPred.apply(node)) { return false; } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { if (has(c, pred, traverseChildrenPred)) { return true;"
      },
      {
        "txt": "} } return false; } static int getCount( Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { int total = 0; if (pred.apply(n)) { total++; }"
      },
      {
        "txt": "if (traverseChildrenPred.apply(n)) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { total += getCount(c, pred, traverseChildrenPred); } } return total; } static interface Visitor { void visit(Node node); }"
      },
      {
        "txt": "static void visitPreOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) { vistor.visit(node); if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPreOrder(c, vistor, traverseChildrenPred); } } }"
      },
      {
        "txt": "static void visitPostOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) { if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPostOrder(c, vistor, traverseChildrenPred); } } vistor.visit(node); }"
      },
      {
        "txt": "static boolean hasFinally(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getChildCount() == 3; } static Node getCatchBlock(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getFirstChild().getNext(); } static boolean hasCatchHandler(Node n) { Preconditions.checkArgument(n.getType() == Token.BLOCK);"
      },
      {
        "txt": "return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH; } static Node getFnParameters(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } static boolean isConstantName(Node node) { return node.getBooleanProp(Node.IS_CONSTANT_NAME); } static boolean isConstantByConvention("
      },
      {
        "txt": "CodingConvention convention, Node node, Node parent) { String name = node.getString(); if (parent.getType() == Token.GETPROP && node == parent.getLastChild()) { return convention.isConstantKey(name); } else if (isObjectLitKey(node, parent)) { return convention.isConstantKey(name); } else { return convention.isConstant(name); }"
      },
      {
        "txt": "} static JSDocInfo getInfoForNameNode(Node nameNode) { JSDocInfo info = null; Node parent = null; if (nameNode != null) { info = nameNode.getJSDocInfo(); parent = nameNode.getParent(); } if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) ||"
      },
      {
        "txt": "parent.getType() == Token.FUNCTION)) { info = parent.getJSDocInfo(); } return info; } static JSDocInfo getFunctionInfo(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION); JSDocInfo fnInfo = n.getJSDocInfo(); if (fnInfo == null && NodeUtil.isFunctionExpression(n)) { Node parent = n.getParent();"
      },
      {
        "txt": "if (parent.getType() == Token.ASSIGN) { fnInfo = parent.getJSDocInfo(); } else if (parent.getType() == Token.NAME) { fnInfo = parent.getParent().getJSDocInfo(); } } return fnInfo; } static String getSourceName(Node n) { String sourceName = null;"
      },
      {
        "txt": "while (sourceName == null && n != null) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); n = n.getParent(); } return sourceName; } static Node newCallNode(Node callTarget, Node... parameters) { boolean isFreeCall = isName(callTarget); Node call = new Node(Token.CALL, callTarget); call.putBooleanProp(Node.FREE_CALL, isFreeCall);"
      },
      {
        "txt": "for (Node parameter : parameters) { call.addChildToBack(parameter); } return call; } static boolean evaluatesToLocalValue(Node value) { return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse()); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) {"
      },
      {
        "txt": "case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);"
      },
      {
        "txt": "case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; }"
      },
      {
        "txt": "case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || locals.apply(value); case Token.NEW:"
      },
      {
        "txt": "return true; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value)"
      },
      {
        "txt": "|| isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }"
      }
    ]
  },
  {
    "id": 410,
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
    "start-bug-line": 337,
    "end-bug-line": 337,
    "bug": "",
    "fix": "case Token.POS:",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Maps; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import javax.annotation.Nullable; public final class NodeUtil { private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS = new HashSet<String>(Arrays.asList( \"Array\", \"Date\", \"Error\", \"Object\", \"RegExp\","
      },
      {
        "txt": "\"XMLHttpRequest\")); private NodeUtil() {} static TernaryValue getExpressionBooleanValue(Node n) { switch (n.getType()) { case Token.ASSIGN: case Token.COMMA: return getExpressionBooleanValue(n.getLastChild()); case Token.NOT: TernaryValue value = getExpressionBooleanValue(n.getLastChild()); return value.not();"
      },
      {
        "txt": "case Token.AND: { TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild()); TernaryValue rhs = getExpressionBooleanValue(n.getLastChild()); return lhs.and(rhs); } case Token.OR: { TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild()); TernaryValue rhs = getExpressionBooleanValue(n.getLastChild()); return lhs.or(rhs); }"
      },
      {
        "txt": "case Token.HOOK: { TernaryValue trueValue = getExpressionBooleanValue( n.getFirstChild().getNext()); TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild()); if (trueValue.equals(falseValue)) { return trueValue; } else { return TernaryValue.UNKNOWN; } }"
      },
      {
        "txt": "default: return getBooleanValue(n); } } static TernaryValue getBooleanValue(Node n) { switch (n.getType()) { case Token.STRING: return TernaryValue.forBoolean(n.getString().length() > 0); case Token.NUMBER: return TernaryValue.forBoolean(n.getDouble() != 0);"
      },
      {
        "txt": "case Token.NULL: case Token.FALSE: case Token.VOID: return TernaryValue.FALSE; case Token.NAME: String name = n.getString(); if (\"undefined\".equals(name) || \"NaN\".equals(name)) { return TernaryValue.FALSE; } else if (\"Infinity\".equals(name)) {"
      },
      {
        "txt": "return TernaryValue.TRUE; } break; case Token.TRUE: case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: return TernaryValue.TRUE; } return TernaryValue.UNKNOWN;"
      },
      {
        "txt": "} static String getStringValue(Node n) { switch (n.getType()) { case Token.NAME: case Token.STRING: return n.getString(); case Token.NUMBER: double value = n.getDouble(); long longValue = (long) value; if (longValue == value) {"
      },
      {
        "txt": "return Long.toString(longValue); } else { return Double.toString(n.getDouble()); } case Token.FALSE: case Token.TRUE: case Token.NULL: return Node.tokenToName(n.getType()); case Token.VOID: return \"undefined\";"
      },
      {
        "txt": "} return null; } static String getFunctionName(Node n) { Node parent = n.getParent(); String name = n.getFirstChild().getString(); switch (parent.getType()) { case Token.NAME: return parent.getString(); case Token.ASSIGN:"
      },
      {
        "txt": "return parent.getFirstChild().getQualifiedName(); default: return name != null && name.length() != 0 ? name : null; } } static String getNearestFunctionName(Node n) { String name = getFunctionName(n); if (name != null) { return name; }"
      },
      {
        "txt": "Node parent = n.getParent(); switch (parent.getType()) { case Token.OBJECTLIT: return getStringValue(parent.getFirstChild()); } return null; } static boolean isImmutableValue(Node n) { switch (n.getType()) { case Token.STRING:"
      },
      {
        "txt": "case Token.NUMBER: case Token.NULL: case Token.TRUE: case Token.FALSE: return true; case Token.VOID: case Token.NEG: return isImmutableValue(n.getFirstChild()); case Token.NAME: String name = n.getString();"
      },
      {
        "txt": "return \"undefined\".equals(name) || \"Infinity\".equals(name) || \"NaN\".equals(name); } return false; } static boolean isLiteralValue(Node n, boolean includeFunctions) { switch (n.getType()) { case Token.ARRAYLIT: case Token.OBJECTLIT:"
      },
      {
        "txt": "case Token.REGEXP: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!isLiteralValue(child, includeFunctions)) { return false; } } return true; case Token.FUNCTION: return includeFunctions && !NodeUtil.isFunctionDeclaration(n);"
      },
      {
        "txt": "default: return isImmutableValue(n); } } static boolean isValidDefineValue(Node val, Set<String> defines) { switch (val.getType()) { case Token.STRING: case Token.NUMBER: case Token.TRUE: case Token.FALSE:"
      },
      {
        "txt": "case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.NOT: case Token.NEG: <extra_id_0> case Token.NAME: case Token.GETPROP: if (val.isQualifiedName()) { return defines.contains(val.getQualifiedName()); } }"
      },
      {
        "txt": "} } return false; } static boolean isEmptyBlock(Node block) { if (block.getType() != Token.BLOCK) { return false; } for (Node n = block.getFirstChild(); n != null; n = n.getNext()) { if (n.getType() != Token.EMPTY) {"
      },
      {
        "txt": "return false; } } return true; } static boolean isSimpleOperator(Node n) { return isSimpleOperatorType(n.getType()); } static boolean isSimpleOperatorType(int type) { switch (type) {"
      },
      {
        "txt": "case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.COMMA: case Token.DIV: case Token.EQ: case Token.GE: case Token.GETELEM:"
      },
      {
        "txt": "case Token.GETPROP: case Token.GT: case Token.INSTANCEOF: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.NOT:"
      },
      {
        "txt": "case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.TYPEOF: case Token.VOID: case Token.POS: case Token.NEG: case Token.URSH: return true;"
      },
      {
        "txt": "default: return false; } } public static Node newExpr(Node child) { Node expr = new Node(Token.EXPR_RESULT, child) .copyInformationFrom(child); return expr; } static boolean mayEffectMutableState(Node n) {"
      },
      {
        "txt": "return mayEffectMutableState(n, null); } static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) { return checkForStateChangeHelper(n, true, compiler); } static boolean mayHaveSideEffects(Node n) { return mayHaveSideEffects(n, null); } static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) { return checkForStateChangeHelper(n, false, compiler);"
      },
      {
        "txt": "} private static boolean checkForStateChangeHelper( Node n, boolean checkForNewObjects, AbstractCompiler compiler) { switch (n.getType()) { case Token.AND: case Token.BLOCK: case Token.EXPR_RESULT: case Token.HOOK: case Token.IF: case Token.IN:"
      },
      {
        "txt": "case Token.LP: case Token.NUMBER: case Token.OR: case Token.THIS: case Token.TRUE: case Token.FALSE: case Token.NULL: case Token.STRING: case Token.SWITCH: case Token.TRY:"
      },
      {
        "txt": "case Token.EMPTY: break; case Token.THROW: return true; case Token.OBJECTLIT: case Token.ARRAYLIT: case Token.REGEXP: if (checkForNewObjects) { return true; }"
      },
      {
        "txt": "break; case Token.VAR: // empty var statement (no declaration) case Token.NAME: // variable by itself if (n.getFirstChild() != null) { return true; } break; case Token.FUNCTION: return checkForNewObjects || !isFunctionExpression(n); case Token.NEW:"
      },
      {
        "txt": "if (checkForNewObjects) { return true; } if (!constructorCallHasSideEffects(n)) { break; } return true; case Token.CALL: if (!functionCallHasSideEffects(n, compiler)) { break;"
      },
      {
        "txt": "} return true; default: if (isSimpleOperatorType(n.getType())) { break; } if (isAssignmentOp(n)) { Node assignTarget = n.getFirstChild(); if (isName(assignTarget)) { return true;"
      },
      {
        "txt": "} if (checkForStateChangeHelper( n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper( n.getLastChild(), checkForNewObjects, compiler)) { return true; } if (isGet(assignTarget)) { Node current = assignTarget.getFirstChild(); if (evaluatesToLocalValue(current)) {"
      },
      {
        "txt": "return false; } while (isGet(current)) { current = current.getFirstChild(); } return !isLiteralValue(current, true); } else { return !isLiteralValue(assignTarget, true); } }"
      },
      {
        "txt": "return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) { return true; } } return false; } static boolean constructorCallHasSideEffects(Node callNode) {"
      },
      {
        "txt": "return constructorCallHasSideEffects(callNode, null); } static boolean constructorCallHasSideEffects( Node callNode, AbstractCompiler compiler) { Preconditions.checkArgument( callNode.getType() == Token.NEW, \"Expected NEW node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; }"
      },
      {
        "txt": "Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) { return false; } return true; } private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS = ImmutableSet.of( \"Object\", \"Array\", \"String\", \"Number\", \"Boolean\", \"RegExp\", \"Error\");"
      },
      {
        "txt": "private static final Set<String> REGEXP_METHODS = ImmutableSet.of(\"test\", \"exec\"); private static final Set<String> STRING_REGEXP_METHODS = ImmutableSet.of(\"match\", \"replace\", \"search\", \"split\"); static boolean functionCallHasSideEffects( Node callNode) { return functionCallHasSideEffects(callNode, null); } static boolean functionCallHasSideEffects( Node callNode, @Nullable AbstractCompiler compiler) {"
      },
      {
        "txt": "Preconditions.checkArgument( callNode.getType() == Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { String name = nameNode.getString(); if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {"
      },
      {
        "txt": "return false; } } else if (nameNode.getType() == Token.GETPROP) { if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) { return false; } if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) {"
      },
      {
        "txt": "return false; } } if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) { return false; } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains( nameNode.getLastChild().getString())) {"
      },
      {
        "txt": "Node param = nameNode.getNext(); if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP)) return false; } } } return true; }"
      },
      {
        "txt": "static boolean callHasLocalResult(Node n) { Preconditions.checkState(n.getType() == Token.CALL); return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0; } static boolean nodeTypeMayHaveSideEffects(Node n) { return nodeTypeMayHaveSideEffects(n, null); } static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) { if (isAssignmentOp(n)) { return true;"
      },
      {
        "txt": "} switch(n.getType()) { case Token.DELPROP: case Token.DEC: case Token.INC: case Token.THROW: return true; case Token.CALL: return NodeUtil.functionCallHasSideEffects(n, compiler); case Token.NEW:"
      },
      {
        "txt": "return NodeUtil.constructorCallHasSideEffects(n, compiler); case Token.NAME: return n.hasChildren(); default: return false; } } static boolean canBeSideEffected(Node n) { Set<String> emptySet = Collections.emptySet(); return canBeSideEffected(n, emptySet);"
      },
      {
        "txt": "} static boolean canBeSideEffected(Node n, Set<String> knownConstants) { switch (n.getType()) { case Token.CALL: case Token.NEW: return true; case Token.NAME: return !isConstantName(n) && !knownConstants.contains(n.getString()); case Token.GETPROP:"
      },
      {
        "txt": "case Token.GETELEM: return true; case Token.FUNCTION: Preconditions.checkState(isFunctionExpression(n)); return false; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (canBeSideEffected(c, knownConstants)) { return true; }"
      },
      {
        "txt": "} return false; } static int precedence(int type) { switch (type) { case Token.COMMA: return 0; case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH:"
      },
      {
        "txt": "case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN: return 1; case Token.HOOK: return 2; // ?: operator case Token.OR: return 3;"
      },
      {
        "txt": "case Token.AND: return 4; case Token.BITOR: return 5; case Token.BITXOR: return 6; case Token.BITAND: return 7; case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: return 8; case Token.LT: case Token.GT:"
      },
      {
        "txt": "case Token.LE: case Token.GE: case Token.INSTANCEOF: case Token.IN: return 9; case Token.LSH: case Token.RSH: case Token.URSH: return 10; case Token.SUB: case Token.ADD: return 11; case Token.MUL:"
      },
      {
        "txt": "case Token.MOD: case Token.DIV: return 12; case Token.INC: case Token.DEC: case Token.NEW: case Token.DELPROP: case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT:"
      },
      {
        "txt": "case Token.POS: case Token.NEG: return 13; case Token.ARRAYLIT: case Token.CALL: case Token.EMPTY: case Token.FALSE: case Token.FUNCTION: case Token.GETELEM: case Token.GETPROP: case Token.GET_REF:"
      },
      {
        "txt": "case Token.IF: case Token.LP: case Token.NAME: case Token.NULL: case Token.NUMBER: case Token.OBJECTLIT: case Token.REGEXP: case Token.RETURN: case Token.STRING: case Token.THIS:"
      },
      {
        "txt": "case Token.TRUE: return 15; default: throw new Error(\"Unknown precedence for \" + Node.tokenToName(type) + \" (type \" + type + \")\"); } } static boolean isAssociative(int type) { switch (type) { case Token.MUL:"
      },
      {
        "txt": "case Token.AND: case Token.OR: case Token.BITOR: case Token.BITAND: return true; default: return false; } } static boolean isAssignmentOp(Node n) {"
      },
      {
        "txt": "switch (n.getType()){ case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB:"
      },
      {
        "txt": "case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: return true; } return false; } static int getOpFromAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN_BITOR:"
      },
      {
        "txt": "return Token.BITOR; case Token.ASSIGN_BITXOR: return Token.BITXOR; case Token.ASSIGN_BITAND: return Token.BITAND; case Token.ASSIGN_LSH: return Token.LSH; case Token.ASSIGN_RSH: return Token.RSH; case Token.ASSIGN_URSH:"
      },
      {
        "txt": "return Token.URSH; case Token.ASSIGN_ADD: return Token.ADD; case Token.ASSIGN_SUB: return Token.SUB; case Token.ASSIGN_MUL: return Token.MUL; case Token.ASSIGN_DIV: return Token.DIV; case Token.ASSIGN_MOD:"
      },
      {
        "txt": "return Token.MOD; } throw new IllegalArgumentException(\"Not an assiment op\"); } static boolean isExpressionNode(Node n) { return n.getType() == Token.EXPR_RESULT; } static boolean containsFunction(Node n) { return containsType(n, Token.FUNCTION); }"
      },
      {
        "txt": "static boolean referencesThis(Node n) { return containsType(n, Token.THIS, new MatchNotFunction()); } static boolean isGet(Node n) { return n.getType() == Token.GETPROP || n.getType() == Token.GETELEM; } static boolean isGetProp(Node n) { return n.getType() == Token.GETPROP; }"
      },
      {
        "txt": "static boolean isName(Node n) { return n.getType() == Token.NAME; } static boolean isNew(Node n) { return n.getType() == Token.NEW; } static boolean isVar(Node n) { return n.getType() == Token.VAR; } static boolean isVarDeclaration(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR; } static Node getAssignedValue(Node n) { Preconditions.checkState(isName(n)); Node parent = n.getParent(); if (isVar(parent)) { return n.getFirstChild(); } else if (isAssign(parent) && parent.getFirstChild() == n) { return n.getNext(); } else {"
      },
      {
        "txt": "return null; } } static boolean isString(Node n) { return n.getType() == Token.STRING; } static boolean isExprAssign(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.ASSIGN; }"
      },
      {
        "txt": "static boolean isAssign(Node n) { return n.getType() == Token.ASSIGN; } static boolean isExprCall(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.CALL; } static boolean isForIn(Node n) { return n.getType() == Token.FOR && n.getChildCount() == 3;"
      },
      {
        "txt": "} static boolean isLoopStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: return true; default: return false; }"
      },
      {
        "txt": "} static Node getLoopCodeBlock(Node n) { switch (n.getType()) { case Token.FOR: case Token.WHILE: return n.getLastChild(); case Token.DO: return n.getFirstChild(); default: return null;"
      },
      {
        "txt": "} } static boolean isWithinLoop(Node n) { for (Node parent : n.getAncestors()) { if (NodeUtil.isLoopStructure(parent)) { return true; } if (NodeUtil.isFunction(parent)) { break; }"
      },
      {
        "txt": "} return false; } static boolean isControlStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: case Token.WITH: case Token.IF:"
      },
      {
        "txt": "case Token.LABEL: case Token.TRY: case Token.CATCH: case Token.SWITCH: case Token.CASE: case Token.DEFAULT: return true; default: return false; }"
      },
      {
        "txt": "} static boolean isControlStructureCodeBlock(Node parent, Node n) { switch (parent.getType()) { case Token.FOR: case Token.WHILE: case Token.LABEL: case Token.WITH: return parent.getLastChild() == n; case Token.DO: return parent.getFirstChild() == n;"
      },
      {
        "txt": "case Token.IF: return parent.getFirstChild() != n; case Token.TRY: return parent.getFirstChild() == n || parent.getLastChild() == n; case Token.CATCH: return parent.getLastChild() == n; case Token.SWITCH: case Token.CASE: return parent.getFirstChild() != n; case Token.DEFAULT:"
      },
      {
        "txt": "return true; default: Preconditions.checkState(isControlStructure(parent)); return false; } } static Node getConditionExpression(Node n) { switch (n.getType()) { case Token.IF: case Token.WHILE:"
      },
      {
        "txt": "return n.getFirstChild(); case Token.DO: return n.getLastChild(); case Token.FOR: switch (n.getChildCount()) { case 3: return null; case 4: return n.getFirstChild().getNext(); }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"malformed 'for' statement \" + n); case Token.CASE: return null; } throw new IllegalArgumentException(n + \" does not have a condition.\"); } static boolean isStatementBlock(Node n) { return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK; } static boolean isStatement(Node n) {"
      },
      {
        "txt": "Node parent = n.getParent(); Preconditions.checkState(parent != null); switch (parent.getType()) { case Token.SCRIPT: case Token.BLOCK: case Token.LABEL: return true; default: return false; }"
      },
      {
        "txt": "} static boolean isSwitchCase(Node n) { return n.getType() == Token.CASE || n.getType() == Token.DEFAULT; } static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty(); } static boolean isLabelName(Node n) { return (n != null && n.getType() == Token.LABEL_NAME); }"
      },
      {
        "txt": "static boolean isTryFinallyNode(Node parent, Node child) { return parent.getType() == Token.TRY && parent.getChildCount() == 3 && child == parent.getLastChild(); } static void removeChild(Node parent, Node node) { if (isStatementBlock(parent) || isSwitchCase(node) || isTryFinallyNode(parent, node)) { parent.removeChild(node); } else if (parent.getType() == Token.VAR) {"
      },
      {
        "txt": "if (parent.hasMoreThanOneChild()) { parent.removeChild(node); } else { parent.removeChild(node); removeChild(parent.getParent(), parent); } } else if (node.getType() == Token.BLOCK) { node.detachChildren(); } else if (parent.getType() == Token.LABEL && node == parent.getLastChild()) {"
      },
      {
        "txt": "parent.removeChild(node); removeChild(parent.getParent(), parent); } else if (parent.getType() == Token.FOR && parent.getChildCount() == 4) { parent.replaceChild(node, new Node(Token.EMPTY)); } else { throw new IllegalStateException(\"Invalid attempt to remove node: \" + node.toString() + \" of \"+ parent.toString()); } }"
      },
      {
        "txt": "static boolean tryMergeBlock(Node block) { Preconditions.checkState(block.getType() == Token.BLOCK); Node parent = block.getParent(); if (isStatementBlock(parent)) { Node previous = block; while (block.hasChildren()) { Node child = block.removeFirstChild(); parent.addChildAfter(child, previous); previous = child; }"
      },
      {
        "txt": "parent.removeChild(block); return true; } else { return false; } } static boolean isCall(Node n) { return n.getType() == Token.CALL; } static boolean isFunction(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.FUNCTION; } static Node getFunctionBody(Node fn) { Preconditions.checkArgument(isFunction(fn)); return fn.getLastChild(); } static boolean isThis(Node node) { return node.getType() == Token.THIS; } static boolean containsCall(Node n) {"
      },
      {
        "txt": "return containsType(n, Token.CALL); } static boolean isFunctionDeclaration(Node n) { return n.getType() == Token.FUNCTION && isStatement(n); } static boolean isHoistedFunctionDeclaration(Node n) { return isFunctionDeclaration(n) && (n.getParent().getType() == Token.SCRIPT || n.getParent().getParent().getType() == Token.FUNCTION); }"
      },
      {
        "txt": "static boolean isFunctionExpression(Node n) { return n.getType() == Token.FUNCTION && !isStatement(n); } static boolean isEmptyFunctionExpression(Node node) { return isFunctionExpression(node) && isEmptyBlock(node.getLastChild()); } static boolean isVarArgsFunction(Node function) { Preconditions.checkArgument(isFunction(function)); return isNameReferenced( function.getLastChild(),"
      },
      {
        "txt": "\"arguments\", new MatchNotFunction()); } static boolean isObjectCallMethod(Node callNode, String methodName) { if (callNode.getType() == Token.CALL) { Node functionIndentifyingExpression = callNode.getFirstChild(); if (isGet(functionIndentifyingExpression)) { Node last = functionIndentifyingExpression.getLastChild(); if (last != null && last.getType() == Token.STRING) { String propName = last.getString();"
      },
      {
        "txt": "return (propName.equals(methodName)); } } } return false; } static boolean isFunctionObjectCall(Node callNode) { return isObjectCallMethod(callNode, \"call\"); } static boolean isFunctionObjectApply(Node callNode) {"
      },
      {
        "txt": "return isObjectCallMethod(callNode, \"apply\"); } static boolean isSimpleFunctionObjectCall(Node callNode) { if (isFunctionObjectCall(callNode)) { if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) { return true; } } return false; }"
      },
      {
        "txt": "static boolean isLhs(Node n, Node parent) { return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) || parent.getType() == Token.VAR; } static boolean isObjectLitKey(Node node, Node parent) { if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) { int index = 0; for (Node current = parent.getFirstChild(); current != null; current = current.getNext()) {"
      },
      {
        "txt": "if (current == node) { return index % 2 == 0; } index++; } } return false; } static String opToStr(int operator) { switch (operator) {"
      },
      {
        "txt": "case Token.BITOR: return \"|\"; case Token.OR: return \"||\"; case Token.BITXOR: return \"^\"; case Token.AND: return \"&&\"; case Token.BITAND: return \"&\"; case Token.SHEQ: return \"===\"; case Token.EQ: return \"==\"; case Token.NOT: return \"!\"; case Token.NE: return \"!=\"; case Token.SHNE: return \"!==\";"
      },
      {
        "txt": "case Token.LSH: return \"<<\"; case Token.IN: return \"in\"; case Token.LE: return \"<=\"; case Token.LT: return \"<\"; case Token.URSH: return \">>>\"; case Token.RSH: return \">>\"; case Token.GE: return \">=\"; case Token.GT: return \">\"; case Token.MUL: return \"*\"; case Token.DIV: return \"/\";"
      },
      {
        "txt": "case Token.MOD: return \"%\"; case Token.BITNOT: return \"~\"; case Token.ADD: return \"+\"; case Token.SUB: return \"-\"; case Token.POS: return \"+\"; case Token.NEG: return \"-\"; case Token.ASSIGN: return \"=\"; case Token.ASSIGN_BITOR: return \"|=\"; case Token.ASSIGN_BITXOR: return \"^=\"; case Token.ASSIGN_BITAND: return \"&=\";"
      },
      {
        "txt": "case Token.ASSIGN_LSH: return \"<<=\"; case Token.ASSIGN_RSH: return \">>=\"; case Token.ASSIGN_URSH: return \">>>=\"; case Token.ASSIGN_ADD: return \"+=\"; case Token.ASSIGN_SUB: return \"-=\"; case Token.ASSIGN_MUL: return \"*=\"; case Token.ASSIGN_DIV: return \"/=\"; case Token.ASSIGN_MOD: return \"%=\"; case Token.VOID: return \"void\"; case Token.TYPEOF: return \"typeof\";"
      },
      {
        "txt": "case Token.INSTANCEOF: return \"instanceof\"; default: return null; } } static String opToStrNoFail(int operator) { String res = opToStr(operator); if (res == null) { throw new Error(\"Unknown op \" + operator + \": \" + Token.name(operator)); }"
      },
      {
        "txt": "return res; } static boolean containsType(Node node, int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static boolean containsType(Node node, int type) { return containsType(node, type, Predicates.<Node>alwaysTrue()); }"
      },
      {
        "txt": "static void redeclareVarsInsideBranch(Node branch) { Collection<Node> vars = getVarsDeclaredInBranch(branch); if (vars.isEmpty()) { return; } Node parent = getAddingRoot(branch); for (Node nameNode : vars) { Node var = new Node( Token.VAR, Node.newString(Token.NAME, nameNode.getString())"
      },
      {
        "txt": ".copyInformationFrom(nameNode)) .copyInformationFrom(nameNode); copyNameAnnotations(nameNode, var.getFirstChild()); parent.addChildToFront(var); } } static void copyNameAnnotations(Node source, Node destination) { if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) { destination.putBooleanProp(Node.IS_CONSTANT_NAME, true); }"
      },
      {
        "txt": "} private static Node getAddingRoot(Node n) { Node addingRoot = null; Node ancestor = n; while (null != (ancestor = ancestor.getParent())) { int type = ancestor.getType(); if (type == Token.SCRIPT) { addingRoot = ancestor; break; } else if (type == Token.FUNCTION) {"
      },
      {
        "txt": "addingRoot = ancestor.getLastChild(); break; } } Preconditions.checkState(addingRoot.getType() == Token.BLOCK || addingRoot.getType() == Token.SCRIPT); Preconditions.checkState(addingRoot.getFirstChild() == null || addingRoot.getFirstChild().getType() != Token.SCRIPT); return addingRoot; }"
      },
      {
        "txt": "public static Node newFunctionNode(String name, List<Node> params, Node body, int lineno, int charno) { Node parameterParen = new Node(Token.LP, lineno, charno); for (Node param : params) { parameterParen.addChildToBack(param); } Node function = new Node(Token.FUNCTION, lineno, charno); function.addChildrenToBack( Node.newString(Token.NAME, name, lineno, charno)); function.addChildToBack(parameterParen);"
      },
      {
        "txt": "function.addChildToBack(body); return function; } public static Node newQualifiedNameNode(String name, int lineno, int charno) { int endPos = name.indexOf('.'); if (endPos == -1) { return Node.newString(Token.NAME, name, lineno, charno); } Node node = Node.newString(Token.NAME, name.substring(0, endPos), lineno, charno);"
      },
      {
        "txt": "int startPos; do { startPos = endPos + 1; endPos = name.indexOf('.', startPos); String part = (endPos == -1 ? name.substring(startPos) : name.substring(startPos, endPos)); node = new Node(Token.GETPROP, node, Node.newString(Token.STRING, part, lineno, charno), lineno, charno);"
      },
      {
        "txt": "} while (endPos != -1); return node; } static Node newQualifiedNameNode(String name, Node basisNode, String originalName) { Node node = newQualifiedNameNode(name, -1, -1); setDebugInformation(node, basisNode, originalName); return node; } static Node getRootOfQualifiedName(Node qName) {"
      },
      {
        "txt": "for (Node current = qName; true; current = current.getFirstChild()) { int type = current.getType(); if (type == Token.NAME || type == Token.THIS) { return current; } Preconditions.checkState(type == Token.GETPROP); } } static void setDebugInformation(Node node, Node basisNode,"
      },
      {
        "txt": "String originalName) { node.copyInformationFromForTree(basisNode); node.putProp(Node.ORIGINALNAME_PROP, originalName); } static Node newName(String name, Node basisNode) { Node nameNode = Node.newString(Token.NAME, name); nameNode.copyInformationFrom(basisNode); return nameNode; } static Node newName(String name, Node basisNode, String originalName) {"
      },
      {
        "txt": "Node nameNode = newName(name, basisNode); nameNode.putProp(Node.ORIGINALNAME_PROP, originalName); return nameNode; } static boolean isLatin(String s) { char LARGEST_BASIC_LATIN = 0x7f; int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c > LARGEST_BASIC_LATIN) {"
      },
      {
        "txt": "return false; } } return true; } static boolean isValidPropertyName(String name) { return TokenStream.isJSIdentifier(name) && !TokenStream.isKeyword(name) && isLatin(name); }"
      },
      {
        "txt": "private static class VarCollector implements Visitor { final Map<String, Node> vars = Maps.newLinkedHashMap(); public void visit(Node n) { if (n.getType() == Token.NAME) { Node parent = n.getParent(); if (parent != null && parent.getType() == Token.VAR) { String name = n.getString(); if (!vars.containsKey(name)) { vars.put(name, n); }"
      },
      {
        "txt": "} } } } public static Collection<Node> getVarsDeclaredInBranch(Node root) { VarCollector collector = new VarCollector(); visitPreOrder( root, collector, new MatchNotFunction());"
      },
      {
        "txt": "return collector.vars.values(); } static boolean isPrototypePropertyDeclaration(Node n) { if (!isExprAssign(n)) { return false; } return isPrototypeProperty(n.getFirstChild().getFirstChild()); } static boolean isPrototypeProperty(Node n) { String lhsString = n.getQualifiedName();"
      },
      {
        "txt": "if (lhsString == null) { return false; } int prototypeIdx = lhsString.indexOf(\".prototype.\"); return prototypeIdx != -1; } static Node getPrototypeClassName(Node qName) { Node cur = qName; while (isGetProp(cur)) { if (cur.getLastChild().getString().equals(\"prototype\")) {"
      },
      {
        "txt": "return cur.getFirstChild(); } else { cur = cur.getFirstChild(); } } return null; } static String getPrototypePropertyName(Node qName) { String qNameStr = qName.getQualifiedName(); int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");"
      },
      {
        "txt": "int memberIndex = prototypeIdx + \".prototype\".length() + 1; return qNameStr.substring(memberIndex); } static Node newUndefinedNode(Node srcReferenceNode) { Node node = new Node(Token.VOID, Node.newNumber(0)); if (srcReferenceNode != null) { node.copyInformationFromForTree(srcReferenceNode); } return node; }"
      },
      {
        "txt": "static Node newVarNode(String name, Node value) { Node nodeName = Node.newString(Token.NAME, name); if (value != null) { Preconditions.checkState(value.getNext() == null); nodeName.addChildToBack(value); nodeName.copyInformationFrom(value); } Node var = new Node(Token.VAR, nodeName) .copyInformationFrom(nodeName); return var;"
      },
      {
        "txt": "} private static class MatchNameNode implements Predicate<Node>{ final String name; MatchNameNode(String name){ this.name = name; } public boolean apply(Node n) { return n.getType() == Token.NAME && n.getString().equals(name); }"
      },
      {
        "txt": "} static class MatchNodeType implements Predicate<Node>{ final int type; MatchNodeType(int type){ this.type = type; } public boolean apply(Node n) { return n.getType() == type; } }"
      },
      {
        "txt": "static class MatchDeclaration implements Predicate<Node> { public boolean apply(Node n) { return isFunctionDeclaration(n) || n.getType() == Token.VAR; } } static class MatchNotFunction implements Predicate<Node>{ public boolean apply(Node n) { return !isFunction(n); } }"
      },
      {
        "txt": "static class MatchShallowStatement implements Predicate<Node>{ public boolean apply(Node n) { Node parent = n.getParent(); return n.getType() == Token.BLOCK || (!isFunction(n) && (parent == null || isControlStructure(parent) || isStatementBlock(parent))); } } static int getNodeTypeReferenceCount("
      },
      {
        "txt": "Node node, int type, Predicate<Node> traverseChildrenPred) { return getCount(node, new MatchNodeType(type), traverseChildrenPred); } static boolean isNameReferenced(Node node, String name, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNameNode(name), traverseChildrenPred); } static boolean isNameReferenced(Node node, String name) { return isNameReferenced(node, name, Predicates.<Node>alwaysTrue());"
      },
      {
        "txt": "} static int getNameReferenceCount(Node node, String name) { return getCount( node, new MatchNameNode(name), Predicates.<Node>alwaysTrue()); } static boolean has(Node node, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { if (pred.apply(node)) { return true;"
      },
      {
        "txt": "} if (!traverseChildrenPred.apply(node)) { return false; } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { if (has(c, pred, traverseChildrenPred)) { return true; } } return false;"
      },
      {
        "txt": "} static int getCount( Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { int total = 0; if (pred.apply(n)) { total++; } if (traverseChildrenPred.apply(n)) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { total += getCount(c, pred, traverseChildrenPred);"
      },
      {
        "txt": "} } return total; } static interface Visitor { void visit(Node node); } static void visitPreOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "vistor.visit(node); if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPreOrder(c, vistor, traverseChildrenPred); } } } static void visitPostOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPostOrder(c, vistor, traverseChildrenPred); } } vistor.visit(node); } static boolean hasFinally(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getChildCount() == 3;"
      },
      {
        "txt": "} static Node getCatchBlock(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getFirstChild().getNext(); } static boolean hasCatchHandler(Node n) { Preconditions.checkArgument(n.getType() == Token.BLOCK); return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH; } static Node getFnParameters(Node fnNode) {"
      },
      {
        "txt": "Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } static boolean isConstantName(Node node) { return node.getBooleanProp(Node.IS_CONSTANT_NAME); } static boolean isConstantByConvention( CodingConvention convention, Node node, Node parent) { String name = node.getString(); if (parent.getType() == Token.GETPROP &&"
      },
      {
        "txt": "node == parent.getLastChild()) { return convention.isConstantKey(name); } else if (isObjectLitKey(node, parent)) { return convention.isConstantKey(name); } else { return convention.isConstant(name); } } static JSDocInfo getInfoForNameNode(Node nameNode) { JSDocInfo info = null;"
      },
      {
        "txt": "Node parent = null; if (nameNode != null) { info = nameNode.getJSDocInfo(); parent = nameNode.getParent(); } if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) || parent.getType() == Token.FUNCTION)) { info = parent.getJSDocInfo(); }"
      },
      {
        "txt": "return info; } static JSDocInfo getFunctionInfo(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION); JSDocInfo fnInfo = n.getJSDocInfo(); if (fnInfo == null && NodeUtil.isFunctionExpression(n)) { Node parent = n.getParent(); if (parent.getType() == Token.ASSIGN) { fnInfo = parent.getJSDocInfo(); } else if (parent.getType() == Token.NAME) {"
      },
      {
        "txt": "fnInfo = parent.getParent().getJSDocInfo(); } } return fnInfo; } static String getSourceName(Node n) { String sourceName = null; while (sourceName == null && n != null) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); n = n.getParent();"
      },
      {
        "txt": "} return sourceName; } static Node newCallNode(Node callTarget, Node... parameters) { boolean isFreeCall = isName(callTarget); Node call = new Node(Token.CALL, callTarget); call.putBooleanProp(Node.FREE_CALL, isFreeCall); for (Node parameter : parameters) { call.addChildToBack(parameter); }"
      },
      {
        "txt": "return call; } static boolean evaluatesToLocalValue(Node value) { return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse()); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value)"
      },
      {
        "txt": "&& evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);"
      },
      {
        "txt": "case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME:"
      },
      {
        "txt": "return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || locals.apply(value); case Token.NEW: return true; case Token.FUNCTION: case Token.REGEXP:"
      },
      {
        "txt": "case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true;"
      },
      {
        "txt": "} throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }"
      }
    ]
  }
]