[
  {
    "id": 210,
    "file_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
    "start-bug-line": 613,
    "end-bug-line": 613,
    "bug": "return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;",
    "fix": "if (resultEqualsValue) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.type; import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CodingConvention;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumElementType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.ParameterizedType; import com.google.javascript.rhino.jstype.StaticSlot;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.UnionType; import com.google.javascript.rhino.jstype.Visitor; public abstract class ChainableReverseAbstractInterpreter implements ReverseAbstractInterpreter { protected final CodingConvention convention; final JSTypeRegistry typeRegistry; private ChainableReverseAbstractInterpreter firstLink; private ChainableReverseAbstractInterpreter nextLink; public ChainableReverseAbstractInterpreter(CodingConvention convention,"
      },
      {
        "txt": "JSTypeRegistry typeRegistry) { Preconditions.checkNotNull(convention); this.convention = convention; this.typeRegistry = typeRegistry; firstLink = this; nextLink = null; } public ChainableReverseAbstractInterpreter append( ChainableReverseAbstractInterpreter lastLink) { Preconditions.checkArgument(lastLink.nextLink == null);"
      },
      {
        "txt": "this.nextLink = lastLink; lastLink.firstLink = this.firstLink; return lastLink; } public ChainableReverseAbstractInterpreter getFirst() { return firstLink; } protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) { return firstLink.getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "condition, blindScope, outcome); } protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) { return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome( condition, blindScope, outcome) : blindScope; } protected JSType getTypeIfRefinable(Node node, FlowScope scope) { switch (node.getType()) { case Token.NAME:"
      },
      {
        "txt": "StaticSlot<JSType> nameVar = scope.getSlot(node.getString()); if (nameVar != null) { JSType nameVarType = nameVar.getType(); if (nameVarType == null) { nameVarType = node.getJSType(); } return nameVarType; } return null; case Token.GETPROP:"
      },
      {
        "txt": "String qualifiedName = node.getQualifiedName(); if (qualifiedName == null) { return null; } StaticSlot<JSType> propVar = scope.getSlot(qualifiedName); JSType propVarType = null; if (propVar != null) { propVarType = propVar.getType(); } if (propVarType == null) {"
      },
      {
        "txt": "propVarType = node.getJSType(); } if (propVarType == null) { propVarType = getNativeType(UNKNOWN_TYPE); } return propVarType; } return null; } protected void declareNameInScope(FlowScope scope, Node node, JSType type) {"
      },
      {
        "txt": "switch (node.getType()) { case Token.NAME: scope.inferSlotType(node.getString(), type); break; case Token.GETPROP: String qualifiedName = node.getQualifiedName(); Preconditions.checkNotNull(qualifiedName); JSType origType = node.getJSType(); origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType; scope.inferQualifiedSlot(node, qualifiedName, origType, type);"
      },
      {
        "txt": "break; case Token.THIS: break; default: throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree()); } } private final Visitor<JSType> restrictUndefinedVisitor = new Visitor<JSType>() {"
      },
      {
        "txt": "@Override public JSType caseEnumElementType(EnumElementType enumElementType) { JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override"
      },
      {
        "txt": "public JSType caseAllType() { return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, NULL_TYPE); } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); } @Override public JSType caseNoType() {"
      },
      {
        "txt": "return getNativeType(NO_TYPE); } @Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; }"
      },
      {
        "txt": "@Override public JSType caseNullType() { return getNativeType(NULL_TYPE); } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) {"
      },
      {
        "txt": "return type; } @Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseUnionType(UnionType type) { return type.getRestrictedUnion(getNativeType(VOID_TYPE)); }"
      },
      {
        "txt": "@Override public JSType caseUnknownType() { return getNativeType(UNKNOWN_TYPE); } @Override public JSType caseVoidType() { return null; } @Override public JSType caseParameterizedType(ParameterizedType type) {"
      },
      {
        "txt": "return caseObjectType(type); } @Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } }; private final Visitor<JSType> restrictNullVisitor = new Visitor<JSType>() { @Override"
      },
      {
        "txt": "public JSType caseEnumElementType(EnumElementType enumElementType) { JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override"
      },
      {
        "txt": "public JSType caseAllType() { return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, VOID_TYPE); } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); } @Override public JSType caseNoType() {"
      },
      {
        "txt": "return getNativeType(NO_TYPE); } @Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; }"
      },
      {
        "txt": "@Override public JSType caseNullType() { return null; } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) {"
      },
      {
        "txt": "return type; } @Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseUnionType(UnionType type) { return type.getRestrictedUnion(getNativeType(NULL_TYPE)); }"
      },
      {
        "txt": "@Override public JSType caseUnknownType() { return getNativeType(UNKNOWN_TYPE); } @Override public JSType caseVoidType() { return getNativeType(VOID_TYPE); } @Override public JSType caseParameterizedType(ParameterizedType type) {"
      },
      {
        "txt": "return caseObjectType(type); } @Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } }; abstract class RestrictByTypeOfResultVisitor implements Visitor<JSType> { protected abstract JSType caseTopType(JSType topType);"
      },
      {
        "txt": "@Override public JSType caseAllType() { return caseTopType(getNativeType(ALL_TYPE)); } @Override public JSType caseUnknownType() { return caseTopType(getNativeType(CHECKED_UNKNOWN_TYPE)); } @Override public JSType caseUnionType(UnionType type) {"
      },
      {
        "txt": "JSType restricted = null; for (JSType alternate : type.getAlternates()) { JSType restrictedAlternate = alternate.visit(this); if (restrictedAlternate != null) { if (restricted == null) { restricted = restrictedAlternate; } else { restricted = restrictedAlternate.getLeastSupertype(restricted); } }"
      },
      {
        "txt": "} return restricted; } @Override public JSType caseNoType() { return getNativeType(NO_TYPE); } @Override public JSType caseEnumElementType(EnumElementType enumElementType) { JSType type = enumElementType.getPrimitiveType().visit(this);"
      },
      {
        "txt": "if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override public JSType caseParameterizedType(ParameterizedType type) { return caseObjectType(type);"
      },
      {
        "txt": "} @Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } } abstract class RestrictByTrueTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override public JSType caseNoObjectType() {"
      },
      {
        "txt": "return null; } @Override public JSType caseBooleanType() { return null; } @Override public JSType caseFunctionType(FunctionType type) { return null; }"
      },
      {
        "txt": "@Override public JSType caseNullType() { return null; } @Override public JSType caseNumberType() { return null; } @Override public JSType caseObjectType(ObjectType type) {"
      },
      {
        "txt": "return null; } @Override public JSType caseStringType() { return null; } @Override public JSType caseVoidType() { return null; }"
      },
      {
        "txt": "} abstract class RestrictByFalseTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override protected JSType caseTopType(JSType topType) { return topType; } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE);"
      },
      {
        "txt": "} @Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; } @Override"
      },
      {
        "txt": "public JSType caseNullType() { return getNativeType(NULL_TYPE); } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) { return type;"
      },
      {
        "txt": "} @Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseVoidType() { return getNativeType(VOID_TYPE); } }"
      },
      {
        "txt": "private class RestrictByOneTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { private final String value; private final boolean resultEqualsValue; RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) { this.value = value; this.resultEqualsValue = resultEqualsValue; } private boolean matchesExpectation(String result) { return result.equals(value) == resultEqualsValue;"
      },
      {
        "txt": "} @Override protected JSType caseTopType(JSType topType) { JSType result = topType; if (resultEqualsValue) { JSType typeByName = getNativeTypeForTypeOf(value); if (typeByName != null) { result = typeByName; } }"
      },
      {
        "txt": "return result; } @Override public JSType caseNoObjectType() { return (value.equals(\"object\") || value.equals(\"function\")) == resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null; } @Override public JSType caseBooleanType() { return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null;"
      },
      {
        "txt": "} @Override public JSType caseFunctionType(FunctionType type) { return matchesExpectation(\"function\") ? type : null; } @Override public JSType caseNullType() { return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null; } @Override"
      },
      {
        "txt": "return matchesExpectation(\"number\") ? getNativeType(NUMBER_TYPE) : null; } @Override public JSType caseObjectType(ObjectType type) { if (value.equals(\"function\")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); <extra_id_0> } return matchesExpectation(\"object\") ? type : null; } @Override public JSType caseStringType() { return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null;"
      },
      {
        "txt": "public JSType caseStringType() { return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null; } @Override public JSType caseVoidType() { return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null; } } protected final JSType getRestrictedWithoutUndefined(JSType type) { return type == null ? null : type.visit(restrictUndefinedVisitor);"
      },
      {
        "txt": "} protected final JSType getRestrictedWithoutNull(JSType type) { return type == null ? null : type.visit(restrictNullVisitor); } JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) { if (type == null) { if (resultEqualsValue) { JSType result = getNativeTypeForTypeOf(value); return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result;"
      },
      {
        "txt": "} else { return null; } } return type.visit( new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue)); } JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); }"
      },
      {
        "txt": "private JSType getNativeTypeForTypeOf(String value) { if (value.equals(\"number\")) { return getNativeType(NUMBER_TYPE); } else if (value.equals(\"boolean\")) { return getNativeType(BOOLEAN_TYPE); } else if (value.equals(\"string\")) { return getNativeType(STRING_TYPE); } else if (value.equals(\"undefined\")) { return getNativeType(VOID_TYPE); } else if (value.equals(\"function\")) {"
      },
      {
        "txt": "return getNativeType(U2U_CONSTRUCTOR_TYPE); } else { return null; } }"
      }
    ]
  },
  {
    "id": 211,
    "file_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
    "start-bug-line": 615,
    "end-bug-line": 615,
    "bug": "",
    "fix": "return ctorType.getGreatestSubtype(type); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.type; import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CodingConvention; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumElementType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.ParameterizedType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.UnionType; import com.google.javascript.rhino.jstype.Visitor; public abstract class ChainableReverseAbstractInterpreter implements ReverseAbstractInterpreter { protected final CodingConvention convention; final JSTypeRegistry typeRegistry; private ChainableReverseAbstractInterpreter firstLink; private ChainableReverseAbstractInterpreter nextLink; public ChainableReverseAbstractInterpreter(CodingConvention convention, JSTypeRegistry typeRegistry) {"
      },
      {
        "txt": "Preconditions.checkNotNull(convention); this.convention = convention; this.typeRegistry = typeRegistry; firstLink = this; nextLink = null; } public ChainableReverseAbstractInterpreter append( ChainableReverseAbstractInterpreter lastLink) { Preconditions.checkArgument(lastLink.nextLink == null); this.nextLink = lastLink;"
      },
      {
        "txt": "lastLink.firstLink = this.firstLink; return lastLink; } public ChainableReverseAbstractInterpreter getFirst() { return firstLink; } protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) { return firstLink.getPreciserScopeKnowingConditionOutcome( condition, blindScope, outcome);"
      },
      {
        "txt": "} protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) { return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome( condition, blindScope, outcome) : blindScope; } protected JSType getTypeIfRefinable(Node node, FlowScope scope) { switch (node.getType()) { case Token.NAME: StaticSlot<JSType> nameVar = scope.getSlot(node.getString());"
      },
      {
        "txt": "if (nameVar != null) { JSType nameVarType = nameVar.getType(); if (nameVarType == null) { nameVarType = node.getJSType(); } return nameVarType; } return null; case Token.GETPROP: String qualifiedName = node.getQualifiedName();"
      },
      {
        "txt": "if (qualifiedName == null) { return null; } StaticSlot<JSType> propVar = scope.getSlot(qualifiedName); JSType propVarType = null; if (propVar != null) { propVarType = propVar.getType(); } if (propVarType == null) { propVarType = node.getJSType();"
      },
      {
        "txt": "} if (propVarType == null) { propVarType = getNativeType(UNKNOWN_TYPE); } return propVarType; } return null; } protected void declareNameInScope(FlowScope scope, Node node, JSType type) { switch (node.getType()) {"
      },
      {
        "txt": "case Token.NAME: scope.inferSlotType(node.getString(), type); break; case Token.GETPROP: String qualifiedName = node.getQualifiedName(); Preconditions.checkNotNull(qualifiedName); JSType origType = node.getJSType(); origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType; scope.inferQualifiedSlot(node, qualifiedName, origType, type); break;"
      },
      {
        "txt": "case Token.THIS: break; default: throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree()); } } private final Visitor<JSType> restrictUndefinedVisitor = new Visitor<JSType>() { @Override"
      },
      {
        "txt": "public JSType caseEnumElementType(EnumElementType enumElementType) { JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override public JSType caseAllType() {"
      },
      {
        "txt": "return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, NULL_TYPE); } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); } @Override public JSType caseNoType() { return getNativeType(NO_TYPE);"
      },
      {
        "txt": "} @Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; } @Override"
      },
      {
        "txt": "public JSType caseNullType() { return getNativeType(NULL_TYPE); } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) { return type;"
      },
      {
        "txt": "} @Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseUnionType(UnionType type) { return type.getRestrictedUnion(getNativeType(VOID_TYPE)); } @Override"
      },
      {
        "txt": "public JSType caseUnknownType() { return getNativeType(UNKNOWN_TYPE); } @Override public JSType caseVoidType() { return null; } @Override public JSType caseParameterizedType(ParameterizedType type) { return caseObjectType(type);"
      },
      {
        "txt": "} @Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } }; private final Visitor<JSType> restrictNullVisitor = new Visitor<JSType>() { @Override public JSType caseEnumElementType(EnumElementType enumElementType) {"
      },
      {
        "txt": "JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override public JSType caseAllType() {"
      },
      {
        "txt": "return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, VOID_TYPE); } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); } @Override public JSType caseNoType() { return getNativeType(NO_TYPE);"
      },
      {
        "txt": "} @Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; } @Override"
      },
      {
        "txt": "public JSType caseNullType() { return null; } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) { return type;"
      },
      {
        "txt": "} @Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseUnionType(UnionType type) { return type.getRestrictedUnion(getNativeType(NULL_TYPE)); } @Override"
      },
      {
        "txt": "public JSType caseUnknownType() { return getNativeType(UNKNOWN_TYPE); } @Override public JSType caseVoidType() { return getNativeType(VOID_TYPE); } @Override public JSType caseParameterizedType(ParameterizedType type) { return caseObjectType(type);"
      },
      {
        "txt": "} @Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } }; abstract class RestrictByTypeOfResultVisitor implements Visitor<JSType> { protected abstract JSType caseTopType(JSType topType); @Override"
      },
      {
        "txt": "public JSType caseAllType() { return caseTopType(getNativeType(ALL_TYPE)); } @Override public JSType caseUnknownType() { return caseTopType(getNativeType(CHECKED_UNKNOWN_TYPE)); } @Override public JSType caseUnionType(UnionType type) { JSType restricted = null;"
      },
      {
        "txt": "for (JSType alternate : type.getAlternates()) { JSType restrictedAlternate = alternate.visit(this); if (restrictedAlternate != null) { if (restricted == null) { restricted = restrictedAlternate; } else { restricted = restrictedAlternate.getLeastSupertype(restricted); } } }"
      },
      {
        "txt": "return restricted; } @Override public JSType caseNoType() { return getNativeType(NO_TYPE); } @Override public JSType caseEnumElementType(EnumElementType enumElementType) { JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null &&"
      },
      {
        "txt": "enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override public JSType caseParameterizedType(ParameterizedType type) { return caseObjectType(type); }"
      },
      {
        "txt": "@Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } } abstract class RestrictByTrueTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override public JSType caseNoObjectType() { return null;"
      },
      {
        "txt": "} @Override public JSType caseBooleanType() { return null; } @Override public JSType caseFunctionType(FunctionType type) { return null; } @Override"
      },
      {
        "txt": "public JSType caseNullType() { return null; } @Override public JSType caseNumberType() { return null; } @Override public JSType caseObjectType(ObjectType type) { return null;"
      },
      {
        "txt": "} @Override public JSType caseStringType() { return null; } @Override public JSType caseVoidType() { return null; } }"
      },
      {
        "txt": "abstract class RestrictByFalseTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override protected JSType caseTopType(JSType topType) { return topType; } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); }"
      },
      {
        "txt": "@Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; } @Override public JSType caseNullType() {"
      },
      {
        "txt": "return getNativeType(NULL_TYPE); } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) { return type; }"
      },
      {
        "txt": "@Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseVoidType() { return getNativeType(VOID_TYPE); } } private class RestrictByOneTypeOfResultVisitor"
      },
      {
        "txt": "extends RestrictByTypeOfResultVisitor { private final String value; private final boolean resultEqualsValue; RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) { this.value = value; this.resultEqualsValue = resultEqualsValue; } private boolean matchesExpectation(String result) { return result.equals(value) == resultEqualsValue; }"
      },
      {
        "txt": "@Override protected JSType caseTopType(JSType topType) { JSType result = topType; if (resultEqualsValue) { JSType typeByName = getNativeTypeForTypeOf(value); if (typeByName != null) { result = typeByName; } } return result;"
      },
      {
        "txt": "} @Override public JSType caseNoObjectType() { return (value.equals(\"object\") || value.equals(\"function\")) == resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null; } @Override public JSType caseBooleanType() { return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null; }"
      },
      {
        "txt": "@Override public JSType caseFunctionType(FunctionType type) { return matchesExpectation(\"function\") ? type : null; } @Override public JSType caseNullType() { return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null; } @Override public JSType caseNumberType() {"
      },
      {
        "txt": "} @Override public JSType caseObjectType(ObjectType type) { if (value.equals(\"function\")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; <extra_id_0> } return matchesExpectation(\"object\") ? type : null; } @Override public JSType caseStringType() { return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null;"
      },
      {
        "txt": "public JSType caseStringType() { return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null; } @Override public JSType caseVoidType() { return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null; } } protected final JSType getRestrictedWithoutUndefined(JSType type) { return type == null ? null : type.visit(restrictUndefinedVisitor);"
      },
      {
        "txt": "} protected final JSType getRestrictedWithoutNull(JSType type) { return type == null ? null : type.visit(restrictNullVisitor); } JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) { if (type == null) { if (resultEqualsValue) { JSType result = getNativeTypeForTypeOf(value); return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result;"
      },
      {
        "txt": "} else { return null; } } return type.visit( new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue)); } JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); }"
      },
      {
        "txt": "private JSType getNativeTypeForTypeOf(String value) { if (value.equals(\"number\")) { return getNativeType(NUMBER_TYPE); } else if (value.equals(\"boolean\")) { return getNativeType(BOOLEAN_TYPE); } else if (value.equals(\"string\")) { return getNativeType(STRING_TYPE); } else if (value.equals(\"undefined\")) { return getNativeType(VOID_TYPE); } else if (value.equals(\"function\")) {"
      },
      {
        "txt": "return getNativeType(U2U_CONSTRUCTOR_TYPE); } else { return null; } }"
      }
    ]
  },
  {
    "id": 212,
    "file_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
    "start-bug-line": 616,
    "end-bug-line": 616,
    "bug": "",
    "fix": "return type.isSubtype(ctorType) ? null : type; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.type; import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CodingConvention; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumElementType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.ParameterizedType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.UnionType; import com.google.javascript.rhino.jstype.Visitor; public abstract class ChainableReverseAbstractInterpreter implements ReverseAbstractInterpreter { protected final CodingConvention convention; final JSTypeRegistry typeRegistry; private ChainableReverseAbstractInterpreter firstLink; private ChainableReverseAbstractInterpreter nextLink; public ChainableReverseAbstractInterpreter(CodingConvention convention, JSTypeRegistry typeRegistry) {"
      },
      {
        "txt": "Preconditions.checkNotNull(convention); this.convention = convention; this.typeRegistry = typeRegistry; firstLink = this; nextLink = null; } public ChainableReverseAbstractInterpreter append( ChainableReverseAbstractInterpreter lastLink) { Preconditions.checkArgument(lastLink.nextLink == null); this.nextLink = lastLink;"
      },
      {
        "txt": "lastLink.firstLink = this.firstLink; return lastLink; } public ChainableReverseAbstractInterpreter getFirst() { return firstLink; } protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) { return firstLink.getPreciserScopeKnowingConditionOutcome( condition, blindScope, outcome);"
      },
      {
        "txt": "} protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) { return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome( condition, blindScope, outcome) : blindScope; } protected JSType getTypeIfRefinable(Node node, FlowScope scope) { switch (node.getType()) { case Token.NAME: StaticSlot<JSType> nameVar = scope.getSlot(node.getString());"
      },
      {
        "txt": "if (nameVar != null) { JSType nameVarType = nameVar.getType(); if (nameVarType == null) { nameVarType = node.getJSType(); } return nameVarType; } return null; case Token.GETPROP: String qualifiedName = node.getQualifiedName();"
      },
      {
        "txt": "if (qualifiedName == null) { return null; } StaticSlot<JSType> propVar = scope.getSlot(qualifiedName); JSType propVarType = null; if (propVar != null) { propVarType = propVar.getType(); } if (propVarType == null) { propVarType = node.getJSType();"
      },
      {
        "txt": "} if (propVarType == null) { propVarType = getNativeType(UNKNOWN_TYPE); } return propVarType; } return null; } protected void declareNameInScope(FlowScope scope, Node node, JSType type) { switch (node.getType()) {"
      },
      {
        "txt": "case Token.NAME: scope.inferSlotType(node.getString(), type); break; case Token.GETPROP: String qualifiedName = node.getQualifiedName(); Preconditions.checkNotNull(qualifiedName); JSType origType = node.getJSType(); origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType; scope.inferQualifiedSlot(node, qualifiedName, origType, type); break;"
      },
      {
        "txt": "case Token.THIS: break; default: throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree()); } } private final Visitor<JSType> restrictUndefinedVisitor = new Visitor<JSType>() { @Override"
      },
      {
        "txt": "public JSType caseEnumElementType(EnumElementType enumElementType) { JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override public JSType caseAllType() {"
      },
      {
        "txt": "return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, NULL_TYPE); } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); } @Override public JSType caseNoType() { return getNativeType(NO_TYPE);"
      },
      {
        "txt": "} @Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; } @Override"
      },
      {
        "txt": "public JSType caseNullType() { return getNativeType(NULL_TYPE); } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) { return type;"
      },
      {
        "txt": "} @Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseUnionType(UnionType type) { return type.getRestrictedUnion(getNativeType(VOID_TYPE)); } @Override"
      },
      {
        "txt": "public JSType caseUnknownType() { return getNativeType(UNKNOWN_TYPE); } @Override public JSType caseVoidType() { return null; } @Override public JSType caseParameterizedType(ParameterizedType type) { return caseObjectType(type);"
      },
      {
        "txt": "} @Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } }; private final Visitor<JSType> restrictNullVisitor = new Visitor<JSType>() { @Override public JSType caseEnumElementType(EnumElementType enumElementType) {"
      },
      {
        "txt": "JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override public JSType caseAllType() {"
      },
      {
        "txt": "return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, VOID_TYPE); } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); } @Override public JSType caseNoType() { return getNativeType(NO_TYPE);"
      },
      {
        "txt": "} @Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; } @Override"
      },
      {
        "txt": "public JSType caseNullType() { return null; } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) { return type;"
      },
      {
        "txt": "} @Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseUnionType(UnionType type) { return type.getRestrictedUnion(getNativeType(NULL_TYPE)); } @Override"
      },
      {
        "txt": "public JSType caseUnknownType() { return getNativeType(UNKNOWN_TYPE); } @Override public JSType caseVoidType() { return getNativeType(VOID_TYPE); } @Override public JSType caseParameterizedType(ParameterizedType type) { return caseObjectType(type);"
      },
      {
        "txt": "} @Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } }; abstract class RestrictByTypeOfResultVisitor implements Visitor<JSType> { protected abstract JSType caseTopType(JSType topType); @Override"
      },
      {
        "txt": "public JSType caseAllType() { return caseTopType(getNativeType(ALL_TYPE)); } @Override public JSType caseUnknownType() { return caseTopType(getNativeType(CHECKED_UNKNOWN_TYPE)); } @Override public JSType caseUnionType(UnionType type) { JSType restricted = null;"
      },
      {
        "txt": "for (JSType alternate : type.getAlternates()) { JSType restrictedAlternate = alternate.visit(this); if (restrictedAlternate != null) { if (restricted == null) { restricted = restrictedAlternate; } else { restricted = restrictedAlternate.getLeastSupertype(restricted); } } }"
      },
      {
        "txt": "return restricted; } @Override public JSType caseNoType() { return getNativeType(NO_TYPE); } @Override public JSType caseEnumElementType(EnumElementType enumElementType) { JSType type = enumElementType.getPrimitiveType().visit(this); if (type != null &&"
      },
      {
        "txt": "enumElementType.getPrimitiveType().isEquivalentTo(type)) { return enumElementType; } else { return type; } } @Override public JSType caseParameterizedType(ParameterizedType type) { return caseObjectType(type); }"
      },
      {
        "txt": "@Override public JSType caseTemplateType(TemplateType templateType) { return caseObjectType(templateType); } } abstract class RestrictByTrueTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override public JSType caseNoObjectType() { return null;"
      },
      {
        "txt": "} @Override public JSType caseBooleanType() { return null; } @Override public JSType caseFunctionType(FunctionType type) { return null; } @Override"
      },
      {
        "txt": "public JSType caseNullType() { return null; } @Override public JSType caseNumberType() { return null; } @Override public JSType caseObjectType(ObjectType type) { return null;"
      },
      {
        "txt": "} @Override public JSType caseStringType() { return null; } @Override public JSType caseVoidType() { return null; } }"
      },
      {
        "txt": "abstract class RestrictByFalseTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override protected JSType caseTopType(JSType topType) { return topType; } @Override public JSType caseNoObjectType() { return getNativeType(NO_OBJECT_TYPE); }"
      },
      {
        "txt": "@Override public JSType caseBooleanType() { return getNativeType(BOOLEAN_TYPE); } @Override public JSType caseFunctionType(FunctionType type) { return type; } @Override public JSType caseNullType() {"
      },
      {
        "txt": "return getNativeType(NULL_TYPE); } @Override public JSType caseNumberType() { return getNativeType(NUMBER_TYPE); } @Override public JSType caseObjectType(ObjectType type) { return type; }"
      },
      {
        "txt": "@Override public JSType caseStringType() { return getNativeType(STRING_TYPE); } @Override public JSType caseVoidType() { return getNativeType(VOID_TYPE); } } private class RestrictByOneTypeOfResultVisitor"
      },
      {
        "txt": "extends RestrictByTypeOfResultVisitor { private final String value; private final boolean resultEqualsValue; RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) { this.value = value; this.resultEqualsValue = resultEqualsValue; } private boolean matchesExpectation(String result) { return result.equals(value) == resultEqualsValue; }"
      },
      {
        "txt": "@Override protected JSType caseTopType(JSType topType) { JSType result = topType; if (resultEqualsValue) { JSType typeByName = getNativeTypeForTypeOf(value); if (typeByName != null) { result = typeByName; } } return result;"
      },
      {
        "txt": "} @Override public JSType caseNoObjectType() { return (value.equals(\"object\") || value.equals(\"function\")) == resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null; } @Override public JSType caseBooleanType() { return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null; }"
      },
      {
        "txt": "@Override public JSType caseFunctionType(FunctionType type) { return matchesExpectation(\"function\") ? type : null; } @Override public JSType caseNullType() { return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null; } @Override public JSType caseNumberType() {"
      },
      {
        "txt": "} @Override public JSType caseObjectType(ObjectType type) { if (value.equals(\"function\")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; <extra_id_0> return matchesExpectation(\"object\") ? type : null; } @Override public JSType caseStringType() { return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null; }"
      },
      {
        "txt": "return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null; } @Override public JSType caseVoidType() { return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null; } } protected final JSType getRestrictedWithoutUndefined(JSType type) { return type == null ? null : type.visit(restrictUndefinedVisitor); }"
      },
      {
        "txt": "protected final JSType getRestrictedWithoutNull(JSType type) { return type == null ? null : type.visit(restrictNullVisitor); } JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) { if (type == null) { if (resultEqualsValue) { JSType result = getNativeTypeForTypeOf(value); return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result; } else {"
      },
      {
        "txt": "return null; } } return type.visit( new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue)); } JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } private JSType getNativeTypeForTypeOf(String value) {"
      },
      {
        "txt": "if (value.equals(\"number\")) { return getNativeType(NUMBER_TYPE); } else if (value.equals(\"boolean\")) { return getNativeType(BOOLEAN_TYPE); } else if (value.equals(\"string\")) { return getNativeType(STRING_TYPE); } else if (value.equals(\"undefined\")) { return getNativeType(VOID_TYPE); } else if (value.equals(\"function\")) { return getNativeType(U2U_CONSTRUCTOR_TYPE);"
      },
      {
        "txt": "} else { return null; } }"
      }
    ]
  }
]