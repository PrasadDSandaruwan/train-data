[
  {
    "id": 417,
    "file_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
    "start-bug-line": 361,
    "end-bug-line": 361,
    "bug": "",
    "fix": "for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class ReferenceCollectingCallback implements ScopedCallback, CompilerPass { private final Map<Var, ReferenceCollection> referenceMap = Maps.newHashMap(); private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>(); private final Behavior behavior;"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final Predicate<Var> varFilter; ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) { this(compiler, behavior, Predicates.<Var>alwaysTrue()); } ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior, Predicate<Var> varFilter) { this.compiler = compiler; this.behavior = behavior; this.varFilter = varFilter;"
      },
      {
        "txt": "} public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); } public ReferenceCollection getReferenceCollection(Var v) { return referenceMap.get(v); } public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v = t.getScope().getVar(n.getString());"
      },
      {
        "txt": "if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek())); } } if (isBlockBoundary(n, parent)) { blockStack.pop(); } } public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "Node n = t.getScope().getRootNode(); BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek(); blockStack.push(new BasicBlock(parent, n)); } public void exitScope(NodeTraversal t) { blockStack.pop(); behavior.afterExitScope(t, referenceMap); } public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {"
      },
      {
        "txt": "if (isBlockBoundary(n, parent)) { blockStack.push(new BasicBlock(blockStack.peek(), n)); } return true; } private static boolean isBlockBoundary(Node n, Node parent) { if (parent != null) { switch (parent.getType()) { case Token.DO: case Token.FOR:"
      },
      {
        "txt": "case Token.TRY: case Token.WHILE: case Token.WITH: return true; case Token.AND: case Token.HOOK: case Token.IF: case Token.OR: return n != parent.getFirstChild(); }"
      },
      {
        "txt": "} return n.getType() == Token.CASE; } private void addReference(NodeTraversal t, Var v, Reference reference) { ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null) { referenceInfo = new ReferenceCollection(); referenceMap.put(v, referenceInfo); } referenceInfo.add(reference, t, v);"
      },
      {
        "txt": "} interface Behavior { void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap); } static Behavior DO_NOTHING_BEHAVIOR = new Behavior() { @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {} };"
      },
      {
        "txt": "static class ReferenceCollection { List<Reference> references = Lists.newArrayList(); void add(Reference reference, NodeTraversal t, Var v) { references.add(reference); } protected boolean isWellDefined() { int size = references.size(); if (size == 0) { return false; }"
      },
      {
        "txt": "Reference init = getInitializingReference(); if (init == null) { return false; } Preconditions.checkState(references.get(0).isDeclaration()); BasicBlock initBlock = init.getBasicBlock(); for (int i = 1; i < size; i++) { if (!initBlock.provablyExecutesBefore( references.get(i).getBasicBlock())) { return false;"
      },
      {
        "txt": "} } return true; } boolean isEscaped() { Scope scope = null; for (Reference ref : references) { if (scope == null) { scope = ref.scope; } else if (scope != ref.scope) {"
      },
      {
        "txt": "return true; } } return false; } private boolean isInitializingDeclarationAt(int index) { Reference maybeInit = references.get(index); if (maybeInit.isInitializingDeclaration()) { return true; }"
      },
      {
        "txt": "return false; } private boolean isInitializingAssignmentAt(int index) { if (index < references.size() && index > 0) { Reference maybeDecl = references.get(index-1); if (maybeDecl.isVarDeclaration()) { Preconditions.checkState(!maybeDecl.isInitializingDeclaration()); Reference maybeInit = references.get(index); if (maybeInit.isSimpleAssignmentToName()) { return true;"
      },
      {
        "txt": "} } } return false; } Reference getInitializingReference() { if (isInitializingDeclarationAt(0)) { return references.get(0); } else if (isInitializingAssignmentAt(1)) { return references.get(1);"
      },
      {
        "txt": "} return null; } Reference getInitializingReferenceForConstants() { int size = references.size(); for (int i = 0; i < size; i++) { if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) { return references.get(i); } }"
      },
      {
        "txt": "} boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } <extra_id_0> return true; } private Reference getOneAndOnlyAssignment() { Reference assignment = null; int size = references.size(); for (int i = 0; i < size; i++) {"
      },
      {
        "txt": "int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { if (assignment == null) { assignment = ref; } else { return null; } }"
      },
      {
        "txt": "} return assignment; } boolean isNeverAssigned() { int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { return false; }"
      },
      {
        "txt": "} return true; } boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); if (size > 0 && references.get(0).isInitializingDeclaration()) { return true; } return false; }"
      },
      {
        "txt": "} static final class Reference { private static final Set<Integer> DECLARATION_PARENTS = ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH); private final Node nameNode; private final Node parent; private final Node grandparent; private final BasicBlock basicBlock; private final Scope scope; private final String sourceName;"
      },
      {
        "txt": "Reference(Node nameNode, Node parent, NodeTraversal t, BasicBlock basicBlock) { this(nameNode, parent, parent.getParent(), basicBlock, t.getScope(), t.getSourceName()); } static Reference newBleedingFunction(NodeTraversal t, BasicBlock basicBlock, Node func) { return new Reference(func.getFirstChild(), func, func.getParent(), basicBlock, t.getScope(), t.getSourceName()); }"
      },
      {
        "txt": "private Reference(Node nameNode, Node parent, Node grandparent, BasicBlock basicBlock, Scope scope, String sourceName) { this.nameNode = nameNode; this.parent = parent; this.grandparent = grandparent; this.basicBlock = basicBlock; this.scope = scope; this.sourceName = sourceName; } boolean isDeclaration() {"
      },
      {
        "txt": "return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() == Token.LP && grandparent.getType() == Token.FUNCTION; } boolean isVarDeclaration() { return parent.getType() == Token.VAR; } boolean isHoistedFunction() { return NodeUtil.isHoistedFunctionDeclaration(parent); }"
      },
      {
        "txt": "boolean isInitializingDeclaration() { return isDeclaration() && (parent.getType() != Token.VAR || nameNode.getFirstChild() != null); } Node getAssignedValue() { return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); } BasicBlock getBasicBlock() { return basicBlock;"
      },
      {
        "txt": "} Node getParent() { return parent; } Node getNameNode() { return nameNode; } Node getGrandparent() { return grandparent; }"
      },
      {
        "txt": "private static boolean isLhsOfForInExpression(Node n) { Node parent = n.getParent(); if (parent.getType() == Token.VAR) { return isLhsOfForInExpression(parent); } return NodeUtil.isForIn(parent) && parent.getFirstChild() == n; } boolean isSimpleAssignmentToName() { return parent.getType() == Token.ASSIGN && parent.getFirstChild() == nameNode;"
      },
      {
        "txt": "} boolean isLvalue() { int parentType = parent.getType(); return (parentType == Token.VAR && nameNode.getFirstChild() != null) || parentType == Token.INC || parentType == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == nameNode) || isLhsOfForInExpression(nameNode); }"
      },
      {
        "txt": "Scope getScope() { return scope; } public String getSourceName() { return sourceName; } } static final class BasicBlock { private final BasicBlock parent; private final boolean isHoisted;"
      },
      {
        "txt": "BasicBlock(BasicBlock parent, Node root) { this.parent = parent; this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); } BasicBlock getParent() { return parent; } boolean provablyExecutesBefore(BasicBlock thatBlock) { BasicBlock currentBlock; for (currentBlock = thatBlock;"
      },
      {
        "txt": "currentBlock != null && currentBlock != this; currentBlock = currentBlock.getParent()) { if (currentBlock.isHoisted) { return false; } } return currentBlock == this; } }"
      }
    ]
  },
  {
    "id": 418,
    "file_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
    "start-bug-line": 545,
    "end-bug-line": 545,
    "bug": "",
    "fix": "private final boolean isFunction;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class ReferenceCollectingCallback implements ScopedCallback, CompilerPass { private final Map<Var, ReferenceCollection> referenceMap = Maps.newHashMap(); private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>(); private final Behavior behavior; private final AbstractCompiler compiler; private final Predicate<Var> varFilter; ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) { this(compiler, behavior, Predicates.<Var>alwaysTrue());"
      },
      {
        "txt": "} ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior, Predicate<Var> varFilter) { this.compiler = compiler; this.behavior = behavior; this.varFilter = varFilter; } public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); }"
      },
      {
        "txt": "public ReferenceCollection getReferenceCollection(Var v) { return referenceMap.get(v); } public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v = t.getScope().getVar(n.getString()); if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek())); }"
      },
      {
        "txt": "} if (isBlockBoundary(n, parent)) { blockStack.pop(); } } public void enterScope(NodeTraversal t) { Node n = t.getScope().getRootNode(); BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek(); blockStack.push(new BasicBlock(parent, n)); }"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { blockStack.pop(); behavior.afterExitScope(t, referenceMap); } public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (isBlockBoundary(n, parent)) { blockStack.push(new BasicBlock(blockStack.peek(), n)); } return true;"
      },
      {
        "txt": "} private static boolean isBlockBoundary(Node n, Node parent) { if (parent != null) { switch (parent.getType()) { case Token.DO: case Token.FOR: case Token.TRY: case Token.WHILE: case Token.WITH: return true;"
      },
      {
        "txt": "case Token.AND: case Token.HOOK: case Token.IF: case Token.OR: return n != parent.getFirstChild(); } } return n.getType() == Token.CASE; } private void addReference(NodeTraversal t, Var v, Reference reference) {"
      },
      {
        "txt": "ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null) { referenceInfo = new ReferenceCollection(); referenceMap.put(v, referenceInfo); } referenceInfo.add(reference, t, v); } interface Behavior { void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap);"
      },
      {
        "txt": "} static Behavior DO_NOTHING_BEHAVIOR = new Behavior() { @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {} }; static class ReferenceCollection { List<Reference> references = Lists.newArrayList(); void add(Reference reference, NodeTraversal t, Var v) { references.add(reference);"
      },
      {
        "txt": "} protected boolean isWellDefined() { int size = references.size(); if (size == 0) { return false; } Reference init = getInitializingReference(); if (init == null) { return false; }"
      },
      {
        "txt": "Preconditions.checkState(references.get(0).isDeclaration()); BasicBlock initBlock = init.getBasicBlock(); for (int i = 1; i < size; i++) { if (!initBlock.provablyExecutesBefore( references.get(i).getBasicBlock())) { return false; } } return true; }"
      },
      {
        "txt": "boolean isEscaped() { Scope scope = null; for (Reference ref : references) { if (scope == null) { scope = ref.scope; } else if (scope != ref.scope) { return true; } } return false;"
      },
      {
        "txt": "} private boolean isInitializingDeclarationAt(int index) { Reference maybeInit = references.get(index); if (maybeInit.isInitializingDeclaration()) { return true; } return false; } private boolean isInitializingAssignmentAt(int index) { if (index < references.size() && index > 0) {"
      },
      {
        "txt": "Reference maybeDecl = references.get(index-1); if (maybeDecl.isVarDeclaration()) { Preconditions.checkState(!maybeDecl.isInitializingDeclaration()); Reference maybeInit = references.get(index); if (maybeInit.isSimpleAssignmentToName()) { return true; } } } return false;"
      },
      {
        "txt": "} Reference getInitializingReference() { if (isInitializingDeclarationAt(0)) { return references.get(0); } else if (isInitializingAssignmentAt(1)) { return references.get(1); } return null; } Reference getInitializingReferenceForConstants() {"
      },
      {
        "txt": "int size = references.size(); for (int i = 0; i < size; i++) { if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) { return references.get(i); } } return null; } boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment();"
      },
      {
        "txt": "if (ref == null) { return false; } return true; } private Reference getOneAndOnlyAssignment() { Reference assignment = null; int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i);"
      },
      {
        "txt": "if (ref.isLvalue() || ref.isInitializingDeclaration()) { if (assignment == null) { assignment = ref; } else { return null; } } } return assignment; }"
      },
      {
        "txt": "boolean isNeverAssigned() { int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { return false; } } return true; }"
      },
      {
        "txt": "boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); if (size > 0 && references.get(0).isInitializingDeclaration()) { return true; } return false; } } static final class Reference { private static final Set<Integer> DECLARATION_PARENTS ="
      },
      {
        "txt": "ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH); private final Node nameNode; private final Node parent; private final Node grandparent; private final BasicBlock basicBlock; private final Scope scope; private final String sourceName; Reference(Node nameNode, Node parent, NodeTraversal t, BasicBlock basicBlock) { this(nameNode, parent, parent.getParent(), basicBlock, t.getScope(),"
      },
      {
        "txt": "t.getSourceName()); } static Reference newBleedingFunction(NodeTraversal t, BasicBlock basicBlock, Node func) { return new Reference(func.getFirstChild(), func, func.getParent(), basicBlock, t.getScope(), t.getSourceName()); } private Reference(Node nameNode, Node parent, Node grandparent, BasicBlock basicBlock, Scope scope, String sourceName) { this.nameNode = nameNode;"
      },
      {
        "txt": "this.parent = parent; this.grandparent = grandparent; this.basicBlock = basicBlock; this.scope = scope; this.sourceName = sourceName; } boolean isDeclaration() { return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() == Token.LP && grandparent.getType() == Token.FUNCTION;"
      },
      {
        "txt": "} boolean isVarDeclaration() { return parent.getType() == Token.VAR; } boolean isHoistedFunction() { return NodeUtil.isHoistedFunctionDeclaration(parent); } boolean isInitializingDeclaration() { return isDeclaration() && (parent.getType() != Token.VAR || nameNode.getFirstChild() != null);"
      },
      {
        "txt": "} Node getAssignedValue() { return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); } BasicBlock getBasicBlock() { return basicBlock; } Node getParent() { return parent;"
      },
      {
        "txt": "} Node getNameNode() { return nameNode; } Node getGrandparent() { return grandparent; } private static boolean isLhsOfForInExpression(Node n) { Node parent = n.getParent(); if (parent.getType() == Token.VAR) {"
      },
      {
        "txt": "return isLhsOfForInExpression(parent); } return NodeUtil.isForIn(parent) && parent.getFirstChild() == n; } boolean isSimpleAssignmentToName() { return parent.getType() == Token.ASSIGN && parent.getFirstChild() == nameNode; } boolean isLvalue() { int parentType = parent.getType();"
      },
      {
        "txt": "return (parentType == Token.VAR && nameNode.getFirstChild() != null) || parentType == Token.INC || parentType == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == nameNode) || isLhsOfForInExpression(nameNode); } Scope getScope() { return scope; }"
      },
      {
        "txt": "return sourceName; } } static final class BasicBlock { private final BasicBlock parent; private final boolean isHoisted; <extra_id_0> BasicBlock(BasicBlock parent, Node root) { this.parent = parent; this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); } BasicBlock getParent() { return parent;"
      },
      {
        "txt": "BasicBlock getParent() { return parent; } boolean provablyExecutesBefore(BasicBlock thatBlock) { BasicBlock currentBlock; for (currentBlock = thatBlock; currentBlock != null && currentBlock != this; currentBlock = currentBlock.getParent()) { if (currentBlock.isHoisted) { return false;"
      },
      {
        "txt": "} } return currentBlock == this; } }"
      }
    ]
  },
  {
    "id": 419,
    "file_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
    "start-bug-line": 549,
    "end-bug-line": 549,
    "bug": "",
    "fix": "private final boolean isLoop;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; class ReferenceCollectingCallback implements ScopedCallback, CompilerPass { private final Map<Var, ReferenceCollection> referenceMap = Maps.newHashMap(); private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>(); private final Behavior behavior; private final AbstractCompiler compiler; private final Predicate<Var> varFilter; ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) { this(compiler, behavior, Predicates.<Var>alwaysTrue());"
      },
      {
        "txt": "} ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior, Predicate<Var> varFilter) { this.compiler = compiler; this.behavior = behavior; this.varFilter = varFilter; } public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); }"
      },
      {
        "txt": "public ReferenceCollection getReferenceCollection(Var v) { return referenceMap.get(v); } public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v = t.getScope().getVar(n.getString()); if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek())); }"
      },
      {
        "txt": "} if (isBlockBoundary(n, parent)) { blockStack.pop(); } } public void enterScope(NodeTraversal t) { Node n = t.getScope().getRootNode(); BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek(); blockStack.push(new BasicBlock(parent, n)); }"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { blockStack.pop(); behavior.afterExitScope(t, referenceMap); } public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (isBlockBoundary(n, parent)) { blockStack.push(new BasicBlock(blockStack.peek(), n)); } return true;"
      },
      {
        "txt": "} private static boolean isBlockBoundary(Node n, Node parent) { if (parent != null) { switch (parent.getType()) { case Token.DO: case Token.FOR: case Token.TRY: case Token.WHILE: case Token.WITH: return true;"
      },
      {
        "txt": "case Token.AND: case Token.HOOK: case Token.IF: case Token.OR: return n != parent.getFirstChild(); } } return n.getType() == Token.CASE; } private void addReference(NodeTraversal t, Var v, Reference reference) {"
      },
      {
        "txt": "ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null) { referenceInfo = new ReferenceCollection(); referenceMap.put(v, referenceInfo); } referenceInfo.add(reference, t, v); } interface Behavior { void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap);"
      },
      {
        "txt": "} static Behavior DO_NOTHING_BEHAVIOR = new Behavior() { @Override public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {} }; static class ReferenceCollection { List<Reference> references = Lists.newArrayList(); void add(Reference reference, NodeTraversal t, Var v) { references.add(reference);"
      },
      {
        "txt": "} protected boolean isWellDefined() { int size = references.size(); if (size == 0) { return false; } Reference init = getInitializingReference(); if (init == null) { return false; }"
      },
      {
        "txt": "Preconditions.checkState(references.get(0).isDeclaration()); BasicBlock initBlock = init.getBasicBlock(); for (int i = 1; i < size; i++) { if (!initBlock.provablyExecutesBefore( references.get(i).getBasicBlock())) { return false; } } return true; }"
      },
      {
        "txt": "boolean isEscaped() { Scope scope = null; for (Reference ref : references) { if (scope == null) { scope = ref.scope; } else if (scope != ref.scope) { return true; } } return false;"
      },
      {
        "txt": "} private boolean isInitializingDeclarationAt(int index) { Reference maybeInit = references.get(index); if (maybeInit.isInitializingDeclaration()) { return true; } return false; } private boolean isInitializingAssignmentAt(int index) { if (index < references.size() && index > 0) {"
      },
      {
        "txt": "Reference maybeDecl = references.get(index-1); if (maybeDecl.isVarDeclaration()) { Preconditions.checkState(!maybeDecl.isInitializingDeclaration()); Reference maybeInit = references.get(index); if (maybeInit.isSimpleAssignmentToName()) { return true; } } } return false;"
      },
      {
        "txt": "} Reference getInitializingReference() { if (isInitializingDeclarationAt(0)) { return references.get(0); } else if (isInitializingAssignmentAt(1)) { return references.get(1); } return null; } Reference getInitializingReferenceForConstants() {"
      },
      {
        "txt": "int size = references.size(); for (int i = 0; i < size; i++) { if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) { return references.get(i); } } return null; } boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment();"
      },
      {
        "txt": "if (ref == null) { return false; } return true; } private Reference getOneAndOnlyAssignment() { Reference assignment = null; int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i);"
      },
      {
        "txt": "if (ref.isLvalue() || ref.isInitializingDeclaration()) { if (assignment == null) { assignment = ref; } else { return null; } } } return assignment; }"
      },
      {
        "txt": "boolean isNeverAssigned() { int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { return false; } } return true; }"
      },
      {
        "txt": "boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); if (size > 0 && references.get(0).isInitializingDeclaration()) { return true; } return false; } } static final class Reference { private static final Set<Integer> DECLARATION_PARENTS ="
      },
      {
        "txt": "ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH); private final Node nameNode; private final Node parent; private final Node grandparent; private final BasicBlock basicBlock; private final Scope scope; private final String sourceName; Reference(Node nameNode, Node parent, NodeTraversal t, BasicBlock basicBlock) { this(nameNode, parent, parent.getParent(), basicBlock, t.getScope(),"
      },
      {
        "txt": "t.getSourceName()); } static Reference newBleedingFunction(NodeTraversal t, BasicBlock basicBlock, Node func) { return new Reference(func.getFirstChild(), func, func.getParent(), basicBlock, t.getScope(), t.getSourceName()); } private Reference(Node nameNode, Node parent, Node grandparent, BasicBlock basicBlock, Scope scope, String sourceName) { this.nameNode = nameNode;"
      },
      {
        "txt": "this.parent = parent; this.grandparent = grandparent; this.basicBlock = basicBlock; this.scope = scope; this.sourceName = sourceName; } boolean isDeclaration() { return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() == Token.LP && grandparent.getType() == Token.FUNCTION;"
      },
      {
        "txt": "} boolean isVarDeclaration() { return parent.getType() == Token.VAR; } boolean isHoistedFunction() { return NodeUtil.isHoistedFunctionDeclaration(parent); } boolean isInitializingDeclaration() { return isDeclaration() && (parent.getType() != Token.VAR || nameNode.getFirstChild() != null);"
      },
      {
        "txt": "} Node getAssignedValue() { return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); } BasicBlock getBasicBlock() { return basicBlock; } Node getParent() { return parent;"
      },
      {
        "txt": "} Node getNameNode() { return nameNode; } Node getGrandparent() { return grandparent; } private static boolean isLhsOfForInExpression(Node n) { Node parent = n.getParent(); if (parent.getType() == Token.VAR) {"
      },
      {
        "txt": "return isLhsOfForInExpression(parent); } return NodeUtil.isForIn(parent) && parent.getFirstChild() == n; } boolean isSimpleAssignmentToName() { return parent.getType() == Token.ASSIGN && parent.getFirstChild() == nameNode; } boolean isLvalue() { int parentType = parent.getType();"
      },
      {
        "txt": "return (parentType == Token.VAR && nameNode.getFirstChild() != null) || parentType == Token.INC || parentType == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == nameNode) || isLhsOfForInExpression(nameNode); } Scope getScope() { return scope; }"
      },
      {
        "txt": "return sourceName; } } static final class BasicBlock { private final BasicBlock parent; private final boolean isHoisted; <extra_id_0> BasicBlock(BasicBlock parent, Node root) { this.parent = parent; this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); } BasicBlock getParent() { return parent;"
      },
      {
        "txt": "BasicBlock getParent() { return parent; } boolean provablyExecutesBefore(BasicBlock thatBlock) { BasicBlock currentBlock; for (currentBlock = thatBlock; currentBlock != null && currentBlock != this; currentBlock = currentBlock.getParent()) { if (currentBlock.isHoisted) { return false;"
      },
      {
        "txt": "} } return currentBlock == this; } }"
      }
    ]
  },
  {
    "id": 420,
    "file_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
    "start-bug-line": 561,
    "end-bug-line": 561,
    "bug": "",
    "fix": "this.isFunction = root.getType() == Token.FUNCTION;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class ReferenceCollectingCallback implements ScopedCallback, CompilerPass { private final Map<Var, ReferenceCollection> referenceMap ="
      },
      {
        "txt": "Maps.newHashMap(); private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>(); private final Behavior behavior; private final AbstractCompiler compiler; private final Predicate<Var> varFilter; ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) { this(compiler, behavior, Predicates.<Var>alwaysTrue()); } ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior, Predicate<Var> varFilter) {"
      },
      {
        "txt": "this.compiler = compiler; this.behavior = behavior; this.varFilter = varFilter; } public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); } public ReferenceCollection getReferenceCollection(Var v) { return referenceMap.get(v); }"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v = t.getScope().getVar(n.getString()); if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek())); } } if (isBlockBoundary(n, parent)) { blockStack.pop();"
      },
      {
        "txt": "} } public void enterScope(NodeTraversal t) { Node n = t.getScope().getRootNode(); BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek(); blockStack.push(new BasicBlock(parent, n)); } public void exitScope(NodeTraversal t) { blockStack.pop(); behavior.afterExitScope(t, referenceMap);"
      },
      {
        "txt": "} public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (isBlockBoundary(n, parent)) { blockStack.push(new BasicBlock(blockStack.peek(), n)); } return true; } private static boolean isBlockBoundary(Node n, Node parent) { if (parent != null) {"
      },
      {
        "txt": "switch (parent.getType()) { case Token.DO: case Token.FOR: case Token.TRY: case Token.WHILE: case Token.WITH: return true; case Token.AND: case Token.HOOK: case Token.IF:"
      },
      {
        "txt": "case Token.OR: return n != parent.getFirstChild(); } } return n.getType() == Token.CASE; } private void addReference(NodeTraversal t, Var v, Reference reference) { ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null) { referenceInfo = new ReferenceCollection();"
      },
      {
        "txt": "referenceMap.put(v, referenceInfo); } referenceInfo.add(reference, t, v); } interface Behavior { void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap); } static Behavior DO_NOTHING_BEHAVIOR = new Behavior() { @Override"
      },
      {
        "txt": "public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {} }; static class ReferenceCollection { List<Reference> references = Lists.newArrayList(); void add(Reference reference, NodeTraversal t, Var v) { references.add(reference); } protected boolean isWellDefined() { int size = references.size();"
      },
      {
        "txt": "if (size == 0) { return false; } Reference init = getInitializingReference(); if (init == null) { return false; } Preconditions.checkState(references.get(0).isDeclaration()); BasicBlock initBlock = init.getBasicBlock(); for (int i = 1; i < size; i++) {"
      },
      {
        "txt": "if (!initBlock.provablyExecutesBefore( references.get(i).getBasicBlock())) { return false; } } return true; } boolean isEscaped() { Scope scope = null; for (Reference ref : references) {"
      },
      {
        "txt": "if (scope == null) { scope = ref.scope; } else if (scope != ref.scope) { return true; } } return false; } private boolean isInitializingDeclarationAt(int index) { Reference maybeInit = references.get(index);"
      },
      {
        "txt": "if (maybeInit.isInitializingDeclaration()) { return true; } return false; } private boolean isInitializingAssignmentAt(int index) { if (index < references.size() && index > 0) { Reference maybeDecl = references.get(index-1); if (maybeDecl.isVarDeclaration()) { Preconditions.checkState(!maybeDecl.isInitializingDeclaration());"
      },
      {
        "txt": "Reference maybeInit = references.get(index); if (maybeInit.isSimpleAssignmentToName()) { return true; } } } return false; } Reference getInitializingReference() { if (isInitializingDeclarationAt(0)) {"
      },
      {
        "txt": "return references.get(0); } else if (isInitializingAssignmentAt(1)) { return references.get(1); } return null; } Reference getInitializingReferenceForConstants() { int size = references.size(); for (int i = 0; i < size; i++) { if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {"
      },
      {
        "txt": "return references.get(i); } } return null; } boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; }"
      },
      {
        "txt": "return true; } private Reference getOneAndOnlyAssignment() { Reference assignment = null; int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { if (assignment == null) { assignment = ref;"
      },
      {
        "txt": "} else { return null; } } } return assignment; } boolean isNeverAssigned() { int size = references.size(); for (int i = 0; i < size; i++) {"
      },
      {
        "txt": "Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { return false; } } return true; } boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); if (size > 0 && references.get(0).isInitializingDeclaration()) {"
      },
      {
        "txt": "return true; } return false; } } static final class Reference { private static final Set<Integer> DECLARATION_PARENTS = ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH); private final Node nameNode; private final Node parent;"
      },
      {
        "txt": "private final Node grandparent; private final BasicBlock basicBlock; private final Scope scope; private final String sourceName; Reference(Node nameNode, Node parent, NodeTraversal t, BasicBlock basicBlock) { this(nameNode, parent, parent.getParent(), basicBlock, t.getScope(), t.getSourceName()); } static Reference newBleedingFunction(NodeTraversal t,"
      },
      {
        "txt": "BasicBlock basicBlock, Node func) { return new Reference(func.getFirstChild(), func, func.getParent(), basicBlock, t.getScope(), t.getSourceName()); } private Reference(Node nameNode, Node parent, Node grandparent, BasicBlock basicBlock, Scope scope, String sourceName) { this.nameNode = nameNode; this.parent = parent; this.grandparent = grandparent; this.basicBlock = basicBlock;"
      },
      {
        "txt": "this.scope = scope; this.sourceName = sourceName; } boolean isDeclaration() { return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() == Token.LP && grandparent.getType() == Token.FUNCTION; } boolean isVarDeclaration() { return parent.getType() == Token.VAR;"
      },
      {
        "txt": "} boolean isHoistedFunction() { return NodeUtil.isHoistedFunctionDeclaration(parent); } boolean isInitializingDeclaration() { return isDeclaration() && (parent.getType() != Token.VAR || nameNode.getFirstChild() != null); } Node getAssignedValue() { return (parent.getType() == Token.FUNCTION)"
      },
      {
        "txt": "? parent : NodeUtil.getAssignedValue(getNameNode()); } BasicBlock getBasicBlock() { return basicBlock; } Node getParent() { return parent; } Node getNameNode() { return nameNode;"
      },
      {
        "txt": "} Node getGrandparent() { return grandparent; } private static boolean isLhsOfForInExpression(Node n) { Node parent = n.getParent(); if (parent.getType() == Token.VAR) { return isLhsOfForInExpression(parent); } return NodeUtil.isForIn(parent) && parent.getFirstChild() == n;"
      },
      {
        "txt": "} boolean isSimpleAssignmentToName() { return parent.getType() == Token.ASSIGN && parent.getFirstChild() == nameNode; } boolean isLvalue() { int parentType = parent.getType(); return (parentType == Token.VAR && nameNode.getFirstChild() != null) || parentType == Token.INC || parentType == Token.DEC"
      },
      {
        "txt": "|| (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == nameNode) || isLhsOfForInExpression(nameNode); } Scope getScope() { return scope; } public String getSourceName() { return sourceName; }"
      },
      {
        "txt": "static final class BasicBlock { private final BasicBlock parent; private final boolean isHoisted; BasicBlock(BasicBlock parent, Node root) { this.parent = parent; this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); <extra_id_0> } BasicBlock getParent() { return parent; } boolean provablyExecutesBefore(BasicBlock thatBlock) { BasicBlock currentBlock;"
      },
      {
        "txt": "boolean provablyExecutesBefore(BasicBlock thatBlock) { BasicBlock currentBlock; for (currentBlock = thatBlock; currentBlock != null && currentBlock != this; currentBlock = currentBlock.getParent()) { if (currentBlock.isHoisted) { return false; } } return currentBlock == this;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 421,
    "file_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
    "start-bug-line": 562,
    "end-bug-line": 562,
    "bug": "",
    "fix": "if (root.getParent() != null) { int pType = root.getParent().getType(); this.isLoop = pType == Token.DO || pType == Token.WHILE || pType == Token.FOR; } else { this.isLoop = false; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayDeque; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.Set; class ReferenceCollectingCallback implements ScopedCallback, CompilerPass { private final Map<Var, ReferenceCollection> referenceMap ="
      },
      {
        "txt": "Maps.newHashMap(); private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>(); private final Behavior behavior; private final AbstractCompiler compiler; private final Predicate<Var> varFilter; ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) { this(compiler, behavior, Predicates.<Var>alwaysTrue()); } ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior, Predicate<Var> varFilter) {"
      },
      {
        "txt": "this.compiler = compiler; this.behavior = behavior; this.varFilter = varFilter; } public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); } public ReferenceCollection getReferenceCollection(Var v) { return referenceMap.get(v); }"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v = t.getScope().getVar(n.getString()); if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek())); } } if (isBlockBoundary(n, parent)) { blockStack.pop();"
      },
      {
        "txt": "} } public void enterScope(NodeTraversal t) { Node n = t.getScope().getRootNode(); BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek(); blockStack.push(new BasicBlock(parent, n)); } public void exitScope(NodeTraversal t) { blockStack.pop(); behavior.afterExitScope(t, referenceMap);"
      },
      {
        "txt": "} public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { if (isBlockBoundary(n, parent)) { blockStack.push(new BasicBlock(blockStack.peek(), n)); } return true; } private static boolean isBlockBoundary(Node n, Node parent) { if (parent != null) {"
      },
      {
        "txt": "switch (parent.getType()) { case Token.DO: case Token.FOR: case Token.TRY: case Token.WHILE: case Token.WITH: return true; case Token.AND: case Token.HOOK: case Token.IF:"
      },
      {
        "txt": "case Token.OR: return n != parent.getFirstChild(); } } return n.getType() == Token.CASE; } private void addReference(NodeTraversal t, Var v, Reference reference) { ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo == null) { referenceInfo = new ReferenceCollection();"
      },
      {
        "txt": "referenceMap.put(v, referenceInfo); } referenceInfo.add(reference, t, v); } interface Behavior { void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap); } static Behavior DO_NOTHING_BEHAVIOR = new Behavior() { @Override"
      },
      {
        "txt": "public void afterExitScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {} }; static class ReferenceCollection { List<Reference> references = Lists.newArrayList(); void add(Reference reference, NodeTraversal t, Var v) { references.add(reference); } protected boolean isWellDefined() { int size = references.size();"
      },
      {
        "txt": "if (size == 0) { return false; } Reference init = getInitializingReference(); if (init == null) { return false; } Preconditions.checkState(references.get(0).isDeclaration()); BasicBlock initBlock = init.getBasicBlock(); for (int i = 1; i < size; i++) {"
      },
      {
        "txt": "if (!initBlock.provablyExecutesBefore( references.get(i).getBasicBlock())) { return false; } } return true; } boolean isEscaped() { Scope scope = null; for (Reference ref : references) {"
      },
      {
        "txt": "if (scope == null) { scope = ref.scope; } else if (scope != ref.scope) { return true; } } return false; } private boolean isInitializingDeclarationAt(int index) { Reference maybeInit = references.get(index);"
      },
      {
        "txt": "if (maybeInit.isInitializingDeclaration()) { return true; } return false; } private boolean isInitializingAssignmentAt(int index) { if (index < references.size() && index > 0) { Reference maybeDecl = references.get(index-1); if (maybeDecl.isVarDeclaration()) { Preconditions.checkState(!maybeDecl.isInitializingDeclaration());"
      },
      {
        "txt": "Reference maybeInit = references.get(index); if (maybeInit.isSimpleAssignmentToName()) { return true; } } } return false; } Reference getInitializingReference() { if (isInitializingDeclarationAt(0)) {"
      },
      {
        "txt": "return references.get(0); } else if (isInitializingAssignmentAt(1)) { return references.get(1); } return null; } Reference getInitializingReferenceForConstants() { int size = references.size(); for (int i = 0; i < size; i++) { if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {"
      },
      {
        "txt": "return references.get(i); } } return null; } boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; }"
      },
      {
        "txt": "return true; } private Reference getOneAndOnlyAssignment() { Reference assignment = null; int size = references.size(); for (int i = 0; i < size; i++) { Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { if (assignment == null) { assignment = ref;"
      },
      {
        "txt": "} else { return null; } } } return assignment; } boolean isNeverAssigned() { int size = references.size(); for (int i = 0; i < size; i++) {"
      },
      {
        "txt": "Reference ref = references.get(i); if (ref.isLvalue() || ref.isInitializingDeclaration()) { return false; } } return true; } boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); if (size > 0 && references.get(0).isInitializingDeclaration()) {"
      },
      {
        "txt": "return true; } return false; } } static final class Reference { private static final Set<Integer> DECLARATION_PARENTS = ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH); private final Node nameNode; private final Node parent;"
      },
      {
        "txt": "private final Node grandparent; private final BasicBlock basicBlock; private final Scope scope; private final String sourceName; Reference(Node nameNode, Node parent, NodeTraversal t, BasicBlock basicBlock) { this(nameNode, parent, parent.getParent(), basicBlock, t.getScope(), t.getSourceName()); } static Reference newBleedingFunction(NodeTraversal t,"
      },
      {
        "txt": "BasicBlock basicBlock, Node func) { return new Reference(func.getFirstChild(), func, func.getParent(), basicBlock, t.getScope(), t.getSourceName()); } private Reference(Node nameNode, Node parent, Node grandparent, BasicBlock basicBlock, Scope scope, String sourceName) { this.nameNode = nameNode; this.parent = parent; this.grandparent = grandparent; this.basicBlock = basicBlock;"
      },
      {
        "txt": "this.scope = scope; this.sourceName = sourceName; } boolean isDeclaration() { return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() == Token.LP && grandparent.getType() == Token.FUNCTION; } boolean isVarDeclaration() { return parent.getType() == Token.VAR;"
      },
      {
        "txt": "} boolean isHoistedFunction() { return NodeUtil.isHoistedFunctionDeclaration(parent); } boolean isInitializingDeclaration() { return isDeclaration() && (parent.getType() != Token.VAR || nameNode.getFirstChild() != null); } Node getAssignedValue() { return (parent.getType() == Token.FUNCTION)"
      },
      {
        "txt": "? parent : NodeUtil.getAssignedValue(getNameNode()); } BasicBlock getBasicBlock() { return basicBlock; } Node getParent() { return parent; } Node getNameNode() { return nameNode;"
      },
      {
        "txt": "} Node getGrandparent() { return grandparent; } private static boolean isLhsOfForInExpression(Node n) { Node parent = n.getParent(); if (parent.getType() == Token.VAR) { return isLhsOfForInExpression(parent); } return NodeUtil.isForIn(parent) && parent.getFirstChild() == n;"
      },
      {
        "txt": "} boolean isSimpleAssignmentToName() { return parent.getType() == Token.ASSIGN && parent.getFirstChild() == nameNode; } boolean isLvalue() { int parentType = parent.getType(); return (parentType == Token.VAR && nameNode.getFirstChild() != null) || parentType == Token.INC || parentType == Token.DEC"
      },
      {
        "txt": "|| (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == nameNode) || isLhsOfForInExpression(nameNode); } Scope getScope() { return scope; } public String getSourceName() { return sourceName; }"
      },
      {
        "txt": "static final class BasicBlock { private final BasicBlock parent; private final boolean isHoisted; BasicBlock(BasicBlock parent, Node root) { this.parent = parent; this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); <extra_id_0> BasicBlock getParent() { return parent; } boolean provablyExecutesBefore(BasicBlock thatBlock) { BasicBlock currentBlock; for (currentBlock = thatBlock;"
      },
      {
        "txt": "BasicBlock currentBlock; for (currentBlock = thatBlock; currentBlock != null && currentBlock != this; currentBlock = currentBlock.getParent()) { if (currentBlock.isHoisted) { return false; } } return currentBlock == this; }"
      }
    ]
  }
]