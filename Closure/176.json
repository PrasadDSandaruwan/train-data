[
  {
    "id": 915,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 530,
    "end-bug-line": 530,
    "bug": "boolean isVarDeclaration = left.hasChildren();",
    "fix": "JSType varType = var == null ? null : var.getType(); boolean isVarDeclaration = left.hasChildren() && varType != null && !var.isTypeInferred();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;"
      },
      {
        "txt": "import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ModificationVisitor; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnionType;"
      },
      {
        "txt": "import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\","
      },
      {
        "txt": "\"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler; private final JSTypeRegistry registry; private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; private final ObjectType unknownType; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,"
      },
      {
        "txt": "ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE); this.syntacticScope = functionScope; inferArguments(functionScope);"
      },
      {
        "txt": "this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); this.assertionFunctionsMap = assertionFunctionsMap; Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType("
      },
      {
        "txt": "var.getName(), getNativeType(VOID_TYPE)); } this.bottomScope = LinkedFlowScope.createEntryLattice( Scope.createLatticeBottom(functionScope.getRootNode())); } private void inferArguments(Scope functionScope) { Node functionNode = functionScope.getRootNode(); Node astParameters = functionNode.getFirstChild().getNext(); Node iifeArgumentNode = null; if (NodeUtil.isCallOrNewTarget(functionNode)) {"
      },
      {
        "txt": "iifeArgumentNode = functionNode.getNext(); } FunctionType functionType = JSType.toMaybeFunctionType(functionNode.getJSType()); if (functionType != null) { Node parameterTypes = functionType.getParametersNode(); if (parameterTypes != null) { Node parameterTypeNode = parameterTypes.getFirstChild(); for (Node astParameter : astParameters.children()) { Var var = functionScope.getVar(astParameter.getString());"
      },
      {
        "txt": "Preconditions.checkNotNull(var); if (var.isTypeInferred() && var.getType() == unknownType) { JSType newType = null; if (iifeArgumentNode != null) { newType = iifeArgumentNode.getJSType(); } else if (parameterTypeNode != null) { newType = parameterTypeNode.getJSType(); } if (newType != null) {"
      },
      {
        "txt": "var.setType(newType); astParameter.setJSType(newType); } } if (parameterTypeNode != null) { parameterTypeNode = parameterTypeNode.getNext(); } if (iifeArgumentNode != null) { iifeArgumentNode = iifeArgumentNode.getNext(); }"
      },
      {
        "txt": "} } } } @Override FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() {"
      },
      {
        "txt": "return functionScope; } @Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) { return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output;"
      },
      {
        "txt": "} @Override @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"}) List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());"
      },
      {
        "txt": "for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch (branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) {"
      },
      {
        "txt": "item = item.getFirstChild(); } if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType( registry.getObjectIndexKey()); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType ="
      },
      {
        "txt": "iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; }"
      },
      {
        "txt": "case ON_FALSE: if (condition == null) { condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } }"
      },
      {
        "txt": "} if (condition != null) { if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope ="
      },
      {
        "txt": "reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); }"
      },
      {
        "txt": "newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break; } result.add(newScope.optimize()); } return result;"
      },
      {
        "txt": "} private FlowScope traverse(Node n, FlowScope scope) { switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP:"
      },
      {
        "txt": "scope = traverseGetProp(n, scope); break; case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break;"
      },
      {
        "txt": "case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW:"
      },
      {
        "txt": "scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE));"
      },
      {
        "txt": "break; case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH:"
      },
      {
        "txt": "case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB:"
      },
      {
        "txt": "case Token.DIV: case Token.MOD: case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT:"
      },
      {
        "txt": "scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild()));"
      },
      {
        "txt": "break; case Token.TYPEOF: scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE:"
      },
      {
        "txt": "case Token.NOT: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break;"
      },
      {
        "txt": "case Token.GETELEM: scope = traverseGetElem(n, scope); break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH:"
      },
      {
        "txt": "scope = traverse(n.getFirstChild(), scope); break; case Token.RETURN: scope = traverseReturn(n, scope); break; case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH:"
      },
      {
        "txt": "scope = traverseCatch(n, scope); break; case Token.CAST: scope = traverseChildren(n, scope); JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { n.setJSType(info.getType().evaluate(syntacticScope, registry)); } break; }"
      },
      {
        "txt": "return scope; } private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) { JSType type = functionScope.getRootNode().getJSType(); if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) {"
      },
      {
        "txt": "inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType()); } } } return scope; } private FlowScope traverseCatch(Node catchNode, FlowScope scope) { Node name = catchNode.getFirstChild(); JSType type;"
      },
      {
        "txt": "JSDocInfo info = name.getJSDocInfo(); if (info != null && info.hasType()) { type = info.getType().evaluate(syntacticScope, registry); } else { type = getNativeType(JSTypeNative.UNKNOWN_TYPE); } redeclareSimpleVar(scope, name, type); name.setJSType(type); return scope; }"
      },
      {
        "txt": "private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = n.getLastChild(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; }"
      },
      {
        "txt": "FlowScope scope, Node left, JSType leftType, JSType resultType) { Preconditions.checkNotNull(resultType); switch (left.getType()) { case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); <extra_id_0> boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred(); if (isVarTypeBetter) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null);"
      },
      {
        "txt": "left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName();"
      },
      {
        "txt": "if (qualifiedName != null) { scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } }"
      },
      {
        "txt": "private void ensurePropertyDefined(Node getprop, JSType rightType) { String propName = getprop.getLastChild().getString(); Node obj = getprop.getFirstChild(); JSType nodeType = getJSType(obj); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); boolean propCreationInConstructor = obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor(); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType);"
      },
      {
        "txt": "} else { if (nodeType.isStruct() && !objectType.hasProperty(propName)) { boolean staticPropCreation = false; Node maybeAssignStm = getprop.getParent().getParent(); if (syntacticScope.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) { String propCreationFilename = maybeAssignStm.getSourceFileName(); Node ctor = objectType.getOwnerFunction().getSource(); if (ctor != null && ctor.getSourceFileName().equals(propCreationFilename)) {"
      },
      {
        "txt": "staticPropCreation = true; } } if (!propCreationInConstructor && !staticPropCreation) { return; // Early return to avoid creating the property below. } } if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; }"
      },
      {
        "txt": "if (!objectType.isPropertyTypeDeclared(propName)) { if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty(propName, rightType, getprop); } else { objectType.defineInferredProperty(propName, rightType, getprop); } } else if (propCreationInConstructor) { objectType.defineInferredProperty(propName, rightType, getprop); } else {"
      },
      {
        "txt": "registry.registerPropertyOnType(propName, objectType); } } } } private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType);"
      },
      {
        "txt": "} } private boolean ensurePropertyDeclaredHelper( Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") ||"
      },
      {
        "txt": "(!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { return objectType.defineDeclaredProperty( propName, var.getType(), getprop); } } } return false; }"
      },
      {
        "txt": "private FlowScope traverseName(Node n, FlowScope scope) { String varName = n.getString(); Node value = n.getFirstChild(); JSType type = n.getJSType(); if (value != null) { scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else {"
      },
      {
        "txt": "StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = false; if (isInferred && syntacticScope.isLocal()) { Var maybeOuterVar = syntacticScope.getParent().getVar(varName); if (var == maybeOuterVar && !maybeOuterVar.isMarkedAssignedExactlyOnce()) {"
      },
      {
        "txt": "nonLocalInferredSlot = true; } } if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = unknownType; } } }"
      },
      {
        "txt": "} n.setJSType(type); return scope; } private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE)); return scope; } private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {"
      },
      {
        "txt": "JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT) || objectType.isEnumType()) { return scope;"
      },
      {
        "txt": "} String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType);"
      },
      {
        "txt": "if (valueType == null) { valueType = unknownType; } objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ?"
      },
      {
        "txt": "valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType); } } else { n.setJSType(unknownType); } }"
      },
      {
        "txt": "return scope; } private FlowScope traverseAdd(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = left.getNext(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = unknownType; if (leftType != null && rightType != null) {"
      },
      {
        "txt": "boolean leftIsUnknown = leftType.isUnknownType(); boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) { type = unknownType; } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = unknownType; } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) {"
      },
      {
        "txt": "type = getNativeType(NUMBER_TYPE); } else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); } } n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope;"
      },
      {
        "txt": "} private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); } private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope);"
      },
      {
        "txt": "FlowScope trueScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, true); FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType();"
      },
      {
        "txt": "if (trueType != null && falseType != null) { n.setJSType(trueType.getLeastSupertype(falseType)); } else { n.setJSType(null); } return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild();"
      },
      {
        "txt": "JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType(); n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.isEquivalentTo( getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } scope = tightenTypesAfterAssertions(scope, n);"
      },
      {
        "txt": "return scope; } private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope;"
      },
      {
        "txt": "} Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) { return scope; } JSType assertedType = assertionFunctionSpec.getAssertedType( callNode, registry); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) {"
      },
      {
        "txt": "scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); } else { JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(assertedType); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } }"
      },
      {
        "txt": "callNode.setJSType(narrowed); return scope; } private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; } scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot("
      },
      {
        "txt": "node, node.getQualifiedName(), getJSType(node), narrowed); } else { redeclareSimpleVar(scope, node, narrowed); } return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { boolean updatedFnType = inferTemplatedTypesForCall(n, fnType); if (updatedFnType) { fnType = n.getFirstChild().getJSType().toMaybeFunctionType();"
      },
      {
        "txt": "} updateTypeOfParameters(n, fnType); updateBind(n); } private void updateBind(Node n) { CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; }"
      },
      {
        "txt": "FunctionType callTargetFn = getJSType(bind.target) .restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return; } n.setJSType( callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) {"
      },
      {
        "txt": "int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) { return; } JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);"
      },
      {
        "txt": "JSType restrictedParameter = iParameterType .restrictByNotNullOrUndefined() .toMaybeFunctionType(); if (restrictedParameter != null) { if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) { iArgument.setJSType(restrictedParameter); } }"
      },
      {
        "txt": "i++; } } private Map<TemplateType, JSType> inferTemplateTypesFromParameters( FunctionType fnType, Node call) { if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) { return Collections.emptyMap(); } Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap(); Set<JSType> seenTypes = Sets.newIdentityHashSet();"
      },
      {
        "txt": "Node callTarget = call.getFirstChild(); if (NodeUtil.isGet(callTarget)) { Node obj = callTarget.getFirstChild(); maybeResolveTemplatedType( fnType.getTypeOfThis(), getJSType(obj), resolvedTypes, seenTypes); } if (call.hasMoreThanOneChild()) {"
      },
      {
        "txt": "maybeResolveTemplateTypeFromNodes( fnType.getParameters(), call.getChildAtIndex(1).siblings(), resolvedTypes, seenTypes); } return resolvedTypes; } private void maybeResolveTemplatedType( JSType paramType,"
      },
      {
        "txt": "JSType argType, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { if (paramType.isTemplateType()) { resolvedTemplateType( resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) { UnionType unionType = paramType.toMaybeUnionType(); for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes, seenTypes); }"
      },
      {
        "txt": "} else if (paramType.isFunctionType()) { FunctionType paramFunctionType = paramType.toMaybeFunctionType(); FunctionType argFunctionType = argType .restrictByNotNullOrUndefined() .collapseUnion() .toMaybeFunctionType(); if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { maybeResolveTemplatedType( paramFunctionType.getTypeOfThis(), argFunctionType.getTypeOfThis(), resolvedTypes, seenTypes);"
      },
      {
        "txt": "maybeResolveTemplatedType( paramFunctionType.getReturnType(), argFunctionType.getReturnType(), resolvedTypes, seenTypes); maybeResolveTemplateTypeFromNodes( paramFunctionType.getParameters(), argFunctionType.getParameters(), resolvedTypes, seenTypes); } } else if (paramType.isRecordType() && !paramType.isNominalType()) { if(!seenTypes.contains(paramType)) { seenTypes.add(paramType);"
      },
      {
        "txt": "ObjectType paramRecordType = paramType.toObjectType(); ObjectType argObjectType = argType.restrictByNotNullOrUndefined() .toObjectType(); if (argObjectType != null && !argObjectType.isUnknownType() && !argObjectType.isEmptyType()) { Set<String> names = paramRecordType.getPropertyNames(); for (String name : names) { if (paramRecordType.hasOwnProperty(name) && argObjectType.hasProperty(name)) {"
      },
      {
        "txt": "maybeResolveTemplatedType( paramRecordType.getPropertyType(name), argObjectType.getPropertyType(name), resolvedTypes, seenTypes); } } } seenTypes.remove(paramType); }"
      },
      {
        "txt": "} else if (paramType.isTemplatizedType()) { ObjectType referencedParamType = paramType .toMaybeTemplatizedType() .getReferencedType(); JSType argObjectType = argType .restrictByNotNullOrUndefined() .collapseUnion(); if (argObjectType.isSubtype(referencedParamType)) { TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();"
      },
      {
        "txt": "for (TemplateType key : paramTypeMap.getTemplateKeys()) { maybeResolveTemplatedType( paramTypeMap.getTemplateType(key), argTypeMap.getTemplateType(key), resolvedTypes, seenTypes); } } } } private void maybeResolveTemplateTypeFromNodes("
      },
      {
        "txt": "Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { maybeResolveTemplateTypeFromNodes( declParams.iterator(), callParams.iterator(), resolvedTypes, seenTypes); } private void maybeResolveTemplateTypeFromNodes( Iterator<Node> declParams, Iterator<Node> callParams, Map<TemplateType, JSType> resolvedTypes,"
      },
      {
        "txt": "Set<JSType> seenTypes) { while (declParams.hasNext() && callParams.hasNext()) { Node declParam = declParams.next(); maybeResolveTemplatedType( getJSType(declParam), getJSType(callParams.next()), resolvedTypes, seenTypes); if (declParam.isVarArgs()) { while (callParams.hasNext()) { maybeResolveTemplatedType("
      },
      {
        "txt": "getJSType(declParam), getJSType(callParams.next()), resolvedTypes, seenTypes); } } } } private static void resolvedTemplateType( Map<TemplateType, JSType> map, TemplateType template, JSType resolved) { JSType previous = map.get(template);"
      },
      {
        "txt": "if (!resolved.isUnknownType()) { if (previous == null) { map.put(template, resolved); } else { JSType join = previous.getLeastSupertype(resolved); map.put(template, join); } } } private static class TemplateTypeReplacer extends ModificationVisitor {"
      },
      {
        "txt": "private final Map<TemplateType, JSType> replacements; private final JSTypeRegistry registry; boolean madeChanges = false; TemplateTypeReplacer( JSTypeRegistry registry, Map<TemplateType, JSType> replacements) { super(registry, true); this.registry = registry; this.replacements = replacements; } @Override"
      },
      {
        "txt": "public JSType caseTemplateType(TemplateType type) { madeChanges = true; JSType replacement = replacements.get(type); return replacement != null ? replacement : registry.getNativeType(UNKNOWN_TYPE); } } private boolean inferTemplatedTypesForCall( Node n, FunctionType fnType) { final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()"
      },
      {
        "txt": ".getTemplateKeys(); if (keys.isEmpty()) { return false; } Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key);"
      },
      {
        "txt": "}} ); TemplateTypeReplacer replacer = new TemplateTypeReplacer( registry, inferred); Node callTarget = n.getFirstChild(); FunctionType replacementFnType = fnType.visit(replacer) .toMaybeFunctionType(); Preconditions.checkNotNull(replacementFnType); callTarget.setJSType(replacementFnType); n.setJSType(replacementFnType.getReturnType());"
      },
      {
        "txt": "return replacer.madeChanges; } private FlowScope traverseNew(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node constructor = n.getFirstChild(); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) {"
      },
      {
        "txt": "type = unknownType; } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { backwardsInferenceFromCallSite(n, ct); ObjectType instanceType = ct.getInstanceType(); Map<TemplateType, JSType> inferredTypes ="
      },
      {
        "txt": "inferTemplateTypesFromParameters(ct, n); if (inferredTypes.isEmpty()) { type = instanceType; } else { type = registry.createTemplatizedType(instanceType, inferredTypes); } } } } n.setJSType(type);"
      },
      {
        "txt": "return scope; } private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope;"
      },
      {
        "txt": "} private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope); JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined(); TemplateTypeMap typeMap = type.getTemplateTypeMap(); if (typeMap.hasTemplateType(registry.getObjectElementKey())) { n.setJSType(typeMap.getTemplateType(registry.getObjectElementKey())); } return dereferencePointer(n.getFirstChild(), scope); }"
      },
      {
        "txt": "private FlowScope traverseGetProp(Node n, FlowScope scope) { Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType( getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private static void inferPropertyTypesToMatchConstraint("
      },
      {
        "txt": "JSType type, JSType constraint) { if (type == null || constraint == null) { return; } type.matchConstraint(constraint); } private FlowScope dereferencePointer(Node n, FlowScope scope) { if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (type != narrowed) { scope = narrowScope(scope, n, narrowed); } } return scope; } private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { JSType propertyType = null; boolean isLocallyInferred = false;"
      },
      {
        "txt": "String qualifiedName = n.getQualifiedName(); StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) { JSType varType = var.getType(); if (varType != null) { boolean isDeclared = !var.isTypeInferred(); isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName)); if (isDeclared || isLocallyInferred) { propertyType = varType; }"
      },
      {
        "txt": "} } if (propertyType == null && objType != null) { JSType foundType = objType.findPropertyType(propName); if (foundType != null) { propertyType = foundType; } } if (propertyType != null && objType != null) { JSType restrictedObjType = objType.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (!restrictedObjType.getTemplateTypeMap().isEmpty() && propertyType.hasAnyTemplateTypes()) { TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap(); TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); propertyType = propertyType.visit(replacer); } } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) {"
      },
      {
        "txt": "ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); if (regType != null) { propertyType = regType.getConstructor(); } } if (propertyType == null) { return unknownType; } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else {"
      },
      {
        "txt": "return propertyType; } } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); } private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild();"
      },
      {
        "txt": "BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp("
      },
      {
        "txt": "right, rightScope.createChildFlowScope()); JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition); if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals;"
      },
      {
        "txt": "} else { type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY && getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE));"
      },
      {
        "txt": "} } } else { type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type);"
      },
      {
        "txt": "return literals; } private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { switch (n.getType()) { case Token.AND: return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default:"
      },
      {
        "txt": "scope = traverse(n, scope); return newBooleanOutcomePair(n.getJSType(), scope); } } BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) { return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition),"
      },
      {
        "txt": "left.getJoinedFlowScope(), right.getJoinedFlowScope()); } static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); } private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope;"
      },
      {
        "txt": "final FlowScope rightScope; FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes; this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; }"
      },
      {
        "txt": "FlowScope getJoinedFlowScope() { if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope); } } return joinedScope; }"
      },
      {
        "txt": "FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope; } else { return getJoinedFlowScope(); } } } private BooleanOutcomePair newBooleanOutcomePair("
      },
      {
        "txt": "JSType jsType, FlowScope flowScope) { if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(), registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); }"
      },
      {
        "txt": "private void redeclareSimpleVar( FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE); } if (isUnflowable(syntacticScope.getVar(varName))) { return; }"
      },
      {
        "txt": "scope.inferSlotType(varName, varType); } private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return unknownType;"
      },
      {
        "txt": "} else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 916,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 548,
    "end-bug-line": 548,
    "bug": "boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();",
    "fix": "boolean isVarTypeBetter = isVarDeclaration &&",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.ControlFlowGraph.Branch;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ModificationVisitor; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnionType; import java.util.Collections;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\");"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final JSTypeRegistry registry; private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; private final ObjectType unknownType; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter,"
      },
      {
        "txt": "Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE); this.syntacticScope = functionScope; inferArguments(functionScope); this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);"
      },
      {
        "txt": "this.assertionFunctionsMap = assertionFunctionsMap; Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType( var.getName(), getNativeType(VOID_TYPE));"
      },
      {
        "txt": "} this.bottomScope = LinkedFlowScope.createEntryLattice( Scope.createLatticeBottom(functionScope.getRootNode())); } private void inferArguments(Scope functionScope) { Node functionNode = functionScope.getRootNode(); Node astParameters = functionNode.getFirstChild().getNext(); Node iifeArgumentNode = null; if (NodeUtil.isCallOrNewTarget(functionNode)) { iifeArgumentNode = functionNode.getNext();"
      },
      {
        "txt": "} FunctionType functionType = JSType.toMaybeFunctionType(functionNode.getJSType()); if (functionType != null) { Node parameterTypes = functionType.getParametersNode(); if (parameterTypes != null) { Node parameterTypeNode = parameterTypes.getFirstChild(); for (Node astParameter : astParameters.children()) { Var var = functionScope.getVar(astParameter.getString()); Preconditions.checkNotNull(var);"
      },
      {
        "txt": "if (var.isTypeInferred() && var.getType() == unknownType) { JSType newType = null; if (iifeArgumentNode != null) { newType = iifeArgumentNode.getJSType(); } else if (parameterTypeNode != null) { newType = parameterTypeNode.getJSType(); } if (newType != null) { var.setType(newType);"
      },
      {
        "txt": "astParameter.setJSType(newType); } } if (parameterTypeNode != null) { parameterTypeNode = parameterTypeNode.getNext(); } if (iifeArgumentNode != null) { iifeArgumentNode = iifeArgumentNode.getNext(); } }"
      },
      {
        "txt": "} } } @Override FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() { return functionScope;"
      },
      {
        "txt": "} @Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) { return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output; }"
      },
      {
        "txt": "@Override @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"}) List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {"
      },
      {
        "txt": "Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch (branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) { item = item.getFirstChild();"
      },
      {
        "txt": "} if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType( registry.getObjectIndexKey()); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);"
      },
      {
        "txt": "if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; } case ON_FALSE:"
      },
      {
        "txt": "if (condition == null) { condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } } }"
      },
      {
        "txt": "if (condition != null) { if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "condition, conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope ="
      },
      {
        "txt": "reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break; } result.add(newScope.optimize()); } return result; }"
      },
      {
        "txt": "private FlowScope traverse(Node n, FlowScope scope) { switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope);"
      },
      {
        "txt": "break; case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK:"
      },
      {
        "txt": "scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope);"
      },
      {
        "txt": "break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE)); break;"
      },
      {
        "txt": "case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH:"
      },
      {
        "txt": "case Token.ASSIGN_URSH: case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV:"
      },
      {
        "txt": "case Token.MOD: case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope);"
      },
      {
        "txt": "n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break;"
      },
      {
        "txt": "case Token.TYPEOF: scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT:"
      },
      {
        "txt": "case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM:"
      },
      {
        "txt": "scope = traverseGetElem(n, scope); break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope);"
      },
      {
        "txt": "break; case Token.RETURN: scope = traverseReturn(n, scope); break; case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope);"
      },
      {
        "txt": "break; case Token.CAST: scope = traverseChildren(n, scope); JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { n.setJSType(info.getType().evaluate(syntacticScope, registry)); } break; } return scope;"
      },
      {
        "txt": "} private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) { JSType type = functionScope.getRootNode().getJSType(); if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint("
      },
      {
        "txt": "retValue.getJSType(), fnType.getReturnType()); } } } return scope; } private FlowScope traverseCatch(Node catchNode, FlowScope scope) { Node name = catchNode.getFirstChild(); JSType type; JSDocInfo info = name.getJSDocInfo();"
      },
      {
        "txt": "if (info != null && info.hasType()) { type = info.getType().evaluate(syntacticScope, registry); } else { type = getNativeType(JSTypeNative.UNKNOWN_TYPE); } redeclareSimpleVar(scope, name, type); name.setJSType(type); return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node left = n.getFirstChild(); Node right = n.getLastChild(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; } private void updateScopeForTypeChange("
      },
      {
        "txt": "Preconditions.checkNotNull(resultType); switch (left.getType()) { case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); <extra_id_0> if (isVarTypeBetter) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) {"
      },
      {
        "txt": "resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) {"
      },
      {
        "txt": "scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) {"
      },
      {
        "txt": "String propName = getprop.getLastChild().getString(); Node obj = getprop.getFirstChild(); JSType nodeType = getJSType(obj); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); boolean propCreationInConstructor = obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor(); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType); } else {"
      },
      {
        "txt": "if (nodeType.isStruct() && !objectType.hasProperty(propName)) { boolean staticPropCreation = false; Node maybeAssignStm = getprop.getParent().getParent(); if (syntacticScope.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) { String propCreationFilename = maybeAssignStm.getSourceFileName(); Node ctor = objectType.getOwnerFunction().getSource(); if (ctor != null && ctor.getSourceFileName().equals(propCreationFilename)) { staticPropCreation = true;"
      },
      {
        "txt": "} } if (!propCreationInConstructor && !staticPropCreation) { return; // Early return to avoid creating the property below. } } if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; } if (!objectType.isPropertyTypeDeclared(propName)) {"
      },
      {
        "txt": "if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty(propName, rightType, getprop); } else { objectType.defineInferredProperty(propName, rightType, getprop); } } else if (propCreationInConstructor) { objectType.defineInferredProperty(propName, rightType, getprop); } else { registry.registerPropertyOnType(propName, objectType);"
      },
      {
        "txt": "} } } } private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType); }"
      },
      {
        "txt": "} private boolean ensurePropertyDeclaredHelper( Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) &&"
      },
      {
        "txt": "(!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { return objectType.defineDeclaredProperty( propName, var.getType(), getprop); } } } return false; } private FlowScope traverseName(Node n, FlowScope scope) {"
      },
      {
        "txt": "String varName = n.getString(); Node value = n.getFirstChild(); JSType type = n.getJSType(); if (value != null) { scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName);"
      },
      {
        "txt": "if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = false; if (isInferred && syntacticScope.isLocal()) { Var maybeOuterVar = syntacticScope.getParent().getVar(varName); if (var == maybeOuterVar && !maybeOuterVar.isMarkedAssignedExactlyOnce()) { nonLocalInferredSlot = true;"
      },
      {
        "txt": "} } if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = unknownType; } } } }"
      },
      {
        "txt": "n.setJSType(type); return scope; } private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE)); return scope; } private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType();"
      },
      {
        "txt": "Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT) || objectType.isEnumType()) { return scope; }"
      },
      {
        "txt": "String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) {"
      },
      {
        "txt": "valueType = unknownType; } objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));"
      },
      {
        "txt": "} scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType); } } else { n.setJSType(unknownType); } } return scope;"
      },
      {
        "txt": "} private FlowScope traverseAdd(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = left.getNext(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = unknownType; if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType();"
      },
      {
        "txt": "boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) { type = unknownType; } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = unknownType; } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE);"
      },
      {
        "txt": "} else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); } } n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope; }"
      },
      {
        "txt": "private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); } private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter."
      },
      {
        "txt": "getPreciserScopeKnowingConditionOutcome( condition, scope, true); FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) {"
      },
      {
        "txt": "n.setJSType(trueType.getLeastSupertype(falseType)); } else { n.setJSType(null); } return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType(); n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.isEquivalentTo( getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } scope = tightenTypesAfterAssertions(scope, n); return scope;"
      },
      {
        "txt": "} private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; }"
      },
      {
        "txt": "Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) { return scope; } JSType assertedType = assertionFunctionSpec.getAssertedType( callNode, registry); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); } else { JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(assertedType); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } } callNode.setJSType(narrowed);"
      },
      {
        "txt": "return scope; } private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; } scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed);"
      },
      {
        "txt": "} else { redeclareSimpleVar(scope, node, narrowed); } return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { boolean updatedFnType = inferTemplatedTypesForCall(n, fnType); if (updatedFnType) { fnType = n.getFirstChild().getJSType().toMaybeFunctionType(); }"
      },
      {
        "txt": "updateTypeOfParameters(n, fnType); updateBind(n); } private void updateBind(Node n) { CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; } FunctionType callTargetFn = getJSType(bind.target)"
      },
      {
        "txt": ".restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return; } n.setJSType( callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) { int i = 0;"
      },
      {
        "txt": "int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) { return; } JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); JSType restrictedParameter = iParameterType"
      },
      {
        "txt": ".restrictByNotNullOrUndefined() .toMaybeFunctionType(); if (restrictedParameter != null) { if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) { iArgument.setJSType(restrictedParameter); } } i++;"
      },
      {
        "txt": "} } private Map<TemplateType, JSType> inferTemplateTypesFromParameters( FunctionType fnType, Node call) { if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) { return Collections.emptyMap(); } Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap(); Set<JSType> seenTypes = Sets.newIdentityHashSet(); Node callTarget = call.getFirstChild();"
      },
      {
        "txt": "if (NodeUtil.isGet(callTarget)) { Node obj = callTarget.getFirstChild(); maybeResolveTemplatedType( fnType.getTypeOfThis(), getJSType(obj), resolvedTypes, seenTypes); } if (call.hasMoreThanOneChild()) { maybeResolveTemplateTypeFromNodes("
      },
      {
        "txt": "fnType.getParameters(), call.getChildAtIndex(1).siblings(), resolvedTypes, seenTypes); } return resolvedTypes; } private void maybeResolveTemplatedType( JSType paramType, JSType argType,"
      },
      {
        "txt": "Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { if (paramType.isTemplateType()) { resolvedTemplateType( resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) { UnionType unionType = paramType.toMaybeUnionType(); for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes, seenTypes); } } else if (paramType.isFunctionType()) {"
      },
      {
        "txt": "FunctionType paramFunctionType = paramType.toMaybeFunctionType(); FunctionType argFunctionType = argType .restrictByNotNullOrUndefined() .collapseUnion() .toMaybeFunctionType(); if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { maybeResolveTemplatedType( paramFunctionType.getTypeOfThis(), argFunctionType.getTypeOfThis(), resolvedTypes, seenTypes); maybeResolveTemplatedType("
      },
      {
        "txt": "paramFunctionType.getReturnType(), argFunctionType.getReturnType(), resolvedTypes, seenTypes); maybeResolveTemplateTypeFromNodes( paramFunctionType.getParameters(), argFunctionType.getParameters(), resolvedTypes, seenTypes); } } else if (paramType.isRecordType() && !paramType.isNominalType()) { if(!seenTypes.contains(paramType)) { seenTypes.add(paramType); ObjectType paramRecordType = paramType.toObjectType();"
      },
      {
        "txt": "ObjectType argObjectType = argType.restrictByNotNullOrUndefined() .toObjectType(); if (argObjectType != null && !argObjectType.isUnknownType() && !argObjectType.isEmptyType()) { Set<String> names = paramRecordType.getPropertyNames(); for (String name : names) { if (paramRecordType.hasOwnProperty(name) && argObjectType.hasProperty(name)) { maybeResolveTemplatedType("
      },
      {
        "txt": "paramRecordType.getPropertyType(name), argObjectType.getPropertyType(name), resolvedTypes, seenTypes); } } } seenTypes.remove(paramType); } } else if (paramType.isTemplatizedType()) {"
      },
      {
        "txt": "ObjectType referencedParamType = paramType .toMaybeTemplatizedType() .getReferencedType(); JSType argObjectType = argType .restrictByNotNullOrUndefined() .collapseUnion(); if (argObjectType.isSubtype(referencedParamType)) { TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap(); for (TemplateType key : paramTypeMap.getTemplateKeys()) {"
      },
      {
        "txt": "maybeResolveTemplatedType( paramTypeMap.getTemplateType(key), argTypeMap.getTemplateType(key), resolvedTypes, seenTypes); } } } } private void maybeResolveTemplateTypeFromNodes( Iterable<Node> declParams,"
      },
      {
        "txt": "Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { maybeResolveTemplateTypeFromNodes( declParams.iterator(), callParams.iterator(), resolvedTypes, seenTypes); } private void maybeResolveTemplateTypeFromNodes( Iterator<Node> declParams, Iterator<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) {"
      },
      {
        "txt": "while (declParams.hasNext() && callParams.hasNext()) { Node declParam = declParams.next(); maybeResolveTemplatedType( getJSType(declParam), getJSType(callParams.next()), resolvedTypes, seenTypes); if (declParam.isVarArgs()) { while (callParams.hasNext()) { maybeResolveTemplatedType( getJSType(declParam),"
      },
      {
        "txt": "getJSType(callParams.next()), resolvedTypes, seenTypes); } } } } private static void resolvedTemplateType( Map<TemplateType, JSType> map, TemplateType template, JSType resolved) { JSType previous = map.get(template); if (!resolved.isUnknownType()) {"
      },
      {
        "txt": "if (previous == null) { map.put(template, resolved); } else { JSType join = previous.getLeastSupertype(resolved); map.put(template, join); } } } private static class TemplateTypeReplacer extends ModificationVisitor { private final Map<TemplateType, JSType> replacements;"
      },
      {
        "txt": "private final JSTypeRegistry registry; boolean madeChanges = false; TemplateTypeReplacer( JSTypeRegistry registry, Map<TemplateType, JSType> replacements) { super(registry, true); this.registry = registry; this.replacements = replacements; } @Override public JSType caseTemplateType(TemplateType type) {"
      },
      {
        "txt": "madeChanges = true; JSType replacement = replacements.get(type); return replacement != null ? replacement : registry.getNativeType(UNKNOWN_TYPE); } } private boolean inferTemplatedTypesForCall( Node n, FunctionType fnType) { final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap() .getTemplateKeys();"
      },
      {
        "txt": "if (keys.isEmpty()) { return false; } Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }}"
      },
      {
        "txt": "); TemplateTypeReplacer replacer = new TemplateTypeReplacer( registry, inferred); Node callTarget = n.getFirstChild(); FunctionType replacementFnType = fnType.visit(replacer) .toMaybeFunctionType(); Preconditions.checkNotNull(replacementFnType); callTarget.setJSType(replacementFnType); n.setJSType(replacementFnType.getReturnType()); return replacer.madeChanges;"
      },
      {
        "txt": "} private FlowScope traverseNew(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node constructor = n.getFirstChild(); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = unknownType;"
      },
      {
        "txt": "} else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { backwardsInferenceFromCallSite(n, ct); ObjectType instanceType = ct.getInstanceType(); Map<TemplateType, JSType> inferredTypes = inferTemplateTypesFromParameters(ct, n);"
      },
      {
        "txt": "if (inferredTypes.isEmpty()) { type = instanceType; } else { type = registry.createTemplatizedType(instanceType, inferredTypes); } } } } n.setJSType(type); return scope;"
      },
      {
        "txt": "} private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope; }"
      },
      {
        "txt": "private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope); JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined(); TemplateTypeMap typeMap = type.getTemplateTypeMap(); if (typeMap.hasTemplateType(registry.getObjectElementKey())) { n.setJSType(typeMap.getTemplateType(registry.getObjectElementKey())); } return dereferencePointer(n.getFirstChild(), scope); } private FlowScope traverseGetProp(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType( getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private static void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) {"
      },
      {
        "txt": "if (type == null || constraint == null) { return; } type.matchConstraint(constraint); } private FlowScope dereferencePointer(Node n, FlowScope scope) { if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) {"
      },
      {
        "txt": "scope = narrowScope(scope, n, narrowed); } } return scope; } private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { JSType propertyType = null; boolean isLocallyInferred = false; String qualifiedName = n.getQualifiedName();"
      },
      {
        "txt": "StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) { JSType varType = var.getType(); if (varType != null) { boolean isDeclared = !var.isTypeInferred(); isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName)); if (isDeclared || isLocallyInferred) { propertyType = varType; } }"
      },
      {
        "txt": "} if (propertyType == null && objType != null) { JSType foundType = objType.findPropertyType(propName); if (foundType != null) { propertyType = foundType; } } if (propertyType != null && objType != null) { JSType restrictedObjType = objType.restrictByNotNullOrUndefined(); if (!restrictedObjType.getTemplateTypeMap().isEmpty()"
      },
      {
        "txt": "&& propertyType.hasAnyTemplateTypes()) { TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap(); TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); propertyType = propertyType.visit(replacer); } } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) { ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));"
      },
      {
        "txt": "if (regType != null) { propertyType = regType.getConstructor(); } } if (propertyType == null) { return unknownType; } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else { return propertyType;"
      },
      {
        "txt": "} } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); } private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild(); BooleanOutcomePair leftLiterals ="
      },
      {
        "txt": "traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp( right, rightScope.createChildFlowScope());"
      },
      {
        "txt": "JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition); if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals; } else {"
      },
      {
        "txt": "type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY && getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE)); }"
      },
      {
        "txt": "} } else { type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type); return literals;"
      },
      {
        "txt": "} private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { switch (n.getType()) { case Token.AND: return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default: scope = traverse(n, scope);"
      },
      {
        "txt": "return newBooleanOutcomePair(n.getJSType(), scope); } } BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) { return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope());"
      },
      {
        "txt": "} static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); } private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope; final FlowScope rightScope;"
      },
      {
        "txt": "FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes; this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; } FlowScope getJoinedFlowScope() {"
      },
      {
        "txt": "if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope); } } return joinedScope; } FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) {"
      },
      {
        "txt": "if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope; } else { return getJoinedFlowScope(); } } } private BooleanOutcomePair newBooleanOutcomePair( JSType jsType, FlowScope flowScope) {"
      },
      {
        "txt": "if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(), registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); } private void redeclareSimpleVar("
      },
      {
        "txt": "FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE); } if (isUnflowable(syntacticScope.getVar(varName))) { return; } scope.inferSlotType(varName, varType);"
      },
      {
        "txt": "} private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return unknownType; } else {"
      },
      {
        "txt": "return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 917,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 550,
    "end-bug-line": 550,
    "bug": "",
    "fix": "!resultType.isNullType() && !resultType.isVoidType();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ModificationVisitor; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnionType; import java.util.Collections; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final JSTypeRegistry registry; private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; private final ObjectType unknownType; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope,"
      },
      {
        "txt": "Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE); this.syntacticScope = functionScope; inferArguments(functionScope); this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); this.assertionFunctionsMap = assertionFunctionsMap;"
      },
      {
        "txt": "Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType( var.getName(), getNativeType(VOID_TYPE)); }"
      },
      {
        "txt": "this.bottomScope = LinkedFlowScope.createEntryLattice( Scope.createLatticeBottom(functionScope.getRootNode())); } private void inferArguments(Scope functionScope) { Node functionNode = functionScope.getRootNode(); Node astParameters = functionNode.getFirstChild().getNext(); Node iifeArgumentNode = null; if (NodeUtil.isCallOrNewTarget(functionNode)) { iifeArgumentNode = functionNode.getNext(); }"
      },
      {
        "txt": "FunctionType functionType = JSType.toMaybeFunctionType(functionNode.getJSType()); if (functionType != null) { Node parameterTypes = functionType.getParametersNode(); if (parameterTypes != null) { Node parameterTypeNode = parameterTypes.getFirstChild(); for (Node astParameter : astParameters.children()) { Var var = functionScope.getVar(astParameter.getString()); Preconditions.checkNotNull(var); if (var.isTypeInferred() &&"
      },
      {
        "txt": "var.getType() == unknownType) { JSType newType = null; if (iifeArgumentNode != null) { newType = iifeArgumentNode.getJSType(); } else if (parameterTypeNode != null) { newType = parameterTypeNode.getJSType(); } if (newType != null) { var.setType(newType); astParameter.setJSType(newType);"
      },
      {
        "txt": "} } if (parameterTypeNode != null) { parameterTypeNode = parameterTypeNode.getNext(); } if (iifeArgumentNode != null) { iifeArgumentNode = iifeArgumentNode.getNext(); } } }"
      },
      {
        "txt": "} } @Override FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() { return functionScope; }"
      },
      {
        "txt": "@Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) { return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output; } @Override"
      },
      {
        "txt": "@SuppressWarnings({\"fallthrough\", \"incomplete-switch\"}) List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue();"
      },
      {
        "txt": "FlowScope newScope = output; switch (branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) { item = item.getFirstChild(); }"
      },
      {
        "txt": "if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType( registry.getObjectIndexKey()); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) {"
      },
      {
        "txt": "iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; } case ON_FALSE: if (condition == null) {"
      },
      {
        "txt": "condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } } } if (condition != null) {"
      },
      {
        "txt": "if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition,"
      },
      {
        "txt": "conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break; } result.add(newScope.optimize()); } return result; } private FlowScope traverse(Node n, FlowScope scope) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope); break;"
      },
      {
        "txt": "case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope);"
      },
      {
        "txt": "break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break;"
      },
      {
        "txt": "case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.ARRAYLIT:"
      },
      {
        "txt": "scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH:"
      },
      {
        "txt": "case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD:"
      },
      {
        "txt": "case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE));"
      },
      {
        "txt": "break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break; case Token.TYPEOF:"
      },
      {
        "txt": "scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT: case Token.EQ:"
      },
      {
        "txt": "case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM: scope = traverseGetElem(n, scope);"
      },
      {
        "txt": "break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope); break;"
      },
      {
        "txt": "case Token.RETURN: scope = traverseReturn(n, scope); break; case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope); break;"
      },
      {
        "txt": "case Token.CAST: scope = traverseChildren(n, scope); JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { n.setJSType(info.getType().evaluate(syntacticScope, registry)); } break; } return scope; }"
      },
      {
        "txt": "private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) { JSType type = functionScope.getRootNode().getJSType(); if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType());"
      },
      {
        "txt": "} } } return scope; } private FlowScope traverseCatch(Node catchNode, FlowScope scope) { Node name = catchNode.getFirstChild(); JSType type; JSDocInfo info = name.getJSDocInfo(); if (info != null && info.hasType()) {"
      },
      {
        "txt": "type = info.getType().evaluate(syntacticScope, registry); } else { type = getNativeType(JSTypeNative.UNKNOWN_TYPE); } redeclareSimpleVar(scope, name, type); name.setJSType(type); return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild();"
      },
      {
        "txt": "Node right = n.getLastChild(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; } private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType) {"
      },
      {
        "txt": "switch (left.getType()) { case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred(); <extra_id_0> if (isVarTypeBetter) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) {"
      },
      {
        "txt": "resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) {"
      },
      {
        "txt": "scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) {"
      },
      {
        "txt": "String propName = getprop.getLastChild().getString(); Node obj = getprop.getFirstChild(); JSType nodeType = getJSType(obj); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); boolean propCreationInConstructor = obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor(); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType); } else {"
      },
      {
        "txt": "if (nodeType.isStruct() && !objectType.hasProperty(propName)) { boolean staticPropCreation = false; Node maybeAssignStm = getprop.getParent().getParent(); if (syntacticScope.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) { String propCreationFilename = maybeAssignStm.getSourceFileName(); Node ctor = objectType.getOwnerFunction().getSource(); if (ctor != null && ctor.getSourceFileName().equals(propCreationFilename)) { staticPropCreation = true;"
      },
      {
        "txt": "} } if (!propCreationInConstructor && !staticPropCreation) { return; // Early return to avoid creating the property below. } } if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; } if (!objectType.isPropertyTypeDeclared(propName)) {"
      },
      {
        "txt": "if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty(propName, rightType, getprop); } else { objectType.defineInferredProperty(propName, rightType, getprop); } } else if (propCreationInConstructor) { objectType.defineInferredProperty(propName, rightType, getprop); } else { registry.registerPropertyOnType(propName, objectType);"
      },
      {
        "txt": "} } } } private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType); }"
      },
      {
        "txt": "} private boolean ensurePropertyDeclaredHelper( Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) &&"
      },
      {
        "txt": "(!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { return objectType.defineDeclaredProperty( propName, var.getType(), getprop); } } } return false; } private FlowScope traverseName(Node n, FlowScope scope) {"
      },
      {
        "txt": "String varName = n.getString(); Node value = n.getFirstChild(); JSType type = n.getJSType(); if (value != null) { scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName);"
      },
      {
        "txt": "if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = false; if (isInferred && syntacticScope.isLocal()) { Var maybeOuterVar = syntacticScope.getParent().getVar(varName); if (var == maybeOuterVar && !maybeOuterVar.isMarkedAssignedExactlyOnce()) { nonLocalInferredSlot = true;"
      },
      {
        "txt": "} } if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = unknownType; } } } }"
      },
      {
        "txt": "n.setJSType(type); return scope; } private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE)); return scope; } private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType();"
      },
      {
        "txt": "Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT) || objectType.isEnumType()) { return scope; }"
      },
      {
        "txt": "String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) {"
      },
      {
        "txt": "valueType = unknownType; } objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));"
      },
      {
        "txt": "} scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType); } } else { n.setJSType(unknownType); } } return scope;"
      },
      {
        "txt": "} private FlowScope traverseAdd(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = left.getNext(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = unknownType; if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType();"
      },
      {
        "txt": "boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) { type = unknownType; } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = unknownType; } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE);"
      },
      {
        "txt": "} else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); } } n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope; }"
      },
      {
        "txt": "private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); } private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter."
      },
      {
        "txt": "getPreciserScopeKnowingConditionOutcome( condition, scope, true); FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) {"
      },
      {
        "txt": "n.setJSType(trueType.getLeastSupertype(falseType)); } else { n.setJSType(null); } return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType(); n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.isEquivalentTo( getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } scope = tightenTypesAfterAssertions(scope, n); return scope;"
      },
      {
        "txt": "} private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; }"
      },
      {
        "txt": "Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) { return scope; } JSType assertedType = assertionFunctionSpec.getAssertedType( callNode, registry); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); } else { JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(assertedType); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } } callNode.setJSType(narrowed);"
      },
      {
        "txt": "return scope; } private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; } scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed);"
      },
      {
        "txt": "} else { redeclareSimpleVar(scope, node, narrowed); } return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { boolean updatedFnType = inferTemplatedTypesForCall(n, fnType); if (updatedFnType) { fnType = n.getFirstChild().getJSType().toMaybeFunctionType(); }"
      },
      {
        "txt": "updateTypeOfParameters(n, fnType); updateBind(n); } private void updateBind(Node n) { CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; } FunctionType callTargetFn = getJSType(bind.target)"
      },
      {
        "txt": ".restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return; } n.setJSType( callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) { int i = 0;"
      },
      {
        "txt": "int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) { return; } JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); JSType restrictedParameter = iParameterType"
      },
      {
        "txt": ".restrictByNotNullOrUndefined() .toMaybeFunctionType(); if (restrictedParameter != null) { if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) { iArgument.setJSType(restrictedParameter); } } i++;"
      },
      {
        "txt": "} } private Map<TemplateType, JSType> inferTemplateTypesFromParameters( FunctionType fnType, Node call) { if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) { return Collections.emptyMap(); } Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap(); Set<JSType> seenTypes = Sets.newIdentityHashSet(); Node callTarget = call.getFirstChild();"
      },
      {
        "txt": "if (NodeUtil.isGet(callTarget)) { Node obj = callTarget.getFirstChild(); maybeResolveTemplatedType( fnType.getTypeOfThis(), getJSType(obj), resolvedTypes, seenTypes); } if (call.hasMoreThanOneChild()) { maybeResolveTemplateTypeFromNodes("
      },
      {
        "txt": "fnType.getParameters(), call.getChildAtIndex(1).siblings(), resolvedTypes, seenTypes); } return resolvedTypes; } private void maybeResolveTemplatedType( JSType paramType, JSType argType,"
      },
      {
        "txt": "Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { if (paramType.isTemplateType()) { resolvedTemplateType( resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) { UnionType unionType = paramType.toMaybeUnionType(); for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes, seenTypes); } } else if (paramType.isFunctionType()) {"
      },
      {
        "txt": "FunctionType paramFunctionType = paramType.toMaybeFunctionType(); FunctionType argFunctionType = argType .restrictByNotNullOrUndefined() .collapseUnion() .toMaybeFunctionType(); if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { maybeResolveTemplatedType( paramFunctionType.getTypeOfThis(), argFunctionType.getTypeOfThis(), resolvedTypes, seenTypes); maybeResolveTemplatedType("
      },
      {
        "txt": "paramFunctionType.getReturnType(), argFunctionType.getReturnType(), resolvedTypes, seenTypes); maybeResolveTemplateTypeFromNodes( paramFunctionType.getParameters(), argFunctionType.getParameters(), resolvedTypes, seenTypes); } } else if (paramType.isRecordType() && !paramType.isNominalType()) { if(!seenTypes.contains(paramType)) { seenTypes.add(paramType); ObjectType paramRecordType = paramType.toObjectType();"
      },
      {
        "txt": "ObjectType argObjectType = argType.restrictByNotNullOrUndefined() .toObjectType(); if (argObjectType != null && !argObjectType.isUnknownType() && !argObjectType.isEmptyType()) { Set<String> names = paramRecordType.getPropertyNames(); for (String name : names) { if (paramRecordType.hasOwnProperty(name) && argObjectType.hasProperty(name)) { maybeResolveTemplatedType("
      },
      {
        "txt": "paramRecordType.getPropertyType(name), argObjectType.getPropertyType(name), resolvedTypes, seenTypes); } } } seenTypes.remove(paramType); } } else if (paramType.isTemplatizedType()) {"
      },
      {
        "txt": "ObjectType referencedParamType = paramType .toMaybeTemplatizedType() .getReferencedType(); JSType argObjectType = argType .restrictByNotNullOrUndefined() .collapseUnion(); if (argObjectType.isSubtype(referencedParamType)) { TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap(); for (TemplateType key : paramTypeMap.getTemplateKeys()) {"
      },
      {
        "txt": "maybeResolveTemplatedType( paramTypeMap.getTemplateType(key), argTypeMap.getTemplateType(key), resolvedTypes, seenTypes); } } } } private void maybeResolveTemplateTypeFromNodes( Iterable<Node> declParams,"
      },
      {
        "txt": "Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { maybeResolveTemplateTypeFromNodes( declParams.iterator(), callParams.iterator(), resolvedTypes, seenTypes); } private void maybeResolveTemplateTypeFromNodes( Iterator<Node> declParams, Iterator<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) {"
      },
      {
        "txt": "while (declParams.hasNext() && callParams.hasNext()) { Node declParam = declParams.next(); maybeResolveTemplatedType( getJSType(declParam), getJSType(callParams.next()), resolvedTypes, seenTypes); if (declParam.isVarArgs()) { while (callParams.hasNext()) { maybeResolveTemplatedType( getJSType(declParam),"
      },
      {
        "txt": "getJSType(callParams.next()), resolvedTypes, seenTypes); } } } } private static void resolvedTemplateType( Map<TemplateType, JSType> map, TemplateType template, JSType resolved) { JSType previous = map.get(template); if (!resolved.isUnknownType()) {"
      },
      {
        "txt": "if (previous == null) { map.put(template, resolved); } else { JSType join = previous.getLeastSupertype(resolved); map.put(template, join); } } } private static class TemplateTypeReplacer extends ModificationVisitor { private final Map<TemplateType, JSType> replacements;"
      },
      {
        "txt": "private final JSTypeRegistry registry; boolean madeChanges = false; TemplateTypeReplacer( JSTypeRegistry registry, Map<TemplateType, JSType> replacements) { super(registry, true); this.registry = registry; this.replacements = replacements; } @Override public JSType caseTemplateType(TemplateType type) {"
      },
      {
        "txt": "madeChanges = true; JSType replacement = replacements.get(type); return replacement != null ? replacement : registry.getNativeType(UNKNOWN_TYPE); } } private boolean inferTemplatedTypesForCall( Node n, FunctionType fnType) { final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap() .getTemplateKeys();"
      },
      {
        "txt": "if (keys.isEmpty()) { return false; } Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }}"
      },
      {
        "txt": "); TemplateTypeReplacer replacer = new TemplateTypeReplacer( registry, inferred); Node callTarget = n.getFirstChild(); FunctionType replacementFnType = fnType.visit(replacer) .toMaybeFunctionType(); Preconditions.checkNotNull(replacementFnType); callTarget.setJSType(replacementFnType); n.setJSType(replacementFnType.getReturnType()); return replacer.madeChanges;"
      },
      {
        "txt": "} private FlowScope traverseNew(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node constructor = n.getFirstChild(); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = unknownType;"
      },
      {
        "txt": "} else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { backwardsInferenceFromCallSite(n, ct); ObjectType instanceType = ct.getInstanceType(); Map<TemplateType, JSType> inferredTypes = inferTemplateTypesFromParameters(ct, n);"
      },
      {
        "txt": "if (inferredTypes.isEmpty()) { type = instanceType; } else { type = registry.createTemplatizedType(instanceType, inferredTypes); } } } } n.setJSType(type); return scope;"
      },
      {
        "txt": "} private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope; }"
      },
      {
        "txt": "private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope); JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined(); TemplateTypeMap typeMap = type.getTemplateTypeMap(); if (typeMap.hasTemplateType(registry.getObjectElementKey())) { n.setJSType(typeMap.getTemplateType(registry.getObjectElementKey())); } return dereferencePointer(n.getFirstChild(), scope); } private FlowScope traverseGetProp(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType( getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private static void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) {"
      },
      {
        "txt": "if (type == null || constraint == null) { return; } type.matchConstraint(constraint); } private FlowScope dereferencePointer(Node n, FlowScope scope) { if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) {"
      },
      {
        "txt": "scope = narrowScope(scope, n, narrowed); } } return scope; } private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { JSType propertyType = null; boolean isLocallyInferred = false; String qualifiedName = n.getQualifiedName();"
      },
      {
        "txt": "StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) { JSType varType = var.getType(); if (varType != null) { boolean isDeclared = !var.isTypeInferred(); isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName)); if (isDeclared || isLocallyInferred) { propertyType = varType; } }"
      },
      {
        "txt": "} if (propertyType == null && objType != null) { JSType foundType = objType.findPropertyType(propName); if (foundType != null) { propertyType = foundType; } } if (propertyType != null && objType != null) { JSType restrictedObjType = objType.restrictByNotNullOrUndefined(); if (!restrictedObjType.getTemplateTypeMap().isEmpty()"
      },
      {
        "txt": "&& propertyType.hasAnyTemplateTypes()) { TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap(); TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); propertyType = propertyType.visit(replacer); } } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) { ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));"
      },
      {
        "txt": "if (regType != null) { propertyType = regType.getConstructor(); } } if (propertyType == null) { return unknownType; } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else { return propertyType;"
      },
      {
        "txt": "} } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); } private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild(); BooleanOutcomePair leftLiterals ="
      },
      {
        "txt": "traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp( right, rightScope.createChildFlowScope());"
      },
      {
        "txt": "JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition); if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals; } else {"
      },
      {
        "txt": "type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY && getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE)); }"
      },
      {
        "txt": "} } else { type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type); return literals;"
      },
      {
        "txt": "} private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { switch (n.getType()) { case Token.AND: return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default: scope = traverse(n, scope);"
      },
      {
        "txt": "return newBooleanOutcomePair(n.getJSType(), scope); } } BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) { return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope());"
      },
      {
        "txt": "} static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); } private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope; final FlowScope rightScope;"
      },
      {
        "txt": "FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes; this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; } FlowScope getJoinedFlowScope() {"
      },
      {
        "txt": "if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope); } } return joinedScope; } FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) {"
      },
      {
        "txt": "if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope; } else { return getJoinedFlowScope(); } } } private BooleanOutcomePair newBooleanOutcomePair( JSType jsType, FlowScope flowScope) {"
      },
      {
        "txt": "if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(), registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); } private void redeclareSimpleVar("
      },
      {
        "txt": "FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE); } if (isUnflowable(syntacticScope.getVar(varName))) { return; } scope.inferSlotType(varName, varType);"
      },
      {
        "txt": "} private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return unknownType; } else {"
      },
      {
        "txt": "return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 918,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 562,
    "end-bug-line": 562,
    "bug": "",
    "fix": "redeclareSimpleVar(scope, left, varType); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;"
      },
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;"
      },
      {
        "txt": "import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.ModificationVisitor; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnionType; import java.util.Collections; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler; private final JSTypeRegistry registry;"
      },
      {
        "txt": "private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; private final ObjectType unknownType; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) {"
      },
      {
        "txt": "super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE); this.syntacticScope = functionScope; inferArguments(functionScope); this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); this.assertionFunctionsMap = assertionFunctionsMap; Iterator<Var> varIt ="
      },
      {
        "txt": "functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType( var.getName(), getNativeType(VOID_TYPE)); } this.bottomScope = LinkedFlowScope.createEntryLattice("
      },
      {
        "txt": "Scope.createLatticeBottom(functionScope.getRootNode())); } private void inferArguments(Scope functionScope) { Node functionNode = functionScope.getRootNode(); Node astParameters = functionNode.getFirstChild().getNext(); Node iifeArgumentNode = null; if (NodeUtil.isCallOrNewTarget(functionNode)) { iifeArgumentNode = functionNode.getNext(); } FunctionType functionType ="
      },
      {
        "txt": "JSType.toMaybeFunctionType(functionNode.getJSType()); if (functionType != null) { Node parameterTypes = functionType.getParametersNode(); if (parameterTypes != null) { Node parameterTypeNode = parameterTypes.getFirstChild(); for (Node astParameter : astParameters.children()) { Var var = functionScope.getVar(astParameter.getString()); Preconditions.checkNotNull(var); if (var.isTypeInferred() && var.getType() == unknownType) {"
      },
      {
        "txt": "JSType newType = null; if (iifeArgumentNode != null) { newType = iifeArgumentNode.getJSType(); } else if (parameterTypeNode != null) { newType = parameterTypeNode.getJSType(); } if (newType != null) { var.setType(newType); astParameter.setJSType(newType); }"
      },
      {
        "txt": "} if (parameterTypeNode != null) { parameterTypeNode = parameterTypeNode.getNext(); } if (iifeArgumentNode != null) { iifeArgumentNode = iifeArgumentNode.getNext(); } } } }"
      },
      {
        "txt": "} @Override FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() { return functionScope; } @Override"
      },
      {
        "txt": "FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) { return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output; } @Override @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"})"
      },
      {
        "txt": "List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue(); FlowScope newScope = output;"
      },
      {
        "txt": "switch (branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) { item = item.getFirstChild(); } if (item.isName()) {"
      },
      {
        "txt": "JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType( registry.getObjectIndexKey()); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType;"
      },
      {
        "txt": "} } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; } case ON_FALSE: if (condition == null) { condition = NodeUtil.getConditionExpression(source);"
      },
      {
        "txt": "if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } } } if (condition != null) { if (condition.isAnd() ||"
      },
      {
        "txt": "condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionOutcomes.getOutcomeFlowScope("
      },
      {
        "txt": "condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionFlowScope, branch == Branch.ON_TRUE);"
      },
      {
        "txt": "} } break; } result.add(newScope.optimize()); } return result; } private FlowScope traverse(Node n, FlowScope scope) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope); break; case Token.AND:"
      },
      {
        "txt": "scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break;"
      },
      {
        "txt": "case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD:"
      },
      {
        "txt": "case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope);"
      },
      {
        "txt": "break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH:"
      },
      {
        "txt": "case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD: case Token.BITAND:"
      },
      {
        "txt": "case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE)); break;"
      },
      {
        "txt": "case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break; case Token.TYPEOF: scope = traverseChildren(n, scope);"
      },
      {
        "txt": "n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT: case Token.EQ: case Token.NE:"
      },
      {
        "txt": "case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM: scope = traverseGetElem(n, scope); break;"
      },
      {
        "txt": "case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope); break; case Token.RETURN:"
      },
      {
        "txt": "scope = traverseReturn(n, scope); break; case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope); break; case Token.CAST:"
      },
      {
        "txt": "scope = traverseChildren(n, scope); JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { n.setJSType(info.getType().evaluate(syntacticScope, registry)); } break; } return scope; } private FlowScope traverseReturn(Node n, FlowScope scope) {"
      },
      {
        "txt": "scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) { JSType type = functionScope.getRootNode().getJSType(); if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType()); }"
      },
      {
        "txt": "} } return scope; } private FlowScope traverseCatch(Node catchNode, FlowScope scope) { Node name = catchNode.getFirstChild(); JSType type; JSDocInfo info = name.getJSDocInfo(); if (info != null && info.hasType()) { type = info.getType().evaluate(syntacticScope, registry);"
      },
      {
        "txt": "} else { type = getNativeType(JSTypeNative.UNKNOWN_TYPE); } redeclareSimpleVar(scope, name, type); name.setJSType(type); return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = n.getLastChild();"
      },
      {
        "txt": "scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; } private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType) { Preconditions.checkNotNull(resultType);"
      },
      {
        "txt": "case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred(); if (isVarTypeBetter) { <extra_id_0> } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ?"
      },
      {
        "txt": "JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) { scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType,"
      },
      {
        "txt": "resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) { String propName = getprop.getLastChild().getString(); Node obj = getprop.getFirstChild();"
      },
      {
        "txt": "JSType nodeType = getJSType(obj); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); boolean propCreationInConstructor = obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor(); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType); } else { if (nodeType.isStruct() && !objectType.hasProperty(propName)) { boolean staticPropCreation = false;"
      },
      {
        "txt": "Node maybeAssignStm = getprop.getParent().getParent(); if (syntacticScope.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) { String propCreationFilename = maybeAssignStm.getSourceFileName(); Node ctor = objectType.getOwnerFunction().getSource(); if (ctor != null && ctor.getSourceFileName().equals(propCreationFilename)) { staticPropCreation = true; } }"
      },
      {
        "txt": "if (!propCreationInConstructor && !staticPropCreation) { return; // Early return to avoid creating the property below. } } if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; } if (!objectType.isPropertyTypeDeclared(propName)) { if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) {"
      },
      {
        "txt": "objectType.defineDeclaredProperty(propName, rightType, getprop); } else { objectType.defineInferredProperty(propName, rightType, getprop); } } else if (propCreationInConstructor) { objectType.defineInferredProperty(propName, rightType, getprop); } else { registry.registerPropertyOnType(propName, objectType); } }"
      },
      {
        "txt": "} } private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType); } } private boolean ensurePropertyDeclaredHelper("
      },
      {
        "txt": "Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) {"
      },
      {
        "txt": "return objectType.defineDeclaredProperty( propName, var.getType(), getprop); } } } return false; } private FlowScope traverseName(Node n, FlowScope scope) { String varName = n.getString(); Node value = n.getFirstChild();"
      },
      {
        "txt": "JSType type = n.getJSType(); if (value != null) { scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { boolean isInferred = var.isTypeInferred();"
      },
      {
        "txt": "boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = false; if (isInferred && syntacticScope.isLocal()) { Var maybeOuterVar = syntacticScope.getParent().getVar(varName); if (var == maybeOuterVar && !maybeOuterVar.isMarkedAssignedExactlyOnce()) { nonLocalInferredSlot = true; } }"
      },
      {
        "txt": "if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = unknownType; } } } } n.setJSType(type); return scope;"
      },
      {
        "txt": "} private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE)); return scope; } private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {"
      },
      {
        "txt": "scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT) || objectType.isEnumType()) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n));"
      },
      {
        "txt": "for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { valueType = unknownType; }"
      },
      {
        "txt": "objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName,"
      },
      {
        "txt": "oldType == null ? unknownType : oldType, valueType); } } else { n.setJSType(unknownType); } } return scope; } private FlowScope traverseAdd(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node left = n.getFirstChild(); Node right = left.getNext(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = unknownType; if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType(); boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) {"
      },
      {
        "txt": "type = unknownType; } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = unknownType; } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE); } else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE);"
      },
      {
        "txt": "} } n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope; } private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE,"
      },
      {
        "txt": "NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); } private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, true);"
      },
      {
        "txt": "FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) { n.setJSType(trueType.getLeastSupertype(falseType)); } else {"
      },
      {
        "txt": "n.setJSType(null); } return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType();"
      },
      {
        "txt": "n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.isEquivalentTo( getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } scope = tightenTypesAfterAssertions(scope, n); return scope; } private FlowScope tightenTypesAfterAssertions(FlowScope scope,"
      },
      {
        "txt": "Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; } Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) {"
      },
      {
        "txt": "return scope; } JSType assertedType = assertionFunctionSpec.getAssertedType( callNode, registry); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined();"
      },
      {
        "txt": "} else { JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(assertedType); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } } callNode.setJSType(narrowed); return scope; }"
      },
      {
        "txt": "private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; } scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed); } else { redeclareSimpleVar(scope, node, narrowed);"
      },
      {
        "txt": "} return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { boolean updatedFnType = inferTemplatedTypesForCall(n, fnType); if (updatedFnType) { fnType = n.getFirstChild().getJSType().toMaybeFunctionType(); } updateTypeOfParameters(n, fnType); updateBind(n);"
      },
      {
        "txt": "} private void updateBind(Node n) { CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; } FunctionType callTargetFn = getJSType(bind.target) .restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) {"
      },
      {
        "txt": "return; } n.setJSType( callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) { int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) {"
      },
      {
        "txt": "if (i + 1 >= childCount) { return; } JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); JSType restrictedParameter = iParameterType .restrictByNotNullOrUndefined() .toMaybeFunctionType();"
      },
      {
        "txt": "if (restrictedParameter != null) { if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) { iArgument.setJSType(restrictedParameter); } } i++; } }"
      },
      {
        "txt": "private Map<TemplateType, JSType> inferTemplateTypesFromParameters( FunctionType fnType, Node call) { if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) { return Collections.emptyMap(); } Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap(); Set<JSType> seenTypes = Sets.newIdentityHashSet(); Node callTarget = call.getFirstChild(); if (NodeUtil.isGet(callTarget)) { Node obj = callTarget.getFirstChild();"
      },
      {
        "txt": "maybeResolveTemplatedType( fnType.getTypeOfThis(), getJSType(obj), resolvedTypes, seenTypes); } if (call.hasMoreThanOneChild()) { maybeResolveTemplateTypeFromNodes( fnType.getParameters(), call.getChildAtIndex(1).siblings(),"
      },
      {
        "txt": "resolvedTypes, seenTypes); } return resolvedTypes; } private void maybeResolveTemplatedType( JSType paramType, JSType argType, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { if (paramType.isTemplateType()) {"
      },
      {
        "txt": "resolvedTemplateType( resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) { UnionType unionType = paramType.toMaybeUnionType(); for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes, seenTypes); } } else if (paramType.isFunctionType()) { FunctionType paramFunctionType = paramType.toMaybeFunctionType(); FunctionType argFunctionType = argType"
      },
      {
        "txt": ".restrictByNotNullOrUndefined() .collapseUnion() .toMaybeFunctionType(); if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { maybeResolveTemplatedType( paramFunctionType.getTypeOfThis(), argFunctionType.getTypeOfThis(), resolvedTypes, seenTypes); maybeResolveTemplatedType( paramFunctionType.getReturnType(), argFunctionType.getReturnType(), resolvedTypes, seenTypes);"
      },
      {
        "txt": "maybeResolveTemplateTypeFromNodes( paramFunctionType.getParameters(), argFunctionType.getParameters(), resolvedTypes, seenTypes); } } else if (paramType.isRecordType() && !paramType.isNominalType()) { if(!seenTypes.contains(paramType)) { seenTypes.add(paramType); ObjectType paramRecordType = paramType.toObjectType(); ObjectType argObjectType = argType.restrictByNotNullOrUndefined() .toObjectType();"
      },
      {
        "txt": "if (argObjectType != null && !argObjectType.isUnknownType() && !argObjectType.isEmptyType()) { Set<String> names = paramRecordType.getPropertyNames(); for (String name : names) { if (paramRecordType.hasOwnProperty(name) && argObjectType.hasProperty(name)) { maybeResolveTemplatedType( paramRecordType.getPropertyType(name), argObjectType.getPropertyType(name),"
      },
      {
        "txt": "resolvedTypes, seenTypes); } } } seenTypes.remove(paramType); } } else if (paramType.isTemplatizedType()) { ObjectType referencedParamType = paramType .toMaybeTemplatizedType()"
      },
      {
        "txt": ".getReferencedType(); JSType argObjectType = argType .restrictByNotNullOrUndefined() .collapseUnion(); if (argObjectType.isSubtype(referencedParamType)) { TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap(); for (TemplateType key : paramTypeMap.getTemplateKeys()) { maybeResolveTemplatedType( paramTypeMap.getTemplateType(key),"
      },
      {
        "txt": "argTypeMap.getTemplateType(key), resolvedTypes, seenTypes); } } } } private void maybeResolveTemplateTypeFromNodes( Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) {"
      },
      {
        "txt": "maybeResolveTemplateTypeFromNodes( declParams.iterator(), callParams.iterator(), resolvedTypes, seenTypes); } private void maybeResolveTemplateTypeFromNodes( Iterator<Node> declParams, Iterator<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { while (declParams.hasNext() && callParams.hasNext()) { Node declParam = declParams.next();"
      },
      {
        "txt": "maybeResolveTemplatedType( getJSType(declParam), getJSType(callParams.next()), resolvedTypes, seenTypes); if (declParam.isVarArgs()) { while (callParams.hasNext()) { maybeResolveTemplatedType( getJSType(declParam), getJSType(callParams.next()), resolvedTypes, seenTypes);"
      },
      {
        "txt": "} } } } private static void resolvedTemplateType( Map<TemplateType, JSType> map, TemplateType template, JSType resolved) { JSType previous = map.get(template); if (!resolved.isUnknownType()) { if (previous == null) { map.put(template, resolved);"
      },
      {
        "txt": "} else { JSType join = previous.getLeastSupertype(resolved); map.put(template, join); } } } private static class TemplateTypeReplacer extends ModificationVisitor { private final Map<TemplateType, JSType> replacements; private final JSTypeRegistry registry; boolean madeChanges = false;"
      },
      {
        "txt": "TemplateTypeReplacer( JSTypeRegistry registry, Map<TemplateType, JSType> replacements) { super(registry, true); this.registry = registry; this.replacements = replacements; } @Override public JSType caseTemplateType(TemplateType type) { madeChanges = true; JSType replacement = replacements.get(type);"
      },
      {
        "txt": "return replacement != null ? replacement : registry.getNativeType(UNKNOWN_TYPE); } } private boolean inferTemplatedTypesForCall( Node n, FunctionType fnType) { final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap() .getTemplateKeys(); if (keys.isEmpty()) { return false;"
      },
      {
        "txt": "} Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} ); TemplateTypeReplacer replacer = new TemplateTypeReplacer("
      },
      {
        "txt": "registry, inferred); Node callTarget = n.getFirstChild(); FunctionType replacementFnType = fnType.visit(replacer) .toMaybeFunctionType(); Preconditions.checkNotNull(replacementFnType); callTarget.setJSType(replacementFnType); n.setJSType(replacementFnType.getReturnType()); return replacer.madeChanges; } private FlowScope traverseNew(Node n, FlowScope scope) {"
      },
      {
        "txt": "scope = traverseChildren(n, scope); Node constructor = n.getFirstChild(); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = unknownType; } else { FunctionType ct = constructorType.toMaybeFunctionType();"
      },
      {
        "txt": "if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { backwardsInferenceFromCallSite(n, ct); ObjectType instanceType = ct.getInstanceType(); Map<TemplateType, JSType> inferredTypes = inferTemplateTypesFromParameters(ct, n); if (inferredTypes.isEmpty()) { type = instanceType;"
      },
      {
        "txt": "} else { type = registry.createTemplatizedType(instanceType, inferredTypes); } } } } n.setJSType(type); return scope; } private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {"
      },
      {
        "txt": "return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope; } private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope);"
      },
      {
        "txt": "JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined(); TemplateTypeMap typeMap = type.getTemplateTypeMap(); if (typeMap.hasTemplateType(registry.getObjectElementKey())) { n.setJSType(typeMap.getTemplateType(registry.getObjectElementKey())); } return dereferencePointer(n.getFirstChild(), scope); } private FlowScope traverseGetProp(Node n, FlowScope scope) { Node objNode = n.getFirstChild(); Node property = n.getLastChild();"
      },
      {
        "txt": "scope = traverseChildren(n, scope); n.setJSType( getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private static void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return;"
      },
      {
        "txt": "} type.matchConstraint(constraint); } private FlowScope dereferencePointer(Node n, FlowScope scope) { if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) { scope = narrowScope(scope, n, narrowed); }"
      },
      {
        "txt": "} return scope; } private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { JSType propertyType = null; boolean isLocallyInferred = false; String qualifiedName = n.getQualifiedName(); StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) {"
      },
      {
        "txt": "JSType varType = var.getType(); if (varType != null) { boolean isDeclared = !var.isTypeInferred(); isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName)); if (isDeclared || isLocallyInferred) { propertyType = varType; } } } if (propertyType == null && objType != null) {"
      },
      {
        "txt": "JSType foundType = objType.findPropertyType(propName); if (foundType != null) { propertyType = foundType; } } if (propertyType != null && objType != null) { JSType restrictedObjType = objType.restrictByNotNullOrUndefined(); if (!restrictedObjType.getTemplateTypeMap().isEmpty() && propertyType.hasAnyTemplateTypes()) { TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();"
      },
      {
        "txt": "TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); propertyType = propertyType.visit(replacer); } } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) { ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); if (regType != null) { propertyType = regType.getConstructor();"
      },
      {
        "txt": "} } if (propertyType == null) { return unknownType; } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else { return propertyType; } }"
      },
      {
        "txt": "private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); } private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild(); BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope());"
      },
      {
        "txt": "JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp( right, rightScope.createChildFlowScope()); JSType rightType = right.getJSType(); JSType type;"
      },
      {
        "txt": "BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition); if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals; } else { type = leftType.getLeastSupertype(rightType); literals ="
      },
      {
        "txt": "getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY && getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE)); } } } else {"
      },
      {
        "txt": "type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type); return literals; } private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n,"
      },
      {
        "txt": "FlowScope scope) { switch (n.getType()) { case Token.AND: return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default: scope = traverse(n, scope); return newBooleanOutcomePair(n.getJSType(), scope); }"
      },
      {
        "txt": "} BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) { return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope()); } static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left,"
      },
      {
        "txt": "BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); } private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope; final FlowScope rightScope; FlowScope joinedScope = null; BooleanOutcomePair("
      },
      {
        "txt": "BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes; this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; } FlowScope getJoinedFlowScope() { if (joinedScope == null) { if (leftScope == rightScope) {"
      },
      {
        "txt": "joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope); } } return joinedScope; } FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) {"
      },
      {
        "txt": "return rightScope; } else { return getJoinedFlowScope(); } } } private BooleanOutcomePair newBooleanOutcomePair( JSType jsType, FlowScope flowScope) { if (jsType == null) { return new BooleanOutcomePair("
      },
      {
        "txt": "BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(), registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); } private void redeclareSimpleVar( FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName());"
      },
      {
        "txt": "String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE); } if (isUnflowable(syntacticScope.getVar(varName))) { return; } scope.inferSlotType(varName, varType); } private boolean isUnflowable(Var v) {"
      },
      {
        "txt": "return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return unknownType; } else { return jsType; }"
      },
      {
        "txt": "} private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 919,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 564,
    "end-bug-line": 565,
    "bug": "left.setJSType(isVarDeclaration || leftType == null ? resultType : null);",
    "fix": "left.setJSType(resultType);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ModificationVisitor; import com.google.javascript.rhino.jstype.ObjectType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.TemplateTypeMap; import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer; import com.google.javascript.rhino.jstype.UnionType; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler; private final JSTypeRegistry registry; private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope;"
      },
      {
        "txt": "private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; private final ObjectType unknownType; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler;"
      },
      {
        "txt": "this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE); this.syntacticScope = functionScope; inferArguments(functionScope); this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); this.assertionFunctionsMap = assertionFunctionsMap; Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) {"
      },
      {
        "txt": "Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType( var.getName(), getNativeType(VOID_TYPE)); } this.bottomScope = LinkedFlowScope.createEntryLattice( Scope.createLatticeBottom(functionScope.getRootNode())); }"
      },
      {
        "txt": "private void inferArguments(Scope functionScope) { Node functionNode = functionScope.getRootNode(); Node astParameters = functionNode.getFirstChild().getNext(); Node iifeArgumentNode = null; if (NodeUtil.isCallOrNewTarget(functionNode)) { iifeArgumentNode = functionNode.getNext(); } FunctionType functionType = JSType.toMaybeFunctionType(functionNode.getJSType()); if (functionType != null) {"
      },
      {
        "txt": "Node parameterTypes = functionType.getParametersNode(); if (parameterTypes != null) { Node parameterTypeNode = parameterTypes.getFirstChild(); for (Node astParameter : astParameters.children()) { Var var = functionScope.getVar(astParameter.getString()); Preconditions.checkNotNull(var); if (var.isTypeInferred() && var.getType() == unknownType) { JSType newType = null; if (iifeArgumentNode != null) {"
      },
      {
        "txt": "newType = iifeArgumentNode.getJSType(); } else if (parameterTypeNode != null) { newType = parameterTypeNode.getJSType(); } if (newType != null) { var.setType(newType); astParameter.setJSType(newType); } } if (parameterTypeNode != null) {"
      },
      {
        "txt": "parameterTypeNode = parameterTypeNode.getNext(); } if (iifeArgumentNode != null) { iifeArgumentNode = iifeArgumentNode.getNext(); } } } } } @Override"
      },
      {
        "txt": "FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() { return functionScope; } @Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) {"
      },
      {
        "txt": "return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output; } @Override @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"}) List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input);"
      },
      {
        "txt": "Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch (branch) { case ON_TRUE:"
      },
      {
        "txt": "if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) { item = item.getFirstChild(); } if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference();"
      },
      {
        "txt": "JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType( registry.getObjectIndexKey()); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType; } }"
      },
      {
        "txt": "redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; } case ON_FALSE: if (condition == null) { condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source;"
      },
      {
        "txt": "if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } } } if (condition != null) { if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) {"
      },
      {
        "txt": "conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);"
      },
      {
        "txt": "} else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionFlowScope, branch == Branch.ON_TRUE); } }"
      },
      {
        "txt": "break; } result.add(newScope.optimize()); } return result; } private FlowScope traverse(Node n, FlowScope scope) { switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope);"
      },
      {
        "txt": "break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope); break; case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope();"
      },
      {
        "txt": "break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope);"
      },
      {
        "txt": "break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope);"
      },
      {
        "txt": "break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope); break; case Token.THIS:"
      },
      {
        "txt": "n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD:"
      },
      {
        "txt": "case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD: case Token.BITAND: case Token.BITXOR: case Token.BITOR:"
      },
      {
        "txt": "case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope);"
      },
      {
        "txt": "n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break; case Token.TYPEOF: scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break;"
      },
      {
        "txt": "case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE:"
      },
      {
        "txt": "case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM: scope = traverseGetElem(n, scope); break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope);"
      },
      {
        "txt": "if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope); break; case Token.RETURN: scope = traverseReturn(n, scope); break;"
      },
      {
        "txt": "case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope); break; case Token.CAST: scope = traverseChildren(n, scope); JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (info != null && info.hasType()) { n.setJSType(info.getType().evaluate(syntacticScope, registry)); } break; } return scope; } private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild();"
      },
      {
        "txt": "if (retValue != null) { JSType type = functionScope.getRootNode().getJSType(); if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType()); } } }"
      },
      {
        "txt": "return scope; } private FlowScope traverseCatch(Node catchNode, FlowScope scope) { Node name = catchNode.getFirstChild(); JSType type; JSDocInfo info = name.getJSDocInfo(); if (info != null && info.hasType()) { type = info.getType().evaluate(syntacticScope, registry); } else { type = getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} redeclareSimpleVar(scope, name, type); name.setJSType(type); return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = n.getLastChild(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType();"
      },
      {
        "txt": "JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; } private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType) { Preconditions.checkNotNull(resultType); switch (left.getType()) { case Token.NAME:"
      },
      {
        "txt": "Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred(); if (isVarTypeBetter) { redeclareSimpleVar(scope, left, resultType); } <extra_id_0> if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break;"
      },
      {
        "txt": "} break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) { scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType); } left.setJSType(resultType);"
      },
      {
        "txt": "ensurePropertyDefined(left, resultType); break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) { String propName = getprop.getLastChild().getString(); Node obj = getprop.getFirstChild(); JSType nodeType = getJSType(obj); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined());"
      },
      {
        "txt": "boolean propCreationInConstructor = obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor(); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType); } else { if (nodeType.isStruct() && !objectType.hasProperty(propName)) { boolean staticPropCreation = false; Node maybeAssignStm = getprop.getParent().getParent(); if (syntacticScope.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {"
      },
      {
        "txt": "String propCreationFilename = maybeAssignStm.getSourceFileName(); Node ctor = objectType.getOwnerFunction().getSource(); if (ctor != null && ctor.getSourceFileName().equals(propCreationFilename)) { staticPropCreation = true; } } if (!propCreationInConstructor && !staticPropCreation) { return; // Early return to avoid creating the property below. }"
      },
      {
        "txt": "} if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; } if (!objectType.isPropertyTypeDeclared(propName)) { if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty(propName, rightType, getprop); } else { objectType.defineInferredProperty(propName, rightType, getprop);"
      },
      {
        "txt": "} } else if (propCreationInConstructor) { objectType.defineInferredProperty(propName, rightType, getprop); } else { registry.registerPropertyOnType(propName, objectType); } } } } private void ensurePropertyDeclared(Node getprop) {"
      },
      {
        "txt": "ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType); } } private boolean ensurePropertyDeclaredHelper( Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName();"
      },
      {
        "txt": "if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { return objectType.defineDeclaredProperty( propName, var.getType(), getprop); }"
      },
      {
        "txt": "} } return false; } private FlowScope traverseName(Node n, FlowScope scope) { String varName = n.getString(); Node value = n.getFirstChild(); JSType type = n.getJSType(); if (value != null) { scope = traverse(value, scope);"
      },
      {
        "txt": "updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = false;"
      },
      {
        "txt": "if (isInferred && syntacticScope.isLocal()) { Var maybeOuterVar = syntacticScope.getParent().getVar(varName); if (var == maybeOuterVar && !maybeOuterVar.isMarkedAssignedExactlyOnce()) { nonLocalInferredSlot = true; } } if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) {"
      },
      {
        "txt": "type = unknownType; } } } } n.setJSType(type); return scope; } private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope);"
      },
      {
        "txt": "n.setJSType(getNativeType(ARRAY_TYPE)); return scope; } private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type);"
      },
      {
        "txt": "if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT) || objectType.isEnumType()) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { String memberName = NodeUtil.getObjectLitKeyName(name);"
      },
      {
        "txt": "if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { valueType = unknownType; } objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName;"
      },
      {
        "txt": "Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType); }"
      },
      {
        "txt": "} else { n.setJSType(unknownType); } } return scope; } private FlowScope traverseAdd(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = left.getNext(); scope = traverseChildren(n, scope);"
      },
      {
        "txt": "JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = unknownType; if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType(); boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) { type = unknownType; } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) {"
      },
      {
        "txt": "type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = unknownType; } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE); } else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); } } n.setJSType(type);"
      },
      {
        "txt": "if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope; } private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); } private FlowScope traverseHook(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, true); FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, false);"
      },
      {
        "txt": "traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) { n.setJSType(trueType.getLeastSupertype(falseType)); } else { n.setJSType(null); } return scope.createChildFlowScope();"
      },
      {
        "txt": "} private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType(); n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.isEquivalentTo("
      },
      {
        "txt": "getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } scope = tightenTypesAfterAssertions(scope, n); return scope; } private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext();"
      },
      {
        "txt": "AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; } Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) { return scope; } JSType assertedType = assertionFunctionSpec.getAssertedType("
      },
      {
        "txt": "callNode, registry); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); } else { JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(assertedType);"
      },
      {
        "txt": "if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } } callNode.setJSType(narrowed); return scope; } private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope;"
      },
      {
        "txt": "} scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed); } else { redeclareSimpleVar(scope, node, narrowed); } return scope; }"
      },
      {
        "txt": "private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { boolean updatedFnType = inferTemplatedTypesForCall(n, fnType); if (updatedFnType) { fnType = n.getFirstChild().getJSType().toMaybeFunctionType(); } updateTypeOfParameters(n, fnType); updateBind(n); } private void updateBind(Node n) { CodingConvention.Bind bind ="
      },
      {
        "txt": "compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; } FunctionType callTargetFn = getJSType(bind.target) .restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return; } n.setJSType("
      },
      {
        "txt": "callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) { int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) { return; }"
      },
      {
        "txt": "JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); JSType restrictedParameter = iParameterType .restrictByNotNullOrUndefined() .toMaybeFunctionType(); if (restrictedParameter != null) { if (iArgument.isFunction() && iArgumentType.isFunctionType() &&"
      },
      {
        "txt": "iArgument.getJSDocInfo() == null) { iArgument.setJSType(restrictedParameter); } } i++; } } private Map<TemplateType, JSType> inferTemplateTypesFromParameters( FunctionType fnType, Node call) { if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {"
      },
      {
        "txt": "return Collections.emptyMap(); } Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap(); Set<JSType> seenTypes = Sets.newIdentityHashSet(); Node callTarget = call.getFirstChild(); if (NodeUtil.isGet(callTarget)) { Node obj = callTarget.getFirstChild(); maybeResolveTemplatedType( fnType.getTypeOfThis(), getJSType(obj),"
      },
      {
        "txt": "resolvedTypes, seenTypes); } if (call.hasMoreThanOneChild()) { maybeResolveTemplateTypeFromNodes( fnType.getParameters(), call.getChildAtIndex(1).siblings(), resolvedTypes, seenTypes); }"
      },
      {
        "txt": "return resolvedTypes; } private void maybeResolveTemplatedType( JSType paramType, JSType argType, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { if (paramType.isTemplateType()) { resolvedTemplateType( resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) {"
      },
      {
        "txt": "UnionType unionType = paramType.toMaybeUnionType(); for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes, seenTypes); } } else if (paramType.isFunctionType()) { FunctionType paramFunctionType = paramType.toMaybeFunctionType(); FunctionType argFunctionType = argType .restrictByNotNullOrUndefined() .collapseUnion() .toMaybeFunctionType();"
      },
      {
        "txt": "if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { maybeResolveTemplatedType( paramFunctionType.getTypeOfThis(), argFunctionType.getTypeOfThis(), resolvedTypes, seenTypes); maybeResolveTemplatedType( paramFunctionType.getReturnType(), argFunctionType.getReturnType(), resolvedTypes, seenTypes); maybeResolveTemplateTypeFromNodes( paramFunctionType.getParameters(), argFunctionType.getParameters(), resolvedTypes, seenTypes);"
      },
      {
        "txt": "} } else if (paramType.isRecordType() && !paramType.isNominalType()) { if(!seenTypes.contains(paramType)) { seenTypes.add(paramType); ObjectType paramRecordType = paramType.toObjectType(); ObjectType argObjectType = argType.restrictByNotNullOrUndefined() .toObjectType(); if (argObjectType != null && !argObjectType.isUnknownType() && !argObjectType.isEmptyType()) {"
      },
      {
        "txt": "Set<String> names = paramRecordType.getPropertyNames(); for (String name : names) { if (paramRecordType.hasOwnProperty(name) && argObjectType.hasProperty(name)) { maybeResolveTemplatedType( paramRecordType.getPropertyType(name), argObjectType.getPropertyType(name), resolvedTypes, seenTypes); }"
      },
      {
        "txt": "} } seenTypes.remove(paramType); } } else if (paramType.isTemplatizedType()) { ObjectType referencedParamType = paramType .toMaybeTemplatizedType() .getReferencedType(); JSType argObjectType = argType .restrictByNotNullOrUndefined()"
      },
      {
        "txt": ".collapseUnion(); if (argObjectType.isSubtype(referencedParamType)) { TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap(); for (TemplateType key : paramTypeMap.getTemplateKeys()) { maybeResolveTemplatedType( paramTypeMap.getTemplateType(key), argTypeMap.getTemplateType(key), resolvedTypes, seenTypes); }"
      },
      {
        "txt": "} } } private void maybeResolveTemplateTypeFromNodes( Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { maybeResolveTemplateTypeFromNodes( declParams.iterator(), callParams.iterator(), resolvedTypes, seenTypes); }"
      },
      {
        "txt": "private void maybeResolveTemplateTypeFromNodes( Iterator<Node> declParams, Iterator<Node> callParams, Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) { while (declParams.hasNext() && callParams.hasNext()) { Node declParam = declParams.next(); maybeResolveTemplatedType( getJSType(declParam), getJSType(callParams.next()),"
      },
      {
        "txt": "resolvedTypes, seenTypes); if (declParam.isVarArgs()) { while (callParams.hasNext()) { maybeResolveTemplatedType( getJSType(declParam), getJSType(callParams.next()), resolvedTypes, seenTypes); } } }"
      },
      {
        "txt": "} private static void resolvedTemplateType( Map<TemplateType, JSType> map, TemplateType template, JSType resolved) { JSType previous = map.get(template); if (!resolved.isUnknownType()) { if (previous == null) { map.put(template, resolved); } else { JSType join = previous.getLeastSupertype(resolved); map.put(template, join);"
      },
      {
        "txt": "} } } private static class TemplateTypeReplacer extends ModificationVisitor { private final Map<TemplateType, JSType> replacements; private final JSTypeRegistry registry; boolean madeChanges = false; TemplateTypeReplacer( JSTypeRegistry registry, Map<TemplateType, JSType> replacements) { super(registry, true);"
      },
      {
        "txt": "this.registry = registry; this.replacements = replacements; } @Override public JSType caseTemplateType(TemplateType type) { madeChanges = true; JSType replacement = replacements.get(type); return replacement != null ? replacement : registry.getNativeType(UNKNOWN_TYPE); }"
      },
      {
        "txt": "} private boolean inferTemplatedTypesForCall( Node n, FunctionType fnType) { final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap() .getTemplateKeys(); if (keys.isEmpty()) { return false; } Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n),"
      },
      {
        "txt": "new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} ); TemplateTypeReplacer replacer = new TemplateTypeReplacer( registry, inferred); Node callTarget = n.getFirstChild(); FunctionType replacementFnType = fnType.visit(replacer)"
      },
      {
        "txt": ".toMaybeFunctionType(); Preconditions.checkNotNull(replacementFnType); callTarget.setJSType(replacementFnType); n.setJSType(replacementFnType.getReturnType()); return replacer.madeChanges; } private FlowScope traverseNew(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node constructor = n.getFirstChild(); JSType constructorType = constructor.getJSType();"
      },
      {
        "txt": "JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = unknownType; } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; }"
      },
      {
        "txt": "if (ct != null && ct.isConstructor()) { backwardsInferenceFromCallSite(n, ct); ObjectType instanceType = ct.getInstanceType(); Map<TemplateType, JSType> inferredTypes = inferTemplateTypesFromParameters(ct, n); if (inferredTypes.isEmpty()) { type = instanceType; } else { type = registry.createTemplatizedType(instanceType, inferredTypes); }"
      },
      {
        "txt": "} } } n.setJSType(type); return scope; } private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) {"
      },
      {
        "txt": "for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope; } private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope); JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined(); TemplateTypeMap typeMap = type.getTemplateTypeMap(); if (typeMap.hasTemplateType(registry.getObjectElementKey())) {"
      },
      {
        "txt": "n.setJSType(typeMap.getTemplateType(registry.getObjectElementKey())); } return dereferencePointer(n.getFirstChild(), scope); } private FlowScope traverseGetProp(Node n, FlowScope scope) { Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType( getPropertyType("
      },
      {
        "txt": "objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private static void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } type.matchConstraint(constraint); }"
      },
      {
        "txt": "private FlowScope dereferencePointer(Node n, FlowScope scope) { if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) { scope = narrowScope(scope, n, narrowed); } } return scope; }"
      },
      {
        "txt": "private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { JSType propertyType = null; boolean isLocallyInferred = false; String qualifiedName = n.getQualifiedName(); StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) { JSType varType = var.getType(); if (varType != null) { boolean isDeclared = !var.isTypeInferred();"
      },
      {
        "txt": "isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName)); if (isDeclared || isLocallyInferred) { propertyType = varType; } } } if (propertyType == null && objType != null) { JSType foundType = objType.findPropertyType(propName); if (foundType != null) { propertyType = foundType;"
      },
      {
        "txt": "} } if (propertyType != null && objType != null) { JSType restrictedObjType = objType.restrictByNotNullOrUndefined(); if (!restrictedObjType.getTemplateTypeMap().isEmpty() && propertyType.hasAnyTemplateTypes()) { TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap(); TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); propertyType = propertyType.visit(replacer);"
      },
      {
        "txt": "} } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) { ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); if (regType != null) { propertyType = regType.getConstructor(); } } if (propertyType == null) {"
      },
      {
        "txt": "return unknownType; } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else { return propertyType; } } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); }"
      },
      {
        "txt": "private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild(); BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp( right, rightScope.createChildFlowScope()); JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition);"
      },
      {
        "txt": "if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals; } else { type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY &&"
      },
      {
        "txt": "getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE)); } } } else { type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH,"
      },
      {
        "txt": "leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type); return literals; } private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { switch (n.getType()) { case Token.AND:"
      },
      {
        "txt": "return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default: scope = traverse(n, scope); return newBooleanOutcomePair(n.getJSType(), scope); } } BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) {"
      },
      {
        "txt": "return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope()); } static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); }"
      },
      {
        "txt": "private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope; final FlowScope rightScope; FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes;"
      },
      {
        "txt": "this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; } FlowScope getJoinedFlowScope() { if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope);"
      },
      {
        "txt": "} } return joinedScope; } FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope; } else { return getJoinedFlowScope();"
      },
      {
        "txt": "} } } private BooleanOutcomePair newBooleanOutcomePair( JSType jsType, FlowScope flowScope) { if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(),"
      },
      {
        "txt": "registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); } private void redeclareSimpleVar( FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} if (isUnflowable(syntacticScope.getVar(varName))) { return; } scope.inferSlotType(varName, varType); } private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; }"
      },
      {
        "txt": "private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return unknownType; } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId);"
      }
    ]
  }
]