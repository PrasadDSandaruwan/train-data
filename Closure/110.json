[
  {
    "id": 450,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 358,
    "end-bug-line": 358,
    "bug": "",
    "fix": "boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\","
      },
      {
        "txt": "\"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler;"
      },
      {
        "txt": "} @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) {"
      },
      {
        "txt": "List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) { newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); }"
      },
      {
        "txt": "} if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break; } else { aliasWorkQueue = newQueue; } }"
      },
      {
        "txt": "for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent();"
      },
      {
        "txt": "Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) {"
      },
      {
        "txt": "compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar; final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference;"
      },
      {
        "txt": "} public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null; } public abstract void applyAlias(); } private class AliasedNode extends AliasUsage {"
      },
      {
        "txt": "AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue(); aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } }"
      },
      {
        "txt": "private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded ="
      },
      {
        "txt": "Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap();"
      },
      {
        "txt": "private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; }"
      },
      {
        "txt": "List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } } @Override"
      },
      {
        "txt": "public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false;"
      },
      {
        "txt": "} } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true;"
      },
      {
        "txt": "} private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();"
      },
      {
        "txt": "SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true;"
      },
      {
        "txt": "private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); <extra_id_0> recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ?"
      },
      {
        "txt": "Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));"
      },
      {
        "txt": "compiler.ensureLibraryInjected(\"base\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name);"
      },
      {
        "txt": "grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } }"
      },
      {
        "txt": "} private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex);"
      },
      {
        "txt": "if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } } private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope();"
      },
      {
        "txt": "for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; } } } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer ="
      },
      {
        "txt": "new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s); } MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); }"
      },
      {
        "txt": "} private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);"
      },
      {
        "txt": "} else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } }"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType();"
      },
      {
        "txt": "Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) {"
      },
      {
        "txt": "if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString();"
      },
      {
        "txt": "int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } }"
      },
      {
        "txt": "for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 451,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 366,
    "end-bug-line": 366,
    "bug": "} else if (isVar) {",
    "fix": "} else if (isVar || isFunctionDecl) { boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\";"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" +"
      },
      {
        "txt": "\" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create();"
      },
      {
        "txt": "ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null);"
      },
      {
        "txt": "} @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList();"
      },
      {
        "txt": "for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) { newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make("
      },
      {
        "txt": "cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break; } else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent();"
      },
      {
        "txt": "} else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall,"
      },
      {
        "txt": "scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } }"
      },
      {
        "txt": "private abstract class AliasUsage { final Var aliasVar; final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition);"
      },
      {
        "txt": "Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null; } public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override"
      },
      {
        "txt": "public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue(); aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); }"
      },
      {
        "txt": "@Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); }"
      },
      {
        "txt": "} private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null;"
      },
      {
        "txt": "Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() {"
      },
      {
        "txt": "return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) {"
      },
      {
        "txt": "transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); }"
      },
      {
        "txt": "if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null;"
      },
      {
        "txt": "for (; next != null || testNode.isScript();) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar);"
      },
      {
        "txt": "return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) {"
      },
      {
        "txt": "Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { <extra_id_0> Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent; String name = n.getString();"
      },
      {
        "txt": "Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(),"
      },
      {
        "txt": "globalName, value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode("
      },
      {
        "txt": "compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar);"
      },
      {
        "txt": "String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } }"
      },
      {
        "txt": "} private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return;"
      },
      {
        "txt": "} } } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) {"
      },
      {
        "txt": "renamer.addDeclaredName(s); } MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild());"
      },
      {
        "txt": "} if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null ||"
      },
      {
        "txt": "NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) {"
      },
      {
        "txt": "validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString());"
      },
      {
        "txt": "if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); }"
      },
      {
        "txt": "} if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }"
      },
      {
        "txt": "} } } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); }"
      },
      {
        "txt": "String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 452,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 368,
    "end-bug-line": 369,
    "bug": "Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() :",
    "fix": "Node value = v.getInitialValue() != null ? v.getInitialValue() :",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) {"
      },
      {
        "txt": "newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break;"
      },
      {
        "txt": "} else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar;"
      },
      {
        "txt": "final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null;"
      },
      {
        "txt": "} public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent();"
      },
      {
        "txt": "if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); <extra_id_0> null; Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName ="
      },
      {
        "txt": "scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())"
      },
      {
        "txt": ".useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName);"
      },
      {
        "txt": "int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } } private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) {"
      },
      {
        "txt": "return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; } } }"
      },
      {
        "txt": "private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s); } MakeDeclaredNamesUnique uniquifier ="
      },
      {
        "txt": "new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY);"
      },
      {
        "txt": "} if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else {"
      },
      {
        "txt": "scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) {"
      },
      {
        "txt": "return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; }"
      },
      {
        "txt": "} if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } }"
      },
      {
        "txt": "if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (aliasVar != null) {"
      },
      {
        "txt": "aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } }"
      },
      {
        "txt": "private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) {"
      },
      {
        "txt": "aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 453,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 371,
    "end-bug-line": 371,
    "bug": "Node varNode = parent;",
    "fix": "Node varNode = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\","
      },
      {
        "txt": "\"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\","
      },
      {
        "txt": "\"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable;"
      },
      {
        "txt": "this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal);"
      },
      {
        "txt": "if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) { newQueue.add(aliasUsage); } else { aliasUsage.applyAlias();"
      },
      {
        "txt": "} } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break; } else { aliasWorkQueue = newQueue; }"
      },
      {
        "txt": "} for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) {"
      },
      {
        "txt": "Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 ||"
      },
      {
        "txt": "traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar; final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar;"
      },
      {
        "txt": "this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null; } public abstract void applyAlias(); }"
      },
      {
        "txt": "private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue(); aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); }"
      },
      {
        "txt": "} private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString();"
      },
      {
        "txt": "String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList();"
      },
      {
        "txt": "private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages;"
      },
      {
        "txt": "} List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());"
      },
      {
        "txt": "} @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null;"
      },
      {
        "txt": "hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } }"
      },
      {
        "txt": "return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();"
      },
      {
        "txt": "int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments));"
      },
      {
        "txt": "hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v);"
      },
      {
        "txt": "} else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; <extra_id_0> String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\");"
      },
      {
        "txt": "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation("
      },
      {
        "txt": "newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); }"
      },
      {
        "txt": "} } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) {"
      },
      {
        "txt": "String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } } private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; }"
      },
      {
        "txt": "Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; } } } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) {"
      },
      {
        "txt": "MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s); } MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier);"
      },
      {
        "txt": "} } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); }"
      },
      {
        "txt": "} } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; }"
      },
      {
        "txt": "int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) {"
      },
      {
        "txt": "if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);"
      },
      {
        "txt": "} else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); }"
      },
      {
        "txt": "JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) {"
      },
      {
        "txt": "String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); }"
      },
      {
        "txt": "} for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 454,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 383,
    "end-bug-line": 383,
    "bug": "",
    "fix": "if (isFunctionDecl) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) {"
      },
      {
        "txt": "newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break;"
      },
      {
        "txt": "} else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar;"
      },
      {
        "txt": "final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null;"
      },
      {
        "txt": "} public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent();"
      },
      {
        "txt": "boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;"
      },
      {
        "txt": "String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); <extra_id_0> if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())"
      },
      {
        "txt": "value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name));"
      },
      {
        "txt": "recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } }"
      },
      {
        "txt": "private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; }"
      },
      {
        "txt": "} } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s);"
      },
      {
        "txt": "} MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) {"
      },
      {
        "txt": "aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } }"
      }
    ]
  },
  {
    "id": 455,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 384,
    "end-bug-line": 384,
    "bug": "",
    "fix": "Node existingName = v.getNameNode();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) {"
      },
      {
        "txt": "newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break;"
      },
      {
        "txt": "} else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar;"
      },
      {
        "txt": "final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null;"
      },
      {
        "txt": "} public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent();"
      },
      {
        "txt": "boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;"
      },
      {
        "txt": "String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); <extra_id_0> if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())"
      },
      {
        "txt": "value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name));"
      },
      {
        "txt": "recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } }"
      },
      {
        "txt": "private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; }"
      },
      {
        "txt": "} } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s);"
      },
      {
        "txt": "} MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) {"
      },
      {
        "txt": "aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } }"
      }
    ]
  },
  {
    "id": 456,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 392,
    "end-bug-line": 392,
    "bug": "",
    "fix": "Node newName = IR.name(\"\").useSourceInfoFrom(existingName); value.replaceChild(existingName, newName);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) {"
      },
      {
        "txt": "newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break;"
      },
      {
        "txt": "} else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar;"
      },
      {
        "txt": "final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null;"
      },
      {
        "txt": "} public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent();"
      },
      {
        "txt": "boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;"
      },
      {
        "txt": "String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); <extra_id_0> if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())"
      },
      {
        "txt": "value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name));"
      },
      {
        "txt": "recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } }"
      },
      {
        "txt": "private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; }"
      },
      {
        "txt": "} } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s);"
      },
      {
        "txt": "} MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) {"
      },
      {
        "txt": "aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } }"
      }
    ]
  },
  {
    "id": 457,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 393,
    "end-bug-line": 393,
    "bug": "",
    "fix": "varNode = IR.var(existingName).useSourceInfoFrom(existingName); grandparent.replaceChild(parent, varNode); } else { if (value != null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) {"
      },
      {
        "txt": "newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break;"
      },
      {
        "txt": "} else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar;"
      },
      {
        "txt": "final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null;"
      },
      {
        "txt": "} public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent();"
      },
      {
        "txt": "boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;"
      },
      {
        "txt": "String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); <extra_id_0> if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())"
      },
      {
        "txt": "value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name));"
      },
      {
        "txt": "recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } }"
      },
      {
        "txt": "private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; }"
      },
      {
        "txt": "} } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s);"
      },
      {
        "txt": "} MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) {"
      },
      {
        "txt": "aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } }"
      }
    ]
  },
  {
    "id": 458,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 395,
    "end-bug-line": 395,
    "bug": "",
    "fix": "value.detachFromParent(); } varNode = parent; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) {"
      },
      {
        "txt": "newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break;"
      },
      {
        "txt": "} else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar;"
      },
      {
        "txt": "final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null;"
      },
      {
        "txt": "} public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent();"
      },
      {
        "txt": "boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;"
      },
      {
        "txt": "String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); <extra_id_0> if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())"
      },
      {
        "txt": "value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name));"
      },
      {
        "txt": "recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } }"
      },
      {
        "txt": "private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; }"
      },
      {
        "txt": "} } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s);"
      },
      {
        "txt": "} MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) {"
      },
      {
        "txt": "aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } }"
      }
    ]
  },
  {
    "id": 459,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 408,
    "end-bug-line": 408,
    "bug": "",
    "fix": "if (isHoisted) { grandparent.addChildToFront(newDecl); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler,"
      },
      {
        "txt": "@Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); }"
      },
      {
        "txt": "@Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) {"
      },
      {
        "txt": "if (aliasUsage.referencesOtherAlias()) { newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));"
      },
      {
        "txt": "break; } else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else {"
      },
      {
        "txt": "aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock);"
      },
      {
        "txt": "NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage {"
      },
      {
        "txt": "final Var aliasVar; final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString());"
      },
      {
        "txt": "return otherAliasVar != null; } public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override"
      },
      {
        "txt": "public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } }"
      },
      {
        "txt": "private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() {"
      },
      {
        "txt": "return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors;"
      },
      {
        "txt": "} private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation("
      },
      {
        "txt": "n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) {"
      },
      {
        "txt": "renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) {"
      },
      {
        "txt": "if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) {"
      },
      {
        "txt": "next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos;"
      },
      {
        "txt": "} private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode();"
      },
      {
        "txt": "Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() :"
      },
      {
        "txt": "null; Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration("
      },
      {
        "txt": "globalName, value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); <extra_id_0> } v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else {"
      },
      {
        "txt": "recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } }"
      },
      {
        "txt": "private void findNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; }"
      },
      {
        "txt": "} } private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s);"
      },
      {
        "txt": "} MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!parent.isExprResult()) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) {"
      },
      {
        "txt": "aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } }"
      }
    ]
  },
  {
    "id": 460,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 409,
    "end-bug-line": 409,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultiset; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_CYCLE\", \"The aliases {0} has a cycle.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); private Multiset<String> scopedAliasNames = HashMultiset.create(); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { List<AliasUsage> aliasWorkQueue = Lists.newArrayList(traversal.getAliasUsages()); while (!aliasWorkQueue.isEmpty()) { List<AliasUsage> newQueue = Lists.newArrayList(); for (AliasUsage aliasUsage : aliasWorkQueue) { if (aliasUsage.referencesOtherAlias()) {"
      },
      {
        "txt": "newQueue.add(aliasUsage); } else { aliasUsage.applyAlias(); } } if (newQueue.size() == aliasWorkQueue.size()) { Var cycleVar = newQueue.get(0).aliasVar; compiler.report(JSError.make( cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName())); break;"
      },
      {
        "txt": "} else { aliasWorkQueue = newQueue; } } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private abstract class AliasUsage { final Var aliasVar;"
      },
      {
        "txt": "final Node aliasReference; AliasUsage(Var aliasVar, Node aliasReference) { this.aliasVar = aliasVar; this.aliasReference = aliasReference; } public boolean referencesOtherAlias() { Node aliasDefinition = aliasVar.getInitialValue(); Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition); Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString()); return otherAliasVar != null;"
      },
      {
        "txt": "} public abstract void applyAlias(); } private class AliasedNode extends AliasUsage { AliasedNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() { Node aliasDefinition = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode extends AliasUsage { AliasedTypeNode(Var aliasVar, Node aliasReference) { super(aliasVar, aliasReference); } @Override public void applyAlias() {"
      },
      {
        "txt": "Node aliasDefinition = aliasVar.getInitialValue(); String aliasName = aliasVar.getName(); String typeName = aliasReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\"); private boolean hasNamespaceShadows = false; private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder;"
      },
      {
        "txt": "} private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; }"
      },
      {
        "txt": "private boolean isCallToScopeMethod(Node n) { return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n));"
      },
      {
        "txt": "findAliases(t); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() > 2) { findNamespaceShadows(t); } if (t.getScopeDepth() == 2) { renameNamespaceShadows(t);"
      },
      {
        "txt": "aliases.clear(); forbiddenLocals.clear(); transformation = null; hasNamespaceShadows = false; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) {"
      },
      {
        "txt": "return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript();) { next = testNode.getNext();"
      },
      {
        "txt": "testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
      },
      {
        "txt": "private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent();"
      },
      {
        "txt": "boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;"
      },
      {
        "txt": "Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount)); compiler.ensureLibraryInjected(\"base\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(),"
      },
      {
        "txt": "value, v.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); <extra_id_0> v.getNameNode().addChildToFront( NodeUtil.newQualifiedNameNode( compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());"
      },
      {
        "txt": "} else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } private void recordAlias(Var aliasVar) { String name = aliasVar.getName(); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName();"
      },
      {
        "txt": "transformation.addAlias(name, qualifiedName); int rootIndex = qualifiedName.indexOf(\".\"); if (rootIndex != -1) { String qNameRoot = qualifiedName.substring(0, rootIndex); if (!aliases.containsKey(qNameRoot)) { forbiddenLocals.add(qNameRoot); } } } private void findNamespaceShadows(NodeTraversal t) {"
      },
      {
        "txt": "if (hasNamespaceShadows) { return; } Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { if (forbiddenLocals.contains(v.getName())) { hasNamespaceShadows = true; return; } }"
      },
      {
        "txt": "} private void renameNamespaceShadows(NodeTraversal t) { if (hasNamespaceShadows) { MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer( new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); for (String s : forbiddenLocals) { renamer.addDeclaredName(s); }"
      },
      {
        "txt": "MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!parent.isExprResult()) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);"
      },
      {
        "txt": "} else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); }"
      },
      {
        "txt": "if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar;"
      },
      {
        "txt": "} } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); }"
      },
      {
        "txt": "} if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) {"
      },
      {
        "txt": "if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } }"
      },
      {
        "txt": "} private void fixTypeNode(Node typeNode) { if (typeNode.isString()) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName);"
      },
      {
        "txt": "if (aliasVar != null) { aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode)); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 461,
    "file_path": "src/com/google/javascript/rhino/Node.java",
    "start-bug-line": 554,
    "end-bug-line": 554,
    "bug": "",
    "fix": "if (n == null) { throw new RuntimeException(\"node is not a child\"); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Objects;"
      },
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.SimpleSourceFile; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.io.IOException; import java.io.Serializable; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.NoSuchElementException;"
      },
      {
        "txt": "import java.util.Set; public class Node implements Cloneable, Serializable { private static final long serialVersionUID = 1L; public static final int JSDOC_INFO_PROP = 29, // contains a TokenStream.JSDocInfo object VAR_ARGS_NAME = 30, // the name node is a variable length INCRDECR_PROP = 32, // pre or post type of increment/decrement QUOTED_PROP = 36, // set to indicate a quoted object lit key OPT_ARG_NAME = 37, // The name node is an optional argument. SYNTHETIC_BLOCK_PROP = 38, // A synthetic block. Used to make"
      },
      {
        "txt": "EMPTY_BLOCK = 39, // Used to indicate BLOCK that replaced ORIGINALNAME_PROP = 40, // The original name of the node, before SIDE_EFFECT_FLAGS = 42, // Function or constructor call side effect IS_CONSTANT_NAME = 43, // The variable or property is constant. IS_NAMESPACE = 46, // The variable creates a namespace. IS_DISPATCHER = 47, // The function is a dispatcher function, DIRECTIVES = 48, // The ES5 directives on this node. DIRECT_EVAL = 49, // ES5 distinguishes between direct and FREE_CALL = 50, // A CALL without an explicit \"this\" value. STATIC_SOURCE_FILE = 51, // A StaticSourceFile indicating the file"
      },
      {
        "txt": "LENGTH = 52, // The length of the code represented by INPUT_ID = 53, // The id of the input associated with this SLASH_V = 54, // Whether a STRING node contains a \\v INFERRED_FUNCTION = 55, // Marks a function whose parameter types CHANGE_TIME = 56, // For passes that work only on changed funs. REFLECTED_OBJECT = 57, // An object that's used for goog.object.reflect-style reflection. LAST_PROP = 57; // Unused in the compiler, but keep for Rhino. public static final int // flags for INCRDECR_PROP DECR_FLAG = 0x1, POST_FLAG = 0x2;"
      },
      {
        "txt": "private static final String propToString(int propType) { switch (propType) { case VAR_ARGS_NAME: return \"var_args_name\"; case JSDOC_INFO_PROP: return \"jsdoc_info\"; case INCRDECR_PROP: return \"incrdecr\"; case QUOTED_PROP: return \"quoted\"; case OPT_ARG_NAME: return \"opt_arg\"; case SYNTHETIC_BLOCK_PROP: return \"synthetic\"; case EMPTY_BLOCK: return \"empty_block\"; case ORIGINALNAME_PROP: return \"originalname\";"
      },
      {
        "txt": "case SIDE_EFFECT_FLAGS: return \"side_effect_flags\"; case IS_CONSTANT_NAME: return \"is_constant_name\"; case IS_NAMESPACE: return \"is_namespace\"; case IS_DISPATCHER: return \"is_dispatcher\"; case DIRECTIVES: return \"directives\"; case DIRECT_EVAL: return \"direct_eval\"; case FREE_CALL: return \"free_call\"; case STATIC_SOURCE_FILE: return \"source_file\"; case INPUT_ID: return \"input_id\"; case LENGTH: return \"length\";"
      },
      {
        "txt": "case SLASH_V: return \"slash_v\"; case INFERRED_FUNCTION: return \"inferred\"; case CHANGE_TIME: return \"change_time\"; case REFLECTED_OBJECT: return \"reflected_object\"; default: throw new IllegalStateException(\"unexpected prop id \" + propType); } } private static class NumberNode extends Node { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "NumberNode(double number) { super(Token.NUMBER); this.number = number; } public NumberNode(double number, int lineno, int charno) { super(Token.NUMBER, lineno, charno); this.number = number; } @Override public double getDouble() {"
      },
      {
        "txt": "return this.number; } @Override public void setDouble(double d) { this.number = d; } @Override boolean isEquivalentTo( Node node, boolean compareJsType, boolean recur, boolean shallow) { boolean equiv = super.isEquivalentTo(node, compareJsType, recur, shallow);"
      },
      {
        "txt": "if (equiv) { double thisValue = getDouble(); double thatValue = ((NumberNode) node).getDouble(); if (thisValue == thatValue) { return (thisValue != 0.0) || (1 / thisValue == 1 / thatValue); } } return false; } private double number;"
      },
      {
        "txt": "} private static class StringNode extends Node { private static final long serialVersionUID = 1L; StringNode(int type, String str) { super(type); if (null == str) { throw new IllegalArgumentException(\"StringNode: str is null\"); } this.str = str; }"
      },
      {
        "txt": "StringNode(int type, String str, int lineno, int charno) { super(type, lineno, charno); if (null == str) { throw new IllegalArgumentException(\"StringNode: str is null\"); } this.str = str; } @Override public String getString() { return this.str;"
      },
      {
        "txt": "} @Override public void setString(String str) { if (null == str) { throw new IllegalArgumentException(\"StringNode: str is null\"); } this.str = str; } @Override boolean isEquivalentTo("
      },
      {
        "txt": "Node node, boolean compareJsType, boolean recur, boolean shallow) { return (super.isEquivalentTo(node, compareJsType, recur, shallow) && this.str.equals(((StringNode) node).str)); } @Override public boolean isQuotedString() { return getBooleanProp(QUOTED_PROP); } @Override public void setQuotedString() {"
      },
      {
        "txt": "putBooleanProp(QUOTED_PROP, true); } private String str; } private interface PropListItem { int getType(); PropListItem getNext(); PropListItem chain(PropListItem next); Object getObjectValue(); int getIntValue();"
      },
      {
        "txt": "} private abstract static class AbstractPropListItem implements PropListItem, Serializable { private static final long serialVersionUID = 1L; private final PropListItem next; private final int propType; AbstractPropListItem(int propType, PropListItem next) { this.propType = propType; this.next = next; }"
      },
      {
        "txt": "@Override public int getType() { return propType; } @Override public PropListItem getNext() { return next; } @Override public abstract PropListItem chain(PropListItem next);"
      },
      {
        "txt": "} private static class ObjectPropListItem extends AbstractPropListItem { private static final long serialVersionUID = 1L; private final Object objectValue; ObjectPropListItem(int propType, Object objectValue, PropListItem next) { super(propType, next); this.objectValue = objectValue; } @Override"
      },
      {
        "txt": "public int getIntValue() { throw new UnsupportedOperationException(); } @Override public Object getObjectValue() { return objectValue; } @Override public String toString() { return objectValue == null ? \"null\" : objectValue.toString();"
      },
      {
        "txt": "} @Override public PropListItem chain(PropListItem next) { return new ObjectPropListItem(getType(), objectValue, next); } } private static class IntPropListItem extends AbstractPropListItem { private static final long serialVersionUID = 1L; final int intValue; IntPropListItem(int propType, int intValue, PropListItem next) {"
      },
      {
        "txt": "super(propType, next); this.intValue = intValue; } @Override public int getIntValue() { return intValue; } @Override public Object getObjectValue() { throw new UnsupportedOperationException();"
      },
      {
        "txt": "} @Override public String toString() { return String.valueOf(intValue); } @Override public PropListItem chain(PropListItem next) { return new IntPropListItem(getType(), intValue, next); } }"
      },
      {
        "txt": "public Node(int nodeType) { type = nodeType; parent = null; sourcePosition = -1; } public Node(int nodeType, Node child) { Preconditions.checkArgument(child.parent == null, \"new child has existing parent\"); Preconditions.checkArgument(child.next == null, \"new child has existing sibling\");"
      },
      {
        "txt": "type = nodeType; parent = null; first = last = child; child.next = null; child.parent = this; sourcePosition = -1; } public Node(int nodeType, Node left, Node right) { Preconditions.checkArgument(left.parent == null, \"first new child has existing parent\");"
      },
      {
        "txt": "Preconditions.checkArgument(left.next == null, \"first new child has existing sibling\"); Preconditions.checkArgument(right.parent == null, \"second new child has existing parent\"); Preconditions.checkArgument(right.next == null, \"second new child has existing sibling\"); type = nodeType; parent = null; first = left; last = right;"
      },
      {
        "txt": "left.next = right; left.parent = this; right.next = null; right.parent = this; sourcePosition = -1; } public Node(int nodeType, Node left, Node mid, Node right) { Preconditions.checkArgument(left.parent == null); Preconditions.checkArgument(left.next == null); Preconditions.checkArgument(mid.parent == null);"
      },
      {
        "txt": "Preconditions.checkArgument(mid.next == null); Preconditions.checkArgument(right.parent == null); Preconditions.checkArgument(right.next == null); type = nodeType; parent = null; first = left; last = right; left.next = mid; left.parent = this; mid.next = right;"
      },
      {
        "txt": "mid.parent = this; right.next = null; right.parent = this; sourcePosition = -1; } public Node(int nodeType, Node left, Node mid, Node mid2, Node right) { Preconditions.checkArgument(left.parent == null); Preconditions.checkArgument(left.next == null); Preconditions.checkArgument(mid.parent == null); Preconditions.checkArgument(mid.next == null);"
      },
      {
        "txt": "Preconditions.checkArgument(mid2.parent == null); Preconditions.checkArgument(mid2.next == null); Preconditions.checkArgument(right.parent == null); Preconditions.checkArgument(right.next == null); type = nodeType; parent = null; first = left; last = right; left.next = mid; left.parent = this;"
      },
      {
        "txt": "mid.next = mid2; mid.parent = this; mid2.next = right; mid2.parent = this; right.next = null; right.parent = this; sourcePosition = -1; } public Node(int nodeType, int lineno, int charno) { type = nodeType;"
      },
      {
        "txt": "parent = null; sourcePosition = mergeLineCharNo(lineno, charno); } public Node(int nodeType, Node child, int lineno, int charno) { this(nodeType, child); sourcePosition = mergeLineCharNo(lineno, charno); } public Node(int nodeType, Node left, Node right, int lineno, int charno) { this(nodeType, left, right); sourcePosition = mergeLineCharNo(lineno, charno);"
      },
      {
        "txt": "} public Node(int nodeType, Node left, Node mid, Node right, int lineno, int charno) { this(nodeType, left, mid, right); sourcePosition = mergeLineCharNo(lineno, charno); } public Node(int nodeType, Node left, Node mid, Node mid2, Node right, int lineno, int charno) { this(nodeType, left, mid, mid2, right); sourcePosition = mergeLineCharNo(lineno, charno);"
      },
      {
        "txt": "} public Node(int nodeType, Node[] children, int lineno, int charno) { this(nodeType, children); sourcePosition = mergeLineCharNo(lineno, charno); } public Node(int nodeType, Node[] children) { this.type = nodeType; parent = null; if (children.length != 0) { this.first = children[0];"
      },
      {
        "txt": "this.last = children[children.length - 1]; for (int i = 1; i < children.length; i++) { if (null != children[i - 1].next) { throw new IllegalArgumentException(\"duplicate child\"); } children[i - 1].next = children[i]; Preconditions.checkArgument(children[i - 1].parent == null); children[i - 1].parent = this; } Preconditions.checkArgument(children[children.length - 1].parent == null);"
      },
      {
        "txt": "children[children.length - 1].parent = this; if (null != this.last.next) { throw new IllegalArgumentException(\"duplicate child\"); } } } public static Node newNumber(double number) { return new NumberNode(number); } public static Node newNumber(double number, int lineno, int charno) {"
      },
      {
        "txt": "return new NumberNode(number, lineno, charno); } public static Node newString(String str) { return new StringNode(Token.STRING, str); } public static Node newString(int type, String str) { return new StringNode(type, str); } public static Node newString(String str, int lineno, int charno) { return new StringNode(Token.STRING, str, lineno, charno);"
      },
      {
        "txt": "} public static Node newString(int type, String str, int lineno, int charno) { return new StringNode(type, str, lineno, charno); } public int getType() { return type; } public void setType(int type) { this.type = type; }"
      },
      {
        "txt": "public boolean hasChildren() { return first != null; } public Node getFirstChild() { return first; } public Node getLastChild() { return last; } public Node getNext() {"
      },
      {
        "txt": "} public Node getChildBefore(Node child) { if (child == first) { return null; } Node n = first; <extra_id_0> while (n.next != child) { n = n.next; if (n == null) { throw new RuntimeException(\"node is not a child\"); } }"
      },
      {
        "txt": "} } return n; } public Node getChildAtIndex(int i) { Node n = first; while (i > 0) { n = n.next; i--; }"
      },
      {
        "txt": "return n; } public int getIndexOfChild(Node child) { Node n = first; int i = 0; while (n != null) { if (child == n) { return i; } n = n.next;"
      },
      {
        "txt": "i++; } return -1; } public Node getLastSibling() { Node n = this; while (n.next != null) { n = n.next; } return n;"
      },
      {
        "txt": "} public void addChildToFront(Node child) { Preconditions.checkArgument(child.parent == null); Preconditions.checkArgument(child.next == null); child.parent = this; child.next = first; first = child; if (last == null) { last = child; }"
      },
      {
        "txt": "} public void addChildToBack(Node child) { Preconditions.checkArgument(child.parent == null); Preconditions.checkArgument(child.next == null); child.parent = this; child.next = null; if (last == null) { first = last = child; return; }"
      },
      {
        "txt": "last.next = child; last = child; } public void addChildrenToFront(Node children) { for (Node child = children; child != null; child = child.next) { Preconditions.checkArgument(child.parent == null); child.parent = this; } Node lastSib = children.getLastSibling(); lastSib.next = first;"
      },
      {
        "txt": "first = children; if (last == null) { last = lastSib; } } public void addChildrenToBack(Node children) { addChildrenAfter(children, getLastChild()); } public void addChildBefore(Node newChild, Node node) { Preconditions.checkArgument(node != null && node.parent == this,"
      },
      {
        "txt": "\"The existing child node of the parent should not be null.\"); Preconditions.checkArgument(newChild.next == null, \"The new child node has siblings.\"); Preconditions.checkArgument(newChild.parent == null, \"The new child node already has a parent.\"); if (first == node) { newChild.parent = this; newChild.next = first; first = newChild; return;"
      },
      {
        "txt": "} Node prev = getChildBefore(node); addChildAfter(newChild, prev); } public void addChildAfter(Node newChild, Node node) { Preconditions.checkArgument(newChild.next == null, \"The new child node has siblings.\"); addChildrenAfter(newChild, node); } public void addChildrenAfter(Node children, Node node) {"
      },
      {
        "txt": "Preconditions.checkArgument(node == null || node.parent == this); for (Node child = children; child != null; child = child.next) { Preconditions.checkArgument(child.parent == null); child.parent = this; } Node lastSibling = children.getLastSibling(); if (node != null) { Node oldNext = node.next; node.next = children; lastSibling.next = oldNext;"
      },
      {
        "txt": "if (node == last) { last = lastSibling; } } else { if (first != null) { lastSibling.next = first; } else { last = lastSibling; } first = children;"
      },
      {
        "txt": "} } public void removeChild(Node child) { Node prev = getChildBefore(child); if (prev == null) { first = first.next; } else { prev.next = child.next; } if (child == last) {"
      },
      {
        "txt": "last = prev; } child.next = null; child.parent = null; } public void replaceChild(Node child, Node newChild) { Preconditions.checkArgument(newChild.next == null, \"The new child node has siblings.\"); Preconditions.checkArgument(newChild.parent == null, \"The new child node already has a parent.\");"
      },
      {
        "txt": "newChild.copyInformationFrom(child); newChild.next = child.next; newChild.parent = this; if (child == first) { first = newChild; } else { Node prev = getChildBefore(child); prev.next = newChild; } if (child == last) {"
      },
      {
        "txt": "last = newChild; } child.next = null; child.parent = null; } public void replaceChildAfter(Node prevChild, Node newChild) { Preconditions.checkArgument(prevChild.parent == this, \"prev is not a child of this node.\"); Preconditions.checkArgument(newChild.next == null, \"The new child node has siblings.\");"
      },
      {
        "txt": "Preconditions.checkArgument(newChild.parent == null, \"The new child node already has a parent.\"); newChild.copyInformationFrom(prevChild); Node child = prevChild.next; newChild.next = child.next; newChild.parent = this; prevChild.next = newChild; if (child == last) { last = newChild; }"
      },
      {
        "txt": "child.next = null; child.parent = null; } @VisibleForTesting PropListItem lookupProperty(int propType) { PropListItem x = propListHead; while (x != null && propType != x.getType()) { x = x.getNext(); } return x;"
      },
      {
        "txt": "} public Node clonePropsFrom(Node other) { Preconditions.checkState(this.propListHead == null, \"Node has existing properties.\"); this.propListHead = other.propListHead; return this; } public void removeProp(int propType) { PropListItem result = removeProp(propListHead, propType); if (result != propListHead) {"
      },
      {
        "txt": "propListHead = result; } } private PropListItem removeProp(PropListItem item, int propType) { if (item == null) { return null; } else if (item.getType() == propType) { return item.getNext(); } else { PropListItem result = removeProp(item.getNext(), propType);"
      },
      {
        "txt": "if (result != item.getNext()) { return item.chain(result); } else { return item; } } } public Object getProp(int propType) { PropListItem item = lookupProperty(propType); if (item == null) {"
      },
      {
        "txt": "return null; } return item.getObjectValue(); } public boolean getBooleanProp(int propType) { return getIntProp(propType) != 0; } public int getIntProp(int propType) { PropListItem item = lookupProperty(propType); if (item == null) {"
      },
      {
        "txt": "return 0; } return item.getIntValue(); } public int getExistingIntProp(int propType) { PropListItem item = lookupProperty(propType); if (item == null) { throw new IllegalStateException(\"missing prop: \" + propType); } return item.getIntValue();"
      },
      {
        "txt": "} public void putProp(int propType, Object value) { removeProp(propType); if (value != null) { propListHead = createProp(propType, value, propListHead); } } public void putBooleanProp(int propType, boolean value) { putIntProp(propType, value ? 1 : 0); }"
      },
      {
        "txt": "public void putIntProp(int propType, int value) { removeProp(propType); if (value != 0) { propListHead = createProp(propType, value, propListHead); } } PropListItem createProp(int propType, Object value, PropListItem next) { return new ObjectPropListItem(propType, value, next); } PropListItem createProp(int propType, int value, PropListItem next) {"
      },
      {
        "txt": "return new IntPropListItem(propType, value, next); } private int[] getSortedPropTypes() { int count = 0; for (PropListItem x = propListHead; x != null; x = x.getNext()) { count++; } int[] keys = new int[count]; for (PropListItem x = propListHead; x != null; x = x.getNext()) { count--;"
      },
      {
        "txt": "keys[count] = x.getType(); } Arrays.sort(keys); return keys; } public double getDouble() throws UnsupportedOperationException { if (this.getType() == Token.NUMBER) { throw new IllegalStateException( \"Number node not created with Node.newNumber\"); } else {"
      },
      {
        "txt": "throw new UnsupportedOperationException(this + \" is not a number node\"); } } public void setDouble(double value) throws UnsupportedOperationException { if (this.getType() == Token.NUMBER) { throw new IllegalStateException( \"Number node not created with Node.newNumber\"); } else { throw new UnsupportedOperationException(this + \" is not a string node\"); }"
      },
      {
        "txt": "} public String getString() throws UnsupportedOperationException { if (this.getType() == Token.STRING) { throw new IllegalStateException( \"String node not created with Node.newString\"); } else { throw new UnsupportedOperationException(this + \" is not a string node\"); } } public void setString(String value) throws UnsupportedOperationException {"
      },
      {
        "txt": "if (this.getType() == Token.STRING || this.getType() == Token.NAME) { throw new IllegalStateException( \"String node not created with Node.newString\"); } else { throw new UnsupportedOperationException(this + \" is not a string node\"); } } @Override public String toString() { return toString(true, true, true);"
      },
      {
        "txt": "} public String toString( boolean printSource, boolean printAnnotations, boolean printType) { StringBuilder sb = new StringBuilder(); toString(sb, printSource, printAnnotations, printType); return sb.toString(); } private void toString("
      },
      {
        "txt": "StringBuilder sb, boolean printSource, boolean printAnnotations, boolean printType) { sb.append(Token.name(type)); if (this instanceof StringNode) { sb.append(' '); sb.append(getString()); } else if (type == Token.FUNCTION) { sb.append(' ');"
      },
      {
        "txt": "if (first == null || first.getType() != Token.NAME) { sb.append(\"<invalid>\"); } else { sb.append(first.getString()); } } else if (type == Token.NUMBER) { sb.append(' '); sb.append(getDouble()); } if (printSource) {"
      },
      {
        "txt": "int lineno = getLineno(); if (lineno != -1) { sb.append(' '); sb.append(lineno); } } if (printAnnotations) { int[] keys = getSortedPropTypes(); for (int i = 0; i < keys.length; i++) { int type = keys[i];"
      },
      {
        "txt": "PropListItem x = lookupProperty(type); sb.append(\" [\"); sb.append(propToString(type)); sb.append(\": \"); String value; switch (type) { default: value = x.toString(); break; }"
      },
      {
        "txt": "sb.append(value); sb.append(']'); } } if (printType) { if (jsType != null) { String jsTypeString = jsType.toString(); if (jsTypeString != null) { sb.append(\" : \"); sb.append(jsTypeString);"
      },
      {
        "txt": "} } } } public String toStringTree() { return toStringTreeImpl(); } private String toStringTreeImpl() { try { StringBuilder s = new StringBuilder();"
      },
      {
        "txt": "appendStringTree(s); return s.toString(); } catch (IOException e) { throw new RuntimeException(\"Should not happen\\n\" + e); } } public void appendStringTree(Appendable appendable) throws IOException { toStringTreeHelper(this, 0, appendable); } private static void toStringTreeHelper(Node n, int level, Appendable sb)"
      },
      {
        "txt": "throws IOException { for (int i = 0; i != level; ++i) { sb.append(\" \"); } sb.append(n.toString()); sb.append('\\n'); for (Node cursor = n.getFirstChild(); cursor != null; cursor = cursor.getNext()) { toStringTreeHelper(cursor, level + 1, sb);"
      },
      {
        "txt": "} } int type; // type of the node; Token.NAME for example Node next; // next sibling private Node first; // first element of a linked list of children private Node last; // last element of a linked list of children private PropListItem propListHead; public static final int COLUMN_BITS = 12; public static final int MAX_COLUMN_NUMBER = (1 << COLUMN_BITS) - 1; public static final int COLUMN_MASK = MAX_COLUMN_NUMBER;"
      },
      {
        "txt": "private int sourcePosition; private JSType jsType; private Node parent; public void setStaticSourceFile(StaticSourceFile file) { this.putProp(STATIC_SOURCE_FILE, file); } public void setSourceFileForTesting(String name) { this.putProp(STATIC_SOURCE_FILE, new SimpleSourceFile(name, false)); } public String getSourceFileName() {"
      },
      {
        "txt": "StaticSourceFile file = getStaticSourceFile(); return file == null ? null : file.getName(); } public StaticSourceFile getStaticSourceFile() { return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE)); } public void setInputId(InputId inputId) { this.putProp(INPUT_ID, inputId); } public InputId getInputId() {"
      },
      {
        "txt": "return ((InputId) this.getProp(INPUT_ID)); } public boolean isFromExterns() { StaticSourceFile file = getStaticSourceFile(); return file == null ? false : file.isExtern(); } public int getLength() { return getIntProp(LENGTH); } public void setLength(int length) {"
      },
      {
        "txt": "putIntProp(LENGTH, length); } public int getLineno() { return extractLineno(sourcePosition); } public int getCharno() { return extractCharno(sourcePosition); } public int getSourceOffset() { StaticSourceFile file = getStaticSourceFile();"
      },
      {
        "txt": "if (file == null) { return -1; } int lineno = getLineno(); if (lineno == -1) { return -1; } return file.getLineOffset(lineno) + getCharno(); } public int getSourcePosition() {"
      },
      {
        "txt": "return sourcePosition; } public void setLineno(int lineno) { int charno = getCharno(); if (charno == -1) { charno = 0; } sourcePosition = mergeLineCharNo(lineno, charno); } public void setCharno(int charno) {"
      },
      {
        "txt": "sourcePosition = mergeLineCharNo(getLineno(), charno); } public void setSourceEncodedPosition(int sourcePosition) { this.sourcePosition = sourcePosition; } public void setSourceEncodedPositionForTree(int sourcePosition) { this.sourcePosition = sourcePosition; for (Node child = getFirstChild(); child != null; child = child.getNext()) { child.setSourceEncodedPositionForTree(sourcePosition);"
      },
      {
        "txt": "} } protected static int mergeLineCharNo(int lineno, int charno) { if (lineno < 0 || charno < 0) { return -1; } else if ((charno & ~COLUMN_MASK) != 0) { return lineno << COLUMN_BITS | COLUMN_MASK; } else { return lineno << COLUMN_BITS | (charno & COLUMN_MASK); }"
      },
      {
        "txt": "} protected static int extractLineno(int lineCharNo) { if (lineCharNo == -1) { return -1; } else { return lineCharNo >>> COLUMN_BITS; } } protected static int extractCharno(int lineCharNo) { if (lineCharNo == -1) {"
      },
      {
        "txt": "return -1; } else { return lineCharNo & COLUMN_MASK; } } public Iterable<Node> children() { if (first == null) { return Collections.emptySet(); } else { return new SiblingNodeIterable(first);"
      },
      {
        "txt": "} } public Iterable<Node> siblings() { return new SiblingNodeIterable(this); } private static final class SiblingNodeIterable implements Iterable<Node>, Iterator<Node> { private final Node start; private Node current; private boolean used;"
      },
      {
        "txt": "SiblingNodeIterable(Node start) { this.start = start; this.current = start; this.used = false; } @Override public Iterator<Node> iterator() { if (!used) { used = true; return this;"
      },
      {
        "txt": "} else { return (new SiblingNodeIterable(start)).iterator(); } } @Override public boolean hasNext() { return current != null; } @Override public Node next() {"
      },
      {
        "txt": "if (current == null) { throw new NoSuchElementException(); } try { return current; } finally { current = current.getNext(); } } @Override"
      },
      {
        "txt": "public void remove() { throw new UnsupportedOperationException(); } } PropListItem getPropListHeadForTesting() { return propListHead; } public Node getParent() { return parent; }"
      },
      {
        "txt": "public Node getAncestor(int level) { Preconditions.checkArgument(level >= 0); Node node = this; while (node != null && level-- > 0) { node = node.getParent(); } return node; } public AncestorIterable getAncestors() { return new AncestorIterable(this.getParent());"
      },
      {
        "txt": "} public static class AncestorIterable implements Iterable<Node> { private Node cur; AncestorIterable(Node cur) { this.cur = cur; } @Override public Iterator<Node> iterator() { return new Iterator<Node>() { @Override"
      },
      {
        "txt": "public boolean hasNext() { return cur != null; } @Override public Node next() { if (!hasNext()) { throw new NoSuchElementException(); } Node n = cur; cur = cur.getParent();"
      },
      {
        "txt": "return n; } @Override public void remove() { throw new UnsupportedOperationException(); } }; } } public boolean hasOneChild() {"
      },
      {
        "txt": "return first != null && first == last; } public boolean hasMoreThanOneChild() { return first != null && first != last; } public int getChildCount() { int c = 0; for (Node n = first; n != null; n = n.next) { c++; }"
      },
      {
        "txt": "return c; } public boolean hasChild(Node child) { for (Node n = first; n != null; n = n.getNext()) { if (child == n) { return true; } } return false; }"
      },
      {
        "txt": "public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\" + node2.toStringTree() + \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() + \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree(); } return null;"
      },
      {
        "txt": "} NodeMismatch checkTreeEqualsImpl(Node node2) { if (!isEquivalentTo(node2, false, false, false)) { return new NodeMismatch(this, node2); } NodeMismatch res = null; Node n, n2; for (n = first, n2 = node2.first; res == null && n != null; n = n.next, n2 = n2.next) {"
      },
      {
        "txt": "if (node2 == null) { throw new IllegalStateException(); } res = n.checkTreeEqualsImpl(n2); if (res != null) { return res; } } return res; }"
      },
      {
        "txt": "NodeMismatch checkTreeTypeAwareEqualsImpl(Node node2) { if (!isEquivalentTo(node2, true, false, false)) { return new NodeMismatch(this, node2); } NodeMismatch res = null; Node n, n2; for (n = first, n2 = node2.first; res == null && n != null; n = n.next, n2 = n2.next) { res = n.checkTreeTypeAwareEqualsImpl(n2);"
      },
      {
        "txt": "if (res != null) { return res; } } return res; } public boolean isEquivalentTo(Node node) { return isEquivalentTo(node, false, true, false); } public boolean isEquivalentToShallow(Node node) {"
      },
      {
        "txt": "return isEquivalentTo(node, false, true, true); } public boolean isEquivalentToTyped(Node node) { return isEquivalentTo(node, true, true, false); } boolean isEquivalentTo( Node node, boolean compareJsType, boolean recur, boolean shallow) { if (type != node.getType() || getChildCount() != node.getChildCount() || this.getClass() != node.getClass()) {"
      },
      {
        "txt": "return false; } if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) { return false; } if (type == Token.INC || type == Token.DEC) { int post1 = this.getIntProp(INCRDECR_PROP); int post2 = node.getIntProp(INCRDECR_PROP); if (post1 != post2) { return false;"
      },
      {
        "txt": "} } else if (type == Token.STRING || type == Token.STRING_KEY) { if (type == Token.STRING_KEY) { int quoted1 = this.getIntProp(QUOTED_PROP); int quoted2 = node.getIntProp(QUOTED_PROP); if (quoted1 != quoted2) { return false; } } int slashV1 = this.getIntProp(SLASH_V);"
      },
      {
        "txt": "int slashV2 = node.getIntProp(SLASH_V); if (slashV1 != slashV2) { return false; } } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { return false; } } if (recur) {"
      },
      {
        "txt": "Node n, n2; for (n = first, n2 = node.first; n != null; n = n.next, n2 = n2.next) { if (!n.isEquivalentTo( n2, compareJsType, !(shallow && n.isFunction()), shallow)) { return false; } } }"
      },
      {
        "txt": "return true; } public String getQualifiedName() { if (type == Token.NAME) { String name = getString(); return name.isEmpty() ? null : name; } else if (type == Token.GETPROP) { String left = getFirstChild().getQualifiedName(); if (left == null) { return null;"
      },
      {
        "txt": "} return left + \".\" + getLastChild().getString(); } else if (type == Token.THIS) { return \"this\"; } else { return null; } } public boolean isQualifiedName() { switch (getType()) {"
      },
      {
        "txt": "case Token.NAME: return getString().isEmpty() ? false : true; case Token.THIS: return true; case Token.GETPROP: return getFirstChild().isQualifiedName(); default: return false; } }"
      },
      {
        "txt": "public boolean isUnscopedQualifiedName() { switch (getType()) { case Token.NAME: return getString().isEmpty() ? false : true; case Token.GETPROP: return getFirstChild().isUnscopedQualifiedName(); default: return false; } }"
      },
      {
        "txt": "public Node detachFromParent() { Preconditions.checkState(parent != null); parent.removeChild(this); return this; } public Node removeFirstChild() { Node child = first; if (child != null) { removeChild(child); }"
      },
      {
        "txt": "return child; } public Node removeChildren() { Node children = first; for (Node child = first; child != null; child = child.getNext()) { child.parent = null; } first = null; last = null; return children;"
      },
      {
        "txt": "} public void detachChildren() { for (Node child = first; child != null;) { Node nextChild = child.getNext(); child.parent = null; child.next = null; child = nextChild; } first = null; last = null;"
      },
      {
        "txt": "} public Node removeChildAfter(Node prev) { Preconditions.checkArgument(prev.parent == this, \"prev is not a child of this node.\"); Preconditions.checkArgument(prev.next != null, \"no next sibling.\"); Node child = prev.next; prev.next = child.next; if (child == last) { last = prev;"
      },
      {
        "txt": "} child.next = null; child.parent = null; return child; } public Node cloneNode() { Node result; try { result = (Node) super.clone(); result.next = null;"
      },
      {
        "txt": "result.first = null; result.last = null; result.parent = null; } catch (CloneNotSupportedException e) { throw new RuntimeException(e.getMessage()); } return result; } public Node cloneTree() { Node result = cloneNode();"
      },
      {
        "txt": "for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) { Node n2clone = n2.cloneTree(); n2clone.parent = result; if (result.last != null) { result.last.next = n2clone; } if (result.first == null) { result.first = n2clone; } result.last = n2clone;"
      },
      {
        "txt": "} return result; } public Node copyInformationFrom(Node other) { if (getProp(ORIGINALNAME_PROP) == null) { putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP)); } if (getProp(STATIC_SOURCE_FILE) == null) { putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE)); sourcePosition = other.sourcePosition;"
      },
      {
        "txt": "} return this; } public Node copyInformationFromForTree(Node other) { copyInformationFrom(other); for (Node child = getFirstChild(); child != null; child = child.getNext()) { child.copyInformationFromForTree(other); } return this;"
      },
      {
        "txt": "} public Node useSourceInfoFrom(Node other) { putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP)); putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE)); sourcePosition = other.sourcePosition; return this; } public Node srcref(Node other) { return useSourceInfoFrom(other); }"
      },
      {
        "txt": "public Node useSourceInfoFromForTree(Node other) { useSourceInfoFrom(other); for (Node child = getFirstChild(); child != null; child = child.getNext()) { child.useSourceInfoFromForTree(other); } return this; } public Node srcrefTree(Node other) { return useSourceInfoFromForTree(other);"
      },
      {
        "txt": "} public Node useSourceInfoIfMissingFrom(Node other) { if (getProp(ORIGINALNAME_PROP) == null) { putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP)); } if (getProp(STATIC_SOURCE_FILE) == null) { putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE)); sourcePosition = other.sourcePosition; } return this;"
      },
      {
        "txt": "} public Node useSourceInfoIfMissingFromForTree(Node other) { useSourceInfoIfMissingFrom(other); for (Node child = getFirstChild(); child != null; child = child.getNext()) { child.useSourceInfoIfMissingFromForTree(other); } return this; } public JSType getJSType() {"
      },
      {
        "txt": "return jsType; } public void setJSType(JSType jsType) { this.jsType = jsType; } public FileLevelJsDocBuilder getJsDocBuilderForNode() { return new FileLevelJsDocBuilder(); } public class FileLevelJsDocBuilder { public void append(String fileLevelComment) {"
      },
      {
        "txt": "JSDocInfo jsDocInfo = getJSDocInfo(); if (jsDocInfo == null) { jsDocInfo = new JSDocInfo(false); } String license = jsDocInfo.getLicense(); if (license == null) { license = \"\"; } jsDocInfo.setLicense(license + fileLevelComment); setJSDocInfo(jsDocInfo);"
      },
      {
        "txt": "} } public JSDocInfo getJSDocInfo() { return (JSDocInfo) getProp(JSDOC_INFO_PROP); } public Node setJSDocInfo(JSDocInfo info) { putProp(JSDOC_INFO_PROP, info); return this; } public void setChangeTime(int time) {"
      },
      {
        "txt": "putIntProp(CHANGE_TIME, time); } public int getChangeTime() { return getIntProp(CHANGE_TIME); } public void setVarArgs(boolean varArgs) { putBooleanProp(VAR_ARGS_NAME, varArgs); } public boolean isVarArgs() { return getBooleanProp(VAR_ARGS_NAME);"
      },
      {
        "txt": "} public void setOptionalArg(boolean optionalArg) { putBooleanProp(OPT_ARG_NAME, optionalArg); } public boolean isOptionalArg() { return getBooleanProp(OPT_ARG_NAME); } public void setIsSyntheticBlock(boolean val) { putBooleanProp(SYNTHETIC_BLOCK_PROP, val); }"
      },
      {
        "txt": "public boolean isSyntheticBlock() { return getBooleanProp(SYNTHETIC_BLOCK_PROP); } public void setDirectives(Set<String> val) { putProp(DIRECTIVES, val); } @SuppressWarnings(\"unchecked\") public Set<String> getDirectives() { return (Set<String>) getProp(DIRECTIVES); }"
      },
      {
        "txt": "public void addSuppression(String warning) { if (getJSDocInfo() == null) { setJSDocInfo(new JSDocInfo(false)); } getJSDocInfo().addSuppression(warning); } public void setWasEmptyNode(boolean val) { putBooleanProp(EMPTY_BLOCK, val); } public boolean wasEmptyNode() {"
      },
      {
        "txt": "return getBooleanProp(EMPTY_BLOCK); } public static final int FLAG_GLOBAL_STATE_UNMODIFIED = 1; public static final int FLAG_THIS_UNMODIFIED = 2; public static final int FLAG_ARGUMENTS_UNMODIFIED = 4; public static final int FLAG_NO_THROWS = 8; public static final int FLAG_LOCAL_RESULTS = 16; public static final int SIDE_EFFECTS_FLAGS_MASK = 31; public static final int SIDE_EFFECTS_ALL = 0; public static final int NO_SIDE_EFFECTS ="
      },
      {
        "txt": "FLAG_GLOBAL_STATE_UNMODIFIED | FLAG_THIS_UNMODIFIED | FLAG_ARGUMENTS_UNMODIFIED | FLAG_NO_THROWS; public void setSideEffectFlags(int flags) { Preconditions.checkArgument( getType() == Token.CALL || getType() == Token.NEW, \"setIsNoSideEffectsCall only supports CALL and NEW nodes, got \" + Token.name(getType())); putIntProp(SIDE_EFFECT_FLAGS, flags);"
      },
      {
        "txt": "} public void setSideEffectFlags(SideEffectFlags flags) { setSideEffectFlags(flags.valueOf()); } public int getSideEffectFlags() { return getIntProp(SIDE_EFFECT_FLAGS); } public static class SideEffectFlags { private int value = Node.SIDE_EFFECTS_ALL; public SideEffectFlags() {"
      },
      {
        "txt": "} public SideEffectFlags(int value) { this.value = value; } public int valueOf() { return value; } public SideEffectFlags setAllFlags() { value = Node.SIDE_EFFECTS_ALL; return this;"
      },
      {
        "txt": "} public SideEffectFlags clearAllFlags() { value = Node.NO_SIDE_EFFECTS | Node.FLAG_LOCAL_RESULTS; return this; } public boolean areAllFlagsSet() { return value == Node.SIDE_EFFECTS_ALL; } public void clearSideEffectFlags() { value |= Node.NO_SIDE_EFFECTS;"
      },
      {
        "txt": "} public SideEffectFlags setMutatesGlobalState() { removeFlag(Node.FLAG_GLOBAL_STATE_UNMODIFIED); removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED); removeFlag(Node.FLAG_THIS_UNMODIFIED); return this; } public SideEffectFlags setThrows() { removeFlag(Node.FLAG_NO_THROWS); return this;"
      },
      {
        "txt": "} public SideEffectFlags setMutatesThis() { removeFlag(Node.FLAG_THIS_UNMODIFIED); return this; } public SideEffectFlags setMutatesArguments() { removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED); return this; } public SideEffectFlags setReturnsTainted() {"
      },
      {
        "txt": "removeFlag(Node.FLAG_LOCAL_RESULTS); return this; } private void removeFlag(int flag) { value &= ~flag; } } public boolean isOnlyModifiesThisCall() { return areBitFlagsSet( getSideEffectFlags() & Node.NO_SIDE_EFFECTS,"
      },
      {
        "txt": "Node.FLAG_GLOBAL_STATE_UNMODIFIED | Node.FLAG_ARGUMENTS_UNMODIFIED | Node.FLAG_NO_THROWS); } public boolean isOnlyModifiesArgumentsCall() { return areBitFlagsSet( getSideEffectFlags() & Node.NO_SIDE_EFFECTS, Node.FLAG_GLOBAL_STATE_UNMODIFIED | Node.FLAG_THIS_UNMODIFIED | Node.FLAG_NO_THROWS);"
      },
      {
        "txt": "} public boolean isNoSideEffectsCall() { return areBitFlagsSet(getSideEffectFlags(), NO_SIDE_EFFECTS); } public boolean isLocalResultCall() { return areBitFlagsSet(getSideEffectFlags(), FLAG_LOCAL_RESULTS); } public boolean mayMutateArguments() { return !areBitFlagsSet(getSideEffectFlags(), FLAG_ARGUMENTS_UNMODIFIED); }"
      },
      {
        "txt": "public boolean mayMutateGlobalStateOrThrow() { return !areBitFlagsSet(getSideEffectFlags(), FLAG_GLOBAL_STATE_UNMODIFIED | FLAG_NO_THROWS); } private boolean areBitFlagsSet(int value, int flags) { return (value & flags) == flags; } public boolean isQuotedString() { return false; }"
      },
      {
        "txt": "public void setQuotedString() { throw new IllegalStateException(\"not a StringNode\"); } static class NodeMismatch { final Node nodeA; final Node nodeB; NodeMismatch(Node nodeA, Node nodeB) { this.nodeA = nodeA; this.nodeB = nodeB; }"
      },
      {
        "txt": "@Override public boolean equals(Object object) { if (object instanceof NodeMismatch) { NodeMismatch that = (NodeMismatch) object; return that.nodeA.equals(this.nodeA) && that.nodeB.equals(this.nodeB); } return false; } @Override public int hashCode() {"
      },
      {
        "txt": "return Objects.hashCode(nodeA, nodeB); } } public boolean isAdd() { return this.getType() == Token.ADD; } public boolean isAnd() { return this.getType() == Token.AND; } public boolean isArrayLit() {"
      },
      {
        "txt": "return this.getType() == Token.ARRAYLIT; } public boolean isAssign() { return this.getType() == Token.ASSIGN; } public boolean isAssignAdd() { return this.getType() == Token.ASSIGN_ADD; } public boolean isBlock() { return this.getType() == Token.BLOCK;"
      },
      {
        "txt": "} public boolean isBreak() { return this.getType() == Token.BREAK; } public boolean isCall() { return this.getType() == Token.CALL; } public boolean isCase() { return this.getType() == Token.CASE; }"
      },
      {
        "txt": "public boolean isCast() { return this.getType() == Token.CAST; } public boolean isCatch() { return this.getType() == Token.CATCH; } public boolean isComma() { return this.getType() == Token.COMMA; } public boolean isContinue() {"
      },
      {
        "txt": "return this.getType() == Token.CONTINUE; } public boolean isDebugger() { return this.getType() == Token.DEBUGGER; } public boolean isDec() { return this.getType() == Token.DEC; } public boolean isDefaultCase() { return this.getType() == Token.DEFAULT_CASE;"
      },
      {
        "txt": "} public boolean isDelProp() { return this.getType() == Token.DELPROP; } public boolean isDo() { return this.getType() == Token.DO; } public boolean isEmpty() { return this.getType() == Token.EMPTY; }"
      },
      {
        "txt": "public boolean isExprResult() { return this.getType() == Token.EXPR_RESULT; } public boolean isFalse() { return this.getType() == Token.FALSE; } public boolean isFor() { return this.getType() == Token.FOR; } public boolean isFunction() {"
      },
      {
        "txt": "return this.getType() == Token.FUNCTION; } public boolean isGetterDef() { return this.getType() == Token.GETTER_DEF; } public boolean isGetElem() { return this.getType() == Token.GETELEM; } public boolean isGetProp() { return this.getType() == Token.GETPROP;"
      },
      {
        "txt": "} public boolean isHook() { return this.getType() == Token.HOOK; } public boolean isIf() { return this.getType() == Token.IF; } public boolean isIn() { return this.getType() == Token.IN; }"
      },
      {
        "txt": "public boolean isInc() { return this.getType() == Token.INC; } public boolean isInstanceOf() { return this.getType() == Token.INSTANCEOF; } public boolean isLabel() { return this.getType() == Token.LABEL; } public boolean isLabelName() {"
      },
      {
        "txt": "return this.getType() == Token.LABEL_NAME; } public boolean isName() { return this.getType() == Token.NAME; } public boolean isNE() { return this.getType() == Token.NE; } public boolean isNew() { return this.getType() == Token.NEW;"
      },
      {
        "txt": "} public boolean isNot() { return this.getType() == Token.NOT; } public boolean isNull() { return this.getType() == Token.NULL; } public boolean isNumber() { return this.getType() == Token.NUMBER; }"
      },
      {
        "txt": "public boolean isObjectLit() { return this.getType() == Token.OBJECTLIT; } public boolean isOr() { return this.getType() == Token.OR; } public boolean isParamList() { return this.getType() == Token.PARAM_LIST; } public boolean isRegExp() {"
      },
      {
        "txt": "return this.getType() == Token.REGEXP; } public boolean isReturn() { return this.getType() == Token.RETURN; } public boolean isScript() { return this.getType() == Token.SCRIPT; } public boolean isSetterDef() { return this.getType() == Token.SETTER_DEF;"
      },
      {
        "txt": "} public boolean isString() { return this.getType() == Token.STRING; } public boolean isStringKey() { return this.getType() == Token.STRING_KEY; } public boolean isSwitch() { return this.getType() == Token.SWITCH; }"
      },
      {
        "txt": "public boolean isThis() { return this.getType() == Token.THIS; } public boolean isThrow() { return this.getType() == Token.THROW; } public boolean isTrue() { return this.getType() == Token.TRUE; } public boolean isTry() {"
      },
      {
        "txt": "return this.getType() == Token.TRY; } public boolean isTypeOf() { return this.getType() == Token.TYPEOF; } public boolean isVar() { return this.getType() == Token.VAR; } public boolean isVoid() { return this.getType() == Token.VOID;"
      },
      {
        "txt": "} public boolean isWhile() { return this.getType() == Token.WHILE; } public boolean isWith() { return this.getType() == Token.WITH; }"
      }
    ]
  }
]