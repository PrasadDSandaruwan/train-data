[
  {
    "id": 854,
    "file_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
    "start-bug-line": 177,
    "end-bug-line": 177,
    "bug": "boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {",
    "fix": "boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; final class ArrowType extends JSType { private static final long serialVersionUID = 1L; final Node parameters; JSType returnType;"
      },
      {
        "txt": "final boolean returnTypeInferred; ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType) { this(registry, parameters, returnType, false); } ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType, boolean returnTypeInferred) { super(registry); this.parameters = parameters == null ? registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :"
      },
      {
        "txt": "parameters; this.returnType = returnType == null ? getNativeType(UNKNOWN_TYPE) : returnType; this.returnTypeInferred = returnTypeInferred; } @Override public boolean isSubtype(JSType other) { if (!(other instanceof ArrowType)) { return false; }"
      },
      {
        "txt": "ArrowType that = (ArrowType) other; if (!this.returnType.isSubtype(that.returnType)) { return false; } Node thisParam = parameters.getFirstChild(); Node thatParam = that.parameters.getFirstChild(); while (thisParam != null && thatParam != null) { JSType thisParamType = thisParam.getJSType(); JSType thatParamType = thatParam.getJSType(); if (thisParamType != null) {"
      },
      {
        "txt": "if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) { return false; } } boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); if (!thisIsOptional && thatIsOptional) {"
      },
      {
        "txt": "boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false; } } if (!thisIsVarArgs) {"
      },
      {
        "txt": "thisParam = thisParam.getNext(); } if (!thatIsVarArgs) { thatParam = thatParam.getNext(); } if (thisIsVarArgs && thatIsVarArgs) { thisParam = null; thatParam = null; } }"
      },
      {
        "txt": "&& !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false; } return true; } <extra_id_0> Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) { JSType thisParamType = thisParam.getJSType(); JSType otherParamType = otherParam.getJSType(); if (thisParamType != null) {"
      },
      {
        "txt": "JSType otherParamType = otherParam.getJSType(); if (thisParamType != null) { if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, tolerateUnknowns)) { return false; } } else { if (otherParamType != null) { return false;"
      },
      {
        "txt": "} } thisParam = thisParam.getNext(); otherParam = otherParam.getNext(); } return thisParam == otherParam; } boolean checkArrowEquivalenceHelper( ArrowType that, boolean tolerateUnknowns) { if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {"
      },
      {
        "txt": "return false; } return hasEqualParameters(that, tolerateUnknowns); } @Override public int hashCode() { int hashCode = 0; if (returnType != null) { hashCode += returnType.hashCode(); }"
      },
      {
        "txt": "if (returnTypeInferred) { hashCode += 1; } if (parameters != null) { Node param = parameters.getFirstChild(); while (param != null) { JSType paramType = param.getJSType(); if (paramType != null) { hashCode += paramType.hashCode(); }"
      },
      {
        "txt": "param = param.getNext(); } } return hashCode; } @Override public JSType getLeastSupertype(JSType that) { throw new UnsupportedOperationException(); } @Override"
      },
      {
        "txt": "public JSType getGreatestSubtype(JSType that) { throw new UnsupportedOperationException(); } @Override public TernaryValue testForEquality(JSType that) { throw new UnsupportedOperationException(); } @Override public <T> T visit(Visitor<T> visitor) { throw new UnsupportedOperationException();"
      },
      {
        "txt": "} @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { return BooleanLiteralSet.TRUE; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { returnType = safeResolve(returnType, t, scope); if (parameters != null) { for (Node paramNode = parameters.getFirstChild();"
      },
      {
        "txt": "paramNode != null; paramNode = paramNode.getNext()) { paramNode.setJSType(paramNode.getJSType().resolve(t, scope)); } } return this; } boolean hasUnknownParamsOrReturn() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) {"
      },
      {
        "txt": "JSType type = paramNode.getJSType(); if (type == null || type.isUnknownType()) { return true; } } } return returnType == null || returnType.isUnknownType(); } @Override String toStringHelper(boolean forAnnotations) {"
      },
      {
        "txt": "return \"[ArrowType]\"; } @Override public boolean hasAnyTemplateInternal() { return returnType.hasAnyTemplate() || hasTemplatedParameterType(); } private boolean hasTemplatedParameterType() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild();"
      },
      {
        "txt": "paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type != null && type.hasAnyTemplate()) { return true; } } } return false; }"
      }
    ]
  },
  {
    "id": 855,
    "file_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
    "start-bug-line": 187,
    "end-bug-line": 187,
    "bug": "otherParamType, tolerateUnknowns)) {",
    "fix": "otherParamType, eqMethod)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; final class ArrowType extends JSType { private static final long serialVersionUID = 1L; final Node parameters;"
      },
      {
        "txt": "JSType returnType; final boolean returnTypeInferred; ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType) { this(registry, parameters, returnType, false); } ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType, boolean returnTypeInferred) { super(registry); this.parameters = parameters == null ?"
      },
      {
        "txt": "registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) : parameters; this.returnType = returnType == null ? getNativeType(UNKNOWN_TYPE) : returnType; this.returnTypeInferred = returnTypeInferred; } @Override public boolean isSubtype(JSType other) { if (!(other instanceof ArrowType)) { return false;"
      },
      {
        "txt": "} ArrowType that = (ArrowType) other; if (!this.returnType.isSubtype(that.returnType)) { return false; } Node thisParam = parameters.getFirstChild(); Node thatParam = that.parameters.getFirstChild(); while (thisParam != null && thatParam != null) { JSType thisParamType = thisParam.getJSType(); JSType thatParamType = thatParam.getJSType();"
      },
      {
        "txt": "if (thisParamType != null) { if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) { return false; } } boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();"
      },
      {
        "txt": "if (!thisIsOptional && thatIsOptional) { boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false; } }"
      },
      {
        "txt": "if (!thisIsVarArgs) { thisParam = thisParam.getNext(); } if (!thatIsVarArgs) { thatParam = thatParam.getNext(); } if (thisIsVarArgs && thatIsVarArgs) { thisParam = null; thatParam = null; }"
      },
      {
        "txt": "} if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false; } return true; } boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) { Node thisParam = parameters.getFirstChild();"
      },
      {
        "txt": "while (thisParam != null && otherParam != null) { JSType thisParamType = thisParam.getJSType(); JSType otherParamType = otherParam.getJSType(); if (thisParamType != null) { if (otherParamType != null && !thisParamType.checkEquivalenceHelper( <extra_id_0> return false; } } else { if (otherParamType != null) { return false; }"
      },
      {
        "txt": "return false; } } thisParam = thisParam.getNext(); otherParam = otherParam.getNext(); } return thisParam == otherParam; } boolean checkArrowEquivalenceHelper( ArrowType that, boolean tolerateUnknowns) {"
      },
      {
        "txt": "if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) { return false; } return hasEqualParameters(that, tolerateUnknowns); } @Override public int hashCode() { int hashCode = 0; if (returnType != null) { hashCode += returnType.hashCode();"
      },
      {
        "txt": "} if (returnTypeInferred) { hashCode += 1; } if (parameters != null) { Node param = parameters.getFirstChild(); while (param != null) { JSType paramType = param.getJSType(); if (paramType != null) { hashCode += paramType.hashCode();"
      },
      {
        "txt": "} param = param.getNext(); } } return hashCode; } @Override public JSType getLeastSupertype(JSType that) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public JSType getGreatestSubtype(JSType that) { throw new UnsupportedOperationException(); } @Override public TernaryValue testForEquality(JSType that) { throw new UnsupportedOperationException(); } @Override public <T> T visit(Visitor<T> visitor) {"
      },
      {
        "txt": "throw new UnsupportedOperationException(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { return BooleanLiteralSet.TRUE; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { returnType = safeResolve(returnType, t, scope); if (parameters != null) {"
      },
      {
        "txt": "for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { paramNode.setJSType(paramNode.getJSType().resolve(t, scope)); } } return this; } boolean hasUnknownParamsOrReturn() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild();"
      },
      {
        "txt": "paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type == null || type.isUnknownType()) { return true; } } } return returnType == null || returnType.isUnknownType(); } @Override"
      },
      {
        "txt": "String toStringHelper(boolean forAnnotations) { return \"[ArrowType]\"; } @Override public boolean hasAnyTemplateInternal() { return returnType.hasAnyTemplate() || hasTemplatedParameterType(); } private boolean hasTemplatedParameterType() { if (parameters != null) {"
      },
      {
        "txt": "for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type != null && type.hasAnyTemplate()) { return true; } } } return false; }"
      }
    ]
  },
  {
    "id": 856,
    "file_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
    "start-bug-line": 204,
    "end-bug-line": 204,
    "bug": "ArrowType that, boolean tolerateUnknowns) {",
    "fix": "ArrowType that, EquivalenceMethod eqMethod) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; final class ArrowType extends JSType { private static final long serialVersionUID = 1L; final Node parameters; JSType returnType; final boolean returnTypeInferred; ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType) {"
      },
      {
        "txt": "this(registry, parameters, returnType, false); } ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType, boolean returnTypeInferred) { super(registry); this.parameters = parameters == null ? registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) : parameters; this.returnType = returnType == null ? getNativeType(UNKNOWN_TYPE) : returnType;"
      },
      {
        "txt": "this.returnTypeInferred = returnTypeInferred; } @Override public boolean isSubtype(JSType other) { if (!(other instanceof ArrowType)) { return false; } ArrowType that = (ArrowType) other; if (!this.returnType.isSubtype(that.returnType)) { return false;"
      },
      {
        "txt": "} Node thisParam = parameters.getFirstChild(); Node thatParam = that.parameters.getFirstChild(); while (thisParam != null && thatParam != null) { JSType thisParamType = thisParam.getJSType(); JSType thatParamType = thatParam.getJSType(); if (thisParamType != null) { if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) { return false;"
      },
      {
        "txt": "} } boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); if (!thisIsOptional && thatIsOptional) { boolean isTopFunction = thatIsVarArgs && (thatParamType == null ||"
      },
      {
        "txt": "thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false; } } if (!thisIsVarArgs) { thisParam = thisParam.getNext(); } if (!thatIsVarArgs) {"
      },
      {
        "txt": "thatParam = thatParam.getNext(); } if (thisIsVarArgs && thatIsVarArgs) { thisParam = null; thatParam = null; } } if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) {"
      },
      {
        "txt": "return false; } return true; } boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) { Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) { JSType thisParamType = thisParam.getJSType(); JSType otherParamType = otherParam.getJSType();"
      },
      {
        "txt": "if (thisParamType != null) { if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, tolerateUnknowns)) { return false; } } else { if (otherParamType != null) { return false; }"
      },
      {
        "txt": "thisParam = thisParam.getNext(); otherParam = otherParam.getNext(); } return thisParam == otherParam; } boolean checkArrowEquivalenceHelper( <extra_id_0> if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) { return false; } return hasEqualParameters(that, tolerateUnknowns); } @Override"
      },
      {
        "txt": "} @Override public int hashCode() { int hashCode = 0; if (returnType != null) { hashCode += returnType.hashCode(); } if (returnTypeInferred) { hashCode += 1; }"
      },
      {
        "txt": "if (parameters != null) { Node param = parameters.getFirstChild(); while (param != null) { JSType paramType = param.getJSType(); if (paramType != null) { hashCode += paramType.hashCode(); } param = param.getNext(); } }"
      },
      {
        "txt": "return hashCode; } @Override public JSType getLeastSupertype(JSType that) { throw new UnsupportedOperationException(); } @Override public JSType getGreatestSubtype(JSType that) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public TernaryValue testForEquality(JSType that) { throw new UnsupportedOperationException(); } @Override public <T> T visit(Visitor<T> visitor) { throw new UnsupportedOperationException(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() {"
      },
      {
        "txt": "return BooleanLiteralSet.TRUE; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { returnType = safeResolve(returnType, t, scope); if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { paramNode.setJSType(paramNode.getJSType().resolve(t, scope)); }"
      },
      {
        "txt": "} return this; } boolean hasUnknownParamsOrReturn() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type == null || type.isUnknownType()) { return true;"
      },
      {
        "txt": "} } } return returnType == null || returnType.isUnknownType(); } @Override String toStringHelper(boolean forAnnotations) { return \"[ArrowType]\"; } @Override"
      },
      {
        "txt": "public boolean hasAnyTemplateInternal() { return returnType.hasAnyTemplate() || hasTemplatedParameterType(); } private boolean hasTemplatedParameterType() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type != null && type.hasAnyTemplate()) {"
      },
      {
        "txt": "return true; } } } return false; }"
      }
    ]
  },
  {
    "id": 857,
    "file_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
    "start-bug-line": 206,
    "end-bug-line": 206,
    "bug": "if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {",
    "fix": "if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; final class ArrowType extends JSType { private static final long serialVersionUID = 1L; final Node parameters; JSType returnType; final boolean returnTypeInferred; ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType) { this(registry, parameters, returnType, false);"
      },
      {
        "txt": "} ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType, boolean returnTypeInferred) { super(registry); this.parameters = parameters == null ? registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) : parameters; this.returnType = returnType == null ? getNativeType(UNKNOWN_TYPE) : returnType; this.returnTypeInferred = returnTypeInferred;"
      },
      {
        "txt": "} @Override public boolean isSubtype(JSType other) { if (!(other instanceof ArrowType)) { return false; } ArrowType that = (ArrowType) other; if (!this.returnType.isSubtype(that.returnType)) { return false; }"
      },
      {
        "txt": "Node thisParam = parameters.getFirstChild(); Node thatParam = that.parameters.getFirstChild(); while (thisParam != null && thatParam != null) { JSType thisParamType = thisParam.getJSType(); JSType thatParamType = thatParam.getJSType(); if (thisParamType != null) { if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) { return false; }"
      },
      {
        "txt": "} boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); if (!thisIsOptional && thatIsOptional) { boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() ||"
      },
      {
        "txt": "thatParamType.isNoType()); if (!isTopFunction) { return false; } } if (!thisIsVarArgs) { thisParam = thisParam.getNext(); } if (!thatIsVarArgs) { thatParam = thatParam.getNext();"
      },
      {
        "txt": "} if (thisIsVarArgs && thatIsVarArgs) { thisParam = null; thatParam = null; } } if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false;"
      },
      {
        "txt": "} return true; } boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) { Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) { JSType thisParamType = thisParam.getJSType(); JSType otherParamType = otherParam.getJSType(); if (thisParamType != null) {"
      },
      {
        "txt": "if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, tolerateUnknowns)) { return false; } } else { if (otherParamType != null) { return false; } }"
      },
      {
        "txt": "otherParam = otherParam.getNext(); } return thisParam == otherParam; } boolean checkArrowEquivalenceHelper( ArrowType that, boolean tolerateUnknowns) { <extra_id_0> return false; } return hasEqualParameters(that, tolerateUnknowns); } @Override public int hashCode() {"
      },
      {
        "txt": "@Override public int hashCode() { int hashCode = 0; if (returnType != null) { hashCode += returnType.hashCode(); } if (returnTypeInferred) { hashCode += 1; } if (parameters != null) {"
      },
      {
        "txt": "Node param = parameters.getFirstChild(); while (param != null) { JSType paramType = param.getJSType(); if (paramType != null) { hashCode += paramType.hashCode(); } param = param.getNext(); } } return hashCode;"
      },
      {
        "txt": "} @Override public JSType getLeastSupertype(JSType that) { throw new UnsupportedOperationException(); } @Override public JSType getGreatestSubtype(JSType that) { throw new UnsupportedOperationException(); } @Override"
      },
      {
        "txt": "public TernaryValue testForEquality(JSType that) { throw new UnsupportedOperationException(); } @Override public <T> T visit(Visitor<T> visitor) { throw new UnsupportedOperationException(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { return BooleanLiteralSet.TRUE;"
      },
      {
        "txt": "} @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { returnType = safeResolve(returnType, t, scope); if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { paramNode.setJSType(paramNode.getJSType().resolve(t, scope)); } }"
      },
      {
        "txt": "return this; } boolean hasUnknownParamsOrReturn() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type == null || type.isUnknownType()) { return true; }"
      },
      {
        "txt": "} } return returnType == null || returnType.isUnknownType(); } @Override String toStringHelper(boolean forAnnotations) { return \"[ArrowType]\"; } @Override public boolean hasAnyTemplateInternal() {"
      },
      {
        "txt": "return returnType.hasAnyTemplate() || hasTemplatedParameterType(); } private boolean hasTemplatedParameterType() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type != null && type.hasAnyTemplate()) { return true;"
      },
      {
        "txt": "} } } return false; }"
      }
    ]
  },
  {
    "id": 858,
    "file_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
    "start-bug-line": 209,
    "end-bug-line": 209,
    "bug": "return hasEqualParameters(that, tolerateUnknowns);",
    "fix": "return hasEqualParameters(that, eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; final class ArrowType extends JSType {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; final Node parameters; JSType returnType; final boolean returnTypeInferred; ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType) { this(registry, parameters, returnType, false); } ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType, boolean returnTypeInferred) {"
      },
      {
        "txt": "super(registry); this.parameters = parameters == null ? registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) : parameters; this.returnType = returnType == null ? getNativeType(UNKNOWN_TYPE) : returnType; this.returnTypeInferred = returnTypeInferred; } @Override public boolean isSubtype(JSType other) {"
      },
      {
        "txt": "if (!(other instanceof ArrowType)) { return false; } ArrowType that = (ArrowType) other; if (!this.returnType.isSubtype(that.returnType)) { return false; } Node thisParam = parameters.getFirstChild(); Node thatParam = that.parameters.getFirstChild(); while (thisParam != null && thatParam != null) {"
      },
      {
        "txt": "JSType thisParamType = thisParam.getJSType(); JSType thatParamType = thatParam.getJSType(); if (thisParamType != null) { if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) { return false; } } boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs();"
      },
      {
        "txt": "boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); if (!thisIsOptional && thatIsOptional) { boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false;"
      },
      {
        "txt": "} } if (!thisIsVarArgs) { thisParam = thisParam.getNext(); } if (!thatIsVarArgs) { thatParam = thatParam.getNext(); } if (thisIsVarArgs && thatIsVarArgs) { thisParam = null;"
      },
      {
        "txt": "thatParam = null; } } if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false; } return true; }"
      },
      {
        "txt": "boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) { Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) { JSType thisParamType = thisParam.getJSType(); JSType otherParamType = otherParam.getJSType(); if (thisParamType != null) { if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, tolerateUnknowns)) {"
      },
      {
        "txt": "return false; } } else { if (otherParamType != null) { return false; } } thisParam = thisParam.getNext(); otherParam = otherParam.getNext(); }"
      },
      {
        "txt": "} boolean checkArrowEquivalenceHelper( ArrowType that, boolean tolerateUnknowns) { if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) { return false; } <extra_id_0> } @Override public int hashCode() { int hashCode = 0; if (returnType != null) { hashCode += returnType.hashCode();"
      },
      {
        "txt": "if (returnType != null) { hashCode += returnType.hashCode(); } if (returnTypeInferred) { hashCode += 1; } if (parameters != null) { Node param = parameters.getFirstChild(); while (param != null) { JSType paramType = param.getJSType();"
      },
      {
        "txt": "if (paramType != null) { hashCode += paramType.hashCode(); } param = param.getNext(); } } return hashCode; } @Override public JSType getLeastSupertype(JSType that) {"
      },
      {
        "txt": "throw new UnsupportedOperationException(); } @Override public JSType getGreatestSubtype(JSType that) { throw new UnsupportedOperationException(); } @Override public TernaryValue testForEquality(JSType that) { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "@Override public <T> T visit(Visitor<T> visitor) { throw new UnsupportedOperationException(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { return BooleanLiteralSet.TRUE; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {"
      },
      {
        "txt": "returnType = safeResolve(returnType, t, scope); if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { paramNode.setJSType(paramNode.getJSType().resolve(t, scope)); } } return this; } boolean hasUnknownParamsOrReturn() {"
      },
      {
        "txt": "if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type == null || type.isUnknownType()) { return true; } } } return returnType == null || returnType.isUnknownType();"
      },
      {
        "txt": "} @Override String toStringHelper(boolean forAnnotations) { return \"[ArrowType]\"; } @Override public boolean hasAnyTemplateInternal() { return returnType.hasAnyTemplate() || hasTemplatedParameterType(); }"
      },
      {
        "txt": "private boolean hasTemplatedParameterType() { if (parameters != null) { for (Node paramNode = parameters.getFirstChild(); paramNode != null; paramNode = paramNode.getNext()) { JSType type = paramNode.getJSType(); if (type != null && type.hasAnyTemplate()) { return true; } } }"
      },
      {
        "txt": "return false; }"
      }
    ]
  },
  {
    "id": 859,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 0,
    "end-bug-line": 0,
    "bug": "",
    "fix": "/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the \"License\"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an \"AS IS\" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): *   Nick Santos *   Google Inc. * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the \"GPL\"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */  package com.google.javascript.rhino.jstype;  /** * Represents different ways for comparing equality among types. * @author nicksantos@google.com (Nick Santos) */ enum EquivalenceMethod { /** * Indicates that the two types should behave exactly the same under * all type operations. * * Thus, {string} != {?} and {Unresolved} != {?} */ IDENTITY,  /** * Indicates that the two types are almost exactly the same, and that a * data flow analysis algorithm comparing them should consider them equal. * * In traditional type inference, the types form a finite lattice, and this * ensures that type inference will terminate. * * In our type system, the unknown types do not obey the lattice rules. So * if we continue to perform inference over the unknown types, we may * never terminate. * * By treating all unknown types as equivalent for the purposes of data * flow analysis, we ensure that the algorithm will terminate. * * Thus, {string} != {?} and {Unresolved} ~= {?} */ DATA_FLOW,  /** * Indicates that two types are invariant. * * In a type system without unknown types, this would be the same * as IDENTITY. But we always want to consider type A invariant with type B * if B is unknown. * * Thus, {string} ~= {?} and {Unresolved} ~= {?} */ INVARIANT }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set;"
      },
      {
        "txt": "public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY, CONSTRUCTOR, INTERFACE } private enum PropAccess { ANY, STRUCT, DICT } private ArrowType call; private Property prototypeSlot;"
      },
      {
        "txt": "private final Kind kind; private PropAccess propAccess; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private final ImmutableList<String> templateTypeNames; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis,"
      },
      {
        "txt": "ImmutableList<String> templateTypeNames, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); setPrettyPrint(true); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source;"
      },
      {
        "txt": "if (isConstructor) { this.kind = Kind.CONSTRUCTOR; this.propAccess = PropAccess.ANY; this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.kind = Kind.ORDINARY; this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} this.call = arrowType; this.templateTypeNames = templateTypeNames != null ? templateTypeNames : ImmutableList.<String>of(); } private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); setPrettyPrint(true); Preconditions.checkArgument(source == null ||"
      },
      {
        "txt": "Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); this.templateTypeNames = ImmutableList.of(); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) {"
      },
      {
        "txt": "return new FunctionType(registry, name, source); } @Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; }"
      },
      {
        "txt": "@Override public boolean isInterface() { return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } public boolean makesStructs() { if (!isConstructor()) {"
      },
      {
        "txt": "return false; } if (propAccess == PropAccess.STRUCT) { return true; } FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesStructs()) { setStruct(); return true; }"
      },
      {
        "txt": "return false; } public boolean makesDicts() { if (!isConstructor()) { return false; } if (propAccess == PropAccess.DICT) { return true; } FunctionType superc = getSuperClassConstructor();"
      },
      {
        "txt": "if (superc != null && superc.makesDicts()) { setDict(); return true; } return false; } public void setStruct() { propAccess = PropAccess.STRUCT; } public void setDict() {"
      },
      {
        "txt": "propAccess = PropAccess.DICT; } @Override public FunctionType toMaybeFunctionType() { return this; } @Override public boolean canBeCalled() { return true; }"
      },
      {
        "txt": "public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){ return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false;"
      },
      {
        "txt": "} public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else { return Collections.emptySet(); } } public Node getParametersNode() {"
      },
      {
        "txt": "return call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) { i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; }"
      },
      {
        "txt": "} return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) { Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); }"
      },
      {
        "txt": "} return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType; } public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() {"
      },
      {
        "txt": "return call; } @Override public Property getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype(); return prototypeSlot; } else { return super.getSlot(name); }"
      },
      {
        "txt": "} @Override public Set<String> getOwnPropertyNames() { if (prototypeSlot == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\"); names.addAll(super.getOwnPropertyNames()); return names; }"
      },
      {
        "txt": "} public ObjectType getPrototype() { if (prototypeSlot == null) { String refName = getReferenceName(); if (refName == null) { setPrototypeNoCheck( registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE), null); } else { setPrototype("
      },
      {
        "txt": "new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType()), null); } } return (ObjectType) prototypeSlot.getType(); }"
      },
      {
        "txt": "public void setPrototypeBasedOn(ObjectType baseType) { setPrototypeBasedOn(baseType, null); } void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) { if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); }"
      },
      {
        "txt": "setPrototype(baseType, propertyNode); } boolean setPrototype(ObjectType prototype, Node propertyNode) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false; } return setPrototypeNoCheck(prototype, propertyNode);"
      },
      {
        "txt": "} private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) { ObjectType oldPrototype = prototypeSlot == null ? null : (ObjectType) prototypeSlot.getType(); boolean replacedPrototype = oldPrototype != null; this.prototypeSlot = new Property(\"prototype\", prototype, true, propertyNode == null ? source : propertyNode); prototype.setOwnerFunction(this); if (oldPrototype != null) { oldPrototype.setOwnerFunction(null);"
      },
      {
        "txt": "} if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this);"
      },
      {
        "txt": "} } } } if (replacedPrototype) { clearCachedValues(); } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() {"
      },
      {
        "txt": "Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) {"
      },
      {
        "txt": "return; } set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ?"
      },
      {
        "txt": "getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces()); } } public Iterable<ObjectType> getOwnImplementedInterfaces() { return implementedInterfaces;"
      },
      {
        "txt": "} public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { if (isConstructor()) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } else { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "} public Iterable<ObjectType> getAllExtendedInterfaces() { Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) {"
      },
      {
        "txt": "FunctionType constructor = instance.getConstructor(); if (constructor != null) { set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces;"
      },
      {
        "txt": "} public int getExtendedInterfacesCount() { return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException();"
      },
      {
        "txt": "} } @Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { boolean isCall = \"call\".equals(name); boolean isBind = \"bind\".equals(name); if (isCall || isBind) { defineDeclaredProperty(name, getCallOrBindSignature(isCall), source); } else if (\"apply\".equals(name)) {"
      },
      {
        "txt": "FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(),"
      },
      {
        "txt": "source); } } return super.getPropertyType(name); } public FunctionType getBindReturnType(int argsToBind) { FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(getReturnType()); if (argsToBind >= 0) { Node origParams = getParametersNode();"
      },
      {
        "txt": "if (origParams != null) { Node params = origParams.cloneTree(); for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) { if (params.getFirstChild().isVarArgs()) { break; } params.removeFirstChild(); } builder.withParamsNode(params); }"
      },
      {
        "txt": "} return builder.build(); } private FunctionType getCallOrBindSignature(boolean isCall) { boolean isBind = !isCall; FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(isCall ? getReturnType() : getBindReturnType(-1)); Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree();"
      },
      {
        "txt": "Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(isCall); if (isBind) { for (Node current = thisTypeNode.getNext(); current != null; current = current.getNext()) { current.setOptionalArg(true); }"
      },
      {
        "txt": "} builder.withParamsNode(params); } return builder.build(); } @Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType();"
      },
      {
        "txt": "if (objType != null) { if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) { return true; } this.setPrototypeBasedOn(objType, propertyNode); return true; } else { return false; }"
      },
      {
        "txt": "} return super.defineProperty(name, type, inferred, propertyNode); } FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) { Preconditions.checkNotNull(that); if (isEquivalentTo(that)) { return this; } if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() &&"
      },
      {
        "txt": "!that.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that); boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this; } else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper); if (merged != null) {"
      },
      {
        "txt": "return merged; } } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; }"
      },
      {
        "txt": "FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn; } private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, false)) {"
      },
      {
        "txt": "newParamsNode = call.parameters; } else { return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis;"
      },
      {
        "txt": "} else { JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);"
      },
      {
        "txt": "} } boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType( registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); }"
      },
      {
        "txt": "public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); } public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) {"
      },
      {
        "txt": "ObjectType foundType = null; if (type.hasProperty(propertyName)) { foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); } } return foundType;"
      },
      {
        "txt": "} public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getInstanceType().hasProperty(propertyName)); FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); } ObjectType topInstanceType = null; do {"
      },
      {
        "txt": "topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName)); return topInstanceType; } boolean checkFunctionEquivalenceHelper( FunctionType that, boolean tolerateUnknowns) { if (isConstructor()) { if (that.isConstructor()) {"
      },
      {
        "txt": "return this == that; } return false; } if (isInterface()) { if (that.isInterface()) { return getReferenceName().equals(that.getReferenceName()); } return false; }"
      },
      {
        "txt": "if (that.isInterface()) { return false; } return typeOfThis.checkEquivalenceHelper( that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode();"
      },
      {
        "txt": "} public boolean hasEqualCallType(FunctionType otherType) { return this.call.checkArrowEquivalenceHelper(otherType.call, false); } @Override String toStringHelper(boolean forAnnotations) { if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; }"
      },
      {
        "txt": "setPrettyPrint(false); StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType); if (hasKnownTypeOfThis) { if (isConstructor()) { b.append(\"new:\"); } else { b.append(\"this:\");"
      },
      {
        "txt": "} b.append(typeOfThis.toStringHelper(forAnnotations)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); appendArgString(b, p, forAnnotations); p = p.getNext();"
      },
      {
        "txt": "while (p != null) { b.append(\", \"); appendArgString(b, p, forAnnotations); p = p.getNext(); } } b.append(\"): \"); b.append(call.returnType.toStringHelper(forAnnotations)); setPrettyPrint(true); return b.toString();"
      },
      {
        "txt": "} private void appendArgString( StringBuilder b, Node p, boolean forAnnotations) { if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType(), forAnnotations); } else if (p.isOptionalArg()) { appendOptionalArgString(b, p.getJSType(), forAnnotations); } else { b.append(p.getJSType().toStringHelper(forAnnotations)); }"
      },
      {
        "txt": "} private void appendVarArgsString(StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append( paramType.toStringHelper(forAnnotations)).append(\"]\"); }"
      },
      {
        "txt": "private void appendOptionalArgString( StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(paramType.toStringHelper(forAnnotations)).append(\"=\"); } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (JSType.isSubtypeHelper(this, that)) { return true; } if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true; } if (this.isInterface()) { return false;"
      },
      {
        "txt": "} boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);"
      },
      {
        "txt": "} @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) {"
      },
      {
        "txt": "typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis; }"
      },
      {
        "txt": "public Node getSource() { return source; } public void setSource(Node source) { if (prototypeSlot != null) { if (source == null || prototypeSlot.getNode() == null) { prototypeSlot = new Property(prototypeSlot.getName(), prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source); } }"
      },
      {
        "txt": "this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType); } @Override public void clearCachedValues() {"
      },
      {
        "txt": "super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) { subType.clearCachedValues(); } } if (!isNativeObjectType()) { if (hasInstanceType()) { getInstanceType().clearCachedValues(); }"
      },
      {
        "txt": "if (prototypeSlot != null) { ((ObjectType) prototypeSlot.getType()).clearCachedValues(); } } } public List<FunctionType> getSubTypes() { return subTypes; } @Override public boolean hasCachedValues() {"
      },
      {
        "txt": "return prototypeSlot != null || super.hasCachedValues(); } public ImmutableList<String> getTemplateTypeNames() { return templateTypeNames; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); if (prototypeSlot != null) {"
      },
      {
        "txt": "prototypeSlot.setType( safeResolve(prototypeSlot.getType(), t, scope)); } JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
      },
      {
        "txt": "boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build();"
      },
      {
        "txt": "} if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } } return super.resolveInternal(t, scope); } @Override"
      },
      {
        "txt": "public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\");"
      },
      {
        "txt": "b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); while (p != null) {"
      },
      {
        "txt": "b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString(); }"
      },
      {
        "txt": "private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); } } public FunctionType cloneWithoutArrowType() { FunctionType result = new FunctionType( registry, getReferenceName(), source,"
      },
      {
        "txt": "registry.createArrowType(null, null), getInstanceType(), null, true, false); result.setPrototypeBasedOn(getInstanceType()); return result; } @Override public boolean hasAnyTemplateInternal() { return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate();"
      }
    ]
  },
  {
    "id": 860,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 792,
    "end-bug-line": 792,
    "bug": "if (call.hasEqualParameters(other.call, false)) {",
    "fix": "if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private enum Kind { ORDINARY, CONSTRUCTOR, INTERFACE } private enum PropAccess { ANY, STRUCT, DICT } private ArrowType call; private Property prototypeSlot; private final Kind kind; private PropAccess propAccess;"
      },
      {
        "txt": "private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private final ImmutableList<String> templateTypeNames; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis, ImmutableList<String> templateTypeNames, boolean isConstructor, boolean nativeType) {"
      },
      {
        "txt": "super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); setPrettyPrint(true); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; if (isConstructor) { this.kind = Kind.CONSTRUCTOR;"
      },
      {
        "txt": "this.propAccess = PropAccess.ANY; this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.kind = Kind.ORDINARY; this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType;"
      },
      {
        "txt": "this.templateTypeNames = templateTypeNames != null ? templateTypeNames : ImmutableList.<String>of(); } private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); setPrettyPrint(true); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null);"
      },
      {
        "txt": "this.source = source; this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); this.templateTypeNames = ImmutableList.of(); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); }"
      },
      {
        "txt": "@Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() {"
      },
      {
        "txt": "return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } public boolean makesStructs() { if (!isConstructor()) { return false; }"
      },
      {
        "txt": "if (propAccess == PropAccess.STRUCT) { return true; } FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesStructs()) { setStruct(); return true; } return false; }"
      },
      {
        "txt": "public boolean makesDicts() { if (!isConstructor()) { return false; } if (propAccess == PropAccess.DICT) { return true; } FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesDicts()) { setDict();"
      },
      {
        "txt": "return true; } return false; } public void setStruct() { propAccess = PropAccess.STRUCT; } public void setDict() { propAccess = PropAccess.DICT; }"
      },
      {
        "txt": "@Override public FunctionType toMaybeFunctionType() { return this; } @Override public boolean canBeCalled() { return true; } public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){"
      },
      {
        "txt": "return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false; } public Iterable<Node> getParameters() {"
      },
      {
        "txt": "Node n = getParametersNode(); if (n != null) { return n.children(); } else { return Collections.emptySet(); } } public Node getParametersNode() { return call.parameters; }"
      },
      {
        "txt": "public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) { i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min;"
      },
      {
        "txt": "} public int getMaxArguments() { Node params = getParametersNode(); if (params != null) { Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE;"
      },
      {
        "txt": "} public JSType getReturnType() { return call.returnType; } public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call; }"
      },
      {
        "txt": "@Override public Property getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype(); return prototypeSlot; } else { return super.getSlot(name); } } @Override"
      },
      {
        "txt": "public Set<String> getOwnPropertyNames() { if (prototypeSlot == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\"); names.addAll(super.getOwnPropertyNames()); return names; } } public ObjectType getPrototype() {"
      },
      {
        "txt": "if (prototypeSlot == null) { String refName = getReferenceName(); if (refName == null) { setPrototypeNoCheck( registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE), null); } else { setPrototype( new PrototypeObjectType( registry,"
      },
      {
        "txt": "this.getReferenceName() + \".prototype\", registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType()), null); } } return (ObjectType) prototypeSlot.getType(); } public void setPrototypeBasedOn(ObjectType baseType) { setPrototypeBasedOn(baseType, null);"
      },
      {
        "txt": "} void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) { if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); } setPrototype(baseType, propertyNode); }"
      },
      {
        "txt": "boolean setPrototype(ObjectType prototype, Node propertyNode) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false; } return setPrototypeNoCheck(prototype, propertyNode); } private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) {"
      },
      {
        "txt": "ObjectType oldPrototype = prototypeSlot == null ? null : (ObjectType) prototypeSlot.getType(); boolean replacedPrototype = oldPrototype != null; this.prototypeSlot = new Property(\"prototype\", prototype, true, propertyNode == null ? source : propertyNode); prototype.setOwnerFunction(this); if (oldPrototype != null) { oldPrototype.setOwnerFunction(null); } if (isConstructor() || isInterface()) {"
      },
      {
        "txt": "FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } }"
      },
      {
        "txt": "} } if (replacedPrototype) { clearCachedValues(); } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) {"
      },
      {
        "txt": "addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; }"
      },
      {
        "txt": "set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) {"
      },
      {
        "txt": "return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces()); } } public Iterable<ObjectType> getOwnImplementedInterfaces() { return implementedInterfaces; } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {"
      },
      {
        "txt": "if (isConstructor()) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } else { throw new UnsupportedOperationException(); } } public Iterable<ObjectType> getAllExtendedInterfaces() {"
      },
      {
        "txt": "Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) {"
      },
      {
        "txt": "set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces; } public int getExtendedInterfacesCount() {"
      },
      {
        "txt": "return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException(); } }"
      },
      {
        "txt": "@Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { boolean isCall = \"call\".equals(name); boolean isBind = \"bind\".equals(name); if (isCall || isBind) { defineDeclaredProperty(name, getCallOrBindSignature(isCall), source); } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams("
      },
      {
        "txt": "registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(), source); }"
      },
      {
        "txt": "} return super.getPropertyType(name); } public FunctionType getBindReturnType(int argsToBind) { FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(getReturnType()); if (argsToBind >= 0) { Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree();"
      },
      {
        "txt": "for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) { if (params.getFirstChild().isVarArgs()) { break; } params.removeFirstChild(); } builder.withParamsNode(params); } } return builder.build();"
      },
      {
        "txt": "} private FunctionType getCallOrBindSignature(boolean isCall) { boolean isBind = !isCall; FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(isCall ? getReturnType() : getBindReturnType(-1)); Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType("
      },
      {
        "txt": "registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(isCall); if (isBind) { for (Node current = thisTypeNode.getNext(); current != null; current = current.getNext()) { current.setOptionalArg(true); } } builder.withParamsNode(params);"
      },
      {
        "txt": "} return builder.build(); } @Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (prototypeSlot != null &&"
      },
      {
        "txt": "objType.isEquivalentTo(prototypeSlot.getType())) { return true; } this.setPrototypeBasedOn(objType, propertyNode); return true; } else { return false; } } return super.defineProperty(name, type, inferred, propertyNode);"
      },
      {
        "txt": "} FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) { Preconditions.checkNotNull(that); if (isEquivalentTo(that)) { return this; } if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that);"
      },
      {
        "txt": "boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this; } else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper); if (merged != null) { return merged; }"
      },
      {
        "txt": "} JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);"
      },
      {
        "txt": "registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn; } private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; <extra_id_0> newParamsNode = call.parameters; } else { return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) :"
      },
      {
        "txt": "JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis; } else { JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis);"
      },
      {
        "txt": "if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE); } } boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred;"
      },
      {
        "txt": "return new FunctionType( registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) {"
      },
      {
        "txt": "return null; } return maybeSuperInstanceType.getConstructor(); } public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { ObjectType foundType = null; if (type.hasProperty(propertyName)) { foundType = type; }"
      },
      {
        "txt": "for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); } } return foundType; } public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getInstanceType().hasProperty(propertyName));"
      },
      {
        "txt": "FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); } ObjectType topInstanceType = null; do { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));"
      },
      {
        "txt": "return topInstanceType; } boolean checkFunctionEquivalenceHelper( FunctionType that, boolean tolerateUnknowns) { if (isConstructor()) { if (that.isConstructor()) { return this == that; } return false; }"
      },
      {
        "txt": "if (isInterface()) { if (that.isInterface()) { return getReferenceName().equals(that.getReferenceName()); } return false; } if (that.isInterface()) { return false; } return typeOfThis.checkEquivalenceHelper("
      },
      {
        "txt": "that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) { return this.call.checkArrowEquivalenceHelper(otherType.call, false); }"
      },
      {
        "txt": "@Override String toStringHelper(boolean forAnnotations) { if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } setPrettyPrint(false); StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount();"
      },
      {
        "txt": "boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType); if (hasKnownTypeOfThis) { if (isConstructor()) { b.append(\"new:\"); } else { b.append(\"this:\"); } b.append(typeOfThis.toStringHelper(forAnnotations)); } if (paramNum > 0) {"
      },
      {
        "txt": "if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); appendArgString(b, p, forAnnotations); p = p.getNext(); while (p != null) { b.append(\", \"); appendArgString(b, p, forAnnotations); p = p.getNext();"
      },
      {
        "txt": "} } b.append(\"): \"); b.append(call.returnType.toStringHelper(forAnnotations)); setPrettyPrint(true); return b.toString(); } private void appendArgString( StringBuilder b, Node p, boolean forAnnotations) { if (p.isVarArgs()) {"
      },
      {
        "txt": "appendVarArgsString(b, p.getJSType(), forAnnotations); } else if (p.isOptionalArg()) { appendOptionalArgString(b, p.getJSType(), forAnnotations); } else { b.append(p.getJSType().toStringHelper(forAnnotations)); } } private void appendVarArgsString(StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) {"
      },
      {
        "txt": "paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append( paramType.toStringHelper(forAnnotations)).append(\"]\"); } private void appendOptionalArgString( StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion("
      },
      {
        "txt": "registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(paramType.toStringHelper(forAnnotations)).append(\"=\"); } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } if (that.isFunctionType()) {"
      },
      {
        "txt": "FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true; } if (this.isInterface()) { return false; } boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null &&"
      },
      {
        "txt": "other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); } @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this);"
      },
      {
        "txt": "} public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface();"
      },
      {
        "txt": "} @Override public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis; } public Node getSource() { return source; } public void setSource(Node source) {"
      },
      {
        "txt": "if (prototypeSlot != null) { if (source == null || prototypeSlot.getNode() == null) { prototypeSlot = new Property(prototypeSlot.getName(), prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source); } } this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) {"
      },
      {
        "txt": "subTypes = Lists.newArrayList(); } subTypes.add(subType); } @Override public void clearCachedValues() { super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) { subType.clearCachedValues();"
      },
      {
        "txt": "} } if (!isNativeObjectType()) { if (hasInstanceType()) { getInstanceType().clearCachedValues(); } if (prototypeSlot != null) { ((ObjectType) prototypeSlot.getType()).clearCachedValues(); } }"
      },
      {
        "txt": "} public List<FunctionType> getSubTypes() { return subTypes; } @Override public boolean hasCachedValues() { return prototypeSlot != null || super.hasCachedValues(); } public ImmutableList<String> getTemplateTypeNames() { return templateTypeNames;"
      },
      {
        "txt": "} @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); if (prototypeSlot != null) { prototypeSlot.setType( safeResolve(prototypeSlot.getType(), t, scope)); } JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);"
      },
      {
        "txt": "if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) {"
      },
      {
        "txt": "ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set("
      },
      {
        "txt": "i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } } return super.resolveInternal(t, scope); } @Override public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); }"
      },
      {
        "txt": "StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\"); b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) {"
      },
      {
        "txt": "b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); while (p != null) { b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); }"
      },
      {
        "txt": "} b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString(); } private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else {"
      },
      {
        "txt": "return type.toDebugHashCodeString(); } } public FunctionType cloneWithoutArrowType() { FunctionType result = new FunctionType( registry, getReferenceName(), source, registry.createArrowType(null, null), getInstanceType(), null, true, false); result.setPrototypeBasedOn(getInstanceType()); return result;"
      },
      {
        "txt": "} @Override public boolean hasAnyTemplateInternal() { return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate(); }"
      }
    ]
  },
  {
    "id": 861,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 890,
    "end-bug-line": 890,
    "bug": "FunctionType that, boolean tolerateUnknowns) {",
    "fix": "FunctionType that, EquivalenceMethod eqMethod) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set;"
      },
      {
        "txt": "public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY, CONSTRUCTOR, INTERFACE } private enum PropAccess { ANY, STRUCT, DICT } private ArrowType call; private Property prototypeSlot;"
      },
      {
        "txt": "private final Kind kind; private PropAccess propAccess; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private final ImmutableList<String> templateTypeNames; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis,"
      },
      {
        "txt": "ImmutableList<String> templateTypeNames, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); setPrettyPrint(true); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source;"
      },
      {
        "txt": "if (isConstructor) { this.kind = Kind.CONSTRUCTOR; this.propAccess = PropAccess.ANY; this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.kind = Kind.ORDINARY; this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} this.call = arrowType; this.templateTypeNames = templateTypeNames != null ? templateTypeNames : ImmutableList.<String>of(); } private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); setPrettyPrint(true); Preconditions.checkArgument(source == null ||"
      },
      {
        "txt": "Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); this.templateTypeNames = ImmutableList.of(); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) {"
      },
      {
        "txt": "return new FunctionType(registry, name, source); } @Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; }"
      },
      {
        "txt": "@Override public boolean isInterface() { return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } public boolean makesStructs() { if (!isConstructor()) {"
      },
      {
        "txt": "return false; } if (propAccess == PropAccess.STRUCT) { return true; } FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesStructs()) { setStruct(); return true; }"
      },
      {
        "txt": "return false; } public boolean makesDicts() { if (!isConstructor()) { return false; } if (propAccess == PropAccess.DICT) { return true; } FunctionType superc = getSuperClassConstructor();"
      },
      {
        "txt": "if (superc != null && superc.makesDicts()) { setDict(); return true; } return false; } public void setStruct() { propAccess = PropAccess.STRUCT; } public void setDict() {"
      },
      {
        "txt": "propAccess = PropAccess.DICT; } @Override public FunctionType toMaybeFunctionType() { return this; } @Override public boolean canBeCalled() { return true; }"
      },
      {
        "txt": "public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){ return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false;"
      },
      {
        "txt": "} public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else { return Collections.emptySet(); } } public Node getParametersNode() {"
      },
      {
        "txt": "return call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) { i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; }"
      },
      {
        "txt": "} return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) { Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); }"
      },
      {
        "txt": "} return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType; } public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() {"
      },
      {
        "txt": "return call; } @Override public Property getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype(); return prototypeSlot; } else { return super.getSlot(name); }"
      },
      {
        "txt": "} @Override public Set<String> getOwnPropertyNames() { if (prototypeSlot == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\"); names.addAll(super.getOwnPropertyNames()); return names; }"
      },
      {
        "txt": "} public ObjectType getPrototype() { if (prototypeSlot == null) { String refName = getReferenceName(); if (refName == null) { setPrototypeNoCheck( registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE), null); } else { setPrototype("
      },
      {
        "txt": "new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType()), null); } } return (ObjectType) prototypeSlot.getType(); }"
      },
      {
        "txt": "public void setPrototypeBasedOn(ObjectType baseType) { setPrototypeBasedOn(baseType, null); } void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) { if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); }"
      },
      {
        "txt": "setPrototype(baseType, propertyNode); } boolean setPrototype(ObjectType prototype, Node propertyNode) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false; } return setPrototypeNoCheck(prototype, propertyNode);"
      },
      {
        "txt": "} private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) { ObjectType oldPrototype = prototypeSlot == null ? null : (ObjectType) prototypeSlot.getType(); boolean replacedPrototype = oldPrototype != null; this.prototypeSlot = new Property(\"prototype\", prototype, true, propertyNode == null ? source : propertyNode); prototype.setOwnerFunction(this); if (oldPrototype != null) { oldPrototype.setOwnerFunction(null);"
      },
      {
        "txt": "} if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this);"
      },
      {
        "txt": "} } } } if (replacedPrototype) { clearCachedValues(); } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() {"
      },
      {
        "txt": "Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) {"
      },
      {
        "txt": "return; } set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ?"
      },
      {
        "txt": "getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces()); } } public Iterable<ObjectType> getOwnImplementedInterfaces() { return implementedInterfaces;"
      },
      {
        "txt": "} public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { if (isConstructor()) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } else { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "} public Iterable<ObjectType> getAllExtendedInterfaces() { Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) {"
      },
      {
        "txt": "FunctionType constructor = instance.getConstructor(); if (constructor != null) { set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } } } public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces;"
      },
      {
        "txt": "} public int getExtendedInterfacesCount() { return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException();"
      },
      {
        "txt": "} } @Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { boolean isCall = \"call\".equals(name); boolean isBind = \"bind\".equals(name); if (isCall || isBind) { defineDeclaredProperty(name, getCallOrBindSignature(isCall), source); } else if (\"apply\".equals(name)) {"
      },
      {
        "txt": "FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(),"
      },
      {
        "txt": "source); } } return super.getPropertyType(name); } public FunctionType getBindReturnType(int argsToBind) { FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(getReturnType()); if (argsToBind >= 0) { Node origParams = getParametersNode();"
      },
      {
        "txt": "if (origParams != null) { Node params = origParams.cloneTree(); for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) { if (params.getFirstChild().isVarArgs()) { break; } params.removeFirstChild(); } builder.withParamsNode(params); }"
      },
      {
        "txt": "} return builder.build(); } private FunctionType getCallOrBindSignature(boolean isCall) { boolean isBind = !isCall; FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(isCall ? getReturnType() : getBindReturnType(-1)); Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree();"
      },
      {
        "txt": "Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(isCall); if (isBind) { for (Node current = thisTypeNode.getNext(); current != null; current = current.getNext()) { current.setOptionalArg(true); }"
      },
      {
        "txt": "} builder.withParamsNode(params); } return builder.build(); } @Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType();"
      },
      {
        "txt": "if (objType != null) { if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) { return true; } this.setPrototypeBasedOn(objType, propertyNode); return true; } else { return false; }"
      },
      {
        "txt": "} return super.defineProperty(name, type, inferred, propertyNode); } FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) { Preconditions.checkNotNull(that); if (isEquivalentTo(that)) { return this; } if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() &&"
      },
      {
        "txt": "!that.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that); boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this; } else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper); if (merged != null) {"
      },
      {
        "txt": "return merged; } } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; }"
      },
      {
        "txt": "FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn; } private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, false)) {"
      },
      {
        "txt": "newParamsNode = call.parameters; } else { return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis;"
      },
      {
        "txt": "} else { JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);"
      },
      {
        "txt": "} } boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType( registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); }"
      },
      {
        "txt": "public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); } public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) {"
      },
      {
        "txt": "ObjectType foundType = null; if (type.hasProperty(propertyName)) { foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); } } return foundType;"
      },
      {
        "txt": "} public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getInstanceType().hasProperty(propertyName)); FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); } ObjectType topInstanceType = null; do {"
      },
      {
        "txt": "ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName)); return topInstanceType; } boolean checkFunctionEquivalenceHelper( <extra_id_0> if (isConstructor()) { if (that.isConstructor()) { return this == that; } return false; }"
      },
      {
        "txt": "return false; } if (isInterface()) { if (that.isInterface()) { return getReferenceName().equals(that.getReferenceName()); } return false; } if (that.isInterface()) { return false;"
      },
      {
        "txt": "} return typeOfThis.checkEquivalenceHelper( that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) {"
      },
      {
        "txt": "return this.call.checkArrowEquivalenceHelper(otherType.call, false); } @Override String toStringHelper(boolean forAnnotations) { if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } setPrettyPrint(false); StringBuilder b = new StringBuilder(32);"
      },
      {
        "txt": "b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType); if (hasKnownTypeOfThis) { if (isConstructor()) { b.append(\"new:\"); } else { b.append(\"this:\"); } b.append(typeOfThis.toStringHelper(forAnnotations));"
      },
      {
        "txt": "} if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); appendArgString(b, p, forAnnotations); p = p.getNext(); while (p != null) { b.append(\", \");"
      },
      {
        "txt": "appendArgString(b, p, forAnnotations); p = p.getNext(); } } b.append(\"): \"); b.append(call.returnType.toStringHelper(forAnnotations)); setPrettyPrint(true); return b.toString(); } private void appendArgString("
      },
      {
        "txt": "StringBuilder b, Node p, boolean forAnnotations) { if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType(), forAnnotations); } else if (p.isOptionalArg()) { appendOptionalArgString(b, p.getJSType(), forAnnotations); } else { b.append(p.getJSType().toStringHelper(forAnnotations)); } } private void appendVarArgsString(StringBuilder builder, JSType paramType,"
      },
      {
        "txt": "boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append( paramType.toStringHelper(forAnnotations)).append(\"]\"); } private void appendOptionalArgString( StringBuilder builder, JSType paramType, boolean forAnnotations) {"
      },
      {
        "txt": "if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(paramType.toStringHelper(forAnnotations)).append(\"=\"); } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true;"
      },
      {
        "txt": "} if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true; } if (this.isInterface()) { return false; } boolean treatThisTypesAsCovariant ="
      },
      {
        "txt": "this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); } @Override"
      },
      {
        "txt": "public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType; }"
      },
      {
        "txt": "public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis; } public Node getSource() { return source;"
      },
      {
        "txt": "} public void setSource(Node source) { if (prototypeSlot != null) { if (source == null || prototypeSlot.getNode() == null) { prototypeSlot = new Property(prototypeSlot.getName(), prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source); } } this.source = source; }"
      },
      {
        "txt": "private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType); } @Override public void clearCachedValues() { super.clearCachedValues(); if (subTypes != null) {"
      },
      {
        "txt": "for (FunctionType subType : subTypes) { subType.clearCachedValues(); } } if (!isNativeObjectType()) { if (hasInstanceType()) { getInstanceType().clearCachedValues(); } if (prototypeSlot != null) { ((ObjectType) prototypeSlot.getType()).clearCachedValues();"
      },
      {
        "txt": "} } } public List<FunctionType> getSubTypes() { return subTypes; } @Override public boolean hasCachedValues() { return prototypeSlot != null || super.hasCachedValues(); }"
      },
      {
        "txt": "public ImmutableList<String> getTemplateTypeNames() { return templateTypeNames; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); if (prototypeSlot != null) { prototypeSlot.setType( safeResolve(prototypeSlot.getType(), t, scope));"
      },
      {
        "txt": "} JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces ="
      },
      {
        "txt": "ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) {"
      },
      {
        "txt": "for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } } return super.resolveInternal(t, scope); } @Override public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {"
      },
      {
        "txt": "return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\"); b.append(getDebugHashCodeStringOf(typeOfThis)); }"
      },
      {
        "txt": "if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); while (p != null) { b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType()));"
      },
      {
        "txt": "p = p.getNext(); } } b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString(); } private String getDebugHashCodeStringOf(JSType type) { if (type == this) {"
      },
      {
        "txt": "return \"me\"; } else { return type.toDebugHashCodeString(); } } public FunctionType cloneWithoutArrowType() { FunctionType result = new FunctionType( registry, getReferenceName(), source, registry.createArrowType(null, null), getInstanceType(), null, true, false);"
      },
      {
        "txt": "result.setPrototypeBasedOn(getInstanceType()); return result; } @Override public boolean hasAnyTemplateInternal() { return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate(); }"
      }
    ]
  },
  {
    "id": 862,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 908,
    "end-bug-line": 909,
    "bug": "that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);",
    "fix": "that.typeOfThis, eqMethod) && call.checkArrowEquivalenceHelper(that.call, eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY, CONSTRUCTOR, INTERFACE }"
      },
      {
        "txt": "private enum PropAccess { ANY, STRUCT, DICT } private ArrowType call; private Property prototypeSlot; private final Kind kind; private PropAccess propAccess; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes;"
      },
      {
        "txt": "private final ImmutableList<String> templateTypeNames; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis, ImmutableList<String> templateTypeNames, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); setPrettyPrint(true); Preconditions.checkArgument(source == null ||"
      },
      {
        "txt": "Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; if (isConstructor) { this.kind = Kind.CONSTRUCTOR; this.propAccess = PropAccess.ANY; this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.kind = Kind.ORDINARY;"
      },
      {
        "txt": "this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType; this.templateTypeNames = templateTypeNames != null ? templateTypeNames : ImmutableList.<String>of(); } private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name,"
      },
      {
        "txt": "registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); setPrettyPrint(true); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null); this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); this.templateTypeNames = ImmutableList.of();"
      },
      {
        "txt": "} static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); } @Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override"
      },
      {
        "txt": "public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() { return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY;"
      },
      {
        "txt": "} public boolean makesStructs() { if (!isConstructor()) { return false; } if (propAccess == PropAccess.STRUCT) { return true; } FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesStructs()) {"
      },
      {
        "txt": "setStruct(); return true; } return false; } public boolean makesDicts() { if (!isConstructor()) { return false; } if (propAccess == PropAccess.DICT) {"
      },
      {
        "txt": "return true; } FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesDicts()) { setDict(); return true; } return false; } public void setStruct() {"
      },
      {
        "txt": "propAccess = PropAccess.STRUCT; } public void setDict() { propAccess = PropAccess.DICT; } @Override public FunctionType toMaybeFunctionType() { return this; } @Override"
      },
      {
        "txt": "public boolean canBeCalled() { return true; } public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){ return true; } FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor != null) {"
      },
      {
        "txt": "return superCtor.hasImplementedInterfaces(); } return false; } public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else { return Collections.emptySet();"
      },
      {
        "txt": "} } public Node getParametersNode() { return call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) { i++;"
      },
      {
        "txt": "if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) { Node lastParam = params.getLastChild();"
      },
      {
        "txt": "if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType; } public boolean isReturnTypeInferred() {"
      },
      {
        "txt": "return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call; } @Override public Property getSlot(String name) { if (\"prototype\".equals(name)) { getPrototype(); return prototypeSlot;"
      },
      {
        "txt": "} else { return super.getSlot(name); } } @Override public Set<String> getOwnPropertyNames() { if (prototypeSlot == null) { return super.getOwnPropertyNames(); } else { Set<String> names = Sets.newHashSet(\"prototype\");"
      },
      {
        "txt": "names.addAll(super.getOwnPropertyNames()); return names; } } public ObjectType getPrototype() { if (prototypeSlot == null) { String refName = getReferenceName(); if (refName == null) { setPrototypeNoCheck( registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),"
      },
      {
        "txt": "null); } else { setPrototype( new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType()), null); }"
      },
      {
        "txt": "} return (ObjectType) prototypeSlot.getType(); } public void setPrototypeBasedOn(ObjectType baseType) { setPrototypeBasedOn(baseType, null); } void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) { if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) {"
      },
      {
        "txt": "baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); } setPrototype(baseType, propertyNode); } boolean setPrototype(ObjectType prototype, Node propertyNode) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) {"
      },
      {
        "txt": "return false; } return setPrototypeNoCheck(prototype, propertyNode); } private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) { ObjectType oldPrototype = prototypeSlot == null ? null : (ObjectType) prototypeSlot.getType(); boolean replacedPrototype = oldPrototype != null; this.prototypeSlot = new Property(\"prototype\", prototype, true, propertyNode == null ? source : propertyNode);"
      },
      {
        "txt": "prototype.setOwnerFunction(this); if (oldPrototype != null) { oldPrototype.setOwnerFunction(null); } if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) {"
      },
      {
        "txt": "for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } } } } if (replacedPrototype) { clearCachedValues(); }"
      },
      {
        "txt": "return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) {"
      },
      {
        "txt": "FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; } set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set); } }"
      },
      {
        "txt": "} public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces()); }"
      },
      {
        "txt": "} public Iterable<ObjectType> getOwnImplementedInterfaces() { return implementedInterfaces; } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { if (isConstructor()) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);"
      },
      {
        "txt": "} else { throw new UnsupportedOperationException(); } } public Iterable<ObjectType> getAllExtendedInterfaces() { Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); } return extendedInterfaces;"
      },
      {
        "txt": "} private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set); } }"
      },
      {
        "txt": "} public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces; } public int getExtendedInterfacesCount() { return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { if (isInterface()) {"
      },
      {
        "txt": "this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException(); } } @Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) { boolean isCall = \"call\".equals(name); boolean isBind = \"bind\".equals(name);"
      },
      {
        "txt": "if (isCall || isBind) { defineDeclaredProperty(name, getCallOrBindSignature(isCall), source); } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionBuilder(registry)"
      },
      {
        "txt": ".withParams(builder) .withReturnType(getReturnType()) .build(), source); } } return super.getPropertyType(name); } public FunctionType getBindReturnType(int argsToBind) { FunctionBuilder builder = new FunctionBuilder(registry)"
      },
      {
        "txt": ".withReturnType(getReturnType()); if (argsToBind >= 0) { Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree(); for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) { if (params.getFirstChild().isVarArgs()) { break; } params.removeFirstChild();"
      },
      {
        "txt": "} builder.withParamsNode(params); } } return builder.build(); } private FunctionType getCallOrBindSignature(boolean isCall) { boolean isBind = !isCall; FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(isCall ? getReturnType() : getBindReturnType(-1));"
      },
      {
        "txt": "Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(isCall); if (isBind) { for (Node current = thisTypeNode.getNext();"
      },
      {
        "txt": "current != null; current = current.getNext()) { current.setOptionalArg(true); } } builder.withParamsNode(params); } return builder.build(); } @Override boolean defineProperty(String name, JSType type,"
      },
      {
        "txt": "boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) { return true; } this.setPrototypeBasedOn(objType, propertyNode); return true;"
      },
      {
        "txt": "} else { return false; } } return super.defineProperty(name, type, inferred, propertyNode); } FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) { Preconditions.checkNotNull(that); if (isEquivalentTo(that)) { return this;"
      },
      {
        "txt": "} if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that); boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this; } else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that;"
      },
      {
        "txt": "} FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper); if (merged != null) { return merged; } } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this;"
      },
      {
        "txt": "} else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn; } private FunctionType tryMergeFunctionPiecewise("
      },
      {
        "txt": "FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, false)) { newParamsNode = call.parameters; } else { return null; } JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType);"
      },
      {
        "txt": "ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis; } else { JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) { newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else {"
      },
      {
        "txt": "newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE); } } boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType( registry, null, null, new ArrowType("
      },
      {
        "txt": "registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor();"
      },
      {
        "txt": "} public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { ObjectType foundType = null; if (type.hasProperty(propertyName)) { foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName);"
      },
      {
        "txt": "} } return foundType; } public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getInstanceType().hasProperty(propertyName)); FunctionType ctor = this; if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName);"
      },
      {
        "txt": "} ObjectType topInstanceType = null; do { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName)); return topInstanceType; } boolean checkFunctionEquivalenceHelper("
      },
      {
        "txt": "FunctionType that, boolean tolerateUnknowns) { if (isConstructor()) { if (that.isConstructor()) { return this == that; } return false; } if (isInterface()) { if (that.isInterface()) { return getReferenceName().equals(that.getReferenceName());"
      },
      {
        "txt": "return false; } if (that.isInterface()) { return false; } return typeOfThis.checkEquivalenceHelper( <extra_id_0> } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) {"
      },
      {
        "txt": "} public boolean hasEqualCallType(FunctionType otherType) { return this.call.checkArrowEquivalenceHelper(otherType.call, false); } @Override String toStringHelper(boolean forAnnotations) { if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; }"
      },
      {
        "txt": "setPrettyPrint(false); StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType); if (hasKnownTypeOfThis) { if (isConstructor()) { b.append(\"new:\"); } else { b.append(\"this:\");"
      },
      {
        "txt": "} b.append(typeOfThis.toStringHelper(forAnnotations)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); appendArgString(b, p, forAnnotations); p = p.getNext();"
      },
      {
        "txt": "while (p != null) { b.append(\", \"); appendArgString(b, p, forAnnotations); p = p.getNext(); } } b.append(\"): \"); b.append(call.returnType.toStringHelper(forAnnotations)); setPrettyPrint(true); return b.toString();"
      },
      {
        "txt": "} private void appendArgString( StringBuilder b, Node p, boolean forAnnotations) { if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType(), forAnnotations); } else if (p.isOptionalArg()) { appendOptionalArgString(b, p.getJSType(), forAnnotations); } else { b.append(p.getJSType().toStringHelper(forAnnotations)); }"
      },
      {
        "txt": "} private void appendVarArgsString(StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append( paramType.toStringHelper(forAnnotations)).append(\"]\"); }"
      },
      {
        "txt": "private void appendOptionalArgString( StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(paramType.toStringHelper(forAnnotations)).append(\"=\"); } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (JSType.isSubtypeHelper(this, that)) { return true; } if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true; } if (this.isInterface()) { return false;"
      },
      {
        "txt": "} boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);"
      },
      {
        "txt": "} @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) {"
      },
      {
        "txt": "typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis; }"
      },
      {
        "txt": "public Node getSource() { return source; } public void setSource(Node source) { if (prototypeSlot != null) { if (source == null || prototypeSlot.getNode() == null) { prototypeSlot = new Property(prototypeSlot.getName(), prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source); } }"
      },
      {
        "txt": "this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType); } @Override public void clearCachedValues() {"
      },
      {
        "txt": "super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) { subType.clearCachedValues(); } } if (!isNativeObjectType()) { if (hasInstanceType()) { getInstanceType().clearCachedValues(); }"
      },
      {
        "txt": "if (prototypeSlot != null) { ((ObjectType) prototypeSlot.getType()).clearCachedValues(); } } } public List<FunctionType> getSubTypes() { return subTypes; } @Override public boolean hasCachedValues() {"
      },
      {
        "txt": "return prototypeSlot != null || super.hasCachedValues(); } public ImmutableList<String> getTemplateTypeNames() { return templateTypeNames; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); if (prototypeSlot != null) {"
      },
      {
        "txt": "prototypeSlot.setType( safeResolve(prototypeSlot.getType(), t, scope)); } JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
      },
      {
        "txt": "boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build();"
      },
      {
        "txt": "} if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } } return super.resolveInternal(t, scope); } @Override"
      },
      {
        "txt": "public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\");"
      },
      {
        "txt": "b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); while (p != null) {"
      },
      {
        "txt": "b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\"); b.append(\": \"); b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString(); }"
      },
      {
        "txt": "private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); } } public FunctionType cloneWithoutArrowType() { FunctionType result = new FunctionType( registry, getReferenceName(), source,"
      },
      {
        "txt": "registry.createArrowType(null, null), getInstanceType(), null, true, false); result.setPrototypeBasedOn(getInstanceType()); return result; } @Override public boolean hasAnyTemplateInternal() { return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate();"
      }
    ]
  },
  {
    "id": 863,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 918,
    "end-bug-line": 918,
    "bug": "return this.call.checkArrowEquivalenceHelper(otherType.call, false);",
    "fix": "return this.call.checkArrowEquivalenceHelper( otherType.call, EquivalenceMethod.IDENTITY);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY, CONSTRUCTOR,"
      },
      {
        "txt": "INTERFACE } private enum PropAccess { ANY, STRUCT, DICT } private ArrowType call; private Property prototypeSlot; private final Kind kind; private PropAccess propAccess; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of();"
      },
      {
        "txt": "private List<ObjectType> extendedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private final ImmutableList<String> templateTypeNames; FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, ObjectType typeOfThis, ImmutableList<String> templateTypeNames, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType);"
      },
      {
        "txt": "setPrettyPrint(true); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkNotNull(arrowType); this.source = source; if (isConstructor) { this.kind = Kind.CONSTRUCTOR; this.propAccess = PropAccess.ANY; this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType);"
      },
      {
        "txt": "} else { this.kind = Kind.ORDINARY; this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = arrowType; this.templateTypeNames = templateTypeNames != null ? templateTypeNames : ImmutableList.<String>of(); }"
      },
      {
        "txt": "private FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); setPrettyPrint(true); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null); this.kind = Kind.INTERFACE;"
      },
      {
        "txt": "this.typeOfThis = new InstanceObjectType(registry, this); this.templateTypeNames = ImmutableList.of(); } static FunctionType forInterface( JSTypeRegistry registry, String name, Node source) { return new FunctionType(registry, name, source); } @Override public boolean isInstanceType() { return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));"
      },
      {
        "txt": "} @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() { return kind == Kind.INTERFACE; } @Override"
      },
      {
        "txt": "public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } public boolean makesStructs() { if (!isConstructor()) { return false; } if (propAccess == PropAccess.STRUCT) { return true; }"
      },
      {
        "txt": "FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesStructs()) { setStruct(); return true; } return false; } public boolean makesDicts() { if (!isConstructor()) { return false;"
      },
      {
        "txt": "} if (propAccess == PropAccess.DICT) { return true; } FunctionType superc = getSuperClassConstructor(); if (superc != null && superc.makesDicts()) { setDict(); return true; } return false;"
      },
      {
        "txt": "} public void setStruct() { propAccess = PropAccess.STRUCT; } public void setDict() { propAccess = PropAccess.DICT; } @Override public FunctionType toMaybeFunctionType() { return this;"
      },
      {
        "txt": "} @Override public boolean canBeCalled() { return true; } public boolean hasImplementedInterfaces() { if (!implementedInterfaces.isEmpty()){ return true; } FunctionType superCtor = isConstructor() ?"
      },
      {
        "txt": "getSuperClassConstructor() : null; if (superCtor != null) { return superCtor.hasImplementedInterfaces(); } return false; } public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children();"
      },
      {
        "txt": "} else { return Collections.emptySet(); } } public Node getParametersNode() { return call.parameters; } public int getMinArguments() { int i = 0; int min = 0;"
      },
      {
        "txt": "for (Node n : getParameters()) { i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min; } public int getMaxArguments() { Node params = getParametersNode();"
      },
      {
        "txt": "if (params != null) { Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE; } public JSType getReturnType() { return call.returnType;"
      },
      {
        "txt": "} public boolean isReturnTypeInferred() { return call.returnTypeInferred; } ArrowType getInternalArrowType() { return call; } @Override public Property getSlot(String name) { if (\"prototype\".equals(name)) {"
      },
      {
        "txt": "getPrototype(); return prototypeSlot; } else { return super.getSlot(name); } } @Override public Set<String> getOwnPropertyNames() { if (prototypeSlot == null) { return super.getOwnPropertyNames();"
      },
      {
        "txt": "} else { Set<String> names = Sets.newHashSet(\"prototype\"); names.addAll(super.getOwnPropertyNames()); return names; } } public ObjectType getPrototype() { if (prototypeSlot == null) { String refName = getReferenceName(); if (refName == null) {"
      },
      {
        "txt": "setPrototypeNoCheck( registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE), null); } else { setPrototype( new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType()),"
      },
      {
        "txt": "null); } } return (ObjectType) prototypeSlot.getType(); } public void setPrototypeBasedOn(ObjectType baseType) { setPrototypeBasedOn(baseType, null); } void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) { if (baseType.hasReferenceName() ||"
      },
      {
        "txt": "isNativeObjectType() || baseType.isFunctionPrototypeType()) { baseType = new PrototypeObjectType( registry, this.getReferenceName() + \".prototype\", baseType); } setPrototype(baseType, propertyNode); } boolean setPrototype(ObjectType prototype, Node propertyNode) { if (prototype == null) { return false;"
      },
      {
        "txt": "} if (isConstructor() && prototype == getInstanceType()) { return false; } return setPrototypeNoCheck(prototype, propertyNode); } private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) { ObjectType oldPrototype = prototypeSlot == null ? null : (ObjectType) prototypeSlot.getType(); boolean replacedPrototype = oldPrototype != null;"
      },
      {
        "txt": "this.prototypeSlot = new Property(\"prototype\", prototype, true, propertyNode == null ? source : propertyNode); prototype.setOwnerFunction(this); if (oldPrototype != null) { oldPrototype.setOwnerFunction(null); } if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this);"
      },
      {
        "txt": "} if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } } } } if (replacedPrototype) {"
      },
      {
        "txt": "clearCachedValues(); } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newLinkedHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces;"
      },
      {
        "txt": "} private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; } set.add(instance); for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { addRelatedInterfaces(interfaceType, set);"
      },
      {
        "txt": "} } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat("
      },
      {
        "txt": "implementedInterfaces, superCtor.getImplementedInterfaces()); } } public Iterable<ObjectType> getOwnImplementedInterfaces() { return implementedInterfaces; } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { if (isConstructor()) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type);"
      },
      {
        "txt": "} this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } else { throw new UnsupportedOperationException(); } } public Iterable<ObjectType> getAllExtendedInterfaces() { Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); for (ObjectType interfaceType : getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, extendedInterfaces);"
      },
      {
        "txt": "} return extendedInterfaces; } private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { set.add(instance); for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { addRelatedExtendedInterfaces(interfaceType, set);"
      },
      {
        "txt": "} } } public Iterable<ObjectType> getExtendedInterfaces() { return extendedInterfaces; } public int getExtendedInterfacesCount() { return extendedInterfaces.size(); } public void setExtendedInterfaces(List<ObjectType> extendedInterfaces)"
      },
      {
        "txt": "throws UnsupportedOperationException { if (isInterface()) { this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); } else { throw new UnsupportedOperationException(); } } @Override public JSType getPropertyType(String name) { if (!hasOwnProperty(name)) {"
      },
      {
        "txt": "boolean isCall = \"call\".equals(name); boolean isBind = \"bind\".equals(name); if (isCall || isBind) { defineDeclaredProperty(name, getCallOrBindSignature(isCall), source); } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE)));"
      },
      {
        "txt": "defineDeclaredProperty(name, new FunctionBuilder(registry) .withParams(builder) .withReturnType(getReturnType()) .build(), source); } } return super.getPropertyType(name); }"
      },
      {
        "txt": "public FunctionType getBindReturnType(int argsToBind) { FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(getReturnType()); if (argsToBind >= 0) { Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree(); for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) { if (params.getFirstChild().isVarArgs()) { break;"
      },
      {
        "txt": "} params.removeFirstChild(); } builder.withParamsNode(params); } } return builder.build(); } private FunctionType getCallOrBindSignature(boolean isCall) { boolean isBind = !isCall;"
      },
      {
        "txt": "FunctionBuilder builder = new FunctionBuilder(registry) .withReturnType(isCall ? getReturnType() : getBindReturnType(-1)); Node origParams = getParametersNode(); if (origParams != null) { Node params = origParams.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(isCall);"
      },
      {
        "txt": "if (isBind) { for (Node current = thisTypeNode.getNext(); current != null; current = current.getNext()) { current.setOptionalArg(true); } } builder.withParamsNode(params); } return builder.build(); }"
      },
      {
        "txt": "@Override boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) { return true; }"
      },
      {
        "txt": "this.setPrototypeBasedOn(objType, propertyNode); return true; } else { return false; } } return super.defineProperty(name, type, inferred, propertyNode); } FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) { Preconditions.checkNotNull(that);"
      },
      {
        "txt": "if (isEquivalentTo(that)) { return this; } if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) { boolean isSubtypeOfThat = this.isSubtype(that); boolean isSubtypeOfThis = that.isSubtype(this); if (isSubtypeOfThat && !isSubtypeOfThis) { return leastSuper ? that : this;"
      },
      {
        "txt": "} else if (isSubtypeOfThis && !isSubtypeOfThat) { return leastSuper ? this : that; } FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper); if (merged != null) { return merged; } } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE);"
      },
      {
        "txt": "if (functionInstance.isEquivalentTo(that)) { return leastSuper ? that : this; } else if (functionInstance.isEquivalentTo(this)) { return leastSuper ? this : that; } FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); return leastSuper ? greatestFn : leastFn;"
      },
      {
        "txt": "} private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, false)) { newParamsNode = call.parameters; } else { return null; } JSType newReturnType = leastSuper ?"
      },
      {
        "txt": "call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); ObjectType newTypeOfThis = null; if (isEquivalent(typeOfThis, other.typeOfThis)) { newTypeOfThis = typeOfThis; } else { JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); if (maybeNewTypeOfThis instanceof ObjectType) {"
      },
      {
        "txt": "newTypeOfThis = (ObjectType) maybeNewTypeOfThis; } else { newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE); } } boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; return new FunctionType("
      },
      {
        "txt": "registry, null, null, new ArrowType( registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); } public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null;"
      },
      {
        "txt": "} return maybeSuperInstanceType.getConstructor(); } public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { ObjectType foundType = null; if (type.hasProperty(propertyName)) { foundType = type; } for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) {"
      },
      {
        "txt": "if (interfaceType.hasProperty(propertyName)) { foundType = getTopDefiningInterface(interfaceType, propertyName); } } return foundType; } public ObjectType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getInstanceType().hasProperty(propertyName)); FunctionType ctor = this;"
      },
      {
        "txt": "if (isInterface()) { return getTopDefiningInterface(this.getInstanceType(), propertyName); } ObjectType topInstanceType = null; do { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName)); return topInstanceType;"
      },
      {
        "txt": "} boolean checkFunctionEquivalenceHelper( FunctionType that, boolean tolerateUnknowns) { if (isConstructor()) { if (that.isConstructor()) { return this == that; } return false; } if (isInterface()) {"
      },
      {
        "txt": "if (that.isInterface()) { return getReferenceName().equals(that.getReferenceName()); } return false; } if (that.isInterface()) { return false; } return typeOfThis.checkEquivalenceHelper( that.typeOfThis, tolerateUnknowns) &&"
      },
      {
        "txt": "} @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) { <extra_id_0> } @Override String toStringHelper(boolean forAnnotations) { if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\";"
      },
      {
        "txt": "this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } setPrettyPrint(false); StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType); if (hasKnownTypeOfThis) { if (isConstructor()) {"
      },
      {
        "txt": "b.append(\"new:\"); } else { b.append(\"this:\"); } b.append(typeOfThis.toStringHelper(forAnnotations)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); }"
      },
      {
        "txt": "Node p = call.parameters.getFirstChild(); appendArgString(b, p, forAnnotations); p = p.getNext(); while (p != null) { b.append(\", \"); appendArgString(b, p, forAnnotations); p = p.getNext(); } } b.append(\"): \");"
      },
      {
        "txt": "b.append(call.returnType.toStringHelper(forAnnotations)); setPrettyPrint(true); return b.toString(); } private void appendArgString( StringBuilder b, Node p, boolean forAnnotations) { if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType(), forAnnotations); } else if (p.isOptionalArg()) { appendOptionalArgString(b, p.getJSType(), forAnnotations);"
      },
      {
        "txt": "} else { b.append(p.getJSType().toStringHelper(forAnnotations)); } } private void appendVarArgsString(StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); }"
      },
      {
        "txt": "builder.append(\"...[\").append( paramType.toStringHelper(forAnnotations)).append(\"]\"); } private void appendOptionalArgString( StringBuilder builder, JSType paramType, boolean forAnnotations) { if (paramType.isUnionType()) { paramType = paramType.toMaybeUnionType().getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(paramType.toStringHelper(forAnnotations)).append(\"=\");"
      },
      {
        "txt": "} @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } if (that.isFunctionType()) { FunctionType other = that.toMaybeFunctionType(); if (other.isInterface()) { return true;"
      },
      {
        "txt": "} if (this.isInterface()) { return false; } boolean treatThisTypesAsCovariant = this.isConstructor() || other.isConstructor() || (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);"
      },
      {
        "txt": "return treatThisTypesAsCovariant && this.call.isSubtype(other.call); } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); } @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType());"
      },
      {
        "txt": "return typeOfThis; } void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); } @Override public ObjectType getTypeOfThis() {"
      },
      {
        "txt": "return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis; } public Node getSource() { return source; } public void setSource(Node source) { if (prototypeSlot != null) { if (source == null || prototypeSlot.getNode() == null) { prototypeSlot = new Property(prototypeSlot.getName(),"
      },
      {
        "txt": "prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source); } } this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType);"
      },
      {
        "txt": "} @Override public void clearCachedValues() { super.clearCachedValues(); if (subTypes != null) { for (FunctionType subType : subTypes) { subType.clearCachedValues(); } } if (!isNativeObjectType()) {"
      },
      {
        "txt": "if (hasInstanceType()) { getInstanceType().clearCachedValues(); } if (prototypeSlot != null) { ((ObjectType) prototypeSlot.getType()).clearCachedValues(); } } } public List<FunctionType> getSubTypes() { return subTypes;"
      },
      {
        "txt": "} @Override public boolean hasCachedValues() { return prototypeSlot != null || super.hasCachedValues(); } public ImmutableList<String> getTemplateTypeNames() { return templateTypeNames; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {"
      },
      {
        "txt": "setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); if (prototypeSlot != null) { prototypeSlot.setType( safeResolve(prototypeSlot.getType(), t, scope)); } JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); }"
      },
      {
        "txt": "if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface);"
      },
      {
        "txt": "} if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set( i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); } }"
      },
      {
        "txt": "return super.resolveInternal(t, scope); } @Override public String toDebugHashCodeString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return super.toDebugHashCodeString(); } StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = call.parameters.getChildCount();"
      },
      {
        "txt": "boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\"); b.append(getDebugHashCodeStringOf(typeOfThis)); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild();"
      },
      {
        "txt": "b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); while (p != null) { b.append(\", \"); b.append(getDebugHashCodeStringOf(p.getJSType())); p = p.getNext(); } } b.append(\")\"); b.append(\": \");"
      },
      {
        "txt": "b.append(getDebugHashCodeStringOf(call.returnType)); return b.toString(); } private String getDebugHashCodeStringOf(JSType type) { if (type == this) { return \"me\"; } else { return type.toDebugHashCodeString(); } }"
      },
      {
        "txt": "public FunctionType cloneWithoutArrowType() { FunctionType result = new FunctionType( registry, getReferenceName(), source, registry.createArrowType(null, null), getInstanceType(), null, true, false); result.setPrototypeBasedOn(getInstanceType()); return result; } @Override public boolean hasAnyTemplateInternal() {"
      },
      {
        "txt": "return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate(); }"
      }
    ]
  },
  {
    "id": 864,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 492,
    "end-bug-line": 492,
    "bug": "return checkEquivalenceHelper(that, false);",
    "fix": "return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator;"
      },
      {
        "txt": "public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE ="
      },
      {
        "txt": "\"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1;"
      },
      {
        "txt": "public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null;"
      },
      {
        "txt": "} public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false;"
      },
      {
        "txt": "} public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; }"
      },
      {
        "txt": "public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false;"
      },
      {
        "txt": "} public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; }"
      },
      {
        "txt": "public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));"
      },
      {
        "txt": "} public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; }"
      },
      {
        "txt": "public boolean isRegexpType() { return false; } public boolean isDateType() { return false; } public boolean isNullType() { return false; } public boolean isVoidType() {"
      },
      {
        "txt": "return false; } public boolean isAllType() { return false; } public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false;"
      },
      {
        "txt": "} public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false;"
      },
      {
        "txt": "} public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null;"
      },
      {
        "txt": "} public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; }"
      },
      {
        "txt": "public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() {"
      },
      {
        "txt": "return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; } boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null;"
      },
      {
        "txt": "} RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; }"
      },
      {
        "txt": "public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) {"
      },
      {
        "txt": "return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false;"
      },
      {
        "txt": "} } boolean hasAnyTemplateInternal() { return false; } public boolean isObject() { return false; } public boolean isConstructor() { return false;"
      },
      {
        "txt": "} public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; }"
      },
      {
        "txt": "if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() { return false; }"
      },
      {
        "txt": "return false; } public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { <extra_id_0> } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true);"
      },
      {
        "txt": "public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) {"
      },
      {
        "txt": "if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns);"
      },
      {
        "txt": "} if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType();"
      },
      {
        "txt": "ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false;"
      },
      {
        "txt": "} JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals("
      },
      {
        "txt": "that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(),"
      },
      {
        "txt": "tolerateUnknowns); } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) {"
      },
      {
        "txt": "return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); }"
      },
      {
        "txt": "public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() {"
      },
      {
        "txt": "return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() {"
      },
      {
        "txt": "return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; } return false; } public JSType autoboxesTo() { return null;"
      },
      {
        "txt": "} public JSType unboxesTo() { return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo();"
      },
      {
        "txt": "return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that);"
      },
      {
        "txt": "} TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType();"
      },
      {
        "txt": "if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype("
      },
      {
        "txt": "getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); }"
      },
      {
        "txt": "return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); }"
      },
      {
        "txt": "public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); }"
      },
      {
        "txt": "return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that);"
      },
      {
        "txt": "} static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);"
      },
      {
        "txt": "} else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType);"
      },
      {
        "txt": "if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) {"
      },
      {
        "txt": "if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; }"
      },
      {
        "txt": "} if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); }"
      },
      {
        "txt": "} return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this;"
      },
      {
        "txt": "} else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); }"
      },
      {
        "txt": "switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) {"
      },
      {
        "txt": "if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN:"
      },
      {
        "txt": "return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) {"
      },
      {
        "txt": "TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } }"
      },
      {
        "txt": "public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; }"
      },
      {
        "txt": "if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) {"
      },
      {
        "txt": "return true; } } } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; }"
      },
      {
        "txt": "public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) {"
      },
      {
        "txt": "if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; }"
      },
      {
        "txt": "abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; } public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false;"
      },
      {
        "txt": "resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair {"
      },
      {
        "txt": "public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false);"
      },
      {
        "txt": "} public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 865,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 500,
    "end-bug-line": 500,
    "bug": "return checkEquivalenceHelper(that, false);",
    "fix": "return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false;"
      },
      {
        "txt": "private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\";"
      },
      {
        "txt": "static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) {"
      },
      {
        "txt": "this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null;"
      },
      {
        "txt": "} public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false;"
      },
      {
        "txt": "} public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType("
      },
      {
        "txt": "JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false;"
      },
      {
        "txt": "} public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false; }"
      },
      {
        "txt": "public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false;"
      },
      {
        "txt": "} public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false; }"
      },
      {
        "txt": "public boolean isDateType() { return false; } public boolean isNullType() { return false; } public boolean isVoidType() { return false; } public boolean isAllType() {"
      },
      {
        "txt": "return false; } public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null;"
      },
      {
        "txt": "} public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() { if (isObject()) {"
      },
      {
        "txt": "FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS);"
      },
      {
        "txt": "} public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); }"
      },
      {
        "txt": "public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() {"
      },
      {
        "txt": "return null; } boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null;"
      },
      {
        "txt": "} public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); }"
      },
      {
        "txt": "public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() {"
      },
      {
        "txt": "if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false; } } boolean hasAnyTemplateInternal() {"
      },
      {
        "txt": "return false; } public boolean isObject() { return false; } public boolean isConstructor() { return false; } public boolean isNominalType() { return false;"
      },
      {
        "txt": "} public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true; }"
      },
      {
        "txt": "return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() { return false; } public boolean isInterface() { return false; }"
      },
      {
        "txt": "return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { <extra_id_0> } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) {"
      },
      {
        "txt": "boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown &&"
      },
      {
        "txt": "(isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper("
      },
      {
        "txt": "that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false;"
      },
      {
        "txt": "if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();"
      },
      {
        "txt": "JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) {"
      },
      {
        "txt": "return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that;"
      },
      {
        "txt": "} public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; }"
      },
      {
        "txt": "@Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); }"
      },
      {
        "txt": "public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) {"
      },
      {
        "txt": "ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) {"
      },
      {
        "txt": "if (this.isSubtype(that)) { return true; } return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null;"
      },
      {
        "txt": "} public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() {"
      },
      {
        "txt": "return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() ||"
      },
      {
        "txt": "bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE;"
      },
      {
        "txt": "} else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE;"
      },
      {
        "txt": "} else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) {"
      },
      {
        "txt": "if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); }"
      },
      {
        "txt": "public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) {"
      },
      {
        "txt": "boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) {"
      },
      {
        "txt": "return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) {"
      },
      {
        "txt": "return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); }"
      },
      {
        "txt": "if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; }"
      },
      {
        "txt": "} if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) {"
      },
      {
        "txt": "UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);"
      },
      {
        "txt": "for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); } } return type; }"
      },
      {
        "txt": "public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); }"
      },
      {
        "txt": "} public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null);"
      },
      {
        "txt": "case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA);"
      },
      {
        "txt": "} switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException();"
      },
      {
        "txt": "} public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); }"
      },
      {
        "txt": "if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this; }"
      },
      {
        "txt": "public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true; }"
      },
      {
        "txt": "if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } }"
      },
      {
        "txt": "} if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode();"
      },
      {
        "txt": "registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); }"
      },
      {
        "txt": "return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type;"
      },
      {
        "txt": "resolved = true; } public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve("
      },
      {
        "txt": "JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) {"
      },
      {
        "txt": "this.typeA = typeA; this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\";"
      },
      {
        "txt": "} public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 866,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 514,
    "end-bug-line": 514,
    "bug": "return !checkEquivalenceHelper(that, true);",
    "fix": "return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME ="
      },
      {
        "txt": "\"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) {"
      },
      {
        "txt": "return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) {"
      },
      {
        "txt": "return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName();"
      },
      {
        "txt": "return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false;"
      },
      {
        "txt": "} public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() {"
      },
      {
        "txt": "return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false;"
      },
      {
        "txt": "} boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));"
      },
      {
        "txt": "} public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false;"
      },
      {
        "txt": "} public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false; } public boolean isDateType() { return false; }"
      },
      {
        "txt": "public boolean isNullType() { return false; } public boolean isVoidType() { return false; } public boolean isAllType() { return false; } public boolean isUnknownType() {"
      },
      {
        "txt": "return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) {"
      },
      {
        "txt": "FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); }"
      },
      {
        "txt": "return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null;"
      },
      {
        "txt": "} public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; }"
      },
      {
        "txt": "public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; } boolean isNamedType() {"
      },
      {
        "txt": "return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null;"
      },
      {
        "txt": "} public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; }"
      },
      {
        "txt": "public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal();"
      },
      {
        "txt": "this.inTemplatedCheckVisit = false; return result; } else { return false; } } boolean hasAnyTemplateInternal() { return false; } public boolean isObject() {"
      },
      {
        "txt": "return false; } public boolean isConstructor() { return false; } public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) {"
      },
      {
        "txt": "FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); } return false;"
      },
      {
        "txt": "} public boolean isInstanceType() { return false; } public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false; }"
      },
      {
        "txt": "return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { <extra_id_0> } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType();"
      },
      {
        "txt": "} boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; }"
      },
      {
        "txt": "} if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) {"
      },
      {
        "txt": "return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns);"
      },
      {
        "txt": "} else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch &&"
      },
      {
        "txt": "thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns);"
      },
      {
        "txt": "} if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ?"
      },
      {
        "txt": "typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() { return System.identityHashCode(this);"
      },
      {
        "txt": "} public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false; }"
      },
      {
        "txt": "public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName);"
      },
      {
        "txt": "} return null; } public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; }"
      },
      {
        "txt": "return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null;"
      },
      {
        "txt": "} public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) {"
      },
      {
        "txt": "return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) {"
      },
      {
        "txt": "return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN; }"
      },
      {
        "txt": "} if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; }"
      },
      {
        "txt": "} if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); }"
      },
      {
        "txt": "JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this; }"
      },
      {
        "txt": "public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType("
      },
      {
        "txt": "thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) {"
      },
      {
        "txt": "return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType);"
      },
      {
        "txt": "} else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) {"
      },
      {
        "txt": "return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);"
      },
      {
        "txt": "} return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) {"
      },
      {
        "txt": "if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt);"
      },
      {
        "txt": "} } return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);"
      },
      {
        "txt": "} BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) {"
      },
      {
        "txt": "if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that);"
      },
      {
        "txt": "} throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE:"
      },
      {
        "txt": "JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that);"
      },
      {
        "txt": "return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null);"
      },
      {
        "txt": "} else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); }"
      },
      {
        "txt": "static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true; }"
      },
      {
        "txt": "if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype("
      },
      {
        "txt": "((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode);"
      },
      {
        "txt": "return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; } resolved = true;"
      },
      {
        "txt": "resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; } public final boolean isResolved() {"
      },
      {
        "txt": "return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); }"
      },
      {
        "txt": "public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; }"
      },
      {
        "txt": "} @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true);"
      },
      {
        "txt": "} abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 867,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 520,
    "end-bug-line": 520,
    "bug": "boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {",
    "fix": "boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS ="
      },
      {
        "txt": "\"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); }"
      },
      {
        "txt": "}; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      },
      {
        "txt": "public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); }"
      },
      {
        "txt": "public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() {"
      },
      {
        "txt": "return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; }"
      },
      {
        "txt": "public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false; } boolean isTheObjectType() {"
      },
      {
        "txt": "return false; } public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() {"
      },
      {
        "txt": "return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() {"
      },
      {
        "txt": "return false; } public boolean isRegexpType() { return false; } public boolean isDateType() { return false; } public boolean isNullType() { return false;"
      },
      {
        "txt": "} public boolean isVoidType() { return false; } public boolean isAllType() { return false; } public boolean isUnknownType() { return false; }"
      },
      {
        "txt": "public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs();"
      },
      {
        "txt": "} return false; } public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; }"
      },
      {
        "txt": "public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() {"
      },
      {
        "txt": "return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null;"
      },
      {
        "txt": "} public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; } boolean isNamedType() { return false; }"
      },
      {
        "txt": "public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() {"
      },
      {
        "txt": "return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null;"
      },
      {
        "txt": "} public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result;"
      },
      {
        "txt": "} else { return false; } } boolean hasAnyTemplateInternal() { return false; } public boolean isObject() { return false; }"
      },
      {
        "txt": "public boolean isConstructor() { return false; } public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) {"
      },
      {
        "txt": "return false; } if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() {"
      },
      {
        "txt": "return false; } public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false);"
      },
      {
        "txt": "public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } <extra_id_0> if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) {"
      },
      {
        "txt": "boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) {"
      },
      {
        "txt": "return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns);"
      },
      {
        "txt": "} ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true;"
      },
      {
        "txt": "} else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); }"
      },
      {
        "txt": "if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) {"
      },
      {
        "txt": "return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); }"
      },
      {
        "txt": "@Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() {"
      },
      {
        "txt": "return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false;"
      },
      {
        "txt": "} public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null;"
      },
      {
        "txt": "} public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; } return false; }"
      },
      {
        "txt": "public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() {"
      },
      {
        "txt": "JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); }"
      },
      {
        "txt": "public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; }"
      },
      {
        "txt": "boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) {"
      },
      {
        "txt": "JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) {"
      },
      {
        "txt": "return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() ||"
      },
      {
        "txt": "inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) {"
      },
      {
        "txt": "return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); }"
      },
      {
        "txt": "public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) {"
      },
      {
        "txt": "return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType);"
      },
      {
        "txt": "} else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; }"
      },
      {
        "txt": "} else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE);"
      },
      {
        "txt": "} static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true;"
      },
      {
        "txt": "break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } }"
      },
      {
        "txt": "return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes();"
      },
      {
        "txt": "if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this);"
      },
      {
        "txt": "return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException();"
      },
      {
        "txt": "} public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType);"
      },
      {
        "txt": "case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); }"
      },
      {
        "txt": "public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that);"
      },
      {
        "txt": "} } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) {"
      },
      {
        "txt": "return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType();"
      },
      {
        "txt": "for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); }"
      },
      {
        "txt": "return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; }"
      },
      {
        "txt": "public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult);"
      },
      {
        "txt": "return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; } public final boolean isResolved() { return resolved; }"
      },
      {
        "txt": "public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this);"
      },
      {
        "txt": "} public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; } } @Override"
      },
      {
        "txt": "public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations);"
      }
    ]
  },
  {
    "id": 868,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 528,
    "end-bug-line": 528,
    "bug": "if (tolerateUnknowns) {",
    "fix": "if (eqMethod == EquivalenceMethod.INVARIANT) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false;"
      },
      {
        "txt": "public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override"
      },
      {
        "txt": "public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; }"
      },
      {
        "txt": "JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null; } public boolean hasDisplayName() {"
      },
      {
        "txt": "String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false; } public boolean isNoResolvedType() {"
      },
      {
        "txt": "return false; } public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); }"
      },
      {
        "txt": "public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() {"
      },
      {
        "txt": "return false; } boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype("
      },
      {
        "txt": "getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false; } public boolean isBooleanObjectType() {"
      },
      {
        "txt": "return false; } public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false; } public boolean isDateType() { return false;"
      },
      {
        "txt": "} public boolean isNullType() { return false; } public boolean isVoidType() { return false; } public boolean isAllType() { return false; }"
      },
      {
        "txt": "public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() {"
      },
      {
        "txt": "if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts();"
      },
      {
        "txt": "} return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() {"
      },
      {
        "txt": "return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null;"
      },
      {
        "txt": "} public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; }"
      },
      {
        "txt": "boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() {"
      },
      {
        "txt": "return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null;"
      },
      {
        "txt": "} public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true;"
      },
      {
        "txt": "boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false; } } boolean hasAnyTemplateInternal() { return false; }"
      },
      {
        "txt": "public boolean isObject() { return false; } public boolean isConstructor() { return false; } public boolean isNominalType() { return false; } public final boolean isNominalConstructor() {"
      },
      {
        "txt": "if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); }"
      },
      {
        "txt": "return false; } public boolean isInstanceType() { return false; } public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false;"
      },
      {
        "txt": "} public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); }"
      },
      {
        "txt": "if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { <extra_id_0> return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } }"
      },
      {
        "txt": "} } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); }"
      },
      {
        "txt": "if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper("
      },
      {
        "txt": "thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();"
      },
      {
        "txt": "return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper("
      },
      {
        "txt": "that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) {"
      },
      {
        "txt": "return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() {"
      },
      {
        "txt": "return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false;"
      },
      {
        "txt": "} public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) {"
      },
      {
        "txt": "return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true;"
      },
      {
        "txt": "} return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; } public ObjectType toObjectType() {"
      },
      {
        "txt": "return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); }"
      },
      {
        "txt": "public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() ||"
      },
      {
        "txt": "aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN;"
      },
      {
        "txt": "} } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN;"
      },
      {
        "txt": "} } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this);"
      },
      {
        "txt": "} JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this;"
      },
      {
        "txt": "} public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType :"
      },
      {
        "txt": "filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false);"
      },
      {
        "txt": "} else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) {"
      },
      {
        "txt": "return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType);"
      },
      {
        "txt": "if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) {"
      },
      {
        "txt": "return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false;"
      },
      {
        "txt": "for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) {"
      },
      {
        "txt": "builder.addAlternate(alt); } } return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {"
      },
      {
        "txt": "return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes();"
      },
      {
        "txt": "public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN:"
      },
      {
        "txt": "return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) {"
      },
      {
        "txt": "case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) {"
      },
      {
        "txt": "JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) {"
      },
      {
        "txt": "return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that);"
      },
      {
        "txt": "} static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true;"
      },
      {
        "txt": "} if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } } if (thatType instanceof ProxyObjectType) {"
      },
      {
        "txt": "return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope);"
      },
      {
        "txt": "registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; }"
      },
      {
        "txt": "resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; }"
      },
      {
        "txt": "public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope);"
      },
      {
        "txt": "} public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB;"
      },
      {
        "txt": "} } @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() {"
      },
      {
        "txt": "return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 869,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 531,
    "end-bug-line": 531,
    "bug": "",
    "fix": "return true; } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME ="
      },
      {
        "txt": "\"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) {"
      },
      {
        "txt": "return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) {"
      },
      {
        "txt": "return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName();"
      },
      {
        "txt": "return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false;"
      },
      {
        "txt": "} public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() {"
      },
      {
        "txt": "return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false;"
      },
      {
        "txt": "} boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));"
      },
      {
        "txt": "} public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false;"
      },
      {
        "txt": "} public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false; } public boolean isDateType() { return false; }"
      },
      {
        "txt": "public boolean isNullType() { return false; } public boolean isVoidType() { return false; } public boolean isAllType() { return false; } public boolean isUnknownType() {"
      },
      {
        "txt": "return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) {"
      },
      {
        "txt": "FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); }"
      },
      {
        "txt": "return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null;"
      },
      {
        "txt": "} public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; }"
      },
      {
        "txt": "public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; } boolean isNamedType() {"
      },
      {
        "txt": "return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null;"
      },
      {
        "txt": "} public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; }"
      },
      {
        "txt": "public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal();"
      },
      {
        "txt": "this.inTemplatedCheckVisit = false; return result; } else { return false; } } boolean hasAnyTemplateInternal() { return false; } public boolean isObject() {"
      },
      {
        "txt": "return false; } public boolean isConstructor() { return false; } public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) {"
      },
      {
        "txt": "FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); } return false;"
      },
      {
        "txt": "} public boolean isInstanceType() { return false; } public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false; }"
      },
      {
        "txt": "public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {"
      },
      {
        "txt": "return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { <extra_id_0> return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } }"
      },
      {
        "txt": "} } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); }"
      },
      {
        "txt": "if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper("
      },
      {
        "txt": "thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();"
      },
      {
        "txt": "return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper("
      },
      {
        "txt": "that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) {"
      },
      {
        "txt": "return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() {"
      },
      {
        "txt": "return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false;"
      },
      {
        "txt": "} public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) {"
      },
      {
        "txt": "return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true;"
      },
      {
        "txt": "} return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; } public ObjectType toObjectType() {"
      },
      {
        "txt": "return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); }"
      },
      {
        "txt": "public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() ||"
      },
      {
        "txt": "aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN;"
      },
      {
        "txt": "} } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN;"
      },
      {
        "txt": "} } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this);"
      },
      {
        "txt": "} JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this;"
      },
      {
        "txt": "} public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType :"
      },
      {
        "txt": "filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false);"
      },
      {
        "txt": "} else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) {"
      },
      {
        "txt": "return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType);"
      },
      {
        "txt": "if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) {"
      },
      {
        "txt": "return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false;"
      },
      {
        "txt": "for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) {"
      },
      {
        "txt": "builder.addAlternate(alt); } } return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {"
      },
      {
        "txt": "return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes();"
      },
      {
        "txt": "public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN:"
      },
      {
        "txt": "return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) {"
      },
      {
        "txt": "case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) {"
      },
      {
        "txt": "JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) {"
      },
      {
        "txt": "return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that);"
      },
      {
        "txt": "} static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true;"
      },
      {
        "txt": "} if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } } if (thatType instanceof ProxyObjectType) {"
      },
      {
        "txt": "return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope);"
      },
      {
        "txt": "registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; }"
      },
      {
        "txt": "resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; }"
      },
      {
        "txt": "public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope);"
      },
      {
        "txt": "} public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB;"
      },
      {
        "txt": "} } @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() {"
      },
      {
        "txt": "return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 870,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 545,
    "end-bug-line": 545,
    "bug": "that.toMaybeUnionType(), tolerateUnknowns);",
    "fix": "that.toMaybeUnionType(), eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;"
      },
      {
        "txt": "import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null;"
      },
      {
        "txt": "private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() {"
      },
      {
        "txt": "@Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry;"
      },
      {
        "txt": "} JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null; }"
      },
      {
        "txt": "public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false; }"
      },
      {
        "txt": "public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this);"
      },
      {
        "txt": "} public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false; }"
      },
      {
        "txt": "public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false; } public final boolean isString() {"
      },
      {
        "txt": "return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false; }"
      },
      {
        "txt": "public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false; } public boolean isDateType() {"
      },
      {
        "txt": "return false; } public boolean isNullType() { return false; } public boolean isVoidType() { return false; } public boolean isAllType() { return false;"
      },
      {
        "txt": "} public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null; }"
      },
      {
        "txt": "public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor();"
      },
      {
        "txt": "return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); }"
      },
      {
        "txt": "public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() {"
      },
      {
        "txt": "return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null;"
      },
      {
        "txt": "} boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null; }"
      },
      {
        "txt": "public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() {"
      },
      {
        "txt": "return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) {"
      },
      {
        "txt": "this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false; } } boolean hasAnyTemplateInternal() { return false;"
      },
      {
        "txt": "} public boolean isObject() { return false; } public boolean isConstructor() { return false; } public boolean isNominalType() { return false; }"
      },
      {
        "txt": "public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true; } return fn.isNativeObjectType();"
      },
      {
        "txt": "} return false; } public boolean isInstanceType() { return false; } public boolean isInterface() { return false; } public boolean isOrdinaryFunction() {"
      },
      {
        "txt": "return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true);"
      },
      {
        "txt": "} boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown;"
      },
      {
        "txt": "(isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( <extra_id_0> } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) {"
      },
      {
        "txt": "} if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) {"
      },
      {
        "txt": "paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ?"
      },
      {
        "txt": "that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this)"
      },
      {
        "txt": ".getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that; }"
      },
      {
        "txt": "public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override"
      },
      {
        "txt": "public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() {"
      },
      {
        "txt": "return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());"
      },
      {
        "txt": "if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) {"
      },
      {
        "txt": "return true; } return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; }"
      },
      {
        "txt": "public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType();"
      },
      {
        "txt": "} public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() ||"
      },
      {
        "txt": "aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else {"
      },
      {
        "txt": "return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else {"
      },
      {
        "txt": "return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) {"
      },
      {
        "txt": "return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() {"
      },
      {
        "txt": "return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType);"
      },
      {
        "txt": "return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper("
      },
      {
        "txt": "thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType);"
      },
      {
        "txt": "} else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) {"
      },
      {
        "txt": "JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } }"
      },
      {
        "txt": "if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType();"
      },
      {
        "txt": "boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) {"
      },
      {
        "txt": "if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {"
      },
      {
        "txt": "if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } }"
      },
      {
        "txt": "public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE:"
      },
      {
        "txt": "case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); }"
      },
      {
        "txt": "switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }"
      },
      {
        "txt": "public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() ||"
      },
      {
        "txt": "this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) {"
      },
      {
        "txt": "return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } }"
      },
      {
        "txt": "if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE);"
      },
      {
        "txt": "JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult;"
      },
      {
        "txt": "} resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true;"
      },
      {
        "txt": "} public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) {"
      },
      {
        "txt": "return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA;"
      },
      {
        "txt": "this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; }"
      },
      {
        "txt": "public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 871,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 550,
    "end-bug-line": 550,
    "bug": "that.toMaybeFunctionType(), tolerateUnknowns);",
    "fix": "that.toMaybeFunctionType(), eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS ="
      },
      {
        "txt": "\"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); }"
      },
      {
        "txt": "}; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      },
      {
        "txt": "public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); }"
      },
      {
        "txt": "public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() {"
      },
      {
        "txt": "return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; }"
      },
      {
        "txt": "public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false; } boolean isTheObjectType() {"
      },
      {
        "txt": "return false; } public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() {"
      },
      {
        "txt": "return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() {"
      },
      {
        "txt": "return false; } public boolean isRegexpType() { return false; } public boolean isDateType() { return false; } public boolean isNullType() { return false;"
      },
      {
        "txt": "} public boolean isVoidType() { return false; } public boolean isAllType() { return false; } public boolean isUnknownType() { return false; }"
      },
      {
        "txt": "public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs();"
      },
      {
        "txt": "} return false; } public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; }"
      },
      {
        "txt": "public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() {"
      },
      {
        "txt": "return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null;"
      },
      {
        "txt": "} public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; } boolean isNamedType() { return false; }"
      },
      {
        "txt": "public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() {"
      },
      {
        "txt": "return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null;"
      },
      {
        "txt": "} public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result;"
      },
      {
        "txt": "} else { return false; } } boolean hasAnyTemplateInternal() { return false; } public boolean isObject() { return false; }"
      },
      {
        "txt": "public boolean isConstructor() { return false; } public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) {"
      },
      {
        "txt": "return false; } if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() {"
      },
      {
        "txt": "return false; } public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false);"
      },
      {
        "txt": "} public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true;"
      },
      {
        "txt": "} boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; }"
      },
      {
        "txt": "if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( <extra_id_0> } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType();"
      },
      {
        "txt": "} ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true;"
      },
      {
        "txt": "} else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); }"
      },
      {
        "txt": "if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) {"
      },
      {
        "txt": "return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); }"
      },
      {
        "txt": "@Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() {"
      },
      {
        "txt": "return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false;"
      },
      {
        "txt": "} public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null;"
      },
      {
        "txt": "} public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; } return false; }"
      },
      {
        "txt": "public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() {"
      },
      {
        "txt": "JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); }"
      },
      {
        "txt": "public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; }"
      },
      {
        "txt": "boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) {"
      },
      {
        "txt": "JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) {"
      },
      {
        "txt": "return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() ||"
      },
      {
        "txt": "inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) {"
      },
      {
        "txt": "return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); }"
      },
      {
        "txt": "public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) {"
      },
      {
        "txt": "return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType);"
      },
      {
        "txt": "} else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; }"
      },
      {
        "txt": "} else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE);"
      },
      {
        "txt": "} static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true;"
      },
      {
        "txt": "break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } }"
      },
      {
        "txt": "return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes();"
      },
      {
        "txt": "if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this);"
      },
      {
        "txt": "return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException();"
      },
      {
        "txt": "} public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType);"
      },
      {
        "txt": "case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); }"
      },
      {
        "txt": "public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that);"
      },
      {
        "txt": "} } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) {"
      },
      {
        "txt": "return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType();"
      },
      {
        "txt": "for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); }"
      },
      {
        "txt": "return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; }"
      },
      {
        "txt": "public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult);"
      },
      {
        "txt": "return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; } public final boolean isResolved() { return resolved; }"
      },
      {
        "txt": "public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this);"
      },
      {
        "txt": "} public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; } } @Override"
      },
      {
        "txt": "public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations);"
      }
    ]
  },
  {
    "id": 872,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 555,
    "end-bug-line": 555,
    "bug": "that.toMaybeRecordType(), tolerateUnknowns);",
    "fix": "that.toMaybeRecordType(), eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L;"
      },
      {
        "txt": "private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT ="
      },
      {
        "txt": "\"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry;"
      },
      {
        "txt": "JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() {"
      },
      {
        "txt": "return null; } public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() {"
      },
      {
        "txt": "return false; } public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() ||"
      },
      {
        "txt": "(registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() {"
      },
      {
        "txt": "return false; } public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false;"
      },
      {
        "txt": "} public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() {"
      },
      {
        "txt": "return false; } public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false;"
      },
      {
        "txt": "} public boolean isDateType() { return false; } public boolean isNullType() { return false; } public boolean isVoidType() { return false; }"
      },
      {
        "txt": "public boolean isAllType() { return false; } public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() {"
      },
      {
        "txt": "return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() {"
      },
      {
        "txt": "if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() {"
      },
      {
        "txt": "return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType();"
      },
      {
        "txt": "} public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; }"
      },
      {
        "txt": "public EnumType toMaybeEnumType() { return null; } boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() {"
      },
      {
        "txt": "return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType();"
      },
      {
        "txt": "} public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); }"
      },
      {
        "txt": "public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false; } }"
      },
      {
        "txt": "boolean hasAnyTemplateInternal() { return false; } public boolean isObject() { return false; } public boolean isConstructor() { return false; } public boolean isNominalType() {"
      },
      {
        "txt": "return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true;"
      },
      {
        "txt": "} return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() { return false; } public boolean isInterface() { return false;"
      },
      {
        "txt": "} public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); }"
      },
      {
        "txt": "public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) {"
      },
      {
        "txt": "if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns);"
      },
      {
        "txt": "if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( <extra_id_0> } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) {"
      },
      {
        "txt": "boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ?"
      },
      {
        "txt": "this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); }"
      },
      {
        "txt": "if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); }"
      },
      {
        "txt": "return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;"
      },
      {
        "txt": "} @Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext();"
      },
      {
        "txt": "} public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; }"
      },
      {
        "txt": "public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false; }"
      },
      {
        "txt": "public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; } return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() {"
      },
      {
        "txt": "return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; }"
      },
      {
        "txt": "public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) {"
      },
      {
        "txt": "if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) {"
      },
      {
        "txt": "return TernaryValue.TRUE; } else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) {"
      },
      {
        "txt": "return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; }"
      },
      {
        "txt": "public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));"
      },
      {
        "txt": "} public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); }"
      },
      {
        "txt": "static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) {"
      },
      {
        "txt": "if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType);"
      },
      {
        "txt": "} else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);"
      },
      {
        "txt": "} if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf;"
      },
      {
        "txt": "} } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);"
      },
      {
        "txt": "} else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) {"
      },
      {
        "txt": "UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); } } return type;"
      },
      {
        "txt": "} public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE);"
      },
      {
        "txt": "} } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE:"
      },
      {
        "txt": "return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this);"
      },
      {
        "txt": "return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); }"
      },
      {
        "txt": "throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA);"
      },
      {
        "txt": "} if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this;"
      },
      {
        "txt": "} public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true;"
      },
      {
        "txt": "} if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; }"
      },
      {
        "txt": "} } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {"
      },
      {
        "txt": "ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) {"
      },
      {
        "txt": "resolveResult = type; resolved = true; } public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; }"
      },
      {
        "txt": "static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB;"
      },
      {
        "txt": "public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() {"
      },
      {
        "txt": "return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 873,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 565,
    "end-bug-line": 566,
    "bug": "thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) {",
    "fix": "thatParamType.getParameterType(), eqMethod); } else if (eqMethod == EquivalenceMethod.IDENTITY) { paramsMatch = false; } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator;"
      },
      {
        "txt": "public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE ="
      },
      {
        "txt": "\"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1;"
      },
      {
        "txt": "public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null;"
      },
      {
        "txt": "} public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false;"
      },
      {
        "txt": "} public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; }"
      },
      {
        "txt": "public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false;"
      },
      {
        "txt": "} public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; }"
      },
      {
        "txt": "public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));"
      },
      {
        "txt": "} public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; }"
      },
      {
        "txt": "public boolean isRegexpType() { return false; } public boolean isDateType() { return false; } public boolean isNullType() { return false; } public boolean isVoidType() {"
      },
      {
        "txt": "return false; } public boolean isAllType() { return false; } public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false;"
      },
      {
        "txt": "} public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false;"
      },
      {
        "txt": "} public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null;"
      },
      {
        "txt": "} public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; }"
      },
      {
        "txt": "public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() {"
      },
      {
        "txt": "return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; } boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null;"
      },
      {
        "txt": "} RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; }"
      },
      {
        "txt": "public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) {"
      },
      {
        "txt": "return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false;"
      },
      {
        "txt": "} } boolean hasAnyTemplateInternal() { return false; } public boolean isObject() { return false; } public boolean isConstructor() { return false;"
      },
      {
        "txt": "} public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; }"
      },
      {
        "txt": "if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() { return false; }"
      },
      {
        "txt": "public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) {"
      },
      {
        "txt": "return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType();"
      },
      {
        "txt": "boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) {"
      },
      {
        "txt": "return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns);"
      },
      {
        "txt": "ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( <extra_id_0> paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();"
      },
      {
        "txt": "JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName());"
      },
      {
        "txt": "} if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns);"
      },
      {
        "txt": "} return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ?"
      },
      {
        "txt": "isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() {"
      },
      {
        "txt": "return matchesNumberContext(); } public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false;"
      },
      {
        "txt": "} public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false;"
      },
      {
        "txt": "} public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; } return false; } public JSType autoboxesTo() { return null; }"
      },
      {
        "txt": "public JSType unboxesTo() { return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox;"
      },
      {
        "txt": "} public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); }"
      },
      {
        "txt": "TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) {"
      },
      {
        "txt": "if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE));"
      },
      {
        "txt": "if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null;"
      },
      {
        "txt": "} public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() {"
      },
      {
        "txt": "return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that);"
      },
      {
        "txt": "} static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); }"
      },
      {
        "txt": "static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) {"
      },
      {
        "txt": "return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) {"
      },
      {
        "txt": "return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) {"
      },
      {
        "txt": "return inf; } } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) {"
      },
      {
        "txt": "return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } }"
      },
      {
        "txt": "if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); } }"
      },
      {
        "txt": "return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else {"
      },
      {
        "txt": "return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) {"
      },
      {
        "txt": "case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) {"
      },
      {
        "txt": "TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that);"
      },
      {
        "txt": "} throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this);"
      },
      {
        "txt": "return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() {"
      },
      {
        "txt": "return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) {"
      },
      {
        "txt": "return true; } if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true;"
      },
      {
        "txt": "} } } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor);"
      },
      {
        "txt": "public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) {"
      },
      {
        "txt": "return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);"
      },
      {
        "txt": "void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; } public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null;"
      },
      {
        "txt": "} static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA;"
      },
      {
        "txt": "public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false); }"
      },
      {
        "txt": "public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 874,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 571,
    "end-bug-line": 572,
    "bug": "} else { paramsMatch = false;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false;"
      },
      {
        "txt": "private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\";"
      },
      {
        "txt": "static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) {"
      },
      {
        "txt": "this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null;"
      },
      {
        "txt": "} public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false;"
      },
      {
        "txt": "} public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType("
      },
      {
        "txt": "JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false;"
      },
      {
        "txt": "} public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false; }"
      },
      {
        "txt": "public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false;"
      },
      {
        "txt": "} public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false; }"
      },
      {
        "txt": "public boolean isDateType() { return false; } public boolean isNullType() { return false; } public boolean isVoidType() { return false; } public boolean isAllType() {"
      },
      {
        "txt": "return false; } public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null;"
      },
      {
        "txt": "} public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() { if (isObject()) {"
      },
      {
        "txt": "FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS);"
      },
      {
        "txt": "} public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); }"
      },
      {
        "txt": "public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() {"
      },
      {
        "txt": "return null; } boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null;"
      },
      {
        "txt": "} public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); }"
      },
      {
        "txt": "public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() {"
      },
      {
        "txt": "if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false; } } boolean hasAnyTemplateInternal() {"
      },
      {
        "txt": "return false; } public boolean isObject() { return false; } public boolean isConstructor() { return false; } public boolean isNominalType() { return false;"
      },
      {
        "txt": "} public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true; }"
      },
      {
        "txt": "return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() { return false; } public boolean isInterface() { return false; }"
      },
      {
        "txt": "public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) {"
      },
      {
        "txt": "return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) {"
      },
      {
        "txt": "return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); }"
      },
      {
        "txt": "if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType();"
      },
      {
        "txt": "boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; <extra_id_0> } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch &&"
      },
      {
        "txt": "that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this)"
      },
      {
        "txt": ".getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } return this == that; }"
      },
      {
        "txt": "public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override"
      },
      {
        "txt": "public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() {"
      },
      {
        "txt": "return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());"
      },
      {
        "txt": "if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) {"
      },
      {
        "txt": "return true; } return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; }"
      },
      {
        "txt": "public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType();"
      },
      {
        "txt": "} public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() ||"
      },
      {
        "txt": "aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else {"
      },
      {
        "txt": "return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else {"
      },
      {
        "txt": "return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) {"
      },
      {
        "txt": "return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() {"
      },
      {
        "txt": "return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType);"
      },
      {
        "txt": "return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper("
      },
      {
        "txt": "thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType);"
      },
      {
        "txt": "} else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) {"
      },
      {
        "txt": "JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } }"
      },
      {
        "txt": "if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType();"
      },
      {
        "txt": "boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) {"
      },
      {
        "txt": "if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {"
      },
      {
        "txt": "if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } }"
      },
      {
        "txt": "public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE:"
      },
      {
        "txt": "case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); }"
      },
      {
        "txt": "switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }"
      },
      {
        "txt": "public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() ||"
      },
      {
        "txt": "this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) {"
      },
      {
        "txt": "return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } }"
      },
      {
        "txt": "if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE);"
      },
      {
        "txt": "JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult;"
      },
      {
        "txt": "} resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true;"
      },
      {
        "txt": "} public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) {"
      },
      {
        "txt": "return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA;"
      },
      {
        "txt": "this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; }"
      },
      {
        "txt": "public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 875,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 580,
    "end-bug-line": 580,
    "bug": "thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);",
    "fix": "thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\";"
      },
      {
        "txt": "public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0;"
      },
      {
        "txt": "final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; }"
      },
      {
        "txt": "public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; }"
      },
      {
        "txt": "public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; } public final boolean isEmptyType() {"
      },
      {
        "txt": "return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false; }"
      },
      {
        "txt": "public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; } public boolean isStringValueType() {"
      },
      {
        "txt": "return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); }"
      },
      {
        "txt": "public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; } public boolean isRegexpType() {"
      },
      {
        "txt": "return false; } public boolean isDateType() { return false; } public boolean isNullType() { return false; } public boolean isVoidType() { return false;"
      },
      {
        "txt": "} public boolean isAllType() { return false; } public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false; }"
      },
      {
        "txt": "public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; }"
      },
      {
        "txt": "public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null; }"
      },
      {
        "txt": "public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) {"
      },
      {
        "txt": "return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null;"
      },
      {
        "txt": "} public EnumType toMaybeEnumType() { return null; } boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null; }"
      },
      {
        "txt": "RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) {"
      },
      {
        "txt": "return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType();"
      },
      {
        "txt": "} public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false; }"
      },
      {
        "txt": "} boolean hasAnyTemplateInternal() { return false; } public boolean isObject() { return false; } public boolean isConstructor() { return false; }"
      },
      {
        "txt": "public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) {"
      },
      {
        "txt": "return true; } return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() { return false; } public boolean isInterface() {"
      },
      {
        "txt": "return false; } public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false);"
      },
      {
        "txt": "} public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType();"
      },
      {
        "txt": "if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper("
      },
      {
        "txt": "that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); }"
      },
      {
        "txt": "ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else {"
      },
      {
        "txt": "} JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && <extra_id_0> } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) {"
      },
      {
        "txt": "} if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns);"
      },
      {
        "txt": "} return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ?"
      },
      {
        "txt": "isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() {"
      },
      {
        "txt": "return matchesNumberContext(); } public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false;"
      },
      {
        "txt": "} public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false;"
      },
      {
        "txt": "} public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; } return false; } public JSType autoboxesTo() { return null; }"
      },
      {
        "txt": "public JSType unboxesTo() { return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox;"
      },
      {
        "txt": "} public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); }"
      },
      {
        "txt": "TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) {"
      },
      {
        "txt": "if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE));"
      },
      {
        "txt": "if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null;"
      },
      {
        "txt": "} public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() {"
      },
      {
        "txt": "return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that);"
      },
      {
        "txt": "} static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); }"
      },
      {
        "txt": "static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) {"
      },
      {
        "txt": "return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) {"
      },
      {
        "txt": "return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) {"
      },
      {
        "txt": "return inf; } } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) {"
      },
      {
        "txt": "return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } }"
      },
      {
        "txt": "if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); } }"
      },
      {
        "txt": "return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else {"
      },
      {
        "txt": "return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) {"
      },
      {
        "txt": "case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) {"
      },
      {
        "txt": "TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that);"
      },
      {
        "txt": "} throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this);"
      },
      {
        "txt": "return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() {"
      },
      {
        "txt": "return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) {"
      },
      {
        "txt": "return true; } if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true;"
      },
      {
        "txt": "} } } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor);"
      },
      {
        "txt": "public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) {"
      },
      {
        "txt": "return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);"
      },
      {
        "txt": "void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; } public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null;"
      },
      {
        "txt": "} static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA;"
      },
      {
        "txt": "public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false); }"
      },
      {
        "txt": "public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 876,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 592,
    "end-bug-line": 592,
    "bug": "that, tolerateUnknowns);",
    "fix": "that, eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator;"
      },
      {
        "txt": "public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false; public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE ="
      },
      {
        "txt": "\"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1;"
      },
      {
        "txt": "public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; } JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null;"
      },
      {
        "txt": "} public String getDisplayName() { return null; } public boolean hasDisplayName() { String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false;"
      },
      {
        "txt": "} public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false; } public boolean isNoObjectType() { return false; }"
      },
      {
        "txt": "public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false;"
      },
      {
        "txt": "} public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() { return false; } boolean isTheObjectType() { return false; }"
      },
      {
        "txt": "public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype( getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));"
      },
      {
        "txt": "} public boolean isArrayType() { return false; } public boolean isBooleanObjectType() { return false; } public boolean isBooleanValueType() { return false; }"
      },
      {
        "txt": "public boolean isRegexpType() { return false; } public boolean isDateType() { return false; } public boolean isNullType() { return false; } public boolean isVoidType() {"
      },
      {
        "txt": "return false; } public boolean isAllType() { return false; } public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false;"
      },
      {
        "txt": "} public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false;"
      },
      {
        "txt": "} public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts(); } return false; } public UnionType toMaybeUnionType() { return null;"
      },
      {
        "txt": "} public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() { return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; }"
      },
      {
        "txt": "public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null; } public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() {"
      },
      {
        "txt": "return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; } boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null;"
      },
      {
        "txt": "} RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() { return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; }"
      },
      {
        "txt": "public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null; } public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) {"
      },
      {
        "txt": "return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true; boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false;"
      },
      {
        "txt": "} } boolean hasAnyTemplateInternal() { return false; } public boolean isObject() { return false; } public boolean isConstructor() { return false;"
      },
      {
        "txt": "} public boolean isNominalType() { return false; } public final boolean isNominalConstructor() { if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; }"
      },
      {
        "txt": "if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); } return false; } public boolean isInstanceType() { return false; }"
      },
      {
        "txt": "public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false; } public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) {"
      },
      {
        "txt": "return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType();"
      },
      {
        "txt": "boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) {"
      },
      {
        "txt": "return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns);"
      },
      {
        "txt": "} ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true;"
      },
      {
        "txt": "} else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); }"
      },
      {
        "txt": "return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( <extra_id_0> } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); }"
      },
      {
        "txt": "tolerateUnknowns); } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) {"
      },
      {
        "txt": "return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() { return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); }"
      },
      {
        "txt": "public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false; } public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() {"
      },
      {
        "txt": "return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) { return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() {"
      },
      {
        "txt": "return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true; } return false; } public JSType autoboxesTo() { return null;"
      },
      {
        "txt": "} public JSType unboxesTo() { return null; } public ObjectType toObjectType() { return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo();"
      },
      {
        "txt": "return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); } public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that);"
      },
      {
        "txt": "} TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() || aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType();"
      },
      {
        "txt": "if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN; } } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype("
      },
      {
        "txt": "getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN; } } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); }"
      },
      {
        "txt": "return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this); } JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); }"
      },
      {
        "txt": "public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this; } public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); }"
      },
      {
        "txt": "return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType : filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that);"
      },
      {
        "txt": "} static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false); } else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) { return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);"
      },
      {
        "txt": "} else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType); if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType);"
      },
      {
        "txt": "if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) { return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) {"
      },
      {
        "txt": "if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false; for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; }"
      },
      {
        "txt": "} if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) { builder.addAlternate(alt); } } return builder.build(); }"
      },
      {
        "txt": "} return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this;"
      },
      {
        "txt": "} else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes(); public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); }"
      },
      {
        "txt": "switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) {"
      },
      {
        "txt": "if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN:"
      },
      {
        "txt": "return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) { JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) {"
      },
      {
        "txt": "TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } }"
      },
      {
        "txt": "public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that); } static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; }"
      },
      {
        "txt": "if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true; } if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) {"
      },
      {
        "txt": "return true; } } } if (thatType instanceof ProxyObjectType) { return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; }"
      },
      {
        "txt": "public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope); registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) {"
      },
      {
        "txt": "if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; } resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; }"
      },
      {
        "txt": "abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; } public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false;"
      },
      {
        "txt": "resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope); } public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair {"
      },
      {
        "txt": "public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB; } } @Override public String toString() { return toStringHelper(false);"
      },
      {
        "txt": "} public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() { return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 877,
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java",
    "start-bug-line": 598,
    "end-bug-line": 598,
    "bug": "tolerateUnknowns);",
    "fix": "eqMethod);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import java.io.Serializable; import java.util.Comparator; public abstract class JSType implements Serializable { private static final long serialVersionUID = 1L; private boolean resolved = false; private JSType resolveResult = null; private boolean inTemplatedCheckVisit = false;"
      },
      {
        "txt": "public static final String UNKNOWN_NAME = \"Unknown class name\"; public static final String NOT_A_CLASS = \"Not declared as a constructor\"; public static final String NOT_A_TYPE = \"Not declared as a type name\"; public static final String EMPTY_TYPE_COMPONENT = \"Named type with empty name component\"; static final Comparator<JSType> ALPHA = new Comparator<JSType>() { @Override"
      },
      {
        "txt": "public int compare(JSType t1, JSType t2) { return t1.toString().compareTo(t2.toString()); } }; public static final int ENUMDECL = 1; public static final int NOT_ENUMDECL = 0; final JSTypeRegistry registry; JSType(JSTypeRegistry registry) { this.registry = registry; }"
      },
      {
        "txt": "JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } public JSDocInfo getJSDocInfo() { return null; } public String getDisplayName() { return null; } public boolean hasDisplayName() {"
      },
      {
        "txt": "String displayName = getDisplayName(); return displayName != null && !displayName.isEmpty(); } public boolean hasProperty(String pname) { return false; } public boolean isNoType() { return false; } public boolean isNoResolvedType() {"
      },
      {
        "txt": "return false; } public boolean isNoObjectType() { return false; } public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); }"
      },
      {
        "txt": "public boolean isNumberObjectType() { return false; } public boolean isNumberValueType() { return false; } public boolean isFunctionPrototypeType() { return false; } public boolean isStringObjectType() {"
      },
      {
        "txt": "return false; } boolean isTheObjectType() { return false; } public boolean isStringValueType() { return false; } public final boolean isString() { return this.isSubtype("
      },
      {
        "txt": "getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE)); } public final boolean isNumber() { return this.isSubtype( getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE)); } public boolean isArrayType() { return false; } public boolean isBooleanObjectType() {"
      },
      {
        "txt": "return false; } public boolean isBooleanValueType() { return false; } public boolean isRegexpType() { return false; } public boolean isDateType() { return false;"
      },
      {
        "txt": "} public boolean isNullType() { return false; } public boolean isVoidType() { return false; } public boolean isAllType() { return false; }"
      },
      {
        "txt": "public boolean isUnknownType() { return false; } public boolean isCheckedUnknownType() { return false; } public final boolean isUnionType() { return toMaybeUnionType() != null; } public boolean isStruct() {"
      },
      {
        "txt": "if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesStructs(); } return false; } public boolean isDict() { if (isObject()) { FunctionType ctor = toObjectType().getConstructor(); return ctor != null && ctor.makesDicts();"
      },
      {
        "txt": "} return false; } public UnionType toMaybeUnionType() { return null; } public final boolean isGlobalThisType() { return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS); } public final boolean isFunctionType() {"
      },
      {
        "txt": "return toMaybeFunctionType() != null; } public FunctionType toMaybeFunctionType() { return null; } public static FunctionType toMaybeFunctionType(JSType type) { return type == null ? null : type.toMaybeFunctionType(); } public final boolean isEnumElementType() { return toMaybeEnumElementType() != null;"
      },
      {
        "txt": "} public EnumElementType toMaybeEnumElementType() { return null; } public boolean isEnumType() { return toMaybeEnumType() != null; } public EnumType toMaybeEnumType() { return null; }"
      },
      {
        "txt": "boolean isNamedType() { return false; } public boolean isRecordType() { return toMaybeRecordType() != null; } RecordType toMaybeRecordType() { return null; } public final boolean isParameterizedType() {"
      },
      {
        "txt": "return toMaybeParameterizedType() != null; } public ParameterizedType toMaybeParameterizedType() { return null; } public static ParameterizedType toMaybeParameterizedType(JSType type) { return type == null ? null : type.toMaybeParameterizedType(); } public final boolean isTemplateType() { return toMaybeTemplateType() != null;"
      },
      {
        "txt": "} public TemplateType toMaybeTemplateType() { return null; } public static TemplateType toMaybeTemplateType(JSType type) { return type == null ? null : type.toMaybeTemplateType(); } public boolean hasAnyTemplate() { if (!this.inTemplatedCheckVisit) { this.inTemplatedCheckVisit = true;"
      },
      {
        "txt": "boolean result = hasAnyTemplateInternal(); this.inTemplatedCheckVisit = false; return result; } else { return false; } } boolean hasAnyTemplateInternal() { return false; }"
      },
      {
        "txt": "public boolean isObject() { return false; } public boolean isConstructor() { return false; } public boolean isNominalType() { return false; } public final boolean isNominalConstructor() {"
      },
      {
        "txt": "if (isConstructor() || isInterface()) { FunctionType fn = toMaybeFunctionType(); if (fn == null) { return false; } if (fn.getSource() != null) { return true; } return fn.isNativeObjectType(); }"
      },
      {
        "txt": "return false; } public boolean isInstanceType() { return false; } public boolean isInterface() { return false; } public boolean isOrdinaryFunction() { return false;"
      },
      {
        "txt": "} public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); }"
      },
      {
        "txt": "boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown &&"
      },
      {
        "txt": "(isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper("
      },
      {
        "txt": "that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false;"
      },
      {
        "txt": "if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();"
      },
      {
        "txt": "JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals( that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) {"
      },
      {
        "txt": ".getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), <extra_id_0> } return this == that; } public static boolean isEquivalent(JSType typeA, JSType typeB) { return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);"
      },
      {
        "txt": "return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB); } @Override public boolean equals(Object jsType) { return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false; } @Override public int hashCode() {"
      },
      {
        "txt": "return System.identityHashCode(this); } public final boolean matchesInt32Context() { return matchesNumberContext(); } public final boolean matchesUint32Context() { return matchesNumberContext(); } public boolean matchesNumberContext() { return false;"
      },
      {
        "txt": "} public boolean matchesStringContext() { return false; } public boolean matchesObjectContext() { return false; } public JSType findPropertyType(String propertyName) { ObjectType autoboxObjType = ObjectType.cast(autoboxesTo()); if (autoboxObjType != null) {"
      },
      {
        "txt": "return autoboxObjType.findPropertyType(propertyName); } return null; } public boolean canBeCalled() { return false; } public boolean canAssignTo(JSType that) { if (this.isSubtype(that)) { return true;"
      },
      {
        "txt": "} return false; } public JSType autoboxesTo() { return null; } public JSType unboxesTo() { return null; } public ObjectType toObjectType() {"
      },
      {
        "txt": "return this instanceof ObjectType ? (ObjectType) this : null; } public JSType autobox() { JSType restricted = restrictByNotNullOrUndefined(); JSType autobox = restricted.autoboxesTo(); return autobox == null ? restricted : autobox; } public final ObjectType dereference() { return autobox().toObjectType(); }"
      },
      {
        "txt": "public final boolean canTestForEqualityWith(JSType that) { return this.testForEquality(that).equals(UNKNOWN); } public TernaryValue testForEquality(JSType that) { return testForEqualityHelper(this, that); } TernaryValue testForEqualityHelper(JSType aType, JSType bType) { if (bType.isAllType() || bType.isUnknownType() || bType.isNoResolvedType() || aType.isAllType() || aType.isUnknownType() ||"
      },
      {
        "txt": "aType.isNoResolvedType()) { return UNKNOWN; } boolean aIsEmpty = aType.isEmptyType(); boolean bIsEmpty = bType.isEmptyType(); if (aIsEmpty || bIsEmpty) { if (aIsEmpty && bIsEmpty) { return TernaryValue.TRUE; } else { return UNKNOWN;"
      },
      {
        "txt": "} } if (aType.isFunctionType() || bType.isFunctionType()) { JSType otherType = aType.isFunctionType() ? bType : aType; JSType meet = otherType.getGreatestSubtype( getNativeType(JSTypeNative.OBJECT_TYPE)); if (meet.isNoType() || meet.isNoObjectType()) { return TernaryValue.FALSE; } else { return TernaryValue.UNKNOWN;"
      },
      {
        "txt": "} } if (bType.isEnumElementType() || bType.isUnionType()) { return bType.testForEquality(aType); } return null; } public final boolean canTestForShallowEqualityWith(JSType that) { if (isEmptyType() || that.isEmptyType()) { return isSubtype(that) || that.isSubtype(this);"
      },
      {
        "txt": "} JSType inf = getGreatestSubtype(that); return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE); } public boolean isNullable() { return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE)); } public JSType collapseUnion() { return this;"
      },
      {
        "txt": "} public JSType getLeastSupertype(JSType that) { if (that.isUnionType()) { return that.toMaybeUnionType().getLeastSupertype(this); } return getLeastSupertype(this, that); } static JSType getLeastSupertype(JSType thisType, JSType thatType) { boolean areEquivalent = thisType.isEquivalentTo(thatType); return areEquivalent ? thisType :"
      },
      {
        "txt": "filterNoResolvedType( thisType.registry.createUnionType(thisType, thatType)); } public JSType getGreatestSubtype(JSType that) { return getGreatestSubtype(this, that); } static JSType getGreatestSubtype(JSType thisType, JSType thatType) { if (thisType.isFunctionType() && thatType.isFunctionType()) { return thisType.toMaybeFunctionType().supAndInfHelper( thatType.toMaybeFunctionType(), false);"
      },
      {
        "txt": "} else if (thisType.isEquivalentTo(thatType)) { return thisType; } else if (thisType.isUnknownType() || thatType.isUnknownType()) { return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE); } else if (thisType.isSubtype(thatType)) { return filterNoResolvedType(thisType); } else if (thatType.isSubtype(thisType)) { return filterNoResolvedType(thatType); } else if (thisType.isUnionType()) {"
      },
      {
        "txt": "return thisType.toMaybeUnionType().meet(thatType); } else if (thatType.isUnionType()) { return thatType.toMaybeUnionType().meet(thisType); } else if (thisType.isRecordType()) { return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType); } else if (thatType.isRecordType()) { return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType); } if (thisType.isEnumElementType()) { JSType inf = thisType.toMaybeEnumElementType().meet(thatType);"
      },
      {
        "txt": "if (inf != null) { return inf; } } else if (thatType.isEnumElementType()) { JSType inf = thatType.toMaybeEnumElementType().meet(thisType); if (inf != null) { return inf; } } if (thisType.isObject() && thatType.isObject()) {"
      },
      {
        "txt": "return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return thisType.getNativeType(JSTypeNative.NO_TYPE); } static JSType filterNoResolvedType(JSType type) { if (type.isNoResolvedType()) { return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE); } else if (type.isUnionType()) { UnionType unionType = type.toMaybeUnionType(); boolean needsFiltering = false;"
      },
      {
        "txt": "for (JSType alt : unionType.getAlternates()) { if (alt.isNoResolvedType()) { needsFiltering = true; break; } } if (needsFiltering) { UnionTypeBuilder builder = new UnionTypeBuilder(type.registry); for (JSType alt : unionType.getAlternates()) { if (!alt.isNoResolvedType()) {"
      },
      {
        "txt": "builder.addAlternate(alt); } } return builder.build(); } } return type; } public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {"
      },
      {
        "txt": "return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) { return this; } else { return getNativeType(JSTypeNative.NO_TYPE); } } public abstract BooleanLiteralSet getPossibleToBooleanOutcomes();"
      },
      {
        "txt": "public TypePair getTypesUnderEquality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case FALSE: return new TypePair(null, null); case TRUE: case UNKNOWN:"
      },
      {
        "txt": "return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) {"
      },
      {
        "txt": "case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } public TypePair getTypesUnderShallowEquality(JSType that) {"
      },
      {
        "txt": "JSType commonType = getGreatestSubtype(that); return new TypePair(commonType, commonType); } public TypePair getTypesUnderShallowInequality(JSType that) { if (that.isUnionType()) { TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) {"
      },
      {
        "txt": "return new TypePair(null, null); } else { return new TypePair(this, that); } } public JSType restrictByNotNullOrUndefined() { return this; } public boolean isSubtype(JSType that) { return isSubtypeHelper(this, that);"
      },
      {
        "txt": "} static boolean isSubtypeHelper(JSType thisType, JSType thatType) { if (thatType.isUnknownType()) { return true; } if (thatType.isAllType()) { return true; } if (thisType.isEquivalentTo(thatType)) { return true;"
      },
      {
        "txt": "} if (thatType.isUnionType()) { UnionType union = thatType.toMaybeUnionType(); for (JSType element : union.alternates) { if (thisType.isSubtype(element)) { return true; } } } if (thatType instanceof ProxyObjectType) {"
      },
      {
        "txt": "return thisType.isSubtype( ((ProxyObjectType) thatType).getReferencedTypeInternal()); } return false; } public abstract <T> T visit(Visitor<T> visitor); public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) { ResolveMode oldResolveMode = registry.getResolveMode(); registry.setResolveMode(ResolveMode.IMMEDIATE); JSType result = resolve(t, scope);"
      },
      {
        "txt": "registry.setResolveMode(oldResolveMode); return result; } public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) { if (resolved) { if (resolveResult == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return resolveResult; }"
      },
      {
        "txt": "resolved = true; resolveResult = resolveInternal(t, scope); resolveResult.setResolvedTypeInternal(resolveResult); return resolveResult; } abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope); void setResolvedTypeInternal(JSType type) { resolveResult = type; resolved = true; }"
      },
      {
        "txt": "public final boolean isResolved() { return resolved; } public final void clearResolved() { resolved = false; resolveResult = null; } static final JSType safeResolve( JSType type, ErrorReporter t, StaticScope<JSType> scope) { return type == null ? null : type.resolve(t, scope);"
      },
      {
        "txt": "} public boolean setValidator(Predicate<JSType> validator) { return validator.apply(this); } public static class TypePair { public final JSType typeA; public final JSType typeB; public TypePair(JSType typeA, JSType typeB) { this.typeA = typeA; this.typeB = typeB;"
      },
      {
        "txt": "} } @Override public String toString() { return toStringHelper(false); } public String toDebugHashCodeString() { return \"{\" + this.hashCode() + \"}\"; } public final String toAnnotationString() {"
      },
      {
        "txt": "return toStringHelper(true); } abstract String toStringHelper(boolean forAnnotations); public void matchConstraint(JSType constraint) {}"
      }
    ]
  },
  {
    "id": 878,
    "file_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
    "start-bug-line": 118,
    "end-bug-line": 118,
    "bug": "RecordType otherRecord, boolean tolerateUnknowns) {",
    "fix": "RecordType otherRecord, EquivalenceMethod eqMethod) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import com.google.common.collect.Maps; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty; import java.util.Map; import java.util.Set; import java.util.SortedMap; class RecordType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private final boolean declared; private boolean isFrozen = false; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {"
      },
      {
        "txt": "this(registry, properties, true); } RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { super(registry, null, null); setPrettyPrint(true); this.declared = declared; for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) {"
      },
      {
        "txt": "throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } if (declared) { defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } else { defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); }"
      },
      {
        "txt": "isFrozen = true; } boolean isSynthetic() { return !declared; } boolean checkRecordEquivalenceHelper( <extra_id_0> Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) {"
      },
      {
        "txt": "} for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), tolerateUnknowns)) { return false; } } return true; } @Override"
      },
      {
        "txt": "public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) {"
      },
      {
        "txt": "properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.setSynthesized(true);"
      },
      {
        "txt": "for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) {"
      },
      {
        "txt": "if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj ="
      },
      {
        "txt": "registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName);"
      },
      {
        "txt": "if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } }"
      },
      {
        "txt": "return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true;"
      },
      {
        "txt": "} if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }"
      },
      {
        "txt": "static boolean isSubtype(ObjectType typeA, RecordType typeB) { for (String property : typeB.properties.keySet()) { if (!typeA.hasProperty(property)) { return false; } JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (!propA.isUnknownType() && !propB.isUnknownType()) { if (typeA.isPropertyTypeDeclared(property)) { if (!propA.isInvariant(propB)) {"
      },
      {
        "txt": "return false; } } else { if (!propA.isSubtype(propB)) { return false; } } } } return true;"
      },
      {
        "txt": "} @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { JSType type = entry.getValue(); JSType resolvedType = type.resolve(t, scope); if (type != resolvedType) { properties.put(entry.getKey(), resolvedType); } }"
      },
      {
        "txt": "return super.resolveInternal(t, scope); }"
      }
    ]
  },
  {
    "id": 879,
    "file_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
    "start-bug-line": 126,
    "end-bug-line": 126,
    "bug": "properties.get(key), tolerateUnknowns)) {",
    "fix": "properties.get(key), eqMethod)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty; import java.util.Map; import java.util.Set; import java.util.SortedMap; class RecordType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private final boolean declared;"
      },
      {
        "txt": "private boolean isFrozen = false; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { this(registry, properties, true); } RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { super(registry, null, null); setPrettyPrint(true); this.declared = declared; for (String property : properties.keySet()) {"
      },
      {
        "txt": "RecordProperty prop = properties.get(property); if (prop == null) { throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } if (declared) { defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } else { defineSynthesizedProperty("
      },
      {
        "txt": "property, prop.getType(), prop.getPropertyNode()); } } isFrozen = true; } boolean isSynthetic() { return !declared; } boolean checkRecordEquivalenceHelper( RecordType otherRecord, boolean tolerateUnknowns) {"
      },
      {
        "txt": "Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( <extra_id_0> return false; } } return true; } @Override"
      },
      {
        "txt": "} @Override public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false;"
      },
      {
        "txt": "} if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();"
      },
      {
        "txt": "RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.setSynthesized(true); for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property));"
      },
      {
        "txt": "} for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType("
      },
      {
        "txt": "JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt :"
      },
      {
        "txt": "registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());"
      },
      {
        "txt": "} } return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (JSType.isSubtypeHelper(this, that)) { return true; } if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } if (!that.isRecordType()) { return false; }"
      },
      {
        "txt": "return RecordType.isSubtype(this, that.toMaybeRecordType()); } static boolean isSubtype(ObjectType typeA, RecordType typeB) { for (String property : typeB.properties.keySet()) { if (!typeA.hasProperty(property)) { return false; } JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (!propA.isUnknownType() && !propB.isUnknownType()) {"
      },
      {
        "txt": "if (typeA.isPropertyTypeDeclared(property)) { if (!propA.isInvariant(propB)) { return false; } } else { if (!propA.isSubtype(propB)) { return false; } } }"
      },
      {
        "txt": "} return true; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { JSType type = entry.getValue(); JSType resolvedType = type.resolve(t, scope); if (type != resolvedType) { properties.put(entry.getKey(), resolvedType);"
      },
      {
        "txt": "} } return super.resolveInternal(t, scope); }"
      }
    ]
  },
  {
    "id": 880,
    "file_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
    "start-bug-line": 204,
    "end-bug-line": 205,
    "bug": "(propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {",
    "fix": "propType.isInvariant(altPropType)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.collect.Maps; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty; import java.util.Map; import java.util.Set; import java.util.SortedMap; class RecordType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap();"
      },
      {
        "txt": "private final boolean declared; private boolean isFrozen = false; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { this(registry, properties, true); } RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { super(registry, null, null); setPrettyPrint(true); this.declared = declared;"
      },
      {
        "txt": "for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) { throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } if (declared) { defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } else {"
      },
      {
        "txt": "defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); } } isFrozen = true; } boolean isSynthetic() { return !declared; } boolean checkRecordEquivalenceHelper("
      },
      {
        "txt": "RecordType otherRecord, boolean tolerateUnknowns) { Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), tolerateUnknowns)) { return false;"
      },
      {
        "txt": "} } return true; } @Override public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type,"
      },
      {
        "txt": "boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); }"
      },
      {
        "txt": "JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.setSynthesized(true); for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE);"
      },
      {
        "txt": "} builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } }"
      },
      {
        "txt": "return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey();"
      },
      {
        "txt": "UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && <extra_id_0> builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } }"
      },
      {
        "txt": "} } return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (JSType.isSubtypeHelper(this, that)) { return true; } if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } if (!that.isRecordType()) { return false; }"
      },
      {
        "txt": "return RecordType.isSubtype(this, that.toMaybeRecordType()); } static boolean isSubtype(ObjectType typeA, RecordType typeB) { for (String property : typeB.properties.keySet()) { if (!typeA.hasProperty(property)) { return false; } JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (!propA.isUnknownType() && !propB.isUnknownType()) {"
      },
      {
        "txt": "if (typeA.isPropertyTypeDeclared(property)) { if (!propA.isInvariant(propB)) { return false; } } else { if (!propA.isSubtype(propB)) { return false; } } }"
      },
      {
        "txt": "} return true; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { JSType type = entry.getValue(); JSType resolvedType = type.resolve(t, scope); if (type != resolvedType) { properties.put(entry.getKey(), resolvedType);"
      },
      {
        "txt": "} } return super.resolveInternal(t, scope); }"
      }
    ]
  },
  {
    "id": 881,
    "file_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
    "start-bug-line": 268,
    "end-bug-line": 268,
    "bug": "if (!propA.isUnknownType() && !propB.isUnknownType()) {",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import com.google.common.collect.Maps; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.SortedMap; class RecordType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private final boolean declared; private boolean isFrozen = false; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { this(registry, properties, true); }"
      },
      {
        "txt": "RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { super(registry, null, null); setPrettyPrint(true); this.declared = declared; for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) { throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\");"
      },
      {
        "txt": "} if (declared) { defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } else { defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); } } isFrozen = true;"
      },
      {
        "txt": "} boolean isSynthetic() { return !declared; } boolean checkRecordEquivalenceHelper( RecordType otherRecord, boolean tolerateUnknowns) { Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false;"
      },
      {
        "txt": "} for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), tolerateUnknowns)) { return false; } } return true; } @Override"
      },
      {
        "txt": "public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) {"
      },
      {
        "txt": "properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.setSynthesized(true);"
      },
      {
        "txt": "for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) {"
      },
      {
        "txt": "if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj ="
      },
      {
        "txt": "registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName);"
      },
      {
        "txt": "if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } }"
      },
      {
        "txt": "return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true;"
      },
      {
        "txt": "} if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }"
      },
      {
        "txt": "for (String property : typeB.properties.keySet()) { if (!typeA.hasProperty(property)) { return false; } JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); <extra_id_0> if (typeA.isPropertyTypeDeclared(property)) { if (!propA.isInvariant(propB)) { return false; } } else { if (!propA.isSubtype(propB)) {"
      },
      {
        "txt": "} else { if (!propA.isSubtype(propB)) { return false; } } } } return true; } @Override"
      },
      {
        "txt": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { JSType type = entry.getValue(); JSType resolvedType = type.resolve(t, scope); if (type != resolvedType) { properties.put(entry.getKey(), resolvedType); } } return super.resolveInternal(t, scope); }"
      }
    ]
  },
  {
    "id": 882,
    "file_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
    "start-bug-line": 280,
    "end-bug-line": 280,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import com.google.common.collect.Maps; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty; import java.util.Map; import java.util.Set; import java.util.SortedMap; class RecordType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private final boolean declared; private boolean isFrozen = false; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {"
      },
      {
        "txt": "this(registry, properties, true); } RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { super(registry, null, null); setPrettyPrint(true); this.declared = declared; for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) {"
      },
      {
        "txt": "throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } if (declared) { defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } else { defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); }"
      },
      {
        "txt": "} isFrozen = true; } boolean isSynthetic() { return !declared; } boolean checkRecordEquivalenceHelper( RecordType otherRecord, boolean tolerateUnknowns) { Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties;"
      },
      {
        "txt": "if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), tolerateUnknowns)) { return false; } } return true;"
      },
      {
        "txt": "} @Override public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false;"
      },
      {
        "txt": "} if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();"
      },
      {
        "txt": "RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.setSynthesized(true); for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property));"
      },
      {
        "txt": "} for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType("
      },
      {
        "txt": "JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt :"
      },
      {
        "txt": "registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());"
      },
      {
        "txt": "} } return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (JSType.isSubtypeHelper(this, that)) { return true; } if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } if (!that.isRecordType()) { return false; }"
      },
      {
        "txt": "return RecordType.isSubtype(this, that.toMaybeRecordType()); } static boolean isSubtype(ObjectType typeA, RecordType typeB) { for (String property : typeB.properties.keySet()) { if (!typeA.hasProperty(property)) { return false; } JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (!propA.isUnknownType() && !propB.isUnknownType()) {"
      },
      {
        "txt": "if (!propA.isInvariant(propB)) { return false; } } else { if (!propA.isSubtype(propB)) { return false; <extra_id_0> } } } return true; } @Override"
      },
      {
        "txt": "} @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { for (Map.Entry<String, JSType> entry : properties.entrySet()) { JSType type = entry.getValue(); JSType resolvedType = type.resolve(t, scope); if (type != resolvedType) { properties.put(entry.getKey(), resolvedType); } }"
      },
      {
        "txt": "return super.resolveInternal(t, scope); }"
      }
    ]
  },
  {
    "id": 883,
    "file_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
    "start-bug-line": 334,
    "end-bug-line": 335,
    "bug": "UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns",
    "fix": "UnionType that, EquivalenceMethod eqMethod) { if (eqMethod == EquivalenceMethod.IDENTITY",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.rhino.ErrorReporter; import java.util.Collection; import java.util.List; import java.util.SortedSet; import java.util.TreeSet; public class UnionType extends JSType { private static final long serialVersionUID = 1L; Collection<JSType> alternates;"
      },
      {
        "txt": "private final int hashcode; UnionType(JSTypeRegistry registry, Collection<JSType> alternates) { super(registry); this.alternates = alternates; this.hashcode = this.alternates.hashCode(); } public Iterable<JSType> getAlternates() { return alternates; } @Override"
      },
      {
        "txt": "public boolean matchesNumberContext() { for (JSType t : alternates) { if (t.matchesNumberContext()) { return true; } } return false; } @Override public boolean matchesStringContext() {"
      },
      {
        "txt": "for (JSType t : alternates) { if (t.matchesStringContext()) { return true; } } return false; } @Override public boolean matchesObjectContext() { for (JSType t : alternates) {"
      },
      {
        "txt": "if (t.matchesObjectContext()) { return true; } } return false; } @Override public JSType findPropertyType(String propertyName) { JSType propertyType = null; for (JSType alternate : getAlternates()) {"
      },
      {
        "txt": "if (alternate.isNullType() || alternate.isVoidType()) { continue; } JSType altPropertyType = alternate.findPropertyType(propertyName); if (altPropertyType == null) { continue; } if (propertyType == null) { propertyType = altPropertyType; } else {"
      },
      {
        "txt": "propertyType = propertyType.getLeastSupertype(altPropertyType); } } return propertyType; } @Override public boolean canAssignTo(JSType that) { boolean canAssign = true; for (JSType t : alternates) { if (t.isUnknownType()) {"
      },
      {
        "txt": "return true; } canAssign &= t.canAssignTo(that); } return canAssign; } @Override public boolean canBeCalled() { for (JSType t : alternates) { if (!t.canBeCalled()) {"
      },
      {
        "txt": "return false; } } return true; } @Override public JSType autobox() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { restricted.addAlternate(t.autobox());"
      },
      {
        "txt": "} return restricted.build(); } @Override public JSType restrictByNotNullOrUndefined() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { restricted.addAlternate(t.restrictByNotNullOrUndefined()); } return restricted.build();"
      },
      {
        "txt": "} @Override public TernaryValue testForEquality(JSType that) { TernaryValue result = null; for (JSType t : alternates) { TernaryValue test = t.testForEquality(that); if (result == null) { result = test; } else if (!result.equals(test)) { return UNKNOWN;"
      },
      {
        "txt": "} } return result; } @Override public boolean isNullable() { for (JSType t : alternates) { if (t.isNullable()) { return true; }"
      },
      {
        "txt": "} return false; } @Override public boolean isUnknownType() { for (JSType t : alternates) { if (t.isUnknownType()) { return true; } }"
      },
      {
        "txt": "return false; } @Override public boolean isStruct() { for (JSType typ : getAlternates()) { if (typ.isStruct()) { return true; } } return false;"
      },
      {
        "txt": "} @Override public boolean isDict() { for (JSType typ : getAlternates()) { if (typ.isDict()) { return true; } } return false; }"
      },
      {
        "txt": "@Override public JSType getLeastSupertype(JSType that) { if (!that.isUnknownType() && !that.isUnionType()) { for (JSType alternate : alternates) { if (!alternate.isUnknownType() && that.isSubtype(alternate)) { return this; } } } return getLeastSupertype(this, that);"
      },
      {
        "txt": "} JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that.isUnionType()) { for (JSType otherAlternate : that.toMaybeUnionType().alternates) {"
      },
      {
        "txt": "if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); if (!result.isNoType()) { return result;"
      },
      {
        "txt": "return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } boolean checkUnionEquivalenceHelper( <extra_id_0> && alternates.size() != that.alternates.size()) { return false; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { return false;"
      },
      {
        "txt": "if (!hasAlternate(alternate, tolerateUnknowns)) { return false; } } return true; } private boolean hasAlternate(JSType type, boolean tolerateUnknowns) { for (JSType alternate : alternates) { if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) { return true;"
      },
      {
        "txt": "} } return false; } @Override public boolean hasProperty(String pname) { for (JSType alternate : alternates) { if (alternate.hasProperty(pname)) { return true; }"
      },
      {
        "txt": "} return false; } @Override public int hashCode() { return this.hashcode; } @Override public UnionType toMaybeUnionType() { return this;"
      },
      {
        "txt": "} @Override public boolean isObject() { for (JSType alternate : alternates) { if (!alternate.isObject()) { return false; } } return true; }"
      },
      {
        "txt": "public boolean contains(JSType type) { for (JSType alt : alternates) { if (alt.isEquivalentTo(type)) { return true; } } return false; } public JSType getRestrictedUnion(JSType type) { UnionTypeBuilder restricted = new UnionTypeBuilder(registry);"
      },
      {
        "txt": "for (JSType t : alternates) { if (t.isUnknownType() || !t.isSubtype(type)) { restricted.addAlternate(t); } } return restricted.build(); } @Override String toStringHelper(boolean forAnnotations) { StringBuilder result = new StringBuilder(); boolean firstAlternate = true;"
      },
      {
        "txt": "result.append(\"(\"); SortedSet<JSType> sorted = new TreeSet<JSType>(ALPHA); sorted.addAll(alternates); for (JSType t : sorted) { if (!firstAlternate) { result.append(\"|\"); } result.append(t.toStringHelper(forAnnotations)); firstAlternate = false; }"
      },
      {
        "txt": "result.append(\")\"); return result.toString(); } @Override public boolean isSubtype(JSType that) { if (that.isUnknownType()) { return true; } if (that.isAllType()) { return true;"
      },
      {
        "txt": "} for (JSType element : alternates) { if (!element.isSubtype(that)) { return false; } } return true; } @Override public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {"
      },
      {
        "txt": "UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { restricted.addAlternate( element.getRestrictedTypeGivenToBooleanOutcome(outcome)); } return restricted.build(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;"
      },
      {
        "txt": "for (JSType element : alternates) { literals = literals.union(element.getPossibleToBooleanOutcomes()); if (literals == BooleanLiteralSet.BOTH) { break; } } return literals; } @Override public TypePair getTypesUnderEquality(JSType that) {"
      },
      {
        "txt": "UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderEquality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); }"
      },
      {
        "txt": "} return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override public TypePair getTypesUnderInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) {"
      },
      {
        "txt": "TypePair p = element.getTypesUnderInequality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(),"
      },
      {
        "txt": "thatRestricted.build()); } @Override public TypePair getTypesUnderShallowInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderShallowInequality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA);"
      },
      {
        "txt": "} if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override"
      },
      {
        "txt": "public <T> T visit(Visitor<T> visitor) { return visitor.caseUnionType(this); } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); // for circularly defined types. boolean changed = false; ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder(); for (JSType alternate : alternates) { JSType newAlternate = alternate.resolve(t, scope);"
      },
      {
        "txt": "changed |= (alternate != newAlternate); resolvedTypes.add(alternate); } if (changed) { Collection<JSType> newAlternates = resolvedTypes.build(); Preconditions.checkState( newAlternates.hashCode() == this.hashcode); alternates = newAlternates; } return this;"
      },
      {
        "txt": "} @Override public String toDebugHashCodeString() { List<String> hashCodes = Lists.newArrayList(); for (JSType a : alternates) { hashCodes.add(a.toDebugHashCodeString()); } return \"{(\" + Joiner.on(\",\").join(hashCodes) + \")}\"; } @Override"
      },
      {
        "txt": "public boolean setValidator(Predicate<JSType> validator) { for (JSType a : alternates) { a.setValidator(validator); } return true; } @Override public JSType collapseUnion() { JSType currentValue = null; ObjectType currentCommonSuper = null;"
      },
      {
        "txt": "for (JSType a : alternates) { if (a.isUnknownType()) { return getNativeType(JSTypeNative.UNKNOWN_TYPE); } ObjectType obj = a.toObjectType(); if (obj == null) { if (currentValue == null && currentCommonSuper == null) { currentValue = a; } else { return getNativeType(JSTypeNative.ALL_TYPE);"
      },
      {
        "txt": "} } else if (currentValue != null) { return getNativeType(JSTypeNative.ALL_TYPE); } else if (currentCommonSuper == null) { currentCommonSuper = obj; } else { currentCommonSuper = registry.findCommonSuperObject(currentCommonSuper, obj); } }"
      },
      {
        "txt": "return currentCommonSuper; } @Override public void matchConstraint(JSType constraint) { for (JSType alternate : alternates) { alternate.matchConstraint(constraint); } } @Override public boolean hasAnyTemplateInternal() {"
      },
      {
        "txt": "for (JSType alternate : alternates) { if (alternate.hasAnyTemplate()) { return true; } } return false; }"
      }
    ]
  },
  {
    "id": 884,
    "file_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
    "start-bug-line": 340,
    "end-bug-line": 340,
    "bug": "if (!hasAlternate(alternate, tolerateUnknowns)) {",
    "fix": "if (!hasAlternate(alternate, eqMethod)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.rhino.ErrorReporter; import java.util.Collection; import java.util.List; import java.util.SortedSet;"
      },
      {
        "txt": "import java.util.TreeSet; public class UnionType extends JSType { private static final long serialVersionUID = 1L; Collection<JSType> alternates; private final int hashcode; UnionType(JSTypeRegistry registry, Collection<JSType> alternates) { super(registry); this.alternates = alternates; this.hashcode = this.alternates.hashCode(); }"
      },
      {
        "txt": "public Iterable<JSType> getAlternates() { return alternates; } @Override public boolean matchesNumberContext() { for (JSType t : alternates) { if (t.matchesNumberContext()) { return true; } }"
      },
      {
        "txt": "return false; } @Override public boolean matchesStringContext() { for (JSType t : alternates) { if (t.matchesStringContext()) { return true; } } return false;"
      },
      {
        "txt": "} @Override public boolean matchesObjectContext() { for (JSType t : alternates) { if (t.matchesObjectContext()) { return true; } } return false; }"
      },
      {
        "txt": "@Override public JSType findPropertyType(String propertyName) { JSType propertyType = null; for (JSType alternate : getAlternates()) { if (alternate.isNullType() || alternate.isVoidType()) { continue; } JSType altPropertyType = alternate.findPropertyType(propertyName); if (altPropertyType == null) { continue;"
      },
      {
        "txt": "} if (propertyType == null) { propertyType = altPropertyType; } else { propertyType = propertyType.getLeastSupertype(altPropertyType); } } return propertyType; } @Override"
      },
      {
        "txt": "public boolean canAssignTo(JSType that) { boolean canAssign = true; for (JSType t : alternates) { if (t.isUnknownType()) { return true; } canAssign &= t.canAssignTo(that); } return canAssign; }"
      },
      {
        "txt": "@Override public boolean canBeCalled() { for (JSType t : alternates) { if (!t.canBeCalled()) { return false; } } return true; } @Override"
      },
      {
        "txt": "public JSType autobox() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { restricted.addAlternate(t.autobox()); } return restricted.build(); } @Override public JSType restrictByNotNullOrUndefined() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry);"
      },
      {
        "txt": "for (JSType t : alternates) { restricted.addAlternate(t.restrictByNotNullOrUndefined()); } return restricted.build(); } @Override public TernaryValue testForEquality(JSType that) { TernaryValue result = null; for (JSType t : alternates) { TernaryValue test = t.testForEquality(that);"
      },
      {
        "txt": "if (result == null) { result = test; } else if (!result.equals(test)) { return UNKNOWN; } } return result; } @Override public boolean isNullable() {"
      },
      {
        "txt": "for (JSType t : alternates) { if (t.isNullable()) { return true; } } return false; } @Override public boolean isUnknownType() { for (JSType t : alternates) {"
      },
      {
        "txt": "if (t.isUnknownType()) { return true; } } return false; } @Override public boolean isStruct() { for (JSType typ : getAlternates()) { if (typ.isStruct()) {"
      },
      {
        "txt": "return true; } } return false; } @Override public boolean isDict() { for (JSType typ : getAlternates()) { if (typ.isDict()) { return true;"
      },
      {
        "txt": "} } return false; } @Override public JSType getLeastSupertype(JSType that) { if (!that.isUnknownType() && !that.isUnionType()) { for (JSType alternate : alternates) { if (!alternate.isUnknownType() && that.isSubtype(alternate)) { return this;"
      },
      {
        "txt": "} } } return getLeastSupertype(this, that); } JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate);"
      },
      {
        "txt": "} } if (that.isUnionType()) { for (JSType otherAlternate : that.toMaybeUnionType().alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that);"
      },
      {
        "txt": "} JSType result = builder.build(); if (!result.isNoType()) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } }"
      },
      {
        "txt": "UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { return false; } for (JSType alternate : that.alternates) { <extra_id_0> return false; } } return true; } private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {"
      },
      {
        "txt": "} private boolean hasAlternate(JSType type, boolean tolerateUnknowns) { for (JSType alternate : alternates) { if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) { return true; } } return false; } @Override"
      },
      {
        "txt": "public boolean hasProperty(String pname) { for (JSType alternate : alternates) { if (alternate.hasProperty(pname)) { return true; } } return false; } @Override public int hashCode() {"
      },
      {
        "txt": "return this.hashcode; } @Override public UnionType toMaybeUnionType() { return this; } @Override public boolean isObject() { for (JSType alternate : alternates) { if (!alternate.isObject()) {"
      },
      {
        "txt": "return false; } } return true; } public boolean contains(JSType type) { for (JSType alt : alternates) { if (alt.isEquivalentTo(type)) { return true; }"
      },
      {
        "txt": "} return false; } public JSType getRestrictedUnion(JSType type) { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { if (t.isUnknownType() || !t.isSubtype(type)) { restricted.addAlternate(t); } }"
      },
      {
        "txt": "return restricted.build(); } @Override String toStringHelper(boolean forAnnotations) { StringBuilder result = new StringBuilder(); boolean firstAlternate = true; result.append(\"(\"); SortedSet<JSType> sorted = new TreeSet<JSType>(ALPHA); sorted.addAll(alternates); for (JSType t : sorted) { if (!firstAlternate) {"
      },
      {
        "txt": "result.append(\"|\"); } result.append(t.toStringHelper(forAnnotations)); firstAlternate = false; } result.append(\")\"); return result.toString(); } @Override public boolean isSubtype(JSType that) {"
      },
      {
        "txt": "if (that.isUnknownType()) { return true; } if (that.isAllType()) { return true; } for (JSType element : alternates) { if (!element.isSubtype(that)) { return false; }"
      },
      {
        "txt": "} return true; } @Override public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { restricted.addAlternate( element.getRestrictedTypeGivenToBooleanOutcome(outcome)); }"
      },
      {
        "txt": "return restricted.build(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { BooleanLiteralSet literals = BooleanLiteralSet.EMPTY; for (JSType element : alternates) { literals = literals.union(element.getPossibleToBooleanOutcomes()); if (literals == BooleanLiteralSet.BOTH) { break; }"
      },
      {
        "txt": "} return literals; } @Override public TypePair getTypesUnderEquality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderEquality(that); if (p.typeA != null) {"
      },
      {
        "txt": "thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(), thatRestricted.build()); }"
      },
      {
        "txt": "@Override public TypePair getTypesUnderInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderInequality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) {"
      },
      {
        "txt": "thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override public TypePair getTypesUnderShallowInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);"
      },
      {
        "txt": "UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderShallowInequality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } }"
      },
      {
        "txt": "return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseUnionType(this); } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {"
      },
      {
        "txt": "setResolvedTypeInternal(this); // for circularly defined types. boolean changed = false; ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder(); for (JSType alternate : alternates) { JSType newAlternate = alternate.resolve(t, scope); changed |= (alternate != newAlternate); resolvedTypes.add(alternate); } if (changed) { Collection<JSType> newAlternates = resolvedTypes.build();"
      },
      {
        "txt": "Preconditions.checkState( newAlternates.hashCode() == this.hashcode); alternates = newAlternates; } return this; } @Override public String toDebugHashCodeString() { List<String> hashCodes = Lists.newArrayList(); for (JSType a : alternates) {"
      },
      {
        "txt": "hashCodes.add(a.toDebugHashCodeString()); } return \"{(\" + Joiner.on(\",\").join(hashCodes) + \")}\"; } @Override public boolean setValidator(Predicate<JSType> validator) { for (JSType a : alternates) { a.setValidator(validator); } return true;"
      },
      {
        "txt": "} @Override public JSType collapseUnion() { JSType currentValue = null; ObjectType currentCommonSuper = null; for (JSType a : alternates) { if (a.isUnknownType()) { return getNativeType(JSTypeNative.UNKNOWN_TYPE); } ObjectType obj = a.toObjectType();"
      },
      {
        "txt": "if (obj == null) { if (currentValue == null && currentCommonSuper == null) { currentValue = a; } else { return getNativeType(JSTypeNative.ALL_TYPE); } } else if (currentValue != null) { return getNativeType(JSTypeNative.ALL_TYPE); } else if (currentCommonSuper == null) { currentCommonSuper = obj;"
      },
      {
        "txt": "} else { currentCommonSuper = registry.findCommonSuperObject(currentCommonSuper, obj); } } return currentCommonSuper; } @Override public void matchConstraint(JSType constraint) { for (JSType alternate : alternates) {"
      },
      {
        "txt": "alternate.matchConstraint(constraint); } } @Override public boolean hasAnyTemplateInternal() { for (JSType alternate : alternates) { if (alternate.hasAnyTemplate()) { return true; } }"
      },
      {
        "txt": "return false; }"
      }
    ]
  },
  {
    "id": 885,
    "file_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
    "start-bug-line": 347,
    "end-bug-line": 347,
    "bug": "private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {",
    "fix": "private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import java.util.Collection; import java.util.List; import java.util.SortedSet; import java.util.TreeSet; public class UnionType extends JSType { private static final long serialVersionUID = 1L; Collection<JSType> alternates; private final int hashcode; UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {"
      },
      {
        "txt": "super(registry); this.alternates = alternates; this.hashcode = this.alternates.hashCode(); } public Iterable<JSType> getAlternates() { return alternates; } @Override public boolean matchesNumberContext() { for (JSType t : alternates) {"
      },
      {
        "txt": "if (t.matchesNumberContext()) { return true; } } return false; } @Override public boolean matchesStringContext() { for (JSType t : alternates) { if (t.matchesStringContext()) {"
      },
      {
        "txt": "return true; } } return false; } @Override public boolean matchesObjectContext() { for (JSType t : alternates) { if (t.matchesObjectContext()) { return true;"
      },
      {
        "txt": "} } return false; } @Override public JSType findPropertyType(String propertyName) { JSType propertyType = null; for (JSType alternate : getAlternates()) { if (alternate.isNullType() || alternate.isVoidType()) { continue;"
      },
      {
        "txt": "} JSType altPropertyType = alternate.findPropertyType(propertyName); if (altPropertyType == null) { continue; } if (propertyType == null) { propertyType = altPropertyType; } else { propertyType = propertyType.getLeastSupertype(altPropertyType); }"
      },
      {
        "txt": "} return propertyType; } @Override public boolean canAssignTo(JSType that) { boolean canAssign = true; for (JSType t : alternates) { if (t.isUnknownType()) { return true; }"
      },
      {
        "txt": "canAssign &= t.canAssignTo(that); } return canAssign; } @Override public boolean canBeCalled() { for (JSType t : alternates) { if (!t.canBeCalled()) { return false; }"
      },
      {
        "txt": "} return true; } @Override public JSType autobox() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { restricted.addAlternate(t.autobox()); } return restricted.build();"
      },
      {
        "txt": "} @Override public JSType restrictByNotNullOrUndefined() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { restricted.addAlternate(t.restrictByNotNullOrUndefined()); } return restricted.build(); } @Override"
      },
      {
        "txt": "public TernaryValue testForEquality(JSType that) { TernaryValue result = null; for (JSType t : alternates) { TernaryValue test = t.testForEquality(that); if (result == null) { result = test; } else if (!result.equals(test)) { return UNKNOWN; } }"
      },
      {
        "txt": "return result; } @Override public boolean isNullable() { for (JSType t : alternates) { if (t.isNullable()) { return true; } } return false;"
      },
      {
        "txt": "} @Override public boolean isUnknownType() { for (JSType t : alternates) { if (t.isUnknownType()) { return true; } } return false; }"
      },
      {
        "txt": "@Override public boolean isStruct() { for (JSType typ : getAlternates()) { if (typ.isStruct()) { return true; } } return false; } @Override"
      },
      {
        "txt": "public boolean isDict() { for (JSType typ : getAlternates()) { if (typ.isDict()) { return true; } } return false; } @Override public JSType getLeastSupertype(JSType that) {"
      },
      {
        "txt": "if (!that.isUnknownType() && !that.isUnionType()) { for (JSType alternate : alternates) { if (!alternate.isUnknownType() && that.isSubtype(alternate)) { return this; } } } return getLeastSupertype(this, that); } JSType meet(JSType that) {"
      },
      {
        "txt": "UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that.isUnionType()) { for (JSType otherAlternate : that.toMaybeUnionType().alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate);"
      },
      {
        "txt": "} } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); if (!result.isNoType()) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE);"
      },
      {
        "txt": "} else { return getNativeType(JSTypeNative.NO_TYPE); } } boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { return false; }"
      },
      {
        "txt": "if (!hasAlternate(alternate, tolerateUnknowns)) { return false; } } return true; } <extra_id_0> for (JSType alternate : alternates) { if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) { return true; } } return false;"
      },
      {
        "txt": "} return false; } @Override public boolean hasProperty(String pname) { for (JSType alternate : alternates) { if (alternate.hasProperty(pname)) { return true; } }"
      },
      {
        "txt": "return false; } @Override public int hashCode() { return this.hashcode; } @Override public UnionType toMaybeUnionType() { return this; }"
      },
      {
        "txt": "@Override public boolean isObject() { for (JSType alternate : alternates) { if (!alternate.isObject()) { return false; } } return true; } public boolean contains(JSType type) {"
      },
      {
        "txt": "for (JSType alt : alternates) { if (alt.isEquivalentTo(type)) { return true; } } return false; } public JSType getRestrictedUnion(JSType type) { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) {"
      },
      {
        "txt": "if (t.isUnknownType() || !t.isSubtype(type)) { restricted.addAlternate(t); } } return restricted.build(); } @Override String toStringHelper(boolean forAnnotations) { StringBuilder result = new StringBuilder(); boolean firstAlternate = true; result.append(\"(\");"
      },
      {
        "txt": "SortedSet<JSType> sorted = new TreeSet<JSType>(ALPHA); sorted.addAll(alternates); for (JSType t : sorted) { if (!firstAlternate) { result.append(\"|\"); } result.append(t.toStringHelper(forAnnotations)); firstAlternate = false; } result.append(\")\");"
      },
      {
        "txt": "return result.toString(); } @Override public boolean isSubtype(JSType that) { if (that.isUnknownType()) { return true; } if (that.isAllType()) { return true; }"
      },
      {
        "txt": "for (JSType element : alternates) { if (!element.isSubtype(that)) { return false; } } return true; } @Override public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { UnionTypeBuilder restricted = new UnionTypeBuilder(registry);"
      },
      {
        "txt": "for (JSType element : alternates) { restricted.addAlternate( element.getRestrictedTypeGivenToBooleanOutcome(outcome)); } return restricted.build(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { BooleanLiteralSet literals = BooleanLiteralSet.EMPTY; for (JSType element : alternates) {"
      },
      {
        "txt": "literals = literals.union(element.getPossibleToBooleanOutcomes()); if (literals == BooleanLiteralSet.BOTH) { break; } } return literals; } @Override public TypePair getTypesUnderEquality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);"
      },
      {
        "txt": "UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderEquality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } }"
      },
      {
        "txt": "return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override public TypePair getTypesUnderInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderInequality(that);"
      },
      {
        "txt": "if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(), thatRestricted.build());"
      },
      {
        "txt": "} @Override public TypePair getTypesUnderShallowInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderShallowInequality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); }"
      },
      {
        "txt": "if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override public <T> T visit(Visitor<T> visitor) {"
      },
      {
        "txt": "return visitor.caseUnionType(this); } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); // for circularly defined types. boolean changed = false; ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder(); for (JSType alternate : alternates) { JSType newAlternate = alternate.resolve(t, scope); changed |= (alternate != newAlternate);"
      },
      {
        "txt": "resolvedTypes.add(alternate); } if (changed) { Collection<JSType> newAlternates = resolvedTypes.build(); Preconditions.checkState( newAlternates.hashCode() == this.hashcode); alternates = newAlternates; } return this; }"
      },
      {
        "txt": "@Override public String toDebugHashCodeString() { List<String> hashCodes = Lists.newArrayList(); for (JSType a : alternates) { hashCodes.add(a.toDebugHashCodeString()); } return \"{(\" + Joiner.on(\",\").join(hashCodes) + \")}\"; } @Override public boolean setValidator(Predicate<JSType> validator) {"
      },
      {
        "txt": "for (JSType a : alternates) { a.setValidator(validator); } return true; } @Override public JSType collapseUnion() { JSType currentValue = null; ObjectType currentCommonSuper = null; for (JSType a : alternates) {"
      },
      {
        "txt": "if (a.isUnknownType()) { return getNativeType(JSTypeNative.UNKNOWN_TYPE); } ObjectType obj = a.toObjectType(); if (obj == null) { if (currentValue == null && currentCommonSuper == null) { currentValue = a; } else { return getNativeType(JSTypeNative.ALL_TYPE); }"
      },
      {
        "txt": "} else if (currentValue != null) { return getNativeType(JSTypeNative.ALL_TYPE); } else if (currentCommonSuper == null) { currentCommonSuper = obj; } else { currentCommonSuper = registry.findCommonSuperObject(currentCommonSuper, obj); } } return currentCommonSuper;"
      },
      {
        "txt": "} @Override public void matchConstraint(JSType constraint) { for (JSType alternate : alternates) { alternate.matchConstraint(constraint); } } @Override public boolean hasAnyTemplateInternal() { for (JSType alternate : alternates) {"
      },
      {
        "txt": "if (alternate.hasAnyTemplate()) { return true; } } return false; }"
      }
    ]
  },
  {
    "id": 886,
    "file_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
    "start-bug-line": 349,
    "end-bug-line": 349,
    "bug": "if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {",
    "fix": "if (alternate.checkEquivalenceHelper(type, eqMethod)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.rhino.ErrorReporter; import java.util.Collection;"
      },
      {
        "txt": "import java.util.List; import java.util.SortedSet; import java.util.TreeSet; public class UnionType extends JSType { private static final long serialVersionUID = 1L; Collection<JSType> alternates; private final int hashcode; UnionType(JSTypeRegistry registry, Collection<JSType> alternates) { super(registry); this.alternates = alternates;"
      },
      {
        "txt": "this.hashcode = this.alternates.hashCode(); } public Iterable<JSType> getAlternates() { return alternates; } @Override public boolean matchesNumberContext() { for (JSType t : alternates) { if (t.matchesNumberContext()) { return true;"
      },
      {
        "txt": "} } return false; } @Override public boolean matchesStringContext() { for (JSType t : alternates) { if (t.matchesStringContext()) { return true; }"
      },
      {
        "txt": "} return false; } @Override public boolean matchesObjectContext() { for (JSType t : alternates) { if (t.matchesObjectContext()) { return true; } }"
      },
      {
        "txt": "return false; } @Override public JSType findPropertyType(String propertyName) { JSType propertyType = null; for (JSType alternate : getAlternates()) { if (alternate.isNullType() || alternate.isVoidType()) { continue; } JSType altPropertyType = alternate.findPropertyType(propertyName);"
      },
      {
        "txt": "if (altPropertyType == null) { continue; } if (propertyType == null) { propertyType = altPropertyType; } else { propertyType = propertyType.getLeastSupertype(altPropertyType); } } return propertyType;"
      },
      {
        "txt": "} @Override public boolean canAssignTo(JSType that) { boolean canAssign = true; for (JSType t : alternates) { if (t.isUnknownType()) { return true; } canAssign &= t.canAssignTo(that); }"
      },
      {
        "txt": "return canAssign; } @Override public boolean canBeCalled() { for (JSType t : alternates) { if (!t.canBeCalled()) { return false; } } return true;"
      },
      {
        "txt": "} @Override public JSType autobox() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { restricted.addAlternate(t.autobox()); } return restricted.build(); } @Override"
      },
      {
        "txt": "public JSType restrictByNotNullOrUndefined() { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { restricted.addAlternate(t.restrictByNotNullOrUndefined()); } return restricted.build(); } @Override public TernaryValue testForEquality(JSType that) { TernaryValue result = null;"
      },
      {
        "txt": "for (JSType t : alternates) { TernaryValue test = t.testForEquality(that); if (result == null) { result = test; } else if (!result.equals(test)) { return UNKNOWN; } } return result; }"
      },
      {
        "txt": "@Override public boolean isNullable() { for (JSType t : alternates) { if (t.isNullable()) { return true; } } return false; } @Override"
      },
      {
        "txt": "public boolean isUnknownType() { for (JSType t : alternates) { if (t.isUnknownType()) { return true; } } return false; } @Override public boolean isStruct() {"
      },
      {
        "txt": "for (JSType typ : getAlternates()) { if (typ.isStruct()) { return true; } } return false; } @Override public boolean isDict() { for (JSType typ : getAlternates()) {"
      },
      {
        "txt": "if (typ.isDict()) { return true; } } return false; } @Override public JSType getLeastSupertype(JSType that) { if (!that.isUnknownType() && !that.isUnionType()) { for (JSType alternate : alternates) {"
      },
      {
        "txt": "if (!alternate.isUnknownType() && that.isSubtype(alternate)) { return this; } } } return getLeastSupertype(this, that); } JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) {"
      },
      {
        "txt": "if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that.isUnionType()) { for (JSType otherAlternate : that.toMaybeUnionType().alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } }"
      },
      {
        "txt": "} else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); if (!result.isNoType()) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE);"
      },
      {
        "txt": "} } boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { return false; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) {"
      },
      {
        "txt": "} } return true; } private boolean hasAlternate(JSType type, boolean tolerateUnknowns) { for (JSType alternate : alternates) { <extra_id_0> return true; } } return false; } @Override"
      },
      {
        "txt": "} @Override public boolean hasProperty(String pname) { for (JSType alternate : alternates) { if (alternate.hasProperty(pname)) { return true; } } return false; }"
      },
      {
        "txt": "@Override public int hashCode() { return this.hashcode; } @Override public UnionType toMaybeUnionType() { return this; } @Override public boolean isObject() {"
      },
      {
        "txt": "for (JSType alternate : alternates) { if (!alternate.isObject()) { return false; } } return true; } public boolean contains(JSType type) { for (JSType alt : alternates) { if (alt.isEquivalentTo(type)) {"
      },
      {
        "txt": "return true; } } return false; } public JSType getRestrictedUnion(JSType type) { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType t : alternates) { if (t.isUnknownType() || !t.isSubtype(type)) { restricted.addAlternate(t);"
      },
      {
        "txt": "} } return restricted.build(); } @Override String toStringHelper(boolean forAnnotations) { StringBuilder result = new StringBuilder(); boolean firstAlternate = true; result.append(\"(\"); SortedSet<JSType> sorted = new TreeSet<JSType>(ALPHA); sorted.addAll(alternates);"
      },
      {
        "txt": "for (JSType t : sorted) { if (!firstAlternate) { result.append(\"|\"); } result.append(t.toStringHelper(forAnnotations)); firstAlternate = false; } result.append(\")\"); return result.toString(); }"
      },
      {
        "txt": "@Override public boolean isSubtype(JSType that) { if (that.isUnknownType()) { return true; } if (that.isAllType()) { return true; } for (JSType element : alternates) { if (!element.isSubtype(that)) {"
      },
      {
        "txt": "return false; } } return true; } @Override public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { UnionTypeBuilder restricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { restricted.addAlternate("
      },
      {
        "txt": "element.getRestrictedTypeGivenToBooleanOutcome(outcome)); } return restricted.build(); } @Override public BooleanLiteralSet getPossibleToBooleanOutcomes() { BooleanLiteralSet literals = BooleanLiteralSet.EMPTY; for (JSType element : alternates) { literals = literals.union(element.getPossibleToBooleanOutcomes()); if (literals == BooleanLiteralSet.BOTH) {"
      },
      {
        "txt": "break; } } return literals; } @Override public TypePair getTypesUnderEquality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) {"
      },
      {
        "txt": "TypePair p = element.getTypesUnderEquality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(),"
      },
      {
        "txt": "thatRestricted.build()); } @Override public TypePair getTypesUnderInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderInequality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA);"
      },
      {
        "txt": "} if (p.typeB != null) { thatRestricted.addAlternate(p.typeB); } } return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override"
      },
      {
        "txt": "public TypePair getTypesUnderShallowInequality(JSType that) { UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry); UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry); for (JSType element : alternates) { TypePair p = element.getTypesUnderShallowInequality(that); if (p.typeA != null) { thisRestricted.addAlternate(p.typeA); } if (p.typeB != null) { thatRestricted.addAlternate(p.typeB);"
      },
      {
        "txt": "} } return new TypePair( thisRestricted.build(), thatRestricted.build()); } @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseUnionType(this); }"
      },
      {
        "txt": "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); // for circularly defined types. boolean changed = false; ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder(); for (JSType alternate : alternates) { JSType newAlternate = alternate.resolve(t, scope); changed |= (alternate != newAlternate); resolvedTypes.add(alternate); }"
      },
      {
        "txt": "if (changed) { Collection<JSType> newAlternates = resolvedTypes.build(); Preconditions.checkState( newAlternates.hashCode() == this.hashcode); alternates = newAlternates; } return this; } @Override public String toDebugHashCodeString() {"
      },
      {
        "txt": "List<String> hashCodes = Lists.newArrayList(); for (JSType a : alternates) { hashCodes.add(a.toDebugHashCodeString()); } return \"{(\" + Joiner.on(\",\").join(hashCodes) + \")}\"; } @Override public boolean setValidator(Predicate<JSType> validator) { for (JSType a : alternates) { a.setValidator(validator);"
      },
      {
        "txt": "} return true; } @Override public JSType collapseUnion() { JSType currentValue = null; ObjectType currentCommonSuper = null; for (JSType a : alternates) { if (a.isUnknownType()) { return getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} ObjectType obj = a.toObjectType(); if (obj == null) { if (currentValue == null && currentCommonSuper == null) { currentValue = a; } else { return getNativeType(JSTypeNative.ALL_TYPE); } } else if (currentValue != null) { return getNativeType(JSTypeNative.ALL_TYPE);"
      },
      {
        "txt": "} else if (currentCommonSuper == null) { currentCommonSuper = obj; } else { currentCommonSuper = registry.findCommonSuperObject(currentCommonSuper, obj); } } return currentCommonSuper; } @Override"
      },
      {
        "txt": "public void matchConstraint(JSType constraint) { for (JSType alternate : alternates) { alternate.matchConstraint(constraint); } } @Override public boolean hasAnyTemplateInternal() { for (JSType alternate : alternates) { if (alternate.hasAnyTemplate()) { return true;"
      },
      {
        "txt": "} } return false; }"
      }
    ]
  }
]