[
  {
    "id": 432,
    "file_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
    "start-bug-line": 894,
    "end-bug-line": 894,
    "bug": "",
    "fix": "case Token.INSTANCEOF:",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.HashMultimap; import com.google.common.collect.Maps; import com.google.common.collect.Multimap; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import java.util.ArrayDeque; import java.util.Comparator; import java.util.Deque; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.PriorityQueue; final class ControlFlowAnalysis implements Callback, CompilerPass { private final AbstractCompiler compiler; private ControlFlowGraph<Node> cfg;"
      },
      {
        "txt": "private Map<Node, Integer> astPosition; private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities; private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() { @Override public int compare( DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) { return astPosition.get(a.getValue()) - astPosition.get(b.getValue()); } };"
      },
      {
        "txt": "private int astPositionCounter; private int priorityCounter; private final boolean shouldTraverseFunctions; private Node root; private final Deque<Node> exceptionHandler = new ArrayDeque<Node>(); private final Multimap<Node, Node> finallyMap = HashMultimap.create(); ControlFlowAnalysis(AbstractCompiler compiler, boolean shouldTraverseFunctions) { this.compiler = compiler; this.shouldTraverseFunctions = shouldTraverseFunctions;"
      },
      {
        "txt": "} ControlFlowGraph<Node> getCfg() { return cfg; } @Override public void process(Node externs, Node root) { this.root = root; astPositionCounter = 0; astPosition = Maps.newHashMap(); nodePriorities = Maps.newHashMap();"
      },
      {
        "txt": "cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities); NodeTraversal.traverse(compiler, root, this); astPosition.put(null, ++astPositionCounter); // the implicit return is last. priorityCounter = 0; DiGraphNode<Node, Branch> entry = cfg.getEntry(); prioritizeFromEntryNode(entry); if (shouldTraverseFunctions) { for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) { Node value = candidate.getValue(); if (value != null && value.getType() == Token.FUNCTION) {"
      },
      {
        "txt": "Preconditions.checkState( !nodePriorities.containsKey(candidate) || candidate == entry); prioritizeFromEntryNode(candidate); } } } for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) { if (!nodePriorities.containsKey(candidate)) { nodePriorities.put(candidate, ++priorityCounter); }"
      },
      {
        "txt": "} nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter); } private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) { PriorityQueue<DiGraphNode<Node, Branch>> worklist = new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator); worklist.add(entry); while (!worklist.isEmpty()) { DiGraphNode<Node, Branch> current = worklist.remove(); if (nodePriorities.containsKey(current)) {"
      },
      {
        "txt": "continue; } nodePriorities.put(current, ++priorityCounter); List<DiGraphNode<Node, Branch>> successors = cfg.getDirectedSuccNodes(current); for (DiGraphNode<Node, Branch> candidate : successors) { worklist.add(candidate); } } }"
      },
      {
        "txt": "@Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { astPosition.put(n, astPositionCounter++); switch (n.getType()) { case Token.FUNCTION: if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) { exceptionHandler.push(n); return true; }"
      },
      {
        "txt": "return false; case Token.TRY: exceptionHandler.push(n); return true; } if (parent != null) { switch (parent.getType()) { case Token.FOR: return n == parent.getLastChild(); case Token.IF:"
      },
      {
        "txt": "case Token.WHILE: case Token.WITH: return n != parent.getFirstChild(); case Token.DO: return n != parent.getFirstChild().getNext(); case Token.SWITCH: case Token.CASE: case Token.CATCH: case Token.LABEL: return n != parent.getFirstChild();"
      },
      {
        "txt": "case Token.FUNCTION: return n == parent.getFirstChild().getNext().getNext(); case Token.CONTINUE: case Token.BREAK: case Token.EXPR_RESULT: case Token.VAR: case Token.RETURN: case Token.THROW: return false; case Token.TRY:"
      },
      {
        "txt": "if (n == parent.getFirstChild().getNext()) { Preconditions.checkState(exceptionHandler.peek() == parent); exceptionHandler.pop(); } } } return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.IF: handleIf(n); return; case Token.WHILE: handleWhile(n); return; case Token.DO: handleDo(n); return;"
      },
      {
        "txt": "case Token.FOR: handleFor(n); return; case Token.SWITCH: handleSwitch(n); return; case Token.CASE: handleCase(n); return; case Token.DEFAULT:"
      },
      {
        "txt": "handleDefault(n); return; case Token.BLOCK: case Token.SCRIPT: handleStmtList(n); return; case Token.FUNCTION: handleFunction(n); return; case Token.EXPR_RESULT:"
      },
      {
        "txt": "handleExpr(n); return; case Token.THROW: handleThrow(n); return; case Token.TRY: handleTry(n); return; case Token.CATCH: handleCatch(n);"
      },
      {
        "txt": "return; case Token.BREAK: handleBreak(n); return; case Token.CONTINUE: handleContinue(n); return; case Token.RETURN: handleReturn(n); return;"
      },
      {
        "txt": "case Token.WITH: handleWith(n); return; case Token.LABEL: return; default: handleStmt(n); return; } }"
      },
      {
        "txt": "private void handleIf(Node node) { Node thenBlock = node.getFirstChild().getNext(); Node elseBlock = thenBlock.getNext(); createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock)); if (elseBlock == null) { createEdge(node, Branch.ON_FALSE, computeFollowNode(node)); // not taken branch } else { createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock)); }"
      },
      {
        "txt": "connectToPossibleExceptionHandler( node, NodeUtil.getConditionExpression(node)); } private void handleWhile(Node node) { createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild().getNext())); createEdge(node, Branch.ON_FALSE, computeFollowNode(node)); connectToPossibleExceptionHandler( node, NodeUtil.getConditionExpression(node));"
      },
      {
        "txt": "} private void handleDo(Node node) { createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild())); createEdge(node, Branch.ON_FALSE, computeFollowNode(node)); connectToPossibleExceptionHandler( node, NodeUtil.getConditionExpression(node)); } private void handleFor(Node forNode) { if (forNode.getChildCount() == 4) {"
      },
      {
        "txt": "Node init = forNode.getFirstChild(); Node cond = init.getNext(); Node iter = cond.getNext(); Node body = iter.getNext(); createEdge(init, Branch.UNCOND, forNode); createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body)); createEdge(forNode, Branch.ON_FALSE, computeFollowNode(forNode)); createEdge(iter, Branch.UNCOND, forNode); connectToPossibleExceptionHandler(init, init);"
      },
      {
        "txt": "connectToPossibleExceptionHandler(forNode, cond); connectToPossibleExceptionHandler(iter, iter); } else { Node item = forNode.getFirstChild(); Node collection = item.getNext(); Node body = collection.getNext(); createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body)); createEdge(forNode, Branch.ON_FALSE, computeFollowNode(forNode)); connectToPossibleExceptionHandler(forNode, collection);"
      },
      {
        "txt": "} } private void handleSwitch(Node node) { Node next = getNextSiblingOfType( node.getFirstChild().getNext(), Token.CASE, Token.EMPTY); if (next != null) { // Has at least one CASE or EMPTY createEdge(node, Branch.UNCOND, next); } else { // Has no CASE but possibly a DEFAULT if (node.getFirstChild().getNext() != null) { createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());"
      },
      {
        "txt": "} else { // No CASE, no DEFAULT createEdge(node, Branch.UNCOND, computeFollowNode(node)); } } connectToPossibleExceptionHandler(node, node.getFirstChild()); } private void handleCase(Node node) { createEdge(node, Branch.ON_TRUE, node.getFirstChild().getNext()); Node next = getNextSiblingOfType(node.getNext(), Token.CASE);"
      },
      {
        "txt": "if (next != null) { // Found a CASE Preconditions.checkState(next.getType() == Token.CASE); createEdge(node, Branch.ON_FALSE, next); } else { // No more CASE found, go back and search for a DEFAULT. Node parent = node.getParent(); Node deflt = getNextSiblingOfType( parent.getFirstChild().getNext(), Token.DEFAULT); if (deflt != null) { // Has a DEFAULT createEdge(node, Branch.ON_FALSE, deflt); } else { // No DEFAULT found, go to the follow of the SWITCH."
      },
      {
        "txt": "createEdge(node, Branch.ON_FALSE, computeFollowNode(node)); } } connectToPossibleExceptionHandler(node, node.getFirstChild()); } private void handleDefault(Node node) { createEdge(node, Branch.UNCOND, node.getFirstChild()); } private void handleWith(Node node) { createEdge(node, Branch.UNCOND, node.getLastChild());"
      },
      {
        "txt": "connectToPossibleExceptionHandler(node, node.getFirstChild()); } private void handleStmtList(Node node) { Node parent = node.getParent(); if (node.getType() == Token.BLOCK && parent != null && parent.getType() == Token.TRY && NodeUtil.getCatchBlock(parent) == node && !NodeUtil.hasCatchHandler(node)) { return; }"
      },
      {
        "txt": "Node child = node.getFirstChild(); while (child != null && child.getType() == Token.FUNCTION) { child = child.getNext(); } if (child != null) { createEdge(node, Branch.UNCOND, computeFallThrough(child)); } else { createEdge(node, Branch.UNCOND, computeFollowNode(node)); } if (parent != null) {"
      },
      {
        "txt": "switch (parent.getType()) { case Token.DEFAULT: case Token.CASE: case Token.TRY: break; default: if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) { Node next = node.getLastChild(); if (next != null) { createEdge(node, Branch.SYN_BLOCK, computeFallThrough(next));"
      },
      {
        "txt": "} } break; } } } private void handleFunction(Node node) { Preconditions.checkState(node.getChildCount() >= 3); createEdge(node, Branch.UNCOND, computeFallThrough(node.getFirstChild().getNext().getNext()));"
      },
      {
        "txt": "Preconditions.checkState(exceptionHandler.peek() == node); exceptionHandler.pop(); } private void handleExpr(Node node) { createEdge(node, Branch.UNCOND, computeFollowNode(node)); connectToPossibleExceptionHandler(node, node); } private void handleThrow(Node node) { connectToPossibleExceptionHandler(node, node); }"
      },
      {
        "txt": "private void handleTry(Node node) { createEdge(node, Branch.UNCOND, node.getFirstChild()); } private void handleCatch(Node node) { createEdge(node, Branch.UNCOND, node.getLastChild()); } private void handleBreak(Node node) { String label = null; if (node.hasChildren()) { label = node.getFirstChild().getString();"
      },
      {
        "txt": "} Node cur; Node lastJump; Node parent = node.getParent(); for (cur = node, lastJump = node; !isBreakTarget(cur, parent, label); cur = parent, parent = parent.getParent()) { if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) { if (lastJump == node) { createEdge(lastJump, Branch.UNCOND, computeFallThrough("
      },
      {
        "txt": "cur.getLastChild())); } else { finallyMap.put(lastJump, computeFallThrough(cur.getLastChild())); } lastJump = cur; } Preconditions.checkState(parent != null, \"Cannot find break target.\"); } if (lastJump == node) { createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur));"
      },
      {
        "txt": "} else { finallyMap.put(lastJump, computeFollowNode(cur)); } } private void handleContinue(Node node) { String label = null; if (node.hasChildren()) { label = node.getFirstChild().getString(); } Node cur;"
      },
      {
        "txt": "Node lastJump; Node parent = node.getParent(); for (cur = node, lastJump = node; !isContinueTarget(cur, parent, label); cur = parent, parent = parent.getParent()) { if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) { if (lastJump == node) { createEdge(lastJump, Branch.UNCOND, cur.getLastChild()); } else { finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));"
      },
      {
        "txt": "} lastJump = cur; } Preconditions.checkState(parent != null, \"Cannot find continue target.\"); } Node iter = cur; if (cur.getChildCount() == 4) { iter = cur.getFirstChild().getNext().getNext(); } if (lastJump == node) {"
      },
      {
        "txt": "createEdge(node, Branch.UNCOND, iter); } else { finallyMap.put(lastJump, iter); } } private void handleReturn(Node node) { Node lastJump = null; for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) { Node curHandler = iter.next(); if (NodeUtil.isFunction(curHandler)) {"
      },
      {
        "txt": "break; } if (NodeUtil.hasFinally(curHandler)) { if (lastJump == null) { createEdge(node, Branch.UNCOND, curHandler.getLastChild()); } else { finallyMap.put(lastJump, computeFallThrough(curHandler.getLastChild())); } lastJump = curHandler;"
      },
      {
        "txt": "} } if (node.hasChildren()) { connectToPossibleExceptionHandler(node, node.getFirstChild()); } if (lastJump == null) { createEdge(node, Branch.UNCOND, null); } else { finallyMap.put(lastJump, null); }"
      },
      {
        "txt": "} private void handleStmt(Node node) { createEdge(node, Branch.UNCOND, computeFollowNode(node)); connectToPossibleExceptionHandler(node, node); } private Node computeFollowNode(Node node) { return computeFollowNode(node, node); } private Node computeFollowNode(Node fromNode, Node node) { Node parent = node.getParent();"
      },
      {
        "txt": "if (parent == null || parent.getType() == Token.FUNCTION || node == root) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent); case Token.CASE: case Token.DEFAULT: if (parent.getNext() != null) { if (parent.getNext().getType() == Token.CASE) {"
      },
      {
        "txt": "return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().getType() == Token.DEFAULT) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent); } break;"
      },
      {
        "txt": "case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY:"
      },
      {
        "txt": "if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { // and have FINALLY block. return computeFallThrough(parent.getLastChild()); } else { // and have no FINALLY. return computeFollowNode(fromNode, parent); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { // and have FINALLY block. return computeFallThrough(node.getNext()); } else {"
      },
      {
        "txt": "return computeFollowNode(fromNode, parent); } } else if (parent.getLastChild() == node){ for (Node finallyNode : finallyMap.get(parent)) { createEdge(fromNode, Branch.UNCOND, finallyNode); } return computeFollowNode(fromNode, parent); } } Node nextSibling = node.getNext();"
      },
      {
        "txt": "while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) { nextSibling = nextSibling.getNext(); } if (nextSibling != null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent); } } private static Node computeFallThrough(Node n) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.DO: return computeFallThrough(n.getFirstChild()); case Token.FOR: if (NodeUtil.isForIn(n)) { return n; } return computeFallThrough(n.getFirstChild()); case Token.LABEL: return computeFallThrough(n.getLastChild());"
      },
      {
        "txt": "default: return n; } } private void createEdge(Node fromNode, ControlFlowGraph.Branch branch, Node toNode) { cfg.createNode(fromNode); cfg.createNode(toNode); cfg.connectIfNotFound(fromNode, branch, toNode); }"
      },
      {
        "txt": "private void connectToPossibleExceptionHandler(Node cfgNode, Node target) { if (mayThrowException(target) && !exceptionHandler.isEmpty()) { Node lastJump = cfgNode; for (Node handler : exceptionHandler) { if (NodeUtil.isFunction(handler)) { return; } Preconditions.checkState(handler.getType() == Token.TRY); Node catchBlock = NodeUtil.getCatchBlock(handler); if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY."
      },
      {
        "txt": "if (lastJump == cfgNode) { createEdge(cfgNode, Branch.ON_EX, handler.getLastChild()); } else { finallyMap.put(lastJump, handler.getLastChild()); } } else { // Has a catch. if (lastJump == cfgNode) { createEdge(cfgNode, Branch.ON_EX, catchBlock); return; } else {"
      },
      {
        "txt": "finallyMap.put(lastJump, catchBlock); } } lastJump = handler; } } } private static Node getNextSiblingOfType(Node first, int ... types) { for (Node c = first; c != null; c = c.getNext()) { for (int type : types) {"
      },
      {
        "txt": "if (c.getType() == type) { return c; } } } return null; } private static boolean isBreakTarget( Node target, Node parent, String label) { return isBreakStructure(target, label != null) && matchLabel(parent, label);"
      },
      {
        "txt": "} private static boolean isContinueTarget( Node target, Node parent, String label) { return isContinueStructure(target) && matchLabel(parent, label); } private static boolean matchLabel(Node target, String label) { if (label == null) { return true; } while (target.getType() == Token.LABEL) {"
      },
      {
        "txt": "if (target.getFirstChild().getString().equals(label)) { return true; } target = target.getParent(); } return false; } private static boolean mayThrowException(Node n) { switch (n.getType()) { case Token.CALL:"
      },
      {
        "txt": "case Token.GETELEM: case Token.THROW: case Token.NEW: case Token.ASSIGN: case Token.INC: case Token.DEC: <extra_id_0> case Token.FUNCTION: return false; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) { return true;"
      },
      {
        "txt": "if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) { return true; } } return false; } static boolean isBreakStructure(Node n, boolean labeled) { switch (n.getType()) { case Token.FOR: case Token.DO:"
      },
      {
        "txt": "case Token.WHILE: case Token.SWITCH: return true; case Token.BLOCK: case Token.IF: case Token.TRY: return labeled; default: return false; }"
      },
      {
        "txt": "} static boolean isContinueStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: return true; default: return false; }"
      },
      {
        "txt": "} private static class AstControlFlowGraph extends ControlFlowGraph<Node> { private final Map<DiGraphNode<Node, Branch>, Integer> priorities; private AstControlFlowGraph(Node entry, Map<DiGraphNode<Node, Branch>, Integer> priorities) { super(entry); this.priorities = priorities; } @Override public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator("
      },
      {
        "txt": "boolean isForward) { if (isForward) { return new Comparator<DiGraphNode<Node, Branch>>() { @Override public int compare( DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) { return getPosition(n1) - getPosition(n2); } }; } else {"
      },
      {
        "txt": "return new Comparator<DiGraphNode<Node, Branch>>() { @Override public int compare( DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) { return getPosition(n2) - getPosition(n1); } }; } } private int getPosition(DiGraphNode<Node, Branch> n) {"
      },
      {
        "txt": "Integer priority = priorities.get(n); Preconditions.checkNotNull(priority); return priority; } }"
      }
    ]
  },
  {
    "id": 433,
    "file_path": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
    "start-bug-line": 763,
    "end-bug-line": 763,
    "bug": "",
    "fix": "if (foundType == null) { ObjectType maybeType = ObjectType.cast( registry.getGreatestSubtypeWithProperty(type, field));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.common.base.Preconditions.checkState; import com.google.common.collect.HashMultimap; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multimap; import com.google.common.collect.Sets; import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType; import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType; import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType; import com.google.javascript.jscomp.ConcreteType.ConcreteUniqueType; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.TypeValidator.TypeMismatch;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.StandardUnionFind; import com.google.javascript.jscomp.graph.UnionFind; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionPrototypeType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.UnionType; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; import java.util.logging.Logger; class DisambiguateProperties<T> implements CompilerPass { private static final Logger logger = Logger.getLogger("
      },
      {
        "txt": "DisambiguateProperties.class.getName()); static final DiagnosticType INVALIDATION = DiagnosticType.warning( \"JSC_INVALIDATION\", \"Property disambiguator skipping all instances of property {0} \" + \"because of type {1} node {2}\"); private final boolean showInvalidationWarnings = false; private final AbstractCompiler compiler; private final TypeSystem<T> typeSystem; private class Property { final String name;"
      },
      {
        "txt": "private UnionFind<T> types; Set<T> typesToSkip = Sets.newHashSet(); boolean skipRenaming; Set<Node> renameNodes = Sets.newHashSet(); final Map<Node, T> rootTypes = Maps.newHashMap(); Property(String name) { this.name = name; } UnionFind<T> getTypes() { if (types == null) {"
      },
      {
        "txt": "types = new StandardUnionFind<T>(); } return types; } boolean addType(T type, T top, T relatedType) { checkState(!skipRenaming, \"Attempt to record skipped property: %s\", name); if (typeSystem.isInvalidatingType(top)) { invalidate(); return false; } else {"
      },
      {
        "txt": "if (typeSystem.isTypeToSkip(top)) { addTypeToSkip(top); } if (relatedType == null) { getTypes().add(top); } else { getTypes().union(top, relatedType); } typeSystem.recordInterfaces(type, top, this); return true;"
      },
      {
        "txt": "} } void addTypeToSkip(T type) { for (T skipType : typeSystem.getTypesToSkipForType(type)) { typesToSkip.add(skipType); getTypes().union(skipType, type); } } void expandTypesToSkip() { if (shouldRename()) {"
      },
      {
        "txt": "int count = 0; while (true) { checkState(++count < 10, \"Stuck in loop expanding types to skip.\"); Set<T> rootTypesToSkip = Sets.newHashSet(); for (T subType : typesToSkip) { rootTypesToSkip.add(types.find(subType)); } typesToSkip.addAll(rootTypesToSkip); Set<T> newTypesToSkip = Sets.newHashSet(); Set<T> allTypes = types.elements();"
      },
      {
        "txt": "int originalTypesSize = allTypes.size(); for (T subType : allTypes) { if (!typesToSkip.contains(subType) && typesToSkip.contains(types.find(subType))) { newTypesToSkip.add(subType); } } for (T newType : newTypesToSkip) { addTypeToSkip(newType); }"
      },
      {
        "txt": "if (types.elements().size() == originalTypesSize) { break; } } } } boolean shouldRename() { return !skipRenaming && types != null && types.allEquivalenceClasses().size() > 1; }"
      },
      {
        "txt": "boolean shouldRename(T type) { return !skipRenaming && !typesToSkip.contains(type); } boolean invalidate() { boolean changed = !skipRenaming; skipRenaming = true; types = null; return changed; } boolean scheduleRenaming(Node node, T type) {"
      },
      {
        "txt": "if (!skipRenaming) { if (typeSystem.isInvalidatingType(type)) { invalidate(); return false; } renameNodes.add(node); rootTypes.put(node, type); } return true; }"
      },
      {
        "txt": "} private Map<String, Property> properties = Maps.newHashMap(); static DisambiguateProperties<JSType> forJSTypeSystem( AbstractCompiler compiler) { return new DisambiguateProperties<JSType>( compiler, new JSTypeSystem(compiler)); } static DisambiguateProperties<ConcreteType> forConcreteTypeSystem( AbstractCompiler compiler, TightenTypes tt) { return new DisambiguateProperties<ConcreteType>("
      },
      {
        "txt": "compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention())); } private DisambiguateProperties(AbstractCompiler compiler, TypeSystem<T> typeSystem) { this.compiler = compiler; this.typeSystem = typeSystem; } public void process(Node externs, Node root) { for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) { addInvalidatingType(mis.typeA);"
      },
      {
        "txt": "addInvalidatingType(mis.typeB); } StaticScope<T> scope = typeSystem.getRootScope(); NodeTraversal.traverse(compiler, externs, new FindExternProperties()); NodeTraversal.traverse(compiler, root, new FindRenameableProperties()); renameProperties(); } private void addInvalidatingType(JSType type) { type = type.restrictByNotNullOrUndefined(); if (type instanceof UnionType) {"
      },
      {
        "txt": "for (JSType alt : ((UnionType) type).getAlternates()) { addInvalidatingType(alt); } return; } typeSystem.addInvalidatingType(type); ObjectType objType = ObjectType.cast(type); if (objType != null && objType.getImplicitPrototype() != null) { typeSystem.addInvalidatingType(objType.getImplicitPrototype()); }"
      },
      {
        "txt": "} protected Property getProperty(String name) { if (!properties.containsKey(name)) { properties.put(name, new Property(name)); } return properties.get(name); } T getTypeWithProperty(String field, T type) { return typeSystem.getTypeWithProperty(field, type); }"
      },
      {
        "txt": "private abstract class AbstractScopingCallback implements ScopedCallback { protected final Stack<StaticScope<T>> scopes = new Stack<StaticScope<T>>(); public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { scopes.push(typeSystem.getRootScope()); } else {"
      },
      {
        "txt": "scopes.push(typeSystem.getFunctionScope(t.getScopeRoot())); } } public void exitScope(NodeTraversal t) { scopes.pop(); } protected StaticScope<T> getScope() { return scopes.peek(); } }"
      },
      {
        "txt": "private class FindExternProperties extends AbstractScopingCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.GETPROP) { String field = n.getLastChild().getString(); T type = typeSystem.getType(getScope(), n.getFirstChild(), field); Property prop = getProperty(field); if (typeSystem.isInvalidatingType(type)) { prop.invalidate(); } else { prop.addTypeToSkip(type);"
      },
      {
        "txt": "if ((type = typeSystem.getInstanceFromPrototype(type)) != null) { prop.getTypes().add(type); prop.typesToSkip.add(type); } } } } } private class FindRenameableProperties extends AbstractScopingCallback { @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.GETPROP) { handleGetProp(t, n); } else if (n.getType() == Token.OBJECTLIT) { handleObjectLit(t, n); } } private void handleGetProp(NodeTraversal t, Node n) { String name = n.getLastChild().getString(); T type = typeSystem.getType(getScope(), n.getFirstChild(), name);"
      },
      {
        "txt": "Property prop = getProperty(name); if (!prop.scheduleRenaming(n.getLastChild(), processProperty(t, prop, type, null))) { if (showInvalidationWarnings) { compiler.report(JSError.make( t.getSourceName(), n, INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString())); } } }"
      },
      {
        "txt": "private void handleObjectLit(NodeTraversal t, Node n) { Node child = n.getFirstChild(); while (child != null) { if (child.getType() == Token.STRING) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (showInvalidationWarnings) {"
      },
      {
        "txt": "compiler.report(JSError.make( t.getSourceName(), child, INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString())); } } } child = child.getNext().getNext(); } } private T processProperty("
      },
      {
        "txt": "NodeTraversal t, Property prop, T type, T relatedType) { type = typeSystem.restrictByNotNullOrUndefined(type); if (prop.skipRenaming || typeSystem.isInvalidatingType(type)) { return null; } Iterable<T> alternatives = typeSystem.getTypeAlternatives(type); if (alternatives != null) { T firstType = null; for (T subType : alternatives) { T lastType = processProperty(t, prop, subType, firstType);"
      },
      {
        "txt": "if (lastType != null) { firstType = firstType == null ? lastType : firstType; } } return firstType; } else { T topType = typeSystem.getTypeWithProperty(prop.name, type); if (typeSystem.isInvalidatingType(topType)) { return null; }"
      },
      {
        "txt": "prop.addType(type, topType, relatedType); return topType; } } } void renameProperties() { int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0, instancesSkipped = 0, singleTypeProps = 0; for (Property prop : properties.values()) { if (prop.shouldRename()) {"
      },
      {
        "txt": "Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name); ++propsRenamed; prop.expandTypesToSkip(); UnionFind<T> types = prop.getTypes(); for (Node node : prop.renameNodes) { T rootType = prop.rootTypes.get(node); if (prop.shouldRename(rootType)) { String newName = propNames.get(rootType); node.setString(newName); compiler.reportCodeChange();"
      },
      {
        "txt": "++instancesRenamed; } else { ++instancesSkipped; } } } else { if (prop.skipRenaming) { ++propsSkipped; } else { ++singleTypeProps;"
      },
      {
        "txt": "} } } logger.info(\"Renamed \" + instancesRenamed + \" instances of \" + propsRenamed + \" properties.\"); logger.info(\"Skipped renaming \" + instancesSkipped + \" invalidated \" + \"properties, \" + propsSkipped + \" instances of properties \" + \"that were skipped for specific types and \" + singleTypeProps + \" properties that were referenced from only one type.\"); }"
      },
      {
        "txt": "private Map<T, String> buildPropNames(UnionFind<T> types, String name) { Map<T, String> names = Maps.newHashMap(); for (Set<T> set : types.allEquivalenceClasses()) { checkState(!set.isEmpty()); String typeName = null; for (T type : set) { if (typeName == null || type.toString().compareTo(typeName) < 0) { typeName = type.toString(); } }"
      },
      {
        "txt": "String newName; if (\"{...}\".equals(typeName)) { newName = name; } else { newName = typeName.replaceAll(\"[^\\\\w$]\", \"_\") + \"$\" + name; } for (T type : set) { names.put(type, newName); } }"
      },
      {
        "txt": "return names; } Multimap<String, Collection<T>> getRenamedTypesForTesting() { Multimap<String, Collection<T>> ret = HashMultimap.create(); for (Map.Entry<String, Property> entry: properties.entrySet()) { Property prop = entry.getValue(); if (!prop.skipRenaming) { for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) { if (!c.isEmpty() && !prop.typesToSkip.contains(c.iterator().next())) { ret.put(entry.getKey(), c);"
      },
      {
        "txt": "} } } } return ret; } private interface TypeSystem<T> { StaticScope<T> getRootScope(); StaticScope<T> getFunctionScope(Node node); T getType(StaticScope<T> scope, Node node, String prop);"
      },
      {
        "txt": "boolean isInvalidatingType(T type); void addInvalidatingType(JSType type); ImmutableSet<T> getTypesToSkipForType(T type); boolean isTypeToSkip(T type); T restrictByNotNullOrUndefined(T type); Iterable<T> getTypeAlternatives(T type); T getTypeWithProperty(String field, T type); T getInstanceFromPrototype(T type); void recordInterfaces(T type, T relatedType, DisambiguateProperties<T>.Property p);"
      },
      {
        "txt": "} private static class JSTypeSystem implements TypeSystem<JSType> { private final Set<JSType> invalidatingTypes; private JSTypeRegistry registry; public JSTypeSystem(AbstractCompiler compiler) { registry = compiler.getTypeRegistry(); invalidatingTypes = Sets.newHashSet( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE),"
      },
      {
        "txt": "registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE), registry.getNativeType(JSTypeNative.UNKNOWN_TYPE)); } @Override public void addInvalidatingType(JSType type) { checkState(!type.isUnionType()); invalidatingTypes.add(type); } @Override public StaticScope<JSType> getRootScope() { return null; }"
      },
      {
        "txt": "@Override public StaticScope<JSType> getFunctionScope(Node node) { return null; } @Override public JSType getType( StaticScope<JSType> scope, Node node, String prop) { if (node.getJSType() == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return node.getJSType(); }"
      },
      {
        "txt": "@Override public boolean isInvalidatingType(JSType type) { if (type == null || invalidatingTypes.contains(type) || (type.isNamedType() && type.isUnknownType())) { return true; } ObjectType objType = ObjectType.cast(type); return objType != null && !objType.hasReferenceName(); } @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) { type = type.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (type instanceof UnionType) { Set<JSType> types = Sets.newHashSet(type); for (JSType alt : ((UnionType) type).getAlternates()) { types.addAll(getTypesToSkipForTypeNonUnion(type)); } return ImmutableSet.copyOf(types); } return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type)); } private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {"
      },
      {
        "txt": "Set<JSType> types = Sets.newHashSet(); JSType skipType = type; while (skipType != null) { types.add(skipType); ObjectType objSkipType = skipType.toObjectType(); if (objSkipType != null) { skipType = objSkipType.getImplicitPrototype(); } else { break; }"
      },
      {
        "txt": "} return types; } @Override public boolean isTypeToSkip(JSType type) { return type.isEnumType() || (type.autoboxesTo() != null); } @Override public JSType restrictByNotNullOrUndefined(JSType type) { return type.restrictByNotNullOrUndefined(); } @Override public Iterable<JSType> getTypeAlternatives(JSType type) {"
      },
      {
        "txt": "if (type.isUnionType()) { return ((UnionType) type).getAlternates(); } else { ObjectType objType = type.toObjectType(); if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) { List<JSType> list = Lists.newArrayList(); for (FunctionType impl : registry.getDirectImplementors(objType)) {"
      },
      {
        "txt": "list.add(impl.getInstanceType()); } return list; } else { return null; } } } @Override public ObjectType getTypeWithProperty(String field, JSType type) { if (!(type instanceof ObjectType)) {"
      },
      {
        "txt": "if (type.autoboxesTo() != null) { type = type.autoboxesTo(); } else { return null; } } if (\"prototype\".equals(field)) { return null; } ObjectType foundType = null;"
      },
      {
        "txt": "while (objType != null && objType.getImplicitPrototype() != objType) { if (objType.hasOwnProperty(field)) { foundType = objType; } objType = objType.getImplicitPrototype(); } <extra_id_0> return foundType; } @Override public JSType getInstanceFromPrototype(JSType type) { if (type.isFunctionPrototypeType()) { FunctionPrototypeType prototype = (FunctionPrototypeType) type; FunctionType owner = prototype.getOwnerFunction();"
      },
      {
        "txt": "FunctionPrototypeType prototype = (FunctionPrototypeType) type; FunctionType owner = prototype.getOwnerFunction(); if (owner.isConstructor() || owner.isInterface()) { return ((FunctionPrototypeType) type).getOwnerFunction() .getInstanceType(); } } return null; } @Override"
      },
      {
        "txt": "public void recordInterfaces(JSType type, JSType relatedType, DisambiguateProperties<JSType>.Property p) { ObjectType objType = ObjectType.cast(type); if (objType != null) { FunctionType constructor; if (objType instanceof FunctionType) { constructor = (FunctionType) objType; } else if (objType instanceof FunctionPrototypeType) { constructor = ((FunctionPrototypeType) objType).getOwnerFunction(); } else {"
      },
      {
        "txt": "constructor = objType.getConstructor(); } while (constructor != null) { for (ObjectType itype : constructor.getImplementedInterfaces()) { JSType top = getTypeWithProperty(p.name, itype); if (top != null) { p.addType(itype, top, relatedType); } else { recordInterfaces(itype, relatedType, p); }"
      },
      {
        "txt": "if (p.skipRenaming) return; } if (constructor.isInterface() || constructor.isConstructor()) { constructor = constructor.getSuperClassConstructor(); } else { constructor = null; } } } }"
      },
      {
        "txt": "} private static class ConcreteTypeSystem implements TypeSystem<ConcreteType> { private final TightenTypes tt; private int nextUniqueId; private CodingConvention codingConvention; private final Set<JSType> invalidatingTypes = Sets.newHashSet(); private static final JSTypeNative [] nativeTypes = new JSTypeNative[] { JSTypeNative.BOOLEAN_OBJECT_TYPE, JSTypeNative.NUMBER_OBJECT_TYPE, JSTypeNative.STRING_OBJECT_TYPE"
      },
      {
        "txt": "}; public ConcreteTypeSystem(TightenTypes tt, CodingConvention convention) { this.tt = tt; this.codingConvention = convention; } @Override public void addInvalidatingType(JSType type) { checkState(!type.isUnionType()); invalidatingTypes.add(type); } @Override public StaticScope<ConcreteType> getRootScope() {"
      },
      {
        "txt": "return tt.getTopScope(); } @Override public StaticScope<ConcreteType> getFunctionScope(Node decl) { ConcreteFunctionType func = tt.getConcreteFunction(decl); return (func != null) ? func.getScope() : (StaticScope<ConcreteType>) null; } @Override public ConcreteType getType( StaticScope<ConcreteType> scope, Node node, String prop) {"
      },
      {
        "txt": "if (scope != null) { ConcreteType c = tt.inferConcreteType( (TightenTypes.ConcreteScope) scope, node); return maybeAddAutoboxes(c, node, prop); } else { return null; } } private ConcreteType maybeAddAutoboxes( ConcreteType cType, Node node, String prop) {"
      },
      {
        "txt": "JSType jsType = node.getJSType(); if (jsType == null) { return cType; } else if (jsType.isUnknownType()) { for (JSTypeNative nativeType : nativeTypes) { ConcreteType concrete = tt.getConcreteInstance( tt.getTypeRegistry().getNativeObjectType(nativeType)); if (concrete != null && !concrete.getPropertyType(prop).isNone()) { cType = cType.unionWith(concrete); }"
      },
      {
        "txt": "} return cType; } return maybeAddAutoboxes(cType, jsType, prop); } private ConcreteType maybeAddAutoboxes( ConcreteType cType, JSType jsType, String prop) { jsType = jsType.restrictByNotNullOrUndefined(); if (jsType instanceof UnionType) { for (JSType alt : ((UnionType) jsType).getAlternates()) {"
      },
      {
        "txt": "return maybeAddAutoboxes(cType, alt, prop); } } if (jsType.autoboxesTo() != null) { JSType autoboxed = jsType.autoboxesTo(); return cType.unionWith(tt.getConcreteInstance((ObjectType) autoboxed)); } else if (jsType.unboxesTo() != null) { return cType.unionWith(tt.getConcreteInstance((ObjectType) jsType)); } return cType;"
      },
      {
        "txt": "} @Override public boolean isInvalidatingType(ConcreteType type) { return (type == null) || type.isAll() || type.isFunction() || (type.isInstance() && invalidatingTypes.contains(type.toInstance().instanceType)); } @Override public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type) { return ImmutableSet.of(type); }"
      },
      {
        "txt": "@Override public boolean isTypeToSkip(ConcreteType type) { return type.isInstance() && !(type.toInstance().isFunctionPrototype() || type.toInstance().instanceType.isInstanceType()); } @Override public ConcreteType restrictByNotNullOrUndefined(ConcreteType type) { return type; } @Override"
      },
      {
        "txt": "public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type) { if (type.isUnion()) { return ((ConcreteUnionType) type).getAlternatives(); } else { return null; } } @Override public ConcreteType getTypeWithProperty(String field, ConcreteType type) { if (type.isInstance()) {"
      },
      {
        "txt": "ConcreteInstanceType instanceType = (ConcreteInstanceType) type; return instanceType.getInstanceTypeWithProperty(field); } else if (type.isFunction()) { if (\"prototype\".equals(field) || codingConvention.isSuperClassReference(field)) { return type; } } else if (type.isNone()) { return new ConcreteUniqueType(++nextUniqueId); } else if (type.isUnion()) {"
      },
      {
        "txt": "for (ConcreteType t : ((ConcreteUnionType) type).getAlternatives()) { ConcreteType ret = getTypeWithProperty(field, t); if (ret != null) { return ret; } } } return null; } @Override public ConcreteType getInstanceFromPrototype(ConcreteType type) {"
      },
      {
        "txt": "if (type.isInstance()) { ConcreteInstanceType instanceType = (ConcreteInstanceType) type; if (instanceType.isFunctionPrototype()) { return instanceType.getConstructorType().getInstanceType(); } } return null; } @Override public void recordInterfaces(ConcreteType type, ConcreteType relatedType,"
      },
      {
        "txt": "DisambiguateProperties<ConcreteType>.Property p) { } }"
      }
    ]
  },
  {
    "id": 434,
    "file_path": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
    "start-bug-line": 766,
    "end-bug-line": 766,
    "bug": "",
    "fix": "if (maybeType != null && maybeType.hasOwnProperty(field)) { foundType = maybeType; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.common.base.Preconditions.checkState; import com.google.common.collect.HashMultimap; import com.google.common.collect.ImmutableSet;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Multimap; import com.google.common.collect.Sets; import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType; import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType; import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType; import com.google.javascript.jscomp.ConcreteType.ConcreteUniqueType; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.TypeValidator.TypeMismatch;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.StandardUnionFind; import com.google.javascript.jscomp.graph.UnionFind; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionPrototypeType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.UnionType; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Stack; import java.util.logging.Logger; class DisambiguateProperties<T> implements CompilerPass { private static final Logger logger = Logger.getLogger("
      },
      {
        "txt": "DisambiguateProperties.class.getName()); static final DiagnosticType INVALIDATION = DiagnosticType.warning( \"JSC_INVALIDATION\", \"Property disambiguator skipping all instances of property {0} \" + \"because of type {1} node {2}\"); private final boolean showInvalidationWarnings = false; private final AbstractCompiler compiler; private final TypeSystem<T> typeSystem; private class Property { final String name;"
      },
      {
        "txt": "private UnionFind<T> types; Set<T> typesToSkip = Sets.newHashSet(); boolean skipRenaming; Set<Node> renameNodes = Sets.newHashSet(); final Map<Node, T> rootTypes = Maps.newHashMap(); Property(String name) { this.name = name; } UnionFind<T> getTypes() { if (types == null) {"
      },
      {
        "txt": "types = new StandardUnionFind<T>(); } return types; } boolean addType(T type, T top, T relatedType) { checkState(!skipRenaming, \"Attempt to record skipped property: %s\", name); if (typeSystem.isInvalidatingType(top)) { invalidate(); return false; } else {"
      },
      {
        "txt": "if (typeSystem.isTypeToSkip(top)) { addTypeToSkip(top); } if (relatedType == null) { getTypes().add(top); } else { getTypes().union(top, relatedType); } typeSystem.recordInterfaces(type, top, this); return true;"
      },
      {
        "txt": "} } void addTypeToSkip(T type) { for (T skipType : typeSystem.getTypesToSkipForType(type)) { typesToSkip.add(skipType); getTypes().union(skipType, type); } } void expandTypesToSkip() { if (shouldRename()) {"
      },
      {
        "txt": "int count = 0; while (true) { checkState(++count < 10, \"Stuck in loop expanding types to skip.\"); Set<T> rootTypesToSkip = Sets.newHashSet(); for (T subType : typesToSkip) { rootTypesToSkip.add(types.find(subType)); } typesToSkip.addAll(rootTypesToSkip); Set<T> newTypesToSkip = Sets.newHashSet(); Set<T> allTypes = types.elements();"
      },
      {
        "txt": "int originalTypesSize = allTypes.size(); for (T subType : allTypes) { if (!typesToSkip.contains(subType) && typesToSkip.contains(types.find(subType))) { newTypesToSkip.add(subType); } } for (T newType : newTypesToSkip) { addTypeToSkip(newType); }"
      },
      {
        "txt": "if (types.elements().size() == originalTypesSize) { break; } } } } boolean shouldRename() { return !skipRenaming && types != null && types.allEquivalenceClasses().size() > 1; }"
      },
      {
        "txt": "boolean shouldRename(T type) { return !skipRenaming && !typesToSkip.contains(type); } boolean invalidate() { boolean changed = !skipRenaming; skipRenaming = true; types = null; return changed; } boolean scheduleRenaming(Node node, T type) {"
      },
      {
        "txt": "if (!skipRenaming) { if (typeSystem.isInvalidatingType(type)) { invalidate(); return false; } renameNodes.add(node); rootTypes.put(node, type); } return true; }"
      },
      {
        "txt": "} private Map<String, Property> properties = Maps.newHashMap(); static DisambiguateProperties<JSType> forJSTypeSystem( AbstractCompiler compiler) { return new DisambiguateProperties<JSType>( compiler, new JSTypeSystem(compiler)); } static DisambiguateProperties<ConcreteType> forConcreteTypeSystem( AbstractCompiler compiler, TightenTypes tt) { return new DisambiguateProperties<ConcreteType>("
      },
      {
        "txt": "compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention())); } private DisambiguateProperties(AbstractCompiler compiler, TypeSystem<T> typeSystem) { this.compiler = compiler; this.typeSystem = typeSystem; } public void process(Node externs, Node root) { for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) { addInvalidatingType(mis.typeA);"
      },
      {
        "txt": "addInvalidatingType(mis.typeB); } StaticScope<T> scope = typeSystem.getRootScope(); NodeTraversal.traverse(compiler, externs, new FindExternProperties()); NodeTraversal.traverse(compiler, root, new FindRenameableProperties()); renameProperties(); } private void addInvalidatingType(JSType type) { type = type.restrictByNotNullOrUndefined(); if (type instanceof UnionType) {"
      },
      {
        "txt": "for (JSType alt : ((UnionType) type).getAlternates()) { addInvalidatingType(alt); } return; } typeSystem.addInvalidatingType(type); ObjectType objType = ObjectType.cast(type); if (objType != null && objType.getImplicitPrototype() != null) { typeSystem.addInvalidatingType(objType.getImplicitPrototype()); }"
      },
      {
        "txt": "} protected Property getProperty(String name) { if (!properties.containsKey(name)) { properties.put(name, new Property(name)); } return properties.get(name); } T getTypeWithProperty(String field, T type) { return typeSystem.getTypeWithProperty(field, type); }"
      },
      {
        "txt": "private abstract class AbstractScopingCallback implements ScopedCallback { protected final Stack<StaticScope<T>> scopes = new Stack<StaticScope<T>>(); public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { scopes.push(typeSystem.getRootScope()); } else {"
      },
      {
        "txt": "scopes.push(typeSystem.getFunctionScope(t.getScopeRoot())); } } public void exitScope(NodeTraversal t) { scopes.pop(); } protected StaticScope<T> getScope() { return scopes.peek(); } }"
      },
      {
        "txt": "private class FindExternProperties extends AbstractScopingCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.GETPROP) { String field = n.getLastChild().getString(); T type = typeSystem.getType(getScope(), n.getFirstChild(), field); Property prop = getProperty(field); if (typeSystem.isInvalidatingType(type)) { prop.invalidate(); } else { prop.addTypeToSkip(type);"
      },
      {
        "txt": "if ((type = typeSystem.getInstanceFromPrototype(type)) != null) { prop.getTypes().add(type); prop.typesToSkip.add(type); } } } } } private class FindRenameableProperties extends AbstractScopingCallback { @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.GETPROP) { handleGetProp(t, n); } else if (n.getType() == Token.OBJECTLIT) { handleObjectLit(t, n); } } private void handleGetProp(NodeTraversal t, Node n) { String name = n.getLastChild().getString(); T type = typeSystem.getType(getScope(), n.getFirstChild(), name);"
      },
      {
        "txt": "Property prop = getProperty(name); if (!prop.scheduleRenaming(n.getLastChild(), processProperty(t, prop, type, null))) { if (showInvalidationWarnings) { compiler.report(JSError.make( t.getSourceName(), n, INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString())); } } }"
      },
      {
        "txt": "private void handleObjectLit(NodeTraversal t, Node n) { Node child = n.getFirstChild(); while (child != null) { if (child.getType() == Token.STRING) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (showInvalidationWarnings) {"
      },
      {
        "txt": "compiler.report(JSError.make( t.getSourceName(), child, INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString())); } } } child = child.getNext().getNext(); } } private T processProperty("
      },
      {
        "txt": "NodeTraversal t, Property prop, T type, T relatedType) { type = typeSystem.restrictByNotNullOrUndefined(type); if (prop.skipRenaming || typeSystem.isInvalidatingType(type)) { return null; } Iterable<T> alternatives = typeSystem.getTypeAlternatives(type); if (alternatives != null) { T firstType = null; for (T subType : alternatives) { T lastType = processProperty(t, prop, subType, firstType);"
      },
      {
        "txt": "if (lastType != null) { firstType = firstType == null ? lastType : firstType; } } return firstType; } else { T topType = typeSystem.getTypeWithProperty(prop.name, type); if (typeSystem.isInvalidatingType(topType)) { return null; }"
      },
      {
        "txt": "prop.addType(type, topType, relatedType); return topType; } } } void renameProperties() { int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0, instancesSkipped = 0, singleTypeProps = 0; for (Property prop : properties.values()) { if (prop.shouldRename()) {"
      },
      {
        "txt": "Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name); ++propsRenamed; prop.expandTypesToSkip(); UnionFind<T> types = prop.getTypes(); for (Node node : prop.renameNodes) { T rootType = prop.rootTypes.get(node); if (prop.shouldRename(rootType)) { String newName = propNames.get(rootType); node.setString(newName); compiler.reportCodeChange();"
      },
      {
        "txt": "++instancesRenamed; } else { ++instancesSkipped; } } } else { if (prop.skipRenaming) { ++propsSkipped; } else { ++singleTypeProps;"
      },
      {
        "txt": "} } } logger.info(\"Renamed \" + instancesRenamed + \" instances of \" + propsRenamed + \" properties.\"); logger.info(\"Skipped renaming \" + instancesSkipped + \" invalidated \" + \"properties, \" + propsSkipped + \" instances of properties \" + \"that were skipped for specific types and \" + singleTypeProps + \" properties that were referenced from only one type.\"); }"
      },
      {
        "txt": "private Map<T, String> buildPropNames(UnionFind<T> types, String name) { Map<T, String> names = Maps.newHashMap(); for (Set<T> set : types.allEquivalenceClasses()) { checkState(!set.isEmpty()); String typeName = null; for (T type : set) { if (typeName == null || type.toString().compareTo(typeName) < 0) { typeName = type.toString(); } }"
      },
      {
        "txt": "String newName; if (\"{...}\".equals(typeName)) { newName = name; } else { newName = typeName.replaceAll(\"[^\\\\w$]\", \"_\") + \"$\" + name; } for (T type : set) { names.put(type, newName); } }"
      },
      {
        "txt": "return names; } Multimap<String, Collection<T>> getRenamedTypesForTesting() { Multimap<String, Collection<T>> ret = HashMultimap.create(); for (Map.Entry<String, Property> entry: properties.entrySet()) { Property prop = entry.getValue(); if (!prop.skipRenaming) { for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) { if (!c.isEmpty() && !prop.typesToSkip.contains(c.iterator().next())) { ret.put(entry.getKey(), c);"
      },
      {
        "txt": "} } } } return ret; } private interface TypeSystem<T> { StaticScope<T> getRootScope(); StaticScope<T> getFunctionScope(Node node); T getType(StaticScope<T> scope, Node node, String prop);"
      },
      {
        "txt": "boolean isInvalidatingType(T type); void addInvalidatingType(JSType type); ImmutableSet<T> getTypesToSkipForType(T type); boolean isTypeToSkip(T type); T restrictByNotNullOrUndefined(T type); Iterable<T> getTypeAlternatives(T type); T getTypeWithProperty(String field, T type); T getInstanceFromPrototype(T type); void recordInterfaces(T type, T relatedType, DisambiguateProperties<T>.Property p);"
      },
      {
        "txt": "} private static class JSTypeSystem implements TypeSystem<JSType> { private final Set<JSType> invalidatingTypes; private JSTypeRegistry registry; public JSTypeSystem(AbstractCompiler compiler) { registry = compiler.getTypeRegistry(); invalidatingTypes = Sets.newHashSet( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE),"
      },
      {
        "txt": "registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE), registry.getNativeType(JSTypeNative.UNKNOWN_TYPE)); } @Override public void addInvalidatingType(JSType type) { checkState(!type.isUnionType()); invalidatingTypes.add(type); } @Override public StaticScope<JSType> getRootScope() { return null; }"
      },
      {
        "txt": "@Override public StaticScope<JSType> getFunctionScope(Node node) { return null; } @Override public JSType getType( StaticScope<JSType> scope, Node node, String prop) { if (node.getJSType() == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return node.getJSType(); }"
      },
      {
        "txt": "@Override public boolean isInvalidatingType(JSType type) { if (type == null || invalidatingTypes.contains(type) || (type.isNamedType() && type.isUnknownType())) { return true; } ObjectType objType = ObjectType.cast(type); return objType != null && !objType.hasReferenceName(); } @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) { type = type.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (type instanceof UnionType) { Set<JSType> types = Sets.newHashSet(type); for (JSType alt : ((UnionType) type).getAlternates()) { types.addAll(getTypesToSkipForTypeNonUnion(type)); } return ImmutableSet.copyOf(types); } return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type)); } private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {"
      },
      {
        "txt": "Set<JSType> types = Sets.newHashSet(); JSType skipType = type; while (skipType != null) { types.add(skipType); ObjectType objSkipType = skipType.toObjectType(); if (objSkipType != null) { skipType = objSkipType.getImplicitPrototype(); } else { break; }"
      },
      {
        "txt": "} return types; } @Override public boolean isTypeToSkip(JSType type) { return type.isEnumType() || (type.autoboxesTo() != null); } @Override public JSType restrictByNotNullOrUndefined(JSType type) { return type.restrictByNotNullOrUndefined(); } @Override public Iterable<JSType> getTypeAlternatives(JSType type) {"
      },
      {
        "txt": "if (type.isUnionType()) { return ((UnionType) type).getAlternates(); } else { ObjectType objType = type.toObjectType(); if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) { List<JSType> list = Lists.newArrayList(); for (FunctionType impl : registry.getDirectImplementors(objType)) {"
      },
      {
        "txt": "list.add(impl.getInstanceType()); } return list; } else { return null; } } } @Override public ObjectType getTypeWithProperty(String field, JSType type) { if (!(type instanceof ObjectType)) {"
      },
      {
        "txt": "if (type.autoboxesTo() != null) { type = type.autoboxesTo(); } else { return null; } } if (\"prototype\".equals(field)) { return null; } ObjectType foundType = null;"
      },
      {
        "txt": "while (objType != null && objType.getImplicitPrototype() != objType) { if (objType.hasOwnProperty(field)) { foundType = objType; } objType = objType.getImplicitPrototype(); } <extra_id_0> } @Override public JSType getInstanceFromPrototype(JSType type) { if (type.isFunctionPrototypeType()) { FunctionPrototypeType prototype = (FunctionPrototypeType) type; FunctionType owner = prototype.getOwnerFunction(); if (owner.isConstructor() || owner.isInterface()) {"
      },
      {
        "txt": "FunctionType owner = prototype.getOwnerFunction(); if (owner.isConstructor() || owner.isInterface()) { return ((FunctionPrototypeType) type).getOwnerFunction() .getInstanceType(); } } return null; } @Override public void recordInterfaces(JSType type, JSType relatedType,"
      },
      {
        "txt": "DisambiguateProperties<JSType>.Property p) { ObjectType objType = ObjectType.cast(type); if (objType != null) { FunctionType constructor; if (objType instanceof FunctionType) { constructor = (FunctionType) objType; } else if (objType instanceof FunctionPrototypeType) { constructor = ((FunctionPrototypeType) objType).getOwnerFunction(); } else { constructor = objType.getConstructor();"
      },
      {
        "txt": "} while (constructor != null) { for (ObjectType itype : constructor.getImplementedInterfaces()) { JSType top = getTypeWithProperty(p.name, itype); if (top != null) { p.addType(itype, top, relatedType); } else { recordInterfaces(itype, relatedType, p); } if (p.skipRenaming) return;"
      },
      {
        "txt": "} if (constructor.isInterface() || constructor.isConstructor()) { constructor = constructor.getSuperClassConstructor(); } else { constructor = null; } } } } }"
      },
      {
        "txt": "private static class ConcreteTypeSystem implements TypeSystem<ConcreteType> { private final TightenTypes tt; private int nextUniqueId; private CodingConvention codingConvention; private final Set<JSType> invalidatingTypes = Sets.newHashSet(); private static final JSTypeNative [] nativeTypes = new JSTypeNative[] { JSTypeNative.BOOLEAN_OBJECT_TYPE, JSTypeNative.NUMBER_OBJECT_TYPE, JSTypeNative.STRING_OBJECT_TYPE };"
      },
      {
        "txt": "public ConcreteTypeSystem(TightenTypes tt, CodingConvention convention) { this.tt = tt; this.codingConvention = convention; } @Override public void addInvalidatingType(JSType type) { checkState(!type.isUnionType()); invalidatingTypes.add(type); } @Override public StaticScope<ConcreteType> getRootScope() { return tt.getTopScope();"
      },
      {
        "txt": "} @Override public StaticScope<ConcreteType> getFunctionScope(Node decl) { ConcreteFunctionType func = tt.getConcreteFunction(decl); return (func != null) ? func.getScope() : (StaticScope<ConcreteType>) null; } @Override public ConcreteType getType( StaticScope<ConcreteType> scope, Node node, String prop) { if (scope != null) {"
      },
      {
        "txt": "ConcreteType c = tt.inferConcreteType( (TightenTypes.ConcreteScope) scope, node); return maybeAddAutoboxes(c, node, prop); } else { return null; } } private ConcreteType maybeAddAutoboxes( ConcreteType cType, Node node, String prop) { JSType jsType = node.getJSType();"
      },
      {
        "txt": "if (jsType == null) { return cType; } else if (jsType.isUnknownType()) { for (JSTypeNative nativeType : nativeTypes) { ConcreteType concrete = tt.getConcreteInstance( tt.getTypeRegistry().getNativeObjectType(nativeType)); if (concrete != null && !concrete.getPropertyType(prop).isNone()) { cType = cType.unionWith(concrete); } }"
      },
      {
        "txt": "return cType; } return maybeAddAutoboxes(cType, jsType, prop); } private ConcreteType maybeAddAutoboxes( ConcreteType cType, JSType jsType, String prop) { jsType = jsType.restrictByNotNullOrUndefined(); if (jsType instanceof UnionType) { for (JSType alt : ((UnionType) jsType).getAlternates()) { return maybeAddAutoboxes(cType, alt, prop);"
      },
      {
        "txt": "} } if (jsType.autoboxesTo() != null) { JSType autoboxed = jsType.autoboxesTo(); return cType.unionWith(tt.getConcreteInstance((ObjectType) autoboxed)); } else if (jsType.unboxesTo() != null) { return cType.unionWith(tt.getConcreteInstance((ObjectType) jsType)); } return cType; }"
      },
      {
        "txt": "@Override public boolean isInvalidatingType(ConcreteType type) { return (type == null) || type.isAll() || type.isFunction() || (type.isInstance() && invalidatingTypes.contains(type.toInstance().instanceType)); } @Override public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type) { return ImmutableSet.of(type); } @Override public boolean isTypeToSkip(ConcreteType type) {"
      },
      {
        "txt": "return type.isInstance() && !(type.toInstance().isFunctionPrototype() || type.toInstance().instanceType.isInstanceType()); } @Override public ConcreteType restrictByNotNullOrUndefined(ConcreteType type) { return type; } @Override public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type) {"
      },
      {
        "txt": "if (type.isUnion()) { return ((ConcreteUnionType) type).getAlternatives(); } else { return null; } } @Override public ConcreteType getTypeWithProperty(String field, ConcreteType type) { if (type.isInstance()) { ConcreteInstanceType instanceType = (ConcreteInstanceType) type;"
      },
      {
        "txt": "return instanceType.getInstanceTypeWithProperty(field); } else if (type.isFunction()) { if (\"prototype\".equals(field) || codingConvention.isSuperClassReference(field)) { return type; } } else if (type.isNone()) { return new ConcreteUniqueType(++nextUniqueId); } else if (type.isUnion()) { for (ConcreteType t : ((ConcreteUnionType) type).getAlternatives()) {"
      },
      {
        "txt": "ConcreteType ret = getTypeWithProperty(field, t); if (ret != null) { return ret; } } } return null; } @Override public ConcreteType getInstanceFromPrototype(ConcreteType type) { if (type.isInstance()) {"
      },
      {
        "txt": "ConcreteInstanceType instanceType = (ConcreteInstanceType) type; if (instanceType.isFunctionPrototype()) { return instanceType.getConstructorType().getInstanceType(); } } return null; } @Override public void recordInterfaces(ConcreteType type, ConcreteType relatedType, DisambiguateProperties<ConcreteType>.Property p) {"
      },
      {
        "txt": "} }"
      }
    ]
  }
]