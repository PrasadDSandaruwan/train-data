[
  {
    "id": 503,
    "file_path": "src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java",
    "start-bug-line": 362,
    "end-bug-line": 362,
    "bug": "",
    "fix": "newName.setJSType(child.getJSType());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.javascript.jscomp.DefinitionsRemover.Definition; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Collection;"
      },
      {
        "txt": "import java.util.List; class DevirtualizePrototypeMethods implements CompilerPass { private final AbstractCompiler compiler; DevirtualizePrototypeMethods(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler); defFinder.process(externs, root);"
      },
      {
        "txt": "for (DefinitionSite defSite : defFinder.getDefinitionSites()) { rewriteDefinitionIfEligible(defSite, defFinder); } } private static boolean isCall(UseSite site) { Node node = site.node; Node parent = node.getParent(); return (parent.getFirstChild() == node) && NodeUtil.isCall(parent); } private static boolean isPrototypeMethodDefinition(Node node) {"
      },
      {
        "txt": "Node parent = node.getParent(); if (parent == null) { return false; } Node gramp = parent.getParent(); if ((gramp == null) || (parent.getFirstChild() != node) || !NodeUtil.isExprAssign(gramp)) { return false; }"
      },
      {
        "txt": "Node functionNode = parent.getLastChild(); if ((functionNode == null) || !NodeUtil.isFunction(functionNode)) { return false; } if (!NodeUtil.isGetProp(node)) { return false; } Node nameNode = node.getFirstChild(); return NodeUtil.isGetProp(nameNode) && nameNode.getLastChild().getString().equals(\"prototype\");"
      },
      {
        "txt": "} private String getRewrittenMethodName(String orginalMethodName) { return \"JSCompiler_StaticMethods_\" + orginalMethodName; } private void rewriteDefinitionIfEligible(DefinitionSite defSite, SimpleDefinitionFinder defFinder) { if (defSite.inExterns || !defSite.inGlobalScope || !isEligibleDefinition(defFinder, defSite)) { return;"
      },
      {
        "txt": "} Node node = defSite.node; if (!isPrototypeMethodDefinition(node)) { return; } for (Node ancestor = node.getParent(); ancestor != null; ancestor = ancestor.getParent()) { if (NodeUtil.isControlStructure(ancestor)) { return;"
      },
      {
        "txt": "} } String newMethodName = getRewrittenMethodName( node.getLastChild().getString()); rewriteDefinition(node, newMethodName); rewriteCallSites(defFinder, defSite.definition, newMethodName); } private boolean isEligibleDefinition(SimpleDefinitionFinder defFinder, DefinitionSite definitionSite) { Definition definition = definitionSite.definition;"
      },
      {
        "txt": "JSModule definitionModule = definitionSite.module; Node rValue = definition.getRValue(); if (rValue == null || !NodeUtil.isFunction(rValue) || NodeUtil.isVarArgsFunction(rValue)) { return false; } Node lValue = definition.getLValue(); if ((lValue == null) || !NodeUtil.isGetProp(lValue)) {"
      },
      {
        "txt": "return false; } CodingConvention codingConvention = compiler.getCodingConvention(); if (codingConvention.isExported(lValue.getLastChild().getString())) { return false; } Collection<UseSite> useSites = defFinder.getUseSites(definition); if (useSites.isEmpty()) { return false; }"
      },
      {
        "txt": "JSModuleGraph moduleGraph = compiler.getModuleGraph(); for (UseSite site : useSites) { if (!isCall(site)) { return false; } Node nameNode = site.node; Collection<Definition> singleSiteDefinitions = defFinder.getDefinitionsReferencedAt(nameNode); if (singleSiteDefinitions.size() > 1) { return false;"
      },
      {
        "txt": "} Preconditions.checkState(!singleSiteDefinitions.isEmpty()); Preconditions.checkState(singleSiteDefinitions.contains(definition)); JSModule callModule = site.module; if ((definitionModule != callModule) && ((callModule == null) || !moduleGraph.dependsOn(callModule, definitionModule))) { return false; } }"
      },
      {
        "txt": "return true; } private void rewriteCallSites(SimpleDefinitionFinder defFinder, Definition definition, String newMethodName) { Collection<UseSite> useSites = defFinder.getUseSites(definition); for (UseSite site : useSites) { Node node = site.node; Node parent = node.getParent(); Node objectNode = node.getFirstChild();"
      },
      {
        "txt": "node.removeChild(objectNode); parent.replaceChild(node, objectNode); parent.addChildToFront(Node.newString(Token.NAME, newMethodName)); compiler.reportCodeChange(); } } private void rewriteDefinition(Node node, String newMethodName) { Node parent = node.getParent(); Node functionNode = parent.getLastChild(); Node expr = parent.getParent();"
      },
      {
        "txt": "Node block = expr.getParent(); Node newNameNode = Node.newString(Token.NAME, newMethodName); parent.removeChild(functionNode); newNameNode.addChildToFront(functionNode); block.replaceChild(expr, new Node(Token.VAR, newNameNode)); String self = newMethodName + \"$self\"; Node argList = functionNode.getFirstChild().getNext(); argList.addChildToFront(Node.newString(Token.NAME, self)); Node body = functionNode.getLastChild(); replaceReferencesToThis(body, self);"
      },
      {
        "txt": "fixFunctionType(functionNode); compiler.reportCodeChange(); } private void fixFunctionType(Node functionNode) { FunctionType type = (FunctionType) functionNode.getJSType(); if (type != null) { JSTypeRegistry typeRegistry = compiler.getTypeRegistry(); List<JSType> parameterTypes = Lists.newArrayList(); parameterTypes.add(type.getTypeOfThis()); for (Node param : type.getParameters()) {"
      },
      {
        "txt": "parameterTypes.add(param.getJSType()); } ObjectType thisType = typeRegistry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); JSType returnType = type.getReturnType(); JSType newType = typeRegistry.createFunctionType( thisType, returnType, parameterTypes); functionNode.setJSType(newType); } }"
      },
      {
        "txt": "if (NodeUtil.isFunction(node)) { return; } for (Node child : node.children()) { if (NodeUtil.isThis(child)) { Node newName = Node.newString(Token.NAME, name); <extra_id_0> } else { replaceReferencesToThis(child, name); } } } }"
      }
    ]
  },
  {
    "id": 504,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 412,
    "end-bug-line": 412,
    "bug": "",
    "fix": "@Override public boolean hasOwnProperty(String name) { return super.hasOwnProperty(name) || \"prototype\".equals(name); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;"
      },
      {
        "txt": "import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections;"
      },
      {
        "txt": "import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY, CONSTRUCTOR, INTERFACE } private ArrowType call;"
      },
      {
        "txt": "private FunctionPrototypeType prototype; private final Kind kind; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes; private String templateTypeName; @VisibleForTesting public FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType) {"
      },
      {
        "txt": "this(registry, name, source, parameters, returnType, null, null, false, false); } public FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType, ObjectType typeOfThis) { this(registry, name, source, parameters, returnType, typeOfThis, null, false, false); } public FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType, ObjectType typeOfThis,"
      },
      {
        "txt": "String templateTypeName) { this(registry, name, source, parameters, returnType, typeOfThis, templateTypeName, false, false); } FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType, ObjectType typeOfThis, String templateTypeName, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType);"
      },
      {
        "txt": "Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); this.source = source; this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY; if (isConstructor) { this.typeOfThis = typeOfThis != null && typeOfThis.isNoObjectType() ? typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.typeOfThis = typeOfThis != null ? typeOfThis :"
      },
      {
        "txt": "registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = new ArrowType(registry, parameters, (returnType == null ? getReturnType() : returnType)); this.templateTypeName = templateTypeName; } FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); Preconditions.checkArgument(source == null ||"
      },
      {
        "txt": "Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = null; this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this); } @Override public boolean isInstanceType() { return equals(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));"
      },
      {
        "txt": "} @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override public boolean isInterface() { return kind == Kind.INTERFACE; } @Override"
      },
      {
        "txt": "public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } @Override public boolean isFunctionType() { return true; } @Override public boolean canBeCalled() { return true;"
      },
      {
        "txt": "} public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else { return Collections.emptySet(); } } public Node getParametersNode() {"
      },
      {
        "txt": "return call == null ? null : call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) { i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; }"
      },
      {
        "txt": "} return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) { Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); }"
      },
      {
        "txt": "} return Integer.MAX_VALUE; } public JSType getReturnType() { return call == null ? null : call.returnType; } public FunctionPrototypeType getPrototype() { if (prototype == null) { setPrototype(new FunctionPrototypeType(registry, this, null)); }"
      },
      {
        "txt": "return prototype; } public void setPrototypeBasedOn(ObjectType baseType) { if (prototype == null) { setPrototype( new FunctionPrototypeType( registry, this, baseType, isNativeObjectType())); } else { prototype.setImplicitPrototype(baseType); }"
      },
      {
        "txt": "} public boolean setPrototype(FunctionPrototypeType prototype) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false; } this.prototype = prototype; if (isConstructor() || isInterface()) {"
      },
      {
        "txt": "FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } } return true; } public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newHashSet(); for (ObjectType type : getImplementedInterfaces()) {"
      },
      {
        "txt": "addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor(); if (constructor != null) { if (!constructor.isInterface()) { return; }"
      },
      {
        "txt": "set.add(instance); if (constructor.getSuperClassConstructor() != null) { addRelatedInterfaces( constructor.getSuperClassConstructor().getInstanceType(), set); } } } public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;"
      },
      {
        "txt": "if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces()); } } public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type);"
      },
      {
        "txt": "this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } @Override public boolean hasProperty(String name) { return super.hasProperty(name) || \"prototype\".equals(name); } <extra_id_0> @Override public JSType getPropertyType(String name) { if (\"prototype\".equals(name)) { return getPrototype(); } else { if (!hasOwnProperty(name)) {"
      },
      {
        "txt": "} else { if (!hasOwnProperty(name)) { if (\"call\".equals(name)) { Node params = getParametersNode(); if (params == null) { defineDeclaredProperty(name, new FunctionType(registry, null, null, null, getReturnType()), false); } else {"
      },
      {
        "txt": "params = params.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode); thisTypeNode.setOptionalArg(true); defineDeclaredProperty(name, new FunctionType(registry, null, null, params, getReturnType()), false);"
      },
      {
        "txt": "} } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()), registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionType(registry, null, null, builder.build(), getReturnType()),"
      },
      {
        "txt": "false); } } return super.getPropertyType(name); } } @Override boolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns) { if (\"prototype\".equals(name)) {"
      },
      {
        "txt": "ObjectType objType = type.toObjectType(); if (objType != null) { return setPrototype( new FunctionPrototypeType( registry, this, objType, isNativeObjectType())); } else { return false; } } return super.defineProperty(name, type, inferred, inExterns);"
      },
      {
        "txt": "} @Override public boolean isPropertyTypeInferred(String property) { return \"prototype\".equals(property) || super.isPropertyTypeInferred(property); } @Override public JSType getLeastSupertype(JSType that) { if (isFunctionType() && that.isFunctionType()) { if (equals(that)) {"
      },
      {
        "txt": "return this; } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.equals(that)) { return that; } else if (functionInstance.equals(this)) { return this; } return registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);"
      },
      {
        "txt": "} return super.getLeastSupertype(that); } @Override public JSType getGreatestSubtype(JSType that) { if (isFunctionType() && that.isFunctionType()) { if (equals(that)) { return this; } JSType functionInstance = registry.getNativeType("
      },
      {
        "txt": "JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.equals(that)) { return this; } else if (functionInstance.equals(this)) { return that; } return registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return super.getGreatestSubtype(that); }"
      },
      {
        "txt": "public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor(); } public boolean hasUnknownSupertype() { Preconditions.checkArgument(isConstructor() || isInterface());"
      },
      {
        "txt": "Preconditions.checkArgument(!this.isUnknownType()); FunctionType ctor = this; while (true) { ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return false; } if (maybeSuperInstanceType.isUnknownType()) { return true;"
      },
      {
        "txt": "} ctor = maybeSuperInstanceType.getConstructor(); if (ctor == null) { return false; } Preconditions.checkState(ctor.isConstructor() || ctor.isInterface()); } } public JSType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface());"
      },
      {
        "txt": "Preconditions.checkArgument(getPrototype().hasProperty(propertyName)); FunctionType ctor = this; JSType topInstanceType; do { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName)); return topInstanceType; } @Override"
      },
      {
        "txt": "public boolean equals(Object otherType) { if (!(otherType instanceof FunctionType)) { return false; } FunctionType that = (FunctionType) otherType; if (!that.isFunctionType()) { return false; } if (this.isConstructor()) { if (that.isConstructor()) {"
      },
      {
        "txt": "return this == that; } return false; } if (this.isInterface()) { if (that.isInterface()) { return this.getReferenceName().equals(that.getReferenceName()); } return false; }"
      },
      {
        "txt": "if (that.isInterface()) { return false; } return this.typeOfThis.equals(that.typeOfThis) && this.call.equals(that.call); } @Override public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); }"
      },
      {
        "txt": "public boolean hasEqualCallType(FunctionType otherType) { return this.call.equals(otherType.call); } @Override public String toString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\"; } StringBuilder b = new StringBuilder(32); b.append(\"function (\");"
      },
      {
        "txt": "int paramNum = (call == null || call.parameters == null) ? 0 : call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\"); b.append(typeOfThis.toString()); } if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \");"
      },
      {
        "txt": "} Node p = call.parameters.getFirstChild(); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); while (p != null) { b.append(\", \");"
      },
      {
        "txt": "if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); } } b.append(\")\"); if (call != null && call.returnType != null) {"
      },
      {
        "txt": "b.append(\": \"); b.append(call.returnType); } return b.toString(); } private void appendVarArgsString(StringBuilder builder, JSType paramType) { if (paramType.isUnionType()) { paramType = ((UnionType) paramType).getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); }"
      },
      {
        "txt": "builder.append(\"...[\").append(paramType.toString()).append(\"]\"); } @Override public boolean isSubtype(JSType that) { if (this.equals(that)) { return true; } if (that.isFunctionType()) { if (((FunctionType) that).isInterface()) { return true;"
      },
      {
        "txt": "} if (this.isInterface()) { return false; } FunctionType other = (FunctionType) that; return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call); }"
      },
      {
        "txt": "if (that instanceof UnionType) { UnionType union = (UnionType) that; for (JSType element : union.alternates) { if (this.isSubtype(element)) { return true; } } } return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); }"
      },
      {
        "txt": "@Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis; } void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType;"
      },
      {
        "txt": "} public boolean hasInstanceType() { return isConstructor() || isInterface(); } public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis; } public Node getSource() { return source;"
      },
      {
        "txt": "} public void setSource(Node source) { this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList(); } subTypes.add(subType); }"
      },
      {
        "txt": "public List<FunctionType> getSubTypes() { return subTypes; } @Override public boolean hasCachedValues() { return prototype != null || super.hasCachedValues(); } public String getTemplateTypeName() { return templateTypeName; }"
      },
      {
        "txt": "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);"
      },
      {
        "txt": "resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); }"
      },
      {
        "txt": "} return super.resolveInternal(t, scope); }"
      }
    ]
  },
  {
    "id": 505,
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
    "start-bug-line": 472,
    "end-bug-line": 472,
    "bug": "",
    "fix": "if (objType.equals(prototype)) { return true; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.List; import java.util.Set; public class FunctionType extends PrototypeObjectType { private static final long serialVersionUID = 1L; private enum Kind { ORDINARY,"
      },
      {
        "txt": "CONSTRUCTOR, INTERFACE } private ArrowType call; private FunctionPrototypeType prototype; private final Kind kind; private ObjectType typeOfThis; private Node source; private List<ObjectType> implementedInterfaces = ImmutableList.of(); private List<FunctionType> subTypes;"
      },
      {
        "txt": "private String templateTypeName; @VisibleForTesting public FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType) { this(registry, name, source, parameters, returnType, null, null, false, false); } public FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType, ObjectType typeOfThis) { this(registry, name, source, parameters, returnType, typeOfThis,"
      },
      {
        "txt": "null, false, false); } public FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType, ObjectType typeOfThis, String templateTypeName) { this(registry, name, source, parameters, returnType, typeOfThis, templateTypeName, false, false); } FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType, ObjectType typeOfThis,"
      },
      {
        "txt": "String templateTypeName, boolean isConstructor, boolean nativeType) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); this.source = source; this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY; if (isConstructor) { this.typeOfThis = typeOfThis != null && typeOfThis.isNoObjectType() ?"
      },
      {
        "txt": "typeOfThis : new InstanceObjectType(registry, this, nativeType); } else { this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); } this.call = new ArrowType(registry, parameters, (returnType == null ? getReturnType() : returnType)); this.templateTypeName = templateTypeName; }"
      },
      {
        "txt": "FunctionType(JSTypeRegistry registry, String name, Node source) { super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); Preconditions.checkArgument(name != null); this.source = source; this.call = null; this.kind = Kind.INTERFACE; this.typeOfThis = new InstanceObjectType(registry, this);"
      },
      {
        "txt": "} @Override public boolean isInstanceType() { return equals(registry.getNativeType(U2U_CONSTRUCTOR_TYPE)); } @Override public boolean isConstructor() { return kind == Kind.CONSTRUCTOR; } @Override"
      },
      {
        "txt": "public boolean isInterface() { return kind == Kind.INTERFACE; } @Override public boolean isOrdinaryFunction() { return kind == Kind.ORDINARY; } @Override public boolean isFunctionType() { return true;"
      },
      {
        "txt": "} @Override public boolean canBeCalled() { return true; } public Iterable<Node> getParameters() { Node n = getParametersNode(); if (n != null) { return n.children(); } else {"
      },
      {
        "txt": "return Collections.emptySet(); } } public Node getParametersNode() { return call == null ? null : call.parameters; } public int getMinArguments() { int i = 0; int min = 0; for (Node n : getParameters()) {"
      },
      {
        "txt": "i++; if (!n.isOptionalArg() && !n.isVarArgs()) { min = i; } } return min; } public int getMaxArguments() { Node params = getParametersNode(); if (params != null) {"
      },
      {
        "txt": "Node lastParam = params.getLastChild(); if (lastParam == null || !lastParam.isVarArgs()) { return params.getChildCount(); } } return Integer.MAX_VALUE; } public JSType getReturnType() { return call == null ? null : call.returnType; }"
      },
      {
        "txt": "public FunctionPrototypeType getPrototype() { if (prototype == null) { setPrototype(new FunctionPrototypeType(registry, this, null)); } return prototype; } public void setPrototypeBasedOn(ObjectType baseType) { if (prototype == null) { setPrototype( new FunctionPrototypeType("
      },
      {
        "txt": "registry, this, baseType, isNativeObjectType())); } else { prototype.setImplicitPrototype(baseType); } } public boolean setPrototype(FunctionPrototypeType prototype) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) {"
      },
      {
        "txt": "return false; } this.prototype = prototype; if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } } return true;"
      },
      {
        "txt": "} public Iterable<ObjectType> getAllImplementedInterfaces() { Set<ObjectType> interfaces = Sets.newHashSet(); for (ObjectType type : getImplementedInterfaces()) { addRelatedInterfaces(type, interfaces); } return interfaces; } private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { FunctionType constructor = instance.getConstructor();"
      },
      {
        "txt": "if (constructor != null) { if (!constructor.isInterface()) { return; } set.add(instance); if (constructor.getSuperClassConstructor() != null) { addRelatedInterfaces( constructor.getSuperClassConstructor().getInstanceType(), set); } }"
      },
      {
        "txt": "} public Iterable<ObjectType> getImplementedInterfaces() { FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; if (superCtor == null) { return implementedInterfaces; } else { return Iterables.concat( implementedInterfaces, superCtor.getImplementedInterfaces()); }"
      },
      {
        "txt": "} public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { for (ObjectType type : implementedInterfaces) { registry.registerTypeImplementingInterface(this, type); } this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); } @Override public boolean hasProperty(String name) { return super.hasProperty(name) || \"prototype\".equals(name);"
      },
      {
        "txt": "} @Override public JSType getPropertyType(String name) { if (\"prototype\".equals(name)) { return getPrototype(); } else { if (!hasOwnProperty(name)) { if (\"call\".equals(name)) { Node params = getParametersNode(); if (params == null) {"
      },
      {
        "txt": "defineDeclaredProperty(name, new FunctionType(registry, null, null, null, getReturnType()), false); } else { params = params.cloneTree(); Node thisTypeNode = Node.newString(Token.NAME, \"thisType\"); thisTypeNode.setJSType( registry.createOptionalNullableType(getTypeOfThis())); params.addChildToFront(thisTypeNode);"
      },
      {
        "txt": "thisTypeNode.setOptionalArg(true); defineDeclaredProperty(name, new FunctionType(registry, null, null, params, getReturnType()), false); } } else if (\"apply\".equals(name)) { FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams( registry.createNullableType(getTypeOfThis()),"
      },
      {
        "txt": "registry.createNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE))); defineDeclaredProperty(name, new FunctionType(registry, null, null, builder.build(), getReturnType()), false); } } return super.getPropertyType(name); }"
      },
      {
        "txt": "@Override boolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns) { if (\"prototype\".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { <extra_id_0> new FunctionPrototypeType( registry, this, objType, isNativeObjectType())); } else { return false; } }"
      },
      {
        "txt": "} } return super.defineProperty(name, type, inferred, inExterns); } @Override public boolean isPropertyTypeInferred(String property) { return \"prototype\".equals(property) || super.isPropertyTypeInferred(property); } @Override"
      },
      {
        "txt": "public JSType getLeastSupertype(JSType that) { if (isFunctionType() && that.isFunctionType()) { if (equals(that)) { return this; } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.equals(that)) { return that; } else if (functionInstance.equals(this)) {"
      },
      {
        "txt": "return this; } return registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); } return super.getLeastSupertype(that); } @Override public JSType getGreatestSubtype(JSType that) { if (isFunctionType() && that.isFunctionType()) { if (equals(that)) {"
      },
      {
        "txt": "return this; } JSType functionInstance = registry.getNativeType( JSTypeNative.FUNCTION_INSTANCE_TYPE); if (functionInstance.equals(that)) { return this; } else if (functionInstance.equals(this)) { return that; } return registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);"
      },
      {
        "txt": "} return super.getGreatestSubtype(that); } public FunctionType getSuperClassConstructor() { Preconditions.checkArgument(isConstructor() || isInterface()); ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return null; } return maybeSuperInstanceType.getConstructor();"
      },
      {
        "txt": "} public boolean hasUnknownSupertype() { Preconditions.checkArgument(isConstructor() || isInterface()); Preconditions.checkArgument(!this.isUnknownType()); FunctionType ctor = this; while (true) { ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return false;"
      },
      {
        "txt": "} if (maybeSuperInstanceType.isUnknownType()) { return true; } ctor = maybeSuperInstanceType.getConstructor(); if (ctor == null) { return false; } Preconditions.checkState(ctor.isConstructor() || ctor.isInterface()); }"
      },
      {
        "txt": "} public JSType getTopMostDefiningType(String propertyName) { Preconditions.checkState(isConstructor() || isInterface()); Preconditions.checkArgument(getPrototype().hasProperty(propertyName)); FunctionType ctor = this; JSType topInstanceType; do { topInstanceType = ctor.getInstanceType(); ctor = ctor.getSuperClassConstructor(); } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));"
      },
      {
        "txt": "return topInstanceType; } @Override public boolean equals(Object otherType) { if (!(otherType instanceof FunctionType)) { return false; } FunctionType that = (FunctionType) otherType; if (!that.isFunctionType()) { return false;"
      },
      {
        "txt": "} if (this.isConstructor()) { if (that.isConstructor()) { return this == that; } return false; } if (this.isInterface()) { if (that.isInterface()) { return this.getReferenceName().equals(that.getReferenceName());"
      },
      {
        "txt": "} return false; } if (that.isInterface()) { return false; } return this.typeOfThis.equals(that.typeOfThis) && this.call.equals(that.call); } @Override"
      },
      {
        "txt": "public int hashCode() { return isInterface() ? getReferenceName().hashCode() : call.hashCode(); } public boolean hasEqualCallType(FunctionType otherType) { return this.call.equals(otherType.call); } @Override public String toString() { if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { return \"Function\";"
      },
      {
        "txt": "} StringBuilder b = new StringBuilder(32); b.append(\"function (\"); int paramNum = (call == null || call.parameters == null) ? 0 : call.parameters.getChildCount(); boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); if (hasKnownTypeOfThis) { b.append(\"this:\"); b.append(typeOfThis.toString()); }"
      },
      {
        "txt": "if (paramNum > 0) { if (hasKnownTypeOfThis) { b.append(\", \"); } Node p = call.parameters.getFirstChild(); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); }"
      },
      {
        "txt": "p = p.getNext(); while (p != null) { b.append(\", \"); if (p.isVarArgs()) { appendVarArgsString(b, p.getJSType()); } else { b.append(p.getJSType().toString()); } p = p.getNext(); }"
      },
      {
        "txt": "} b.append(\")\"); if (call != null && call.returnType != null) { b.append(\": \"); b.append(call.returnType); } return b.toString(); } private void appendVarArgsString(StringBuilder builder, JSType paramType) { if (paramType.isUnionType()) {"
      },
      {
        "txt": "paramType = ((UnionType) paramType).getRestrictedUnion( registry.getNativeType(JSTypeNative.VOID_TYPE)); } builder.append(\"...[\").append(paramType.toString()).append(\"]\"); } @Override public boolean isSubtype(JSType that) { if (this.equals(that)) { return true; }"
      },
      {
        "txt": "if (that.isFunctionType()) { if (((FunctionType) that).isInterface()) { return true; } if (this.isInterface()) { return false; } FunctionType other = (FunctionType) that; return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) ||"
      },
      {
        "txt": "this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call); } if (that instanceof UnionType) { UnionType union = (UnionType) that; for (JSType element : union.alternates) { if (this.isSubtype(element)) { return true; } }"
      },
      {
        "txt": "} return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); } @Override public <T> T visit(Visitor<T> visitor) { return visitor.caseFunctionType(this); } public ObjectType getInstanceType() { Preconditions.checkState(hasInstanceType()); return typeOfThis;"
      },
      {
        "txt": "} void setInstanceType(ObjectType instanceType) { typeOfThis = instanceType; } public boolean hasInstanceType() { return isConstructor() || isInterface(); } public ObjectType getTypeOfThis() { return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis;"
      },
      {
        "txt": "} public Node getSource() { return source; } public void setSource(Node source) { this.source = source; } private void addSubType(FunctionType subType) { if (subTypes == null) { subTypes = Lists.newArrayList();"
      },
      {
        "txt": "} subTypes.add(subType); } public List<FunctionType> getSubTypes() { return subTypes; } @Override public boolean hasCachedValues() { return prototype != null || super.hasCachedValues(); }"
      },
      {
        "txt": "public String getTemplateTypeName() { return templateTypeName; } @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces ="
      },
      {
        "txt": "ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) {"
      },
      {
        "txt": "for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }"
      }
    ]
  }
]